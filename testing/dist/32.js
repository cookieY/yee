((typeof self !== 'undefined' ? self : this)["webpackJsonp"] = (typeof self !== 'undefined' ? self : this)["webpackJsonp"] || []).push([[32],{

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcz8xZmI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../@vue/cli-service/node_modules/webpack/buildin/global.js */ \"./node_modules/@vue/cli-service/node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz9iNjM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/buffer/index.js\n");

/***/ }),

/***/ "./node_modules/emmet/emmet.js":
/*!*************************************!*\
  !*** ./node_modules/emmet/emmet.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, Buffer, global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;!function(e){var val=e(); if(true)module.exports=val;if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (val),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.emmet=val}}(function(){var define,module,exports;return (function outer (modules, cache, entry) {\n    // Save the require from previous bundle to this closure if any\n    var previousRequire = typeof require == \"function\" && require;\n\n    function newRequire(name, jumped){\n        if(!cache[name]) {\n            if(!modules[name]) {\n                // if we cannot find the the module within our internal map or\n                // cache jump to the current global require ie. the last bundle\n                // that was added to the page.\n                var currentRequire = typeof require == \"function\" && require;\n                if (!jumped && currentRequire) return require(name, true);\n\n                // If there are other bundles on this page the require from the\n                // previous one is saved to 'previousRequire'. Repeat this as\n                // many times as there are bundles until the module is found or\n                // we exhaust the require chain.\n                if (true) return require(name, true);\n                var err = new Error('Cannot find module \\'' + name + '\\'');\n                err.code = 'MODULE_NOT_FOUND';\n                throw err;\n            }\n            var m = cache[name] = {exports:{}};\n            modules[name][0].call(m.exports, function(x){\n                var id = modules[name][1][x];\n                return newRequire(id ? id : x);\n            },m,m.exports,outer,modules,cache,entry);\n        }\n        return cache[name].exports;\n    }\n    for(var i=0;i<entry.length;i++) newRequire(entry[i]);\n\n    // Override the current require with this new one\n    return newRequire;\n})\n({\"./bundles/snippets.js\":[function(require,module,exports){\n/**\n * Bundler, used in builder script to statically\n * include snippets.json into bundle\n */\nvar res = require('../lib/assets/resources');\nvar snippets = require('../lib/snippets.json');\nres.setVocabulary(snippets, 'system');\n\n},{\"../lib/assets/resources\":\"assets\\\\resources.js\",\"../lib/snippets.json\":\"snippets.json\"}],\"./lib/emmet.js\":[function(require,module,exports){\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar global = typeof self != 'undefined' ? self : this;\n\n\tvar utils = require('./utils/common');\n\tvar actions = require('./action/main');\n\tvar parser = require('./parser/abbreviation');\n\tvar file = require('./plugin/file');\n\n\tvar preferences = require('./assets/preferences');\n\tvar resources = require('./assets/resources');\n\tvar profile = require('./assets/profile');\n\tvar ciu = require('./assets/caniuse');\n\tvar logger = require('./assets/logger');\n\n\tvar sliceFn = Array.prototype.slice;\n\n\t/**\n\t * Returns file name part from path\n\t * @param {String} path Path to file\n\t * @return {String}\n\t */\n\tfunction getFileName(path) {\n\t\tvar re = /([\\w\\.\\-]+)$/i;\n\t\tvar m = re.exec(path);\n\t\treturn m ? m[1] : '';\n\t}\n\n\t/**\n\t * Normalizes profile definition: converts some\n\t * properties to valid data types\n\t * @param {Object} profile\n\t * @return {Object}\n\t */\n\tfunction normalizeProfile(profile) {\n\t\tif (typeof profile === 'object') {\n\t\t\tif ('indent' in profile) {\n\t\t\t\tprofile.indent = !!profile.indent;\n\t\t\t}\n\n\t\t\tif ('self_closing_tag' in profile) {\n\t\t\t\tif (typeof profile.self_closing_tag === 'number') {\n\t\t\t\t\tprofile.self_closing_tag = !!profile.self_closing_tag;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn profile;\n\t}\n\n\treturn {\n\t\t/**\n\t\t * The essential function that expands Emmet abbreviation\n\t\t * @param {String} abbr Abbreviation to parse\n\t\t * @param {String} syntax Abbreviation's context syntax\n\t\t * @param {String} profile Output profile (or its name)\n\t\t * @param {Object} contextNode Contextual node where abbreviation is\n\t\t * written\n\t\t * @return {String}\n\t\t */\n\t\texpandAbbreviation: function(abbr, syntax, profile, contextNode) {\n\t\t\treturn parser.expand(abbr, {\n\t\t\t\tsyntax: syntax,\n\t\t\t\tprofile: profile,\n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Runs given action\n\t\t * @param  {String} name Action name\n\t\t * @param  {IEmmetEditor} editor Editor instance\n\t\t * @return {Boolean} Returns true if action was performed successfully\n\t\t */\n\t\trun: function(name) {\n\t\t\treturn actions.run.apply(actions, sliceFn.call(arguments, 0));\n\t\t},\n\n\t\t/**\n\t\t * Loads Emmet extensions. Extensions are simple .js files that\n\t\t * uses Emmet modules and resources to create new actions, modify\n\t\t * existing ones etc.\n\t\t * @param {Array} fileList List of absolute paths to files in extensions\n\t\t * folder. Back-end app should not filter this list (e.g. by extension)\n\t\t * but return it \"as-is\" so bootstrap can decide how to load contents\n\t\t * of each file.\n\t\t * This method requires a <code>file</code> module of <code>IEmmetFile</code>\n\t\t * interface to be implemented.\n\t\t * @memberOf bootstrap\n\t\t */\n\t\tloadExtensions: function(fileList) {\n\t\t\tvar payload = {};\n\t\t\tvar userSnippets = null;\n\t\t\tvar that = this;\n\n\t\t\t// make sure file list contians only valid extension files\n\t\t\tfileList = fileList.filter(function(f) {\n\t\t\t\tvar ext = file.getExt(f);\n\t\t\t\treturn ext === 'json' || ext === 'js';\n\t\t\t});\n\n\t\t\tvar reader = (file.readText || file.read).bind(file);\n\t\t\tvar next = function() {\n\t\t\t\tif (fileList.length) {\n\t\t\t\t\tvar f = fileList.shift();\n\t\t\t\t\treader(f, function(err, content) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tlogger.log('Unable to read \"' + f + '\" file: '+ err);\n\t\t\t\t\t\t\treturn next();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch (file.getExt(f)) {\n\t\t\t\t\t\t\tcase 'js':\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\teval(content);\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\tlogger.log('Unable to eval \"' + f + '\" file: '+ e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'json':\n\t\t\t\t\t\t\t\tvar fileName = getFileName(f).toLowerCase().replace(/\\.json$/, '');\n\t\t\t\t\t\t\t\tcontent = utils.parseJSON(content);\n\t\t\t\t\t\t\t\tif (/^snippets/.test(fileName)) {\n\t\t\t\t\t\t\t\t\tif (fileName === 'snippets') {\n\t\t\t\t\t\t\t\t\t\t// data in snippets.json is more important to user\n\t\t\t\t\t\t\t\t\t\tuserSnippets = content;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpayload.snippets = utils.deepMerge(payload.snippets || {}, content);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tpayload[fileName] = content;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// complete\n\t\t\t\t\tif (userSnippets) {\n\t\t\t\t\t\tpayload.snippets = utils.deepMerge(payload.snippets || {}, userSnippets);\n\t\t\t\t\t}\n\n\t\t\t\t\tthat.loadUserData(payload);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tnext();\n\t\t},\n\n\t\t/**\n\t\t * Loads preferences from JSON object (or string representation of JSON)\n\t\t * @param {Object} data\n\t\t * @returns\n\t\t */\n\t\tloadPreferences: function(data) {\n\t\t\tpreferences.load(utils.parseJSON(data));\n\t\t},\n\n\t\t/**\n\t\t * Loads user snippets and abbreviations. It doesnt replace current\n\t\t * user resource vocabulary but merges it with passed one. If you need\n\t\t * to <i>replaces</i> user snippets you should call\n\t\t * <code>resetSnippets()</code> method first\n\t\t */\n\t\tloadSnippets: function(data) {\n\t\t\tdata = utils.parseJSON(data);\n\n\t\t\tvar userData = resources.getVocabulary('user') || {};\n\t\t\tresources.setVocabulary(utils.deepMerge(userData, data), 'user');\n\t\t},\n\n\t\t/**\n\t\t * Helper function that loads default snippets, defined in projects\n\t\t * <i>snippets.json</i>\n\t\t * @param {Object} data\n\t\t */\n\t\tloadSystemSnippets: function(data) {\n\t\t\tresources.setVocabulary(utils.parseJSON(data), 'system');\n\t\t},\n\n\t\t/**\n\t\t * Helper function that loads Can I Use database\n\t\t * @param {Object} data\n\t\t */\n\t\tloadCIU: function(data) {\n\t\t\tciu.load(utils.parseJSON(data));\n\t\t},\n\n\t\t/**\n\t\t * Removes all user-defined snippets\n\t\t */\n\t\tresetSnippets: function() {\n\t\t\tresources.setVocabulary({}, 'user');\n\t\t},\n\n\t\t/**\n\t\t * Helper function that loads all user data (snippets and preferences)\n\t\t * defined as a single JSON object. This is useful for loading data\n\t\t * stored in a common storage, for example <code>NSUserDefaults</code>\n\t\t * @param {Object} data\n\t\t */\n\t\tloadUserData: function(data) {\n\t\t\tdata = utils.parseJSON(data);\n\t\t\tif (data.snippets) {\n\t\t\t\tthis.loadSnippets(data.snippets);\n\t\t\t}\n\n\t\t\tif (data.preferences) {\n\t\t\t\tthis.loadPreferences(data.preferences);\n\t\t\t}\n\n\t\t\tif (data.profiles) {\n\t\t\t\tthis.loadProfiles(data.profiles);\n\t\t\t}\n\n\t\t\tif (data.caniuse) {\n\t\t\t\tthis.loadCIU(data.caniuse);\n\t\t\t}\n\n\t\t\tvar profiles = data.syntaxProfiles || data.syntaxprofiles;\n\t\t\tif (profiles) {\n\t\t\t\tthis.loadSyntaxProfiles(profiles);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Resets all user-defined data: preferences, snippets etc.\n\t\t * @returns\n\t\t */\n\t\tresetUserData: function() {\n\t\t\tthis.resetSnippets();\n\t\t\tpreferences.reset();\n\t\t\tprofile.reset();\n\t\t},\n\n\t\t/**\n\t\t * Load syntax-specific output profiles. These are essentially\n\t\t * an extension to syntax snippets\n\t\t * @param {Object} profiles Dictionary of profiles\n\t\t */\n\t\tloadSyntaxProfiles: function(profiles) {\n\t\t\tprofiles = utils.parseJSON(profiles);\n\t\t\tvar snippets = {};\n\t\t\tObject.keys(profiles).forEach(function(syntax) {\n\t\t\t\tvar options = profiles[syntax];\n\t\t\t\tif (!(syntax in snippets)) {\n\t\t\t\t\tsnippets[syntax] = {};\n\t\t\t\t}\n\t\t\t\tsnippets[syntax].profile = normalizeProfile(options);\n\t\t\t});\n\n\t\t\tthis.loadSnippets(snippets);\n\t\t},\n\n\t\t/**\n\t\t * Load named profiles\n\t\t * @param {Object} profiles\n\t\t */\n\t\tloadProfiles: function(profiles) {\n\t\t\tprofiles = utils.parseJSON(profiles);\n\t\t\tObject.keys(profiles).forEach(function(name) {\n\t\t\t\tprofile.create(name, normalizeProfile(profiles[name]));\n\t\t\t});\n\t\t},\n\n\t\t// expose some useful data for plugin authors\n\t\tactions: actions,\n\t\tparser: parser,\n\t\tfile: file,\n\t\tpreferences: preferences,\n\t\tresources: resources,\n\t\tprofile: profile,\n\t\ttabStops: require('./assets/tabStops'),\n\t\thtmlMatcher: require('./assets/htmlMatcher'),\n\t\tutils: {\n\t\t\tcommon: utils,\n\t\t\taction: require('./utils/action'),\n\t\t\teditor: require('./utils/editor')\n\t\t}\n\t};\n});\n\n},{\"./action/main\":\"action\\\\main.js\",\"./assets/caniuse\":\"assets\\\\caniuse.js\",\"./assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"./assets/logger\":\"assets\\\\logger.js\",\"./assets/preferences\":\"assets\\\\preferences.js\",\"./assets/profile\":\"assets\\\\profile.js\",\"./assets/resources\":\"assets\\\\resources.js\",\"./assets/tabStops\":\"assets\\\\tabStops.js\",\"./parser/abbreviation\":\"parser\\\\abbreviation.js\",\"./plugin/file\":\"plugin\\\\file.js\",\"./utils/action\":\"utils\\\\action.js\",\"./utils/common\":\"utils\\\\common.js\",\"./utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\balance.js\":[function(require,module,exports){\n/**\n * HTML pair matching (balancing) actions\n * @constructor\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar htmlMatcher = require('../assets/htmlMatcher');\n\tvar utils = require('../utils/common');\n\tvar editorUtils = require('../utils/editor');\n\tvar actionUtils = require('../utils/action');\n\tvar range = require('../assets/range');\n\tvar cssEditTree = require('../editTree/css');\n\tvar cssSections = require('../utils/cssSections');\n\tvar lastMatch = null;\n\n\tfunction last(arr) {\n\t\treturn arr[arr.length - 1];\n\t}\n\n\tfunction balanceHTML(editor, direction) {\n\t\tvar info = editorUtils.outputInfo(editor);\n\t\tvar content = info.content;\n\t\tvar sel = range(editor.getSelectionRange());\n\t\t\n\t\t// validate previous match\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\n\t\t\tlastMatch = null;\n\t\t}\n\t\t\n\t\tif (lastMatch && sel.length()) {\n\t\t\tif (direction == 'in') {\n\t\t\t\t// user has previously selected tag and wants to move inward\n\t\t\t\tif (lastMatch.type == 'tag' && !lastMatch.close) {\n\t\t\t\t\t// unary tag was selected, can't move inward\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastMatch.range.equal(lastMatch.outerRange)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar narrowed = utils.narrowToNonSpace(content, lastMatch.innerRange);\n\t\t\t\t\t\tlastMatch = htmlMatcher.find(content, narrowed.start + 1);\n\t\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.outerRange.equal(sel)) {\n\t\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\t!lastMatch.innerRange.equal(lastMatch.outerRange) \n\t\t\t\t\t&& lastMatch.range.equal(lastMatch.innerRange) \n\t\t\t\t\t&& sel.equal(lastMatch.range)) {\n\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t} else {\n\t\t\t\t\tlastMatch = htmlMatcher.find(content, sel.start);\n\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.innerRange.equal(sel)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlastMatch = htmlMatcher.find(content, sel.start);\n\t\t}\n\n\t\tif (lastMatch) {\n\t\t\tif (lastMatch.innerRange.equal(sel)) {\n\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t}\n\n\t\t\tif (!lastMatch.range.equal(sel)) {\n\t\t\t\teditor.createSelection(lastMatch.range.start, lastMatch.range.end);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlastMatch = null;\n\t\treturn false;\n\t}\n\n\tfunction rangesForCSSRule(rule, pos) {\n\t\t// find all possible ranges\n\t\tvar ranges = [rule.range(true)];\n\n\t\t// braces content\n\t\tranges.push(rule.valueRange(true));\n\n\t\t// find nested sections\n\t\tvar nestedSections = cssSections.nestedSectionsInRule(rule);\n\n\t\t// real content, e.g. from first property name to\n\t\t// last property value\n\t\tvar items = rule.list();\n\t\tif (items.length || nestedSections.length) {\n\t\t\tvar start = Number.POSITIVE_INFINITY, end = -1;\n\t\t\tif (items.length) {\n\t\t\t\tstart = items[0].namePosition(true);\n\t\t\t\tend = last(items).range(true).end;\n\t\t\t}\n\n\t\t\tif (nestedSections.length) {\n\t\t\t\tif (nestedSections[0].start < start) {\n\t\t\t\t\tstart = nestedSections[0].start;\n\t\t\t\t}\n\n\t\t\t\tif (last(nestedSections).end > end) {\n\t\t\t\t\tend = last(nestedSections).end;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tranges.push(range.create2(start, end));\n\t\t}\n\n\t\tranges = ranges.concat(nestedSections);\n\n\t\tvar prop = cssEditTree.propertyFromPosition(rule, pos) || items[0];\n\t\tif (prop) {\n\t\t\tranges.push(prop.range(true));\n\t\t\tvar valueRange = prop.valueRange(true);\n\t\t\tif (!prop.end()) {\n\t\t\t\tvalueRange._unterminated = true;\n\t\t\t}\n\t\t\tranges.push(valueRange);\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns all possible selection ranges for given caret position\n\t * @param  {String} content CSS content\n\t * @param  {Number} pos     Caret position(where to start searching)\n\t * @return {Array}\n\t */\n\tfunction getCSSRanges(content, pos) {\n\t\tvar rule;\n\t\tif (typeof content === 'string') {\n\t\t\tvar ruleRange = cssSections.matchEnclosingRule(content, pos);\n\t\t\tif (ruleRange) {\n\t\t\t\trule = cssEditTree.parse(ruleRange.substring(content), {\n\t\t\t\t\toffset: ruleRange.start\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// passed parsed CSS rule\n\t\t\trule = content;\n\t\t}\n\n\t\tif (!rule) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// find all possible ranges\n\t\tvar ranges = rangesForCSSRule(rule, pos);\n\n\t\t// remove empty ranges\n\t\tranges = ranges.filter(function(item) {\n\t\t\treturn !!item.length;\n\t\t});\n\n\t\treturn utils.unique(ranges, function(item) {\n\t\t\treturn item.valueOf();\n\t\t});\n\t}\n\n\tfunction balanceCSS(editor, direction) {\n\t\tvar info = editorUtils.outputInfo(editor);\n\t\tvar content = info.content;\n\t\tvar sel = range(editor.getSelectionRange());\n\n\t\tvar ranges = getCSSRanges(info.content, sel.start);\n\t\tif (!ranges && sel.length()) {\n\t\t\t// possible reason: user has already selected\n\t\t\t// CSS rule from last match\n\t\t\ttry {\n\t\t\t\tvar rule = cssEditTree.parse(sel.substring(info.content), {\n\t\t\t\t\toffset: sel.start\n\t\t\t\t});\n\t\t\t\tranges = getCSSRanges(rule, sel.start);\n\t\t\t} catch(e) {}\n\t\t}\n\n\t\tif (!ranges) {\n\t\t\treturn false;\n\t\t}\n\n\t\tranges = range.sort(ranges, true);\n\n\t\t// edge case: find match that equals current selection,\n\t\t// in case if user moves inward after selecting full CSS rule\n\t\tvar bestMatch = utils.find(ranges, function(r) {\n\t\t\treturn r.equal(sel);\n\t\t});\n\n\t\tif (!bestMatch) {\n\t\t\tbestMatch = utils.find(ranges, function(r) {\n\t\t\t\t// Check for edge case: caret right after CSS value\n\t\t\t\t// but it doesnt contains terminating semicolon.\n\t\t\t\t// In this case we have to check full value range\n\t\t\t\treturn r._unterminated ? r.include(sel.start) : r.inside(sel.start);\n\t\t\t});\n\t\t}\n\n\t\tif (!bestMatch) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if best match equals to current selection, move index\n\t\t// one position up or down, depending on direction\n\t\tvar bestMatchIx = ranges.indexOf(bestMatch);\n\t\tif (bestMatch.equal(sel)) {\n\t\t\tbestMatchIx += direction == 'out' ? 1 : -1;\n\t\t}\n\n\t\tif (bestMatchIx < 0 || bestMatchIx >= ranges.length) {\n\t\t\tif (bestMatchIx >= ranges.length && direction == 'out') {\n\t\t\t\tpos = bestMatch.start - 1;\n\n\t\t\t\tvar outerRanges = getCSSRanges(content, pos);\n\t\t\t\tif (outerRanges) {\n\t\t\t\t\tbestMatch = last(outerRanges.filter(function(r) {\n\t\t\t\t\t\treturn r.inside(pos);\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t} else if (bestMatchIx < 0 && direction == 'in') {\n\t\t\t\tbestMatch = null;\n\t\t\t} else {\n\t\t\t\tbestMatch = null;\n\t\t\t}\n\t\t} else {\n\t\t\tbestMatch = ranges[bestMatchIx];\t\n\t\t}\n\n\t\tif (bestMatch) {\n\t\t\teditor.createSelection(bestMatch.start, bestMatch.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Find and select HTML tag pair\n\t\t * @param {IEmmetEditor} editor Editor instance\n\t\t * @param {String} direction Direction of pair matching: 'in' or 'out'. \n\t\t * Default is 'out'\n\t\t */\n\t\tbalance: function(editor, direction) {\n\t\t\tdirection = String((direction || 'out').toLowerCase());\n\t\t\tvar info = editorUtils.outputInfo(editor);\n\t\t\tif (actionUtils.isSupportedCSS(info.syntax)) {\n\t\t\t\treturn balanceCSS(editor, direction);\n\t\t\t}\n\t\t\t\n\t\t\treturn balanceHTML(editor, direction);\n\t\t},\n\n\t\tbalanceInwardAction: function(editor) {\n\t\t\treturn this.balance(editor, 'in');\n\t\t},\n\n\t\tbalanceOutwardAction: function(editor) {\n\t\t\treturn this.balance(editor, 'out');\t\n\t\t},\n\n\t\t/**\n\t\t * Moves caret to matching opening or closing tag\n\t\t * @param {IEmmetEditor} editor\n\t\t */\n\t\tgoToMatchingPairAction: function(editor) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\t\n\t\t\tif (content.charAt(caretPos) == '<') \n\t\t\t\t// looks like caret is outside of tag pair  \n\t\t\t\tcaretPos++;\n\t\t\t\t\n\t\t\tvar tag = htmlMatcher.tag(content, caretPos);\n\t\t\tif (tag && tag.close) { // exclude unary tags\n\t\t\t\tif (tag.open.range.inside(caretPos)) {\n\t\t\t\t\teditor.setCaretPos(tag.close.range.start);\n\t\t\t\t} else {\n\t\t\t\t\teditor.setCaretPos(tag.open.range.start);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t};\n});\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/cssSections\":\"utils\\\\cssSections.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\base64.js\":[function(require,module,exports){\n/**\n * Encodes/decodes image under cursor to/from base64\n * @param {IEmmetEditor} editor\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar file = require('../plugin/file');\n\tvar base64 = require('../utils/base64');\n\tvar actionUtils = require('../utils/action');\n\tvar editorUtils = require('../utils/editor');\n\n\t/**\n\t * Test if <code>text</code> starts with <code>token</code> at <code>pos</code>\n\t * position. If <code>pos</code> is omitted, search from beginning of text \n\t * @param {String} token Token to test\n\t * @param {String} text Where to search\n\t * @param {Number} pos Position where to start search\n\t * @return {Boolean}\n\t * @since 0.65\n\t */\n\tfunction startsWith(token, text, pos) {\n\t\tpos = pos || 0;\n\t\treturn text.charAt(pos) == token.charAt(0) && text.substr(pos, token.length) == token;\n\t}\n\n\t/**\n\t * Encodes image to base64\n\t * \n\t * @param {IEmmetEditor} editor\n\t * @param {String} imgPath Path to image\n\t * @param {Number} pos Caret position where image is located in the editor\n\t * @return {Boolean}\n\t */\n\tfunction encodeToBase64(editor, imgPath, pos) {\n\t\tvar editorFile = editor.getFilePath();\n\t\tvar defaultMimeType = 'application/octet-stream';\n\n\t\tif (editorFile === null) {\n\t\t\tthrow \"You should save your file before using this action\";\n\t\t}\n\n\t\t// locate real image path\n\t\tfile.locateFile(editorFile, imgPath, function(realImgPath) {\n\t\t\tif (realImgPath === null) {\n\t\t\t\tthrow \"Can't find \" + imgPath + ' file';\n\t\t\t}\n\n\t\t\tfile.read(realImgPath, function(err, content) {\n\t\t\t\tif (err) {\n\t\t\t\t\tthrow 'Unable to read ' + realImgPath + ': ' + err;\n\t\t\t\t}\n\n\t\t\t\tvar b64 = base64.encode(String(content));\n\t\t\t\tif (!b64) {\n\t\t\t\t\tthrow \"Can't encode file content to base64\";\n\t\t\t\t}\n\n\t\t\t\tb64 = 'data:' + (actionUtils.mimeTypes[String(file.getExt(realImgPath))] || defaultMimeType) +\n\t\t\t\t\t';base64,' + b64;\n\n\t\t\t\teditor.replaceContent('$0' + b64, pos, pos + imgPath.length);\n\t\t\t});\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Decodes base64 string back to file.\n\t * @param {IEmmetEditor} editor\n\t * @param {String} filePath to new image\n\t * @param {String} data Base64-encoded file content\n\t * @param {Number} pos Caret position where image is located in the editor\n\t */\n\tfunction decodeFromBase64(editor, filePath, data, pos) {\n\t\t// ask user to enter path to file\n\t\tfilePath = filePath || String(editor.prompt('Enter path to file (absolute or relative)'));\n\t\tif (!filePath) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar editorFile = editor.getFilePath();\n\t\tfile.createPath(editorFile, filePath, function(err, absPath) {\n\t\t\tif (err || !absPath) {\n\t\t\t\tthrow \"Can't save file\";\n\t\t\t}\n\n\t\t\tvar content = data.replace(/^data\\:.+?;.+?,/, '');\n\t\t\tfile.save(absPath, base64.decode(content), function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tthrow 'Unable to save ' + absPath + ': ' + err;\n\t\t\t\t}\n\n\t\t\t\teditor.replaceContent('$0' + filePath, pos, pos + data.length);\n\t\t\t});\n\t\t});\n\n\t\treturn true;\n\t}\n\n\treturn {\n\t\t/**\n\t\t * Action to encode or decode file to data:url\n\t\t * @param  {IEmmetEditor} editor  Editor instance\n\t\t * @param  {String} syntax  Current document syntax\n\t\t * @param  {String} profile Output profile name\n\t\t * @return {Boolean}\n\t\t */\n\t\tencodeDecodeDataUrlAction: function(editor, filepath) {\n\t\t\tvar data = String(editor.getSelection());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar info = editorUtils.outputInfo(editor);\n\n\t\t\tif (!data) {\n\t\t\t\t// no selection, try to find image bounds from current caret position\n\t\t\t\tvar text = info.content, m;\n\t\t\t\twhile (caretPos-- >= 0) {\n\t\t\t\t\tif (startsWith('src=', text, caretPos)) { // found <img src=\"\">\n\t\t\t\t\t\tif ((m = text.substr(caretPos).match(/^(src=([\"'])?)([^'\"<>\\s]+)\\1?/))) {\n\t\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (startsWith('url(', text, caretPos)) { // found CSS url() pattern\n\t\t\t\t\t\tif ((m = text.substr(caretPos).match(/^(url\\((['\"])?)([^'\"\\)\\s]+)\\1?/))) {\n\t\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data) {\n\t\t\t\tif (startsWith('data:', data)) {\n\t\t\t\t\treturn decodeFromBase64(editor, filepath, data, caretPos);\n\t\t\t\t} else {\n\t\t\t\t\treturn encodeToBase64(editor, data, caretPos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t};\n});\n\n},{\"../plugin/file\":\"plugin\\\\file.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/base64\":\"utils\\\\base64.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\editPoints.js\":[function(require,module,exports){\n/**\n * Move between next/prev edit points. 'Edit points' are places between tags \n * and quotes of empty attributes in html\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\t/**\n\t * Search for new caret insertion point\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {Number} inc Search increment: -1  search left, 1  search right\n\t * @param {Number} offset Initial offset relative to current caret position\n\t * @return {Number} Returns -1 if insertion point wasn't found\n\t */\n\tfunction findNewEditPoint(editor, inc, offset) {\n\t\tinc = inc || 1;\n\t\toffset = offset || 0;\n\t\t\n\t\tvar curPoint = editor.getCaretPos() + offset;\n\t\tvar content = String(editor.getContent());\n\t\tvar maxLen = content.length;\n\t\tvar nextPoint = -1;\n\t\tvar reEmptyLine = /^\\s+$/;\n\t\t\n\t\tfunction getLine(ix) {\n\t\t\tvar start = ix;\n\t\t\twhile (start >= 0) {\n\t\t\t\tvar c = content.charAt(start);\n\t\t\t\tif (c == '\\n' || c == '\\r')\n\t\t\t\t\tbreak;\n\t\t\t\tstart--;\n\t\t\t}\n\t\t\t\n\t\t\treturn content.substring(start, ix);\n\t\t}\n\t\t\t\n\t\twhile (curPoint <= maxLen && curPoint >= 0) {\n\t\t\tcurPoint += inc;\n\t\t\tvar curChar = content.charAt(curPoint);\n\t\t\tvar nextChar = content.charAt(curPoint + 1);\n\t\t\tvar prevChar = content.charAt(curPoint - 1);\n\t\t\t\t\n\t\t\tswitch (curChar) {\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (nextChar == curChar && prevChar == '=') {\n\t\t\t\t\t\t// empty attribute\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tif (nextChar == '<') {\n\t\t\t\t\t\t// between tags\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\n':\n\t\t\t\tcase '\\r':\n\t\t\t\t\t// empty line\n\t\t\t\t\tif (reEmptyLine.test(getLine(curPoint - 1))) {\n\t\t\t\t\t\tnextPoint = curPoint;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextPoint != -1)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn nextPoint;\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Move to previous edit point\n\t\t * @param  {IEmmetEditor} editor  Editor instance\n\t\t * @param  {String} syntax  Current document syntax\n\t\t * @param  {String} profile Output profile name\n\t\t * @return {Boolean}\n\t\t */\n\t\tpreviousEditPointAction: function(editor, syntax, profile) {\n\t\t\tvar curPos = editor.getCaretPos();\n\t\t\tvar newPoint = findNewEditPoint(editor, -1);\n\t\t\t\t\n\t\t\tif (newPoint == curPos)\n\t\t\t\t// we're still in the same point, try searching from the other place\n\t\t\t\tnewPoint = findNewEditPoint(editor, -1, -2);\n\t\t\t\n\t\t\tif (newPoint != -1) {\n\t\t\t\teditor.setCaretPos(newPoint);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\n\t\t/**\n\t\t * Move to next edit point\n\t\t * @param  {IEmmetEditor} editor  Editor instance\n\t\t * @param  {String} syntax  Current document syntax\n\t\t * @param  {String} profile Output profile name\n\t\t * @return {Boolean}\n\t\t */\n\t\tnextEditPointAction: function(editor, syntax, profile) {\n\t\t\tvar newPoint = findNewEditPoint(editor, 1);\n\t\t\tif (newPoint != -1) {\n\t\t\t\teditor.setCaretPos(newPoint);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t};\n});\n},{}],\"action\\\\evaluateMath.js\":[function(require,module,exports){\n/**\n * Evaluates simple math expression under caret\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar actionUtils = require('../utils/action');\n\tvar utils = require('../utils/common');\n\tvar math = require('../utils/math');\n\tvar range = require('../assets/range');\n\n\treturn {\n\t\t/**\n\t\t * Evaluates math expression under the caret\n\t\t * @param  {IEmmetEditor} editor\n\t\t * @return {Boolean}\n\t\t */\n\t\tevaluateMathAction: function(editor) {\n\t\t\tvar content = editor.getContent();\n\t\t\tvar chars = '.+-*/\\\\';\n\t\t\t\n\t\t\t/** @type Range */\n\t\t\tvar sel = range(editor.getSelectionRange());\n\t\t\tif (!sel.length()) {\n\t\t\t\tsel = actionUtils.findExpressionBounds(editor, function(ch) {\n\t\t\t\t\treturn utils.isNumeric(ch) || chars.indexOf(ch) != -1;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tif (sel && sel.length()) {\n\t\t\t\tvar expr = sel.substring(content);\n\t\t\t\t\n\t\t\t\t// replace integral division: 11\\2 => Math.round(11/2) \n\t\t\t\texpr = expr.replace(/([\\d\\.\\-]+)\\\\([\\d\\.\\-]+)/g, 'round($1/$2)');\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tvar result = utils.prettifyNumber(math.evaluate(expr));\n\t\t\t\t\teditor.replaceContent(result, sel.start, sel.end);\n\t\t\t\t\teditor.setCaretPos(sel.start + result.length);\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t};\n});\n\n},{\"../assets/range\":\"assets\\\\range.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/math\":\"utils\\\\math.js\"}],\"action\\\\expandAbbreviation.js\":[function(require,module,exports){\n/**\n * 'Expand abbreviation' editor action: extracts abbreviation from current caret \n * position and replaces it with formatted output. \n * <br><br>\n * This behavior can be overridden with custom handlers which can perform \n * different actions when 'Expand Abbreviation' action is called.\n * For example, a CSS gradient handler that produces vendor-prefixed gradient\n * definitions registers its own expand abbreviation handler.  \n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar handlerList = require('../assets/handlerList');\n\tvar range = require('../assets/range');\n\tvar prefs = require('../assets/preferences');\n\tvar utils = require('../utils/common');\n\tvar editorUtils = require('../utils/editor');\n\tvar actionUtils = require('../utils/action');\n\tvar cssGradient = require('../resolver/cssGradient');\n\tvar parser = require('../parser/abbreviation');\n\n\t/**\n\t * Search for abbreviation in editor from current caret position\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @return {String}\n\t */\n\tfunction findAbbreviation(editor) {\n\t\tvar r = range(editor.getSelectionRange());\n\t\tvar content = String(editor.getContent());\n\t\tif (r.length()) {\n\t\t\t// abbreviation is selected by user\n\t\t\treturn r.substring(content);\n\t\t}\n\t\t\n\t\t// search for new abbreviation from current caret position\n\t\tvar curLine = editor.getCurrentLineRange();\n\t\treturn actionUtils.extractAbbreviation(content.substring(curLine.start, r.start));\n\t}\n\n\t/**\n\t * @type HandlerList List of registered handlers\n\t */\n\tvar handlers = handlerList.create();\n\n\t// XXX setup default expand handlers\n\t\n\t/**\n\t * Extracts abbreviation from current caret \n\t * position and replaces it with formatted output \n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \n\t * successfully\n\t */\n\thandlers.add(function(editor, syntax, profile) {\n\t\tvar caretPos = editor.getSelectionRange().end;\n\t\tvar abbr = findAbbreviation(editor);\n\t\t\t\n\t\tif (abbr) {\n\t\t\tvar content = parser.expand(abbr, {\n\t\t\t\tsyntax: syntax, \n\t\t\t\tprofile: profile, \n\t\t\t\tcontextNode: actionUtils.captureContext(editor)\n\t\t\t});\n\n\t\t\tif (content) {\n\t\t\t\tvar replaceFrom = caretPos - abbr.length;\n\t\t\t\tvar replaceTo = caretPos;\n\n\t\t\t\t// a special case for CSS: if editor already contains\n\t\t\t\t// semicolon right after current caret position  replace it too\n\t\t\t\tvar cssSyntaxes = prefs.getArray('css.syntaxes');\n\t\t\t\tif (cssSyntaxes && ~cssSyntaxes.indexOf(syntax)) {\n\t\t\t\t\tvar curContent = editor.getContent();\n\t\t\t\t\tif (curContent.charAt(caretPos) == ';' && content.charAt(content.length - 1) == ';') {\n\t\t\t\t\t\treplaceTo++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\teditor.replaceContent(content, replaceFrom, replaceTo);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {order: -1});\n\thandlers.add(cssGradient.expandAbbreviationHandler.bind(cssGradient));\n\t\t\n\treturn {\n\t\t/**\n\t\t * The actual Expand Abbreviation action routine\n\t\t * @param  {IEmmetEditor} editor  Editor instance\n\t\t * @param  {String} syntax  Current document syntax\n\t\t * @param  {String} profile Output profile name\n\t\t * @return {Boolean}\n\t\t */\n\t\texpandAbbreviationAction: function(editor, syntax, profile) {\n\t\t\tvar args = utils.toArray(arguments);\n\t\t\t\n\t\t\t// normalize incoming arguments\n\t\t\tvar info = editorUtils.outputInfo(editor, syntax, profile);\n\t\t\targs[1] = info.syntax;\n\t\t\targs[2] = info.profile;\n\t\t\t\n\t\t\treturn handlers.exec(false, args);\n\t\t},\n\n\t\t/**\n\t\t * A special case of Expand Abbreviation action, invoked by Tab key.\n\t\t * In this case if abbreviation wasnt expanded successfully or theres a selecetion, \n\t\t * the current line/selection will be indented. \n\t\t * @param  {IEmmetEditor} editor  Editor instance\n\t\t * @param  {String} syntax  Current document syntax\n\t\t * @param  {String} profile Output profile name\n\t\t * @return {Boolean}\n\t\t */\n\t\texpandAbbreviationWithTabAction: function(editor, syntax, profile) {\n\t\t\tvar sel = editor.getSelection();\n\t\t\tvar indent = '\\t';\n\n\t\t\t// if something is selected in editor,\n\t\t\t// we should indent the selected content\n\t\t\tif (sel) {\n\t\t\t\tvar selRange = range(editor.getSelectionRange());\n\t\t\t\tvar content = utils.padString(sel, indent);\n\t\t\t\t\n\t\t\t\teditor.replaceContent(indent + '${0}', editor.getCaretPos());\n\t\t\t\tvar replaceRange = range(editor.getCaretPos(), selRange.length());\n\t\t\t\teditor.replaceContent(content, replaceRange.start, replaceRange.end, true);\n\t\t\t\teditor.createSelection(replaceRange.start, replaceRange.start + content.length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\t// nothing selected, try to expand\n\t\t\tif (!this.expandAbbreviationAction(editor, syntax, profile)) {\n\t\t\t\teditor.replaceContent(indent, editor.getCaretPos());\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t},\n\n\t\t\n\t\t_defaultHandler: function(editor, syntax, profile) {\n\t\t\tvar caretPos = editor.getSelectionRange().end;\n\t\t\tvar abbr = this.findAbbreviation(editor);\n\t\t\t\t\n\t\t\tif (abbr) {\n\t\t\t\tvar ctx = actionUtils.captureContext(editor);\n\t\t\t\tvar content = parser.expand(abbr, syntax, profile, ctx);\n\t\t\t\tif (content) {\n\t\t\t\t\teditor.replaceContent(content, caretPos - abbr.length, caretPos);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\n\t\t/**\n\t\t * Adds custom expand abbreviation handler. The passed function should \n\t\t * return <code>true</code> if it was performed successfully, \n\t\t * <code>false</code> otherwise.\n\t\t * \n\t\t * Added handlers will be called when 'Expand Abbreviation' is called\n\t\t * in order they were added\n\t\t * @memberOf expandAbbreviation\n\t\t * @param {Function} fn\n\t\t * @param {Object} options\n\t\t */\n\t\taddHandler: function(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered handler\n\t\t * @returns\n\t\t */\n\t\tremoveHandler: function(fn) {\n\t\t\thandlers.remove(fn);\n\t\t},\n\t\t\n\t\tfindAbbreviation: findAbbreviation\n\t};\n});\n},{\"../assets/handlerList\":\"assets\\\\handlerList.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/range\":\"assets\\\\range.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"../resolver/cssGradient\":\"resolver\\\\cssGradient.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\incrementDecrement.js\":[function(require,module,exports){\n/**\n * Increment/decrement number under cursor\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar actionUtils = require('../utils/action');\n\n\t/**\n\t * Returns length of integer part of number\n\t * @param {String} num\n\t */\n\tfunction intLength(num) {\n\t\tnum = num.replace(/^\\-/, '');\n\t\tif (~num.indexOf('.')) {\n\t\t\treturn num.split('.')[0].length;\n\t\t}\n\t\t\n\t\treturn num.length;\n\t}\n\n\treturn {\n\t\tincrement01Action: function(editor) {\n\t\t\treturn this.incrementNumber(editor, .1);\n\t\t},\n\n\t\tincrement1Action: function(editor) {\n\t\t\treturn this.incrementNumber(editor, 1);\n\t\t},\n\n\t\tincrement10Action: function(editor) {\n\t\t\treturn this.incrementNumber(editor, 10);\n\t\t},\n\n\t\tdecrement01Action: function(editor) {\n\t\t\treturn this.incrementNumber(editor, -.1);\n\t\t},\n\n\t\tdecrement1Action: function(editor) {\n\t\t\treturn this.incrementNumber(editor, -1);\n\t\t},\n\n\t\tdecrement10Action: function(editor) {\n\t\t\treturn this.incrementNumber(editor, -10);\n\t\t},\n\n\t\t/**\n\t\t * Default method to increment/decrement number under\n\t\t * caret with given step\n\t\t * @param  {IEmmetEditor} editor\n\t\t * @param  {Number} step\n\t\t * @return {Boolean}\n\t\t */\n\t\tincrementNumber: function(editor, step) {\n\t\t\tvar hasSign = false;\n\t\t\tvar hasDecimal = false;\n\t\t\t\t\n\t\t\tvar r = actionUtils.findExpressionBounds(editor, function(ch, pos, content) {\n\t\t\t\tif (utils.isNumeric(ch))\n\t\t\t\t\treturn true;\n\t\t\t\tif (ch == '.') {\n\t\t\t\t\t// make sure that next character is numeric too\n\t\t\t\t\tif (!utils.isNumeric(content.charAt(pos + 1)))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t\n\t\t\t\t\treturn hasDecimal ? false : hasDecimal = true;\n\t\t\t\t}\n\t\t\t\tif (ch == '-')\n\t\t\t\t\treturn hasSign ? false : hasSign = true;\n\t\t\t\t\t\n\t\t\t\treturn false;\n\t\t\t});\n\t\t\t\t\n\t\t\tif (r && r.length()) {\n\t\t\t\tvar strNum = r.substring(String(editor.getContent()));\n\t\t\t\tvar num = parseFloat(strNum);\n\t\t\t\tif (!isNaN(num)) {\n\t\t\t\t\tnum = utils.prettifyNumber(num + step);\n\t\t\t\t\t\n\t\t\t\t\t// do we have zero-padded number?\n\t\t\t\t\tif (/^(\\-?)0+[1-9]/.test(strNum)) {\n\t\t\t\t\t\tvar minus = '';\n\t\t\t\t\t\tif (RegExp.$1) {\n\t\t\t\t\t\t\tminus = '-';\n\t\t\t\t\t\t\tnum = num.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar parts = num.split('.');\n\t\t\t\t\t\tparts[0] = utils.zeroPadString(parts[0], intLength(strNum));\n\t\t\t\t\t\tnum = minus + parts.join('.');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\teditor.replaceContent(num, r.start, r.end);\n\t\t\t\t\teditor.createSelection(r.start, r.start + num.length);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t};\n});\n},{\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\"}],\"action\\\\lineBreaks.js\":[function(require,module,exports){\n/**\n * Actions to insert line breaks. Some simple editors (like browser's \n * &lt;textarea&gt;, for example) do not provide such simple things\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar prefs = require('../assets/preferences');\n\tvar utils = require('../utils/common');\n\tvar resources = require('../assets/resources');\n\tvar htmlMatcher = require('../assets/htmlMatcher');\n\tvar editorUtils = require('../utils/editor');\n\n\tvar xmlSyntaxes = ['html', 'xml', 'xsl'];\n\n\t// setup default preferences\n\tprefs.define('css.closeBraceIndentation', '\\n',\n\t\t\t'Indentation before closing brace of CSS rule. Some users prefere ' \n\t\t\t+ 'indented closing brace of CSS rule for better readability. '\n\t\t\t+ 'This preferences value will be automatically inserted before '\n\t\t\t+ 'closing brace when user adds newline in newly created CSS rule '\n\t\t\t+ '(e.g. when Insert formatted linebreak action will be performed ' \n\t\t\t+ 'in CSS file). If youre such user, you may want to write put a value ' \n\t\t\t+ 'like <code>\\\\n\\\\t</code> in this preference.');\n\n\treturn {\n\t\t/**\n\t\t * Inserts newline character with proper indentation. This action is used in\n\t\t * editors that doesn't have indentation control (like textarea element) to \n\t\t * provide proper indentation for inserted newlines\n\t\t * @param {IEmmetEditor} editor Editor instance\n\t\t */\n\t\tinsertLineBreakAction: function(editor) {\n\t\t\tif (!this.insertLineBreakOnlyAction(editor)) {\n\t\t\t\tvar curPadding = editorUtils.getCurrentLinePadding(editor);\n\t\t\t\tvar content = String(editor.getContent());\n\t\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\t\tvar len = content.length;\n\t\t\t\tvar nl = '\\n';\n\t\t\t\t\t\n\t\t\t\t// check out next line padding\n\t\t\t\tvar lineRange = editor.getCurrentLineRange();\n\t\t\t\tvar nextPadding = '';\n\t\t\t\t\t\n\t\t\t\tfor (var i = lineRange.end, ch; i < len; i++) {\n\t\t\t\t\tch = content.charAt(i);\n\t\t\t\t\tif (ch == ' ' || ch == '\\t')\n\t\t\t\t\t\tnextPadding += ch;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (nextPadding.length > curPadding.length) {\n\t\t\t\t\teditor.replaceContent(nl + nextPadding, caretPos, caretPos, true);\n\t\t\t\t} else {\n\t\t\t\t\teditor.replaceContent(nl, caretPos);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t},\n\n\t\t/**\n\t\t * Inserts newline character with proper indentation in specific positions only.\n\t\t * @param {IEmmetEditor} editor\n\t\t * @return {Boolean} Returns <code>true</code> if line break was inserted \n\t\t */\n\t\tinsertLineBreakOnlyAction: function(editor) {\n\t\t\tvar info = editorUtils.outputInfo(editor);\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar nl = '\\n';\n\t\t\tvar pad = '\\t';\n\t\t\t\n\t\t\tif (~xmlSyntaxes.indexOf(info.syntax)) {\n\t\t\t\t// let's see if we're breaking newly created tag\n\t\t\t\tvar tag = htmlMatcher.tag(info.content, caretPos);\n\t\t\t\tif (tag && !tag.innerRange.length()) {\n\t\t\t\t\teditor.replaceContent(nl + pad + utils.getCaretPlaceholder() + nl, caretPos);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (info.syntax == 'css') {\n\t\t\t\t/** @type String */\n\t\t\t\tvar content = info.content;\n\t\t\t\tif (caretPos && content.charAt(caretPos - 1) == '{') {\n\t\t\t\t\tvar append = prefs.get('css.closeBraceIndentation');\n\t\t\t\t\t\n\t\t\t\t\tvar hasCloseBrace = content.charAt(caretPos) == '}';\n\t\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\t\t// do we really need special formatting here?\n\t\t\t\t\t\t// check if this is really a newly created rule,\n\t\t\t\t\t\t// look ahead for a closing brace\n\t\t\t\t\t\tfor (var i = caretPos, il = content.length, ch; i < il; i++) {\n\t\t\t\t\t\t\tch = content.charAt(i);\n\t\t\t\t\t\t\tif (ch == '{') {\n\t\t\t\t\t\t\t\t// ok, this is a new rule without closing brace\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (ch == '}') {\n\t\t\t\t\t\t\t\t// not a new rule, just add indentation\n\t\t\t\t\t\t\t\tappend = '';\n\t\t\t\t\t\t\t\thasCloseBrace = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\t\tappend += '}';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// defining rule set\n\t\t\t\t\tvar insValue = nl + pad + utils.getCaretPlaceholder() + append;\n\t\t\t\t\teditor.replaceContent(insValue, caretPos);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\treturn false;\n\t\t}\n\t};\n});\n\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\main.js\":[function(require,module,exports){\n/**\n * Module describes and performs Emmet actions. The actions themselves are\n * defined in <i>actions</i> folder\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\n\t// all registered actions\n\tvar actions = {};\n\n\t// load all default actions\n\tvar actionModules = {\n\t\tbase64: require('./base64'),\n\t\teditPoints: require('./editPoints'),\n\t\tevaluateMath: require('./evaluateMath'),\n\t\texpandAbbreviation: require('./expandAbbreviation'),\n\t\tincrementDecrement: require('./incrementDecrement'),\n\t\tlineBreaks: require('./lineBreaks'),\n\t\tbalance: require('./balance'),\n\t\tmergeLines: require('./mergeLines'),\n\t\treflectCSSValue: require('./reflectCSSValue'),\n\t\tremoveTag: require('./removeTag'),\n\t\tselectItem: require('./selectItem'),\n\t\tselectLine: require('./selectLine'),\n\t\tsplitJoinTag: require('./splitJoinTag'),\n\t\ttoggleComment: require('./toggleComment'),\n\t\tupdateImageSize: require('./updateImageSize'),\n\t\twrapWithAbbreviation: require('./wrapWithAbbreviation'),\n\t\tupdateTag: require('./updateTag')\n\t};\n\n\tfunction addAction(name, fn, options) {\n\t\tname = name.toLowerCase();\n\t\toptions = options || {};\n\t\t\n\t\tif (typeof options === 'string') {\n\t\t\toptions = {label: options};\n\t\t}\n\n\t\tif (!options.label) {\n\t\t\toptions.label = humanizeActionName(name);\n\t\t}\n\t\t\n\t\tactions[name] = {\n\t\t\tname: name,\n\t\t\tfn: fn,\n\t\t\toptions: options\n\t\t};\n\t}\n\t\n\t/**\n\t * Humanizes action name, makes it more readable for people\n\t * @param {String} name Action name (like 'expand_abbreviation')\n\t * @return Humanized name (like 'Expand Abbreviation')\n\t */\n\tfunction humanizeActionName(name) {\n\t\treturn utils.trim(name.charAt(0).toUpperCase() \n\t\t\t+ name.substring(1).replace(/_[a-z]/g, function(str) {\n\t\t\t\treturn ' ' + str.charAt(1).toUpperCase();\n\t\t\t}));\n\t}\n\n\tvar bind = function(name, method) {\n\t\tvar m = actionModules[name];\n\t\treturn m[method].bind(m);\n\t};\n\n\t// XXX register default actions\n\taddAction('encode_decode_data_url', bind('base64', 'encodeDecodeDataUrlAction'), 'Encode\\\\Decode data:URL image');\n\taddAction('prev_edit_point', bind('editPoints', 'previousEditPointAction'), 'Previous Edit Point');\n\taddAction('next_edit_point', bind('editPoints', 'nextEditPointAction'), 'Next Edit Point');\n\taddAction('evaluate_math_expression', bind('evaluateMath', 'evaluateMathAction'), 'Numbers/Evaluate Math Expression');\n\taddAction('expand_abbreviation_with_tab', bind('expandAbbreviation', 'expandAbbreviationWithTabAction'), {hidden: true});\n\taddAction('expand_abbreviation', bind('expandAbbreviation', 'expandAbbreviationAction'), 'Expand Abbreviation');\n\taddAction('insert_formatted_line_break_only', bind('lineBreaks', 'insertLineBreakOnlyAction'), {hidden: true});\n\taddAction('insert_formatted_line_break', bind('lineBreaks', 'insertLineBreakAction'), {hidden: true});\n\taddAction('balance_inward', bind('balance', 'balanceInwardAction'), 'Balance (inward)');\n\taddAction('balance_outward', bind('balance', 'balanceOutwardAction'), 'Balance (outward)');\n\taddAction('matching_pair', bind('balance', 'goToMatchingPairAction'), 'HTML/Go To Matching Tag Pair');\n\taddAction('merge_lines', bind('mergeLines', 'mergeLinesAction'), 'Merge Lines');\n\taddAction('reflect_css_value', bind('reflectCSSValue', 'reflectCSSValueAction'), 'CSS/Reflect Value');\n\taddAction('remove_tag', bind('removeTag', 'removeTagAction'), 'HTML/Remove Tag');\n\taddAction('select_next_item', bind('selectItem', 'selectNextItemAction'), 'Select Next Item');\n\taddAction('select_previous_item', bind('selectItem', 'selectPreviousItemAction'), 'Select Previous Item');\n\taddAction('split_join_tag', bind('splitJoinTag', 'splitJoinTagAction'), 'HTML/Split\\\\Join Tag Declaration');\n\taddAction('toggle_comment', bind('toggleComment', 'toggleCommentAction'), 'Toggle Comment');\n\taddAction('update_image_size', bind('updateImageSize', 'updateImageSizeAction'), 'Update Image Size');\n\taddAction('wrap_with_abbreviation', bind('wrapWithAbbreviation', 'wrapWithAbbreviationAction'), 'Wrap With Abbreviation');\n\taddAction('update_tag', bind('updateTag', 'updateTagAction'), 'HTML/Update Tag');\n\n\t[1, -1, 10, -10, 0.1, -0.1].forEach(function(num) {\n\t\tvar prefix = num > 0 ? 'increment' : 'decrement';\n\t\tvar suffix = String(Math.abs(num)).replace('.', '').substring(0, 2);\n\t\tvar actionId = prefix + '_number_by_' + suffix;\n\t\tvar actionMethod = prefix + suffix + 'Action';\n\t\tvar actionLabel = 'Numbers/' + prefix.charAt(0).toUpperCase() + prefix.substring(1) + ' number by ' + Math.abs(num);\n\t\taddAction(actionId, bind('incrementDecrement', actionMethod), actionLabel);\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Registers new action\n\t\t * @param {String} name Action name\n\t\t * @param {Function} fn Action function\n\t\t * @param {Object} options Custom action options:<br>\n\t\t * <b>label</b> : (<code>String</code>)  Human-readable action name. \n\t\t * May contain '/' symbols as submenu separators<br>\n\t\t * <b>hidden</b> : (<code>Boolean</code>)  Indicates whether action\n\t\t * should be displayed in menu (<code>getMenu()</code> method)\n\t\t */\n\t\tadd: addAction,\n\t\t\n\t\t/**\n\t\t * Returns action object\n\t\t * @param {String} name Action name\n\t\t * @returns {Object}\n\t\t */\n\t\tget: function(name) {\n\t\t\treturn actions[name.toLowerCase()];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Runs Emmet action. For list of available actions and their\n\t\t * arguments see <i>actions</i> folder.\n\t\t * @param {String} name Action name \n\t\t * @param {Array} args Additional arguments. It may be array of arguments\n\t\t * or inline arguments. The first argument should be <code>IEmmetEditor</code> instance\n\t\t * @returns {Boolean} Status of performed operation, <code>true</code>\n\t\t * means action was performed successfully.\n\t\t * @example\n\t\t * require('action/main').run('expand_abbreviation', editor);  \n\t\t * require('action/main').run('wrap_with_abbreviation', [editor, 'div']);  \n\t\t */\n\t\trun: function(name, args) {\n\t\t\tif (!Array.isArray(args)) {\n\t\t\t\targs = utils.toArray(arguments, 1);\n\t\t\t}\n\t\t\t\n\t\t\tvar action = this.get(name);\n\t\t\tif (!action) {\n\t\t\t\tthrow new Error('Action \"' + name + '\" is not defined');\n\t\t\t}\n\n\t\t\treturn action.fn.apply(action, args);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all registered actions as object\n\t\t * @returns {Object}\n\t\t */\n\t\tgetAll: function() {\n\t\t\treturn actions;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all registered actions as array\n\t\t * @returns {Array}\n\t\t */\n\t\tgetList: function() {\n\t\t\tvar all = this.getAll();\n\t\t\treturn Object.keys(all).map(function(key) {\n\t\t\t\treturn all[key];\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns actions list as structured menu. If action has <i>label</i>,\n\t\t * it will be splitted by '/' symbol into submenus (for example: \n\t\t * CSS/Reflect Value) and grouped with other items\n\t\t * @param {Array} skipActions List of action identifiers that should be \n\t\t * skipped from menu\n\t\t * @returns {Array}\n\t\t */\n\t\tgetMenu: function(skipActions) {\n\t\t\tvar result = [];\n\t\t\tskipActions = skipActions || [];\n\t\t\tthis.getList().forEach(function(action) {\n\t\t\t\tif (action.options.hidden || ~skipActions.indexOf(action.name))\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tvar actionName = humanizeActionName(action.name);\n\t\t\t\tvar ctx = result;\n\t\t\t\tif (action.options.label) {\n\t\t\t\t\tvar parts = action.options.label.split('/');\n\t\t\t\t\tactionName = parts.pop();\n\t\t\t\t\t\n\t\t\t\t\t// create submenus, if needed\n\t\t\t\t\tvar menuName, submenu;\n\t\t\t\t\twhile ((menuName = parts.shift())) {\n\t\t\t\t\t\tsubmenu = utils.find(ctx, function(item) {\n\t\t\t\t\t\t\treturn item.type == 'submenu' && item.name == menuName;\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!submenu) {\n\t\t\t\t\t\t\tsubmenu = {\n\t\t\t\t\t\t\t\tname: menuName,\n\t\t\t\t\t\t\t\ttype: 'submenu',\n\t\t\t\t\t\t\t\titems: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tctx.push(submenu);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tctx = submenu.items;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.push({\n\t\t\t\t\ttype: 'action',\n\t\t\t\t\tname: action.name,\n\t\t\t\t\tlabel: actionName\n\t\t\t\t});\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Returns action name associated with menu item title\n\t\t * @param {String} title\n\t\t * @returns {String}\n\t\t */\n\t\tgetActionNameForMenuTitle: function(title, menu) {\n\t\t\treturn utils.find(menu || this.getMenu(), function(val) {\n\t\t\t\tif (val.type == 'action') {\n\t\t\t\t\tif (val.label == title || val.name == title) {\n\t\t\t\t\t\treturn val.name;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn this.getActionNameForMenuTitle(title, val.items);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t};\n});\n},{\"../utils/common\":\"utils\\\\common.js\",\"./balance\":\"action\\\\balance.js\",\"./base64\":\"action\\\\base64.js\",\"./editPoints\":\"action\\\\editPoints.js\",\"./evaluateMath\":\"action\\\\evaluateMath.js\",\"./expandAbbreviation\":\"action\\\\expandAbbreviation.js\",\"./incrementDecrement\":\"action\\\\incrementDecrement.js\",\"./lineBreaks\":\"action\\\\lineBreaks.js\",\"./mergeLines\":\"action\\\\mergeLines.js\",\"./reflectCSSValue\":\"action\\\\reflectCSSValue.js\",\"./removeTag\":\"action\\\\removeTag.js\",\"./selectItem\":\"action\\\\selectItem.js\",\"./selectLine\":\"action\\\\selectLine.js\",\"./splitJoinTag\":\"action\\\\splitJoinTag.js\",\"./toggleComment\":\"action\\\\toggleComment.js\",\"./updateImageSize\":\"action\\\\updateImageSize.js\",\"./updateTag\":\"action\\\\updateTag.js\",\"./wrapWithAbbreviation\":\"action\\\\wrapWithAbbreviation.js\"}],\"action\\\\mergeLines.js\":[function(require,module,exports){\n/**\n * Merges selected lines or lines between XHTML tag pairs\n * @param {Function} require\n * @param {Underscore} _\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar htmlMatcher = require('../assets/htmlMatcher');\n\tvar utils = require('../utils/common');\n\tvar editorUtils = require('../utils/editor');\n\tvar range = require('../assets/range');\n\n\treturn {\n\t\tmergeLinesAction: function(editor) {\n\t\t\tvar info = editorUtils.outputInfo(editor);\n\t\t\n\t\t\tvar selection = range(editor.getSelectionRange());\n\t\t\tif (!selection.length()) {\n\t\t\t\t// find matching tag\n\t\t\t\tvar pair = htmlMatcher.find(info.content, editor.getCaretPos());\n\t\t\t\tif (pair) {\n\t\t\t\t\tselection = pair.outerRange;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (selection.length()) {\n\t\t\t\t// got range, merge lines\n\t\t\t\tvar text =  selection.substring(info.content);\n\t\t\t\tvar lines = utils.splitByLines(text);\n\t\t\t\t\n\t\t\t\tfor (var i = 1; i < lines.length; i++) {\n\t\t\t\t\tlines[i] = lines[i].replace(/^\\s+/, '');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttext = lines.join('').replace(/\\s{2,}/, ' ');\n\t\t\t\tvar textLen = text.length;\n\t\t\t\ttext = utils.escapeText(text);\n\t\t\t\teditor.replaceContent(text, selection.start, selection.end);\n\t\t\t\teditor.createSelection(selection.start, selection.start + textLen);\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t};\n});\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\reflectCSSValue.js\":[function(require,module,exports){\n/**\n * Reflect CSS value: takes rule's value under caret and pastes it for the same \n * rules with vendor prefixes\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar handlerList = require('../assets/handlerList');\n\tvar prefs = require('../assets/preferences');\n\tvar cssResolver = require('../resolver/css');\n\tvar cssEditTree = require('../editTree/css');\n\tvar utils = require('../utils/common');\n\tvar actionUtils = require('../utils/action');\n\tvar editorUtils = require('../utils/editor');\n\tvar cssGradient = require('../resolver/cssGradient');\n\n\tprefs.define('css.reflect.oldIEOpacity', false, 'Support IE6/7/8 opacity notation, e.g. <code>filter:alpha(opacity=...)</code>.\\\n\t\tNote that CSS3 and SVG also provides <code>filter</code> property so this option is disabled by default.')\n\n\t/**\n\t * @type HandlerList List of registered handlers\n\t */\n\tvar handlers = handlerList.create();\n\t\n\tfunction doCSSReflection(editor) {\n\t\tvar outputInfo = editorUtils.outputInfo(editor);\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\tvar cssRule = cssEditTree.parseFromPosition(outputInfo.content, caretPos);\n\t\tif (!cssRule) return;\n\t\t\n\t\tvar property = cssRule.itemFromPosition(caretPos, true);\n\t\t// no property under cursor, nothing to reflect\n\t\tif (!property) return;\n\t\t\n\t\tvar oldRule = cssRule.source;\n\t\tvar offset = cssRule.options.offset;\n\t\tvar caretDelta = caretPos - offset - property.range().start;\n\t\t\n\t\thandlers.exec(false, [property]);\n\t\t\n\t\tif (oldRule !== cssRule.source) {\n\t\t\treturn {\n\t\t\t\tdata:  cssRule.source,\n\t\t\t\tstart: offset,\n\t\t\t\tend:   offset + oldRule.length,\n\t\t\t\tcaret: offset + property.range().start + caretDelta\n\t\t\t};\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns regexp that should match reflected CSS property names\n\t * @param {String} name Current CSS property name\n\t * @return {RegExp}\n\t */\n\tfunction getReflectedCSSName(name) {\n\t\tname = cssEditTree.baseName(name);\n\t\tvar vendorPrefix = '^(?:\\\\-\\\\w+\\\\-)?', m;\n\t\t\n\t\tif ((name == 'opacity' || name == 'filter') && prefs.get('css.reflect.oldIEOpacity')) {\n\t\t\treturn new RegExp(vendorPrefix + '(?:opacity|filter)$');\n\t\t} else if ((m = name.match(/^border-radius-(top|bottom)(left|right)/))) {\n\t\t\t// Mozilla-style border radius\n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-' + m[1] + '-' + m[2] + '-radius)$');\n\t\t} else if ((m = name.match(/^border-(top|bottom)-(left|right)-radius/))) { \n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-radius-' + m[1] + m[2] + ')$');\n\t\t}\n\t\t\n\t\treturn new RegExp(vendorPrefix + name + '$');\n\t}\n\n\t/**\n\t * Reflects inner CSS properites in given value\n\t * agains names vendor prefix. In other words, it tries\n\t * to modify `transform 0.2s linear` value for `-webkit-transition`\n\t * property\n\t * @param  {String} name  Reciever CSS property name\n\t * @param  {String} value New property value\n\t * @return {String}\n\t */\n\tfunction reflectValueParts(name, value) {\n\t\t// detects and updates vendor-specific properties in value,\n\t\t// e.g. -webkit-transition: -webkit-transform\n\t\t\n\t\tvar reVendor = /^\\-(\\w+)\\-/;\n\t\tvar propPrefix = reVendor.test(name) ? RegExp.$1.toLowerCase() : '';\n\t\tvar parts = cssEditTree.findParts(value);\n\n\t\tparts.reverse();\n\t\tparts.forEach(function(part) {\n\t\t\tvar partValue = part.substring(value).replace(reVendor, '');\n\t\t\tvar prefixes = cssResolver.vendorPrefixes(partValue);\n\t\t\tif (prefixes) {\n\t\t\t\t// if prefixes are not null then given value can\n\t\t\t\t// be resolved against Can I Use database and may or\n\t\t\t\t// may not contain prefixed variant\n\t\t\t\tif (propPrefix && ~prefixes.indexOf(propPrefix)) {\n\t\t\t\t\tpartValue = '-' + propPrefix + '-' + partValue;\n\t\t\t\t}\n\n\t\t\t\tvalue = utils.replaceSubstring(value, partValue, part);\n\t\t\t}\n\t\t});\n\n\t\treturn value;\n\t}\n\t\n\t/**\n\t * Reflects value from <code>donor</code> into <code>receiver</code>\n\t * @param {CSSProperty} donor Donor CSS property from which value should\n\t * be reflected\n\t * @param {CSSProperty} receiver Property that should receive reflected \n\t * value from donor\n\t */\n\tfunction reflectValue(donor, receiver) {\n\t\tvar value = getReflectedValue(donor.name(), donor.value(), \n\t\t\t\treceiver.name(), receiver.value());\n\t\t\n\t\tvalue = reflectValueParts(receiver.name(), value);\n\t\treceiver.value(value);\n\t}\n\t\n\t/**\n\t * Returns value that should be reflected for <code>refName</code> CSS property\n\t * from <code>curName</code> property. This function is used for special cases,\n\t * when the same result must be achieved with different properties for different\n\t * browsers. For example: opcity:0.5;  filter:alpha(opacity=50);<br><br>\n\t * \n\t * This function does value conversion between different CSS properties\n\t * \n\t * @param {String} curName Current CSS property name\n\t * @param {String} curValue Current CSS property value\n\t * @param {String} refName Receiver CSS property's name \n\t * @param {String} refValue Receiver CSS property's value\n\t * @return {String} New value for receiver property\n\t */\n\tfunction getReflectedValue(curName, curValue, refName, refValue) {\n\t\tcurName = cssEditTree.baseName(curName);\n\t\trefName = cssEditTree.baseName(refName);\n\t\t\n\t\tif (curName == 'opacity' && refName == 'filter') {\n\t\t\treturn refValue.replace(/opacity=[^)]*/i, 'opacity=' + Math.floor(parseFloat(curValue) * 100));\n\t\t} else if (curName == 'filter' && refName == 'opacity') {\n\t\t\tvar m = curValue.match(/opacity=([^)]*)/i);\n\t\t\treturn m ? utils.prettifyNumber(parseInt(m[1], 10) / 100) : refValue;\n\t\t}\n\t\t\n\t\treturn curValue;\n\t}\n\t\n\tmodule = module || {};\n\tmodule.exports = {\n\t\treflectCSSValueAction: function(editor) {\n\t\t\tif (editor.getSyntax() != 'css') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn actionUtils.compoundUpdate(editor, doCSSReflection(editor));\n\t\t},\n\n\t\t_defaultHandler: function(property) {\n\t\t\tvar reName = getReflectedCSSName(property.name());\n\t\t\tproperty.parent.list().forEach(function(p) {\n\t\t\t\tif (reName.test(p.name())) {\n\t\t\t\t\treflectValue(property, p);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Adds custom reflect handler. The passed function will receive matched\n\t\t * CSS property (as <code>CSSEditElement</code> object) and should\n\t\t * return <code>true</code> if it was performed successfully (handled \n\t\t * reflection), <code>false</code> otherwise.\n\t\t * @param {Function} fn\n\t\t * @param {Object} options\n\t\t */\n\t\taddHandler: function(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered handler\n\t\t * @returns\n\t\t */\n\t\tremoveHandler: function(fn) {\n\t\t\thandlers.remove(fn);\n\t\t}\n\t};\n\n\t// XXX add default handlers\n\thandlers.add(module.exports._defaultHandler.bind(module.exports), {order: -1});\n\thandlers.add(cssGradient.reflectValueHandler.bind(cssGradient));\n\n\treturn module.exports;\n});\n},{\"../assets/handlerList\":\"assets\\\\handlerList.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../resolver/css\":\"resolver\\\\css.js\",\"../resolver/cssGradient\":\"resolver\\\\cssGradient.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\removeTag.js\":[function(require,module,exports){\n/**\n * Gracefully removes tag under cursor\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar editorUtils = require('../utils/editor');\n\tvar htmlMatcher = require('../assets/htmlMatcher');\n\n\treturn {\n\t\tremoveTagAction: function(editor) {\n\t\t\tvar info = editorUtils.outputInfo(editor);\n\t\t\t\n\t\t\t// search for tag\n\t\t\tvar tag = htmlMatcher.tag(info.content, editor.getCaretPos());\n\t\t\tif (tag) {\n\t\t\t\tif (!tag.close) {\n\t\t\t\t\t// simply remove unary tag\n\t\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder(), tag.range.start, tag.range.end);\n\t\t\t\t} else {\n\t\t\t\t\t// remove tag and its newlines\n\t\t\t\t\t/** @type Range */\n\t\t\t\t\tvar tagContentRange = utils.narrowToNonSpace(info.content, tag.innerRange);\n\t\t\t\t\t/** @type Range */\n\t\t\t\t\tvar startLineBounds = utils.findNewlineBounds(info.content, tagContentRange.start);\n\t\t\t\t\tvar startLinePad = utils.getLinePadding(startLineBounds.substring(info.content));\n\t\t\t\t\tvar tagContent = tagContentRange.substring(info.content);\n\t\t\t\t\t\n\t\t\t\t\ttagContent = utils.unindentString(tagContent, startLinePad);\n\t\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder() + utils.escapeText(tagContent), tag.outerRange.start, tag.outerRange.end);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t};\n});\n\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\selectItem.js\":[function(require,module,exports){\n/**\n * Actions that use stream parsers and tokenizers for traversing:\n * -- Search for next/previous items in HTML\n * -- Search for next/previous items in CSS\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar range = require('../assets/range');\n\tvar utils = require('../utils/common');\n\tvar editorUtils = require('../utils/editor');\n\tvar actionUtils = require('../utils/action');\n\tvar stringStream = require('../assets/stringStream');\n\tvar xmlParser = require('../parser/xml');\n\tvar cssEditTree = require('../editTree/css');\n\tvar cssSections = require('../utils/cssSections');\n\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\n\t/**\n\t * Generic function for searching for items to select\n\t * @param {IEmmetEditor} editor\n\t * @param {Boolean} isBackward Search backward (search forward otherwise)\n\t * @param {Function} extractFn Function that extracts item content\n\t * @param {Function} rangeFn Function that search for next token range\n\t */\n\tfunction findItem(editor, isBackward, extractFn, rangeFn) {\n\t\tvar content = editorUtils.outputInfo(editor).content;\n\t\t\n\t\tvar contentLength = content.length;\n\t\tvar itemRange, rng;\n\t\t/** @type Range */\n\t\tvar prevRange = range(-1, 0);\n\t\t/** @type Range */\n\t\tvar sel = range(editor.getSelectionRange());\n\t\t\n\t\tvar searchPos = sel.start, loop = 100000; // endless loop protection\n\t\twhile (searchPos >= 0 && searchPos < contentLength && --loop > 0) {\n\t\t\tif ( (itemRange = extractFn(content, searchPos, isBackward)) ) {\n\t\t\t\tif (prevRange.equal(itemRange)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprevRange = itemRange.clone();\n\t\t\t\trng = rangeFn(itemRange.substring(content), itemRange.start, sel.clone());\n\t\t\t\t\n\t\t\t\tif (rng) {\n\t\t\t\t\teditor.createSelection(rng.start, rng.end);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tsearchPos = isBackward ? itemRange.start : itemRange.end - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsearchPos += isBackward ? -1 : 1;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t// XXX HTML section\n\t\n\t/**\n\t * Find next HTML item\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction findNextHTMLItem(editor) {\n\t\tvar isFirst = true;\n\t\treturn findItem(editor, false, function(content, searchPos){\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t\treturn findOpeningTagFromPosition(content, searchPos);\n\t\t\t} else {\n\t\t\t\treturn getOpeningTagFromPosition(content, searchPos);\n\t\t\t}\n\t\t}, function(tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, false);\n\t\t});\n\t}\n\t\n\t/**\n\t * Find previous HTML item\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction findPrevHTMLItem(editor) {\n\t\treturn findItem(editor, true, getOpeningTagFromPosition, function (tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, true);\n\t\t});\n\t}\n\t\n\t/**\n\t * Creates possible selection ranges for HTML tag\n\t * @param {String} source Original HTML source for tokens\n\t * @param {Array} tokens List of HTML tokens\n\t * @returns {Array}\n\t */\n\tfunction makePossibleRangesHTML(source, tokens, offset) {\n\t\toffset = offset || 0;\n\t\tvar result = [];\n\t\tvar attrStart = -1, attrName = '', attrValue = '', attrValueRange, tagName;\n\t\ttokens.forEach(function(tok) {\n\t\t\tswitch (tok.type) {\n\t\t\t\tcase 'tag':\n\t\t\t\t\ttagName = source.substring(tok.start, tok.end);\n\t\t\t\t\tif (/^<[\\w\\:\\-]/.test(tagName)) {\n\t\t\t\t\t\t// add tag name\n\t\t\t\t\t\tresult.push(range({\n\t\t\t\t\t\t\tstart: tok.start + 1, \n\t\t\t\t\t\t\tend: tok.end\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'attribute':\n\t\t\t\t\tattrStart = tok.start;\n\t\t\t\t\tattrName = source.substring(tok.start, tok.end);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'string':\n\t\t\t\t\t// attribute value\n\t\t\t\t\t// push full attribute first\n\t\t\t\t\tresult.push(range(attrStart, tok.end - attrStart));\n\t\t\t\t\t\n\t\t\t\t\tattrValueRange = range(tok);\n\t\t\t\t\tattrValue = attrValueRange.substring(source);\n\t\t\t\t\t\n\t\t\t\t\t// is this a quoted attribute?\n\t\t\t\t\tif (isQuote(attrValue.charAt(0)))\n\t\t\t\t\t\tattrValueRange.start++;\n\t\t\t\t\t\n\t\t\t\t\tif (isQuote(attrValue.charAt(attrValue.length - 1)))\n\t\t\t\t\t\tattrValueRange.end--;\n\t\t\t\t\t\n\t\t\t\t\tresult.push(attrValueRange);\n\t\t\t\t\t\n\t\t\t\t\tif (attrName == 'class') {\n\t\t\t\t\t\tresult = result.concat(classNameRanges(attrValueRange.substring(source), attrValueRange.start));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\t\n\t\t// offset ranges\n\t\tresult = result.filter(function(item) {\n\t\t\tif (item.length()) {\n\t\t\t\titem.shift(offset);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\t// remove duplicates\n\t\treturn utils.unique(result, function(item) {\n\t\t\treturn item.toString();\n\t\t});\n\t}\n\t\n\t/**\n\t * Returns ranges of class names in \"class\" attribute value\n\t * @param {String} className\n\t * @returns {Array}\n\t */\n\tfunction classNameRanges(className, offset) {\n\t\toffset = offset || 0;\n\t\tvar result = [];\n\t\t/** @type StringStream */\n\t\tvar stream = stringStream.create(className);\n\t\t\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\t\t\n\t\tvar ch;\n\t\twhile ((ch = stream.next())) {\n\t\t\tif (/[\\s\\u00a0]/.test(ch)) {\n\t\t\t\tresult.push(range(stream.start + offset, stream.pos - stream.start - 1));\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.push(range(stream.start + offset, stream.pos - stream.start));\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Returns best HTML tag range match for current selection\n\t * @param {String} tag Tag declaration\n\t * @param {Number} offset Tag's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForHTMLItem(tag, offset, selRange, isBackward) {\n\t\tvar ranges = makePossibleRangesHTML(tag, xmlParser.parse(tag), offset);\n\t\t\n\t\tif (isBackward)\n\t\t\tranges.reverse();\n\t\t\n\t\t// try to find selected range\n\t\tvar curRange = utils.find(ranges, function(r) {\n\t\t\treturn r.equal(selRange);\n\t\t});\n\t\t\n\t\tif (curRange) {\n\t\t\tvar ix = ranges.indexOf(curRange);\n\t\t\tif (ix < ranges.length - 1)\n\t\t\t\treturn ranges[ix + 1];\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// no selected range, find nearest one\n\t\tif (isBackward)\n\t\t\t// search backward\n\t\t\treturn utils.find(ranges, function(r) {\n\t\t\t\treturn r.start < selRange.start;\n\t\t\t});\n\t\t\n\t\t// search forward\n\t\t// to deal with overlapping ranges (like full attribute definition\n\t\t// and attribute value) let's find range under caret first\n\t\tif (!curRange) {\n\t\t\tvar matchedRanges = ranges.filter(function(r) {\n\t\t\t\treturn r.inside(selRange.end);\n\t\t\t});\n\t\t\t\n\t\t\tif (matchedRanges.length > 1)\n\t\t\t\treturn matchedRanges[1];\n\t\t}\n\t\t\n\t\t\n\t\treturn utils.find(ranges, function(r) {\n\t\t\treturn r.end > selRange.end;\n\t\t});\n\t}\n\t\n\t/**\n\t * Search for opening tag in content, starting at specified position\n\t * @param {String} html Where to search tag\n\t * @param {Number} pos Character index where to start searching\n\t * @return {Range} Returns range if valid opening tag was found,\n\t * <code>null</code> otherwise\n\t */\n\tfunction findOpeningTagFromPosition(html, pos) {\n\t\tvar tag;\n\t\twhile (pos >= 0) {\n\t\t\tif ((tag = getOpeningTagFromPosition(html, pos)))\n\t\t\t\treturn tag;\n\t\t\tpos--;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * @param {String} html Where to search tag\n\t * @param {Number} pos Character index where to start searching\n\t * @return {Range} Returns range if valid opening tag was found,\n\t * <code>null</code> otherwise\n\t */\n\tfunction getOpeningTagFromPosition(html, pos) {\n\t\tvar m;\n\t\tif (html.charAt(pos) == '<' && (m = html.substring(pos, html.length).match(startTag))) {\n\t\t\treturn range(pos, m[0]);\n\t\t}\n\t}\n\t\n\tfunction isQuote(ch) {\n\t\treturn ch == '\"' || ch == \"'\";\n\t}\n\n\t/**\n\t * Returns all ranges inside given rule, available for selection\n\t * @param  {CSSEditContainer} rule\n\t * @return {Array}\n\t */\n\tfunction findInnerRanges(rule) {\n\t\t// rule selector\n\t\tvar ranges = [rule.nameRange(true)];\n\n\t\t// find nested sections, keep selectors only\n\t\tvar nestedSections = cssSections.nestedSectionsInRule(rule);\n\t\tnestedSections.forEach(function(section) {\n\t\t\tranges.push(range.create2(section.start, section._selectorEnd));\n\t\t});\n\n\t\t// add full property ranges and values\n\t\trule.list().forEach(function(property) {\n\t\t\tranges = ranges.concat(makePossibleRangesCSS(property));\n\t\t});\n\n\t\tranges = range.sort(ranges);\n\n\t\t// optimize result: remove empty ranges and duplicates\n\t\tranges = ranges.filter(function(item) {\n\t\t\treturn !!item.length();\n\t\t});\n\t\treturn utils.unique(ranges, function(item) {\n\t\t\treturn item.toString();\n\t\t});\n\t}\n\t\n\t/**\n\t * Makes all possible selection ranges for specified CSS property\n\t * @param {CSSProperty} property\n\t * @returns {Array}\n\t */\n\tfunction makePossibleRangesCSS(property) {\n\t\t// find all possible ranges, sorted by position and size\n\t\tvar valueRange = property.valueRange(true);\n\t\tvar result = [property.range(true), valueRange];\n\t\t\n\t\t// locate parts of complex values.\n\t\t// some examples:\n\t\t//  1px solid red: 3 parts\n\t\t//  arial, sans-serif: enumeration, 2 parts\n\t\t//  url(image.png): function value part\n\t\tvar value = property.value();\n\t\tproperty.valueParts().forEach(function(r) {\n\t\t\t// add absolute range\n\t\t\tvar clone = r.clone();\n\t\t\tresult.push(clone.shift(valueRange.start));\n\t\t\t\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = stringStream.create(r.substring(value));\n\t\t\tif (stream.match(/^[\\w\\-]+\\(/, true)) {\n\t\t\t\t// we have a function, find values in it.\n\t\t\t\t// but first add function contents\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tstream.backUp(1);\n\t\t\t\tstream.skipToPair('(', ')');\n\t\t\t\tstream.backUp(1);\n\t\t\t\tvar fnBody = stream.current();\n\t\t\t\tresult.push(range(clone.start + stream.start, fnBody));\n\t\t\t\t\n\t\t\t\t// find parts\n\t\t\t\tcssEditTree.findParts(fnBody).forEach(function(part) {\n\t\t\t\t\tresult.push(range(clone.start + stream.start + part.start, part.substring(fnBody)));\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Tries to find matched CSS property and nearest range for selection\n\t * @param {CSSRule} rule\n\t * @param {Range} selRange\n\t * @param {Boolean} isBackward\n\t * @returns {Range}\n\t */\n\tfunction matchedRangeForCSSProperty(rule, selRange, isBackward) {\n\t\tvar ranges = findInnerRanges(rule);\n\t\tif (isBackward) {\n\t\t\tranges.reverse();\n\t\t}\n\t\t\n\t\t// return next to selected range, if possible\n\t\tvar r = utils.find(ranges, function(item) {\n\t\t\treturn item.equal(selRange);\n\t\t});\n\n\t\tif (r) {\n\t\t\treturn ranges[ranges.indexOf(r) + 1];\n\t\t}\n\n\t\t// find matched and (possibly) overlapping ranges\n\t\tvar nested = ranges.filter(function(item) {\n\t\t\treturn item.inside(selRange.end);\n\t\t});\n\n\t\tif (nested.length) {\n\t\t\treturn nested.sort(function(a, b) {\n\t\t\t\treturn a.length() - b.length();\n\t\t\t})[0];\n\t\t}\n\n\t\t// return range next to caret\n\t\tvar test = \n\t\tr = utils.find(ranges, isBackward \n\t\t\t? function(item) {return item.end < selRange.start;}\n\t\t\t: function(item) {return item.end > selRange.start;}\n\t\t);\n\n\t\tif (!r) {\n\t\t\t// cant find anything, just pick first one\n\t\t\tr = ranges[0];\n\t\t}\n\n\t\treturn r;\n\t}\n\t\n\tfunction findNextCSSItem(editor) {\n\t\treturn findItem(editor, false, cssSections.locateRule.bind(cssSections), getRangeForNextItemInCSS);\n\t}\n\t\n\tfunction findPrevCSSItem(editor) {\n\t\treturn findItem(editor, true, cssSections.locateRule.bind(cssSections), getRangeForPrevItemInCSS);\n\t}\n\t\n\t/**\n\t * Returns range for item to be selected in CSS after current caret \n\t * (selection) position\n\t * @param {String} rule CSS rule declaration\n\t * @param {Number} offset Rule's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForNextItemInCSS(rule, offset, selRange) {\n\t\tvar tree = cssEditTree.parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\n\t\treturn matchedRangeForCSSProperty(tree, selRange, false);\n\t}\n\t\n\t/**\n\t * Returns range for item to be selected in CSS before current caret \n\t * (selection) position\n\t * @param {String} rule CSS rule declaration\n\t * @param {Number} offset Rule's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if previous item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForPrevItemInCSS(rule, offset, selRange) {\n\t\tvar tree = cssEditTree.parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\n\t\treturn matchedRangeForCSSProperty(tree, selRange, true);\n\t}\n\n\treturn {\n\t\tselectNextItemAction: function(editor) {\n\t\t\tif (actionUtils.isSupportedCSS(editor.getSyntax())) {\n\t\t\t\treturn findNextCSSItem(editor);\n\t\t\t} else {\n\t\t\t\treturn findNextHTMLItem(editor);\n\t\t\t}\n\t\t},\n\n\t\tselectPreviousItemAction: function(editor) {\n\t\t\tif (actionUtils.isSupportedCSS(editor.getSyntax())) {\n\t\t\t\treturn findPrevCSSItem(editor);\n\t\t\t} else {\n\t\t\t\treturn findPrevHTMLItem(editor);\n\t\t\t}\n\t\t}\n\t};\n});\n},{\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../parser/xml\":\"parser\\\\xml.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/cssSections\":\"utils\\\\cssSections.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\selectLine.js\":[function(require,module,exports){\n/**\n * Select current line (for simple editors like browser's &lt;textarea&gt;)\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\treturn {\n\t\tselectLineAction: function(editor) {\n\t\t\tvar range = editor.getCurrentLineRange();\n\t\t\teditor.createSelection(range.start, range.end);\n\t\t\treturn true;\n\t\t}\n\t};\n});\n},{}],\"action\\\\splitJoinTag.js\":[function(require,module,exports){\n/**\n * Splits or joins tag, e.g. transforms it into a short notation and vice versa:<br>\n * &lt;div&gt;&lt;/div&gt;  &lt;div /&gt; : join<br>\n * &lt;div /&gt;  &lt;div&gt;&lt;/div&gt; : split\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar resources = require('../assets/resources');\n\tvar matcher = require('../assets/htmlMatcher');\n\tvar editorUtils = require('../utils/editor');\n\tvar profile = require('../assets/profile');\n\n\t/**\n\t * @param {IEmmetEditor} editor\n\t * @param {Object} profile\n\t * @param {Object} tag\n\t */\n\tfunction joinTag(editor, profile, tag) {\n\t\t// empty closing slash is a nonsense for this action\n\t\tvar slash = profile.selfClosing() || ' /';\n\t\tvar content = tag.open.range.substring(tag.source).replace(/\\s*>$/, slash + '>');\n\t\t\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\t// update caret position\n\t\tif (content.length + tag.outerRange.start < caretPos) {\n\t\t\tcaretPos = content.length + tag.outerRange.start;\n\t\t}\n\t\t\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\t\n\tfunction splitTag(editor, profile, tag) {\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\t// define tag content depending on profile\n\t\tvar tagContent = (profile.tag_nl === true) ? '\\n\\t\\n' : '';\n\t\tvar content = tag.outerContent().replace(/\\s*\\/>$/, '>');\n\t\tcaretPos = tag.outerRange.start + content.length;\n\t\tcontent += tagContent + '</' + tag.open.name + '>';\n\t\t\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\n\treturn {\n\t\tsplitJoinTagAction: function(editor, profileName) {\n\t\t\tvar info = editorUtils.outputInfo(editor, null, profileName);\n\t\t\tvar curProfile = profile.get(info.profile);\n\t\t\t\n\t\t\t// find tag at current position\n\t\t\tvar tag = matcher.tag(info.content, editor.getCaretPos());\n\t\t\tif (tag) {\n\t\t\t\treturn tag.close \n\t\t\t\t\t? joinTag(editor, curProfile, tag) \n\t\t\t\t\t: splitTag(editor, curProfile, tag);\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t};\n});\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\toggleComment.js\":[function(require,module,exports){\n/**\n * Toggles HTML and CSS comments depending on current caret context. Unlike\n * the same action in most editors, this action toggles comment on currently\n * matched itemHTML tag or CSS selectorwhen nothing is selected.\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar prefs = require('../assets/preferences');\n\tvar range = require('../assets/range');\n\tvar utils = require('../utils/common');\n\tvar actionUtils = require('../utils/action');\n\tvar editorUtils = require('../utils/editor');\n\tvar htmlMatcher = require('../assets/htmlMatcher');\n\tvar cssEditTree = require('../editTree/css');\n\n\t/**\n\t * Toggle HTML comment on current selection or tag\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\n\t */\n\tfunction toggleHTMLComment(editor) {\n\t\t/** @type Range */\n\t\tvar r = range(editor.getSelectionRange());\n\t\tvar info = editorUtils.outputInfo(editor);\n\t\t\t\n\t\tif (!r.length()) {\n\t\t\t// no selection, find matching tag\n\t\t\tvar tag = htmlMatcher.tag(info.content, editor.getCaretPos());\n\t\t\tif (tag) { // found pair\n\t\t\t\tr = tag.outerRange;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn genericCommentToggle(editor, '<!--', '-->', r);\n\t}\n\n\t/**\n\t * Simple CSS commenting\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\n\t */\n\tfunction toggleCSSComment(editor) {\n\t\t/** @type Range */\n\t\tvar rng = range(editor.getSelectionRange());\n\t\tvar info = editorUtils.outputInfo(editor);\n\t\t\t\n\t\tif (!rng.length()) {\n\t\t\t// no selection, try to get current rule\n\t\t\t/** @type CSSRule */\n\t\t\tvar rule = cssEditTree.parseFromPosition(info.content, editor.getCaretPos());\n\t\t\tif (rule) {\n\t\t\t\tvar property = cssItemFromPosition(rule, editor.getCaretPos());\n\t\t\t\trng = property \n\t\t\t\t\t? property.range(true) \n\t\t\t\t\t: range(rule.nameRange(true).start, rule.source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!rng.length()) {\n\t\t\t// still no selection, get current line\n\t\t\trng = range(editor.getCurrentLineRange());\n\t\t\tutils.narrowToNonSpace(info.content, rng);\n\t\t}\n\t\t\n\t\treturn genericCommentToggle(editor, '/*', '*/', rng);\n\t}\n\t\n\t/**\n\t * Returns CSS property from <code>rule</code> that matches passed position\n\t * @param {EditContainer} rule\n\t * @param {Number} absPos\n\t * @returns {EditElement}\n\t */\n\tfunction cssItemFromPosition(rule, absPos) {\n\t\t// do not use default EditContainer.itemFromPosition() here, because\n\t\t// we need to make a few assumptions to make CSS commenting more reliable\n\t\tvar relPos = absPos - (rule.options.offset || 0);\n\t\tvar reSafeChar = /^[\\s\\n\\r]/;\n\t\treturn utils.find(rule.list(), function(item) {\n\t\t\tif (item.range().end === relPos) {\n\t\t\t\t// at the end of property, but outside of it\n\t\t\t\t// if theres a space character at current position,\n\t\t\t\t// use current property\n\t\t\t\treturn reSafeChar.test(rule.source.charAt(relPos));\n\t\t\t}\n\t\t\t\n\t\t\treturn item.range().inside(relPos);\n\t\t});\n\t}\n\n\t/**\n\t * Search for nearest comment in <code>str</code>, starting from index <code>from</code>\n\t * @param {String} text Where to search\n\t * @param {Number} from Search start index\n\t * @param {String} start_token Comment start string\n\t * @param {String} end_token Comment end string\n\t * @return {Range} Returns null if comment wasn't found\n\t */\n\tfunction searchComment(text, from, startToken, endToken) {\n\t\tvar commentStart = -1;\n\t\tvar commentEnd = -1;\n\t\t\n\t\tvar hasMatch = function(str, start) {\n\t\t\treturn text.substr(start, str.length) == str;\n\t\t};\n\t\t\t\n\t\t// search for comment start\n\t\twhile (from--) {\n\t\t\tif (hasMatch(startToken, from)) {\n\t\t\t\tcommentStart = from;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (commentStart != -1) {\n\t\t\t// search for comment end\n\t\t\tfrom = commentStart;\n\t\t\tvar contentLen = text.length;\n\t\t\twhile (contentLen >= from++) {\n\t\t\t\tif (hasMatch(endToken, from)) {\n\t\t\t\t\tcommentEnd = from + endToken.length;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (commentStart != -1 && commentEnd != -1) \n\t\t\t? range(commentStart, commentEnd - commentStart) \n\t\t\t: null;\n\t}\n\n\t/**\n\t * Generic comment toggling routine\n\t * @param {IEmmetEditor} editor\n\t * @param {String} commentStart Comment start token\n\t * @param {String} commentEnd Comment end token\n\t * @param {Range} range Selection range\n\t * @return {Boolean}\n\t */\n\tfunction genericCommentToggle(editor, commentStart, commentEnd, range) {\n\t\tvar content = editorUtils.outputInfo(editor).content;\n\t\tvar caretPos = editor.getCaretPos();\n\t\tvar newContent = null;\n\t\t\t\n\t\t/**\n\t\t * Remove comment markers from string\n\t\t * @param {Sting} str\n\t\t * @return {String}\n\t\t */\n\t\tfunction removeComment(str) {\n\t\t\treturn str\n\t\t\t\t.replace(new RegExp('^' + utils.escapeForRegexp(commentStart) + '\\\\s*'), function(str){\n\t\t\t\t\tcaretPos -= str.length;\n\t\t\t\t\treturn '';\n\t\t\t\t}).replace(new RegExp('\\\\s*' + utils.escapeForRegexp(commentEnd) + '$'), '');\n\t\t}\n\t\t\n\t\t// first, we need to make sure that this substring is not inside \n\t\t// comment\n\t\tvar commentRange = searchComment(content, caretPos, commentStart, commentEnd);\n\t\tif (commentRange && commentRange.overlap(range)) {\n\t\t\t// we're inside comment, remove it\n\t\t\trange = commentRange;\n\t\t\tnewContent = removeComment(range.substring(content));\n\t\t} else {\n\t\t\t// should add comment\n\t\t\t// make sure that there's no comment inside selection\n\t\t\tnewContent = commentStart + ' ' +\n\t\t\t\trange.substring(content)\n\t\t\t\t\t.replace(new RegExp(utils.escapeForRegexp(commentStart) + '\\\\s*|\\\\s*' + utils.escapeForRegexp(commentEnd), 'g'), '') +\n\t\t\t\t' ' + commentEnd;\n\t\t\t\t\n\t\t\t// adjust caret position\n\t\t\tcaretPos += commentStart.length + 1;\n\t\t}\n\n\t\t// replace editor content\n\t\tif (newContent !== null) {\n\t\t\tnewContent = utils.escapeText(newContent);\n\t\t\teditor.setCaretPos(range.start);\n\t\t\teditor.replaceContent(editorUtils.unindent(editor, newContent), range.start, range.end);\n\t\t\teditor.setCaretPos(caretPos);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Toggle comment on current editor's selection or HTML tag/CSS rule\n\t\t * @param {IEmmetEditor} editor\n\t\t */\n\t\ttoggleCommentAction: function(editor) {\n\t\t\tvar info = editorUtils.outputInfo(editor);\n\t\t\tif (actionUtils.isSupportedCSS(info.syntax)) {\n\t\t\t\t// in case our editor is good enough and can recognize syntax from \n\t\t\t\t// current token, we have to make sure that cursor is not inside\n\t\t\t\t// 'style' attribute of html element\n\t\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\t\tvar tag = htmlMatcher.tag(info.content, caretPos);\n\t\t\t\tif (tag && tag.open.range.inside(caretPos)) {\n\t\t\t\t\tinfo.syntax = 'html';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar cssSyntaxes = prefs.getArray('css.syntaxes');\n\t\t\tif (~cssSyntaxes.indexOf(info.syntax)) {\n\t\t\t\treturn toggleCSSComment(editor);\n\t\t\t}\n\t\t\t\n\t\t\treturn toggleHTMLComment(editor);\n\t\t}\n\t};\n});\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/range\":\"assets\\\\range.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\updateImageSize.js\":[function(require,module,exports){\n/**\n * Automatically updates image size attributes in HTML's &lt;img&gt; element or\n * CSS rule\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar editorUtils = require('../utils/editor');\n\tvar actionUtils = require('../utils/action');\n\tvar xmlEditTree = require('../editTree/xml');\n\tvar cssEditTree = require('../editTree/css');\n\tvar base64 = require('../utils/base64');\n\tvar file = require('../plugin/file');\n\n\t/**\n\t * Updates image size of &lt;img src=\"\"&gt; tag\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction updateImageSizeHTML(editor) {\n\t\tvar offset = editor.getCaretPos();\n\n\t\t// find tag from current caret position\n\t\tvar info = editorUtils.outputInfo(editor);\n\t\tvar xmlElem = xmlEditTree.parseFromPosition(info.content, offset, true);\n\t\tif (xmlElem && (xmlElem.name() || '').toLowerCase() == 'img') {\n\t\t\tgetImageSizeForSource(editor, xmlElem.value('src'), function(size) {\n\t\t\t\tif (size) {\n\t\t\t\t\tvar compoundData = xmlElem.range(true);\n\t\t\t\t\txmlElem.value('width', size.width);\n\t\t\t\t\txmlElem.value('height', size.height, xmlElem.indexOf('width') + 1);\n\n\t\t\t\t\tactionUtils.compoundUpdate(editor, utils.extend(compoundData, {\n\t\t\t\t\t\tdata: xmlElem.toString(),\n\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Updates image size of CSS property\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction updateImageSizeCSS(editor) {\n\t\tvar offset = editor.getCaretPos();\n\n\t\t// find tag from current caret position\n\t\tvar info = editorUtils.outputInfo(editor);\n\t\tvar cssRule = cssEditTree.parseFromPosition(info.content, offset, true);\n\t\tif (cssRule) {\n\t\t\t// check if there is property with image under caret\n\t\t\tvar prop = cssRule.itemFromPosition(offset, true), m;\n\t\t\tif (prop && (m = /url\\(([\"']?)(.+?)\\1\\)/i.exec(prop.value() || ''))) {\n\t\t\t\tgetImageSizeForSource(editor, m[2], function(size) {\n\t\t\t\t\tif (size) {\n\t\t\t\t\t\tvar compoundData = cssRule.range(true);\n\t\t\t\t\t\tcssRule.value('width', size.width + 'px');\n\t\t\t\t\t\tcssRule.value('height', size.height + 'px', cssRule.indexOf('width') + 1);\n\n\t\t\t\t\t\tactionUtils.compoundUpdate(editor, utils.extend(compoundData, {\n\t\t\t\t\t\t\tdata: cssRule.toString(),\n\t\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns image dimensions for source\n\t * @param {IEmmetEditor} editor\n\t * @param {String} src Image source (path or data:url)\n\t */\n\tfunction getImageSizeForSource(editor, src, callback) {\n\t\tvar fileContent;\n\t\tif (src) {\n\t\t\t// check if it is data:url\n\t\t\tif (/^data:/.test(src)) {\n\t\t\t\tfileContent = base64.decode( src.replace(/^data\\:.+?;.+?,/, '') );\n\t\t\t\treturn callback(actionUtils.getImageSize(fileContent));\n\t\t\t}\n\n\t\t\tvar filePath = editor.getFilePath();\n\t\t\tfile.locateFile(filePath, src, function(absPath) {\n\t\t\t\tif (absPath === null) {\n\t\t\t\t\tthrow \"Can't find \" + src + ' file';\n\t\t\t\t}\n\n\t\t\t\tfile.read(absPath, function(err, content) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tthrow 'Unable to read ' + absPath + ': ' + err;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent = String(content);\n\t\t\t\t\tcallback(actionUtils.getImageSize(content));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\treturn {\n\t\tupdateImageSizeAction: function(editor) {\n\t\t\t// this action will definitely wont work in SASS dialect,\n\t\t\t// but may work in SCSS or LESS\n\t\t\tif (actionUtils.isSupportedCSS(editor.getSyntax())) {\n\t\t\t\tupdateImageSizeCSS(editor);\n\t\t\t} else {\n\t\t\t\tupdateImageSizeHTML(editor);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t};\n});\n},{\"../editTree/css\":\"editTree\\\\css.js\",\"../editTree/xml\":\"editTree\\\\xml.js\",\"../plugin/file\":\"plugin\\\\file.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/base64\":\"utils\\\\base64.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\updateTag.js\":[function(require,module,exports){\n/**\n * Update Tag action: allows users to update existing HTML tags and add/remove\n * attributes or even tag name\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar xmlEditTree = require('../editTree/xml');\n\tvar editorUtils = require('../utils/editor');\n\tvar actionUtils = require('../utils/action');\n\tvar utils = require('../utils/common');\n\tvar parser = require('../parser/abbreviation');\n\n\tfunction updateAttributes(tag, abbrNode, ix) {\n\t\tvar classNames = (abbrNode.attribute('class') || '').split(/\\s+/g);\n\t\tif (ix) {\n\t\t\tclassNames.push('+' + abbrNode.name());\n\t\t}\n\n\t\tvar r = function(str) {\n\t\t\treturn utils.replaceCounter(str, abbrNode.counter);\n\t\t};\n\n\t\t// update class\n\t\tclassNames.forEach(function(className) {\n\t\t\tif (!className) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclassName = r(className);\n\t\t\tvar ch = className.charAt(0);\n\t\t\tif (ch == '+') {\n\t\t\t\ttag.addClass(className.substr(1));\n\t\t\t} else if (ch == '-') {\n\t\t\t\ttag.removeClass(className.substr(1));\n\t\t\t} else {\n\t\t\t\ttag.value('class', className);\n\t\t\t}\n\t\t});\n\n\t\t// update attributes\n\t\tabbrNode.attributeList().forEach(function(attr) {\n\t\t\tif (attr.name.toLowerCase() == 'class') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar ch = attr.name.charAt(0);\n\t\t\tif (ch == '+') {\n\t\t\t\tvar attrName = attr.name.substr(1);\n\t\t\t\tvar tagAttr = tag.get(attrName);\n\t\t\t\tif (tagAttr) {\n\t\t\t\t\ttagAttr.value(tagAttr.value() + r(attr.value));\n\t\t\t\t} else {\n\t\t\t\t\ttag.value(attrName, r(attr.value));\n\t\t\t\t}\n\t\t\t} else if (ch == '-') {\n\t\t\t\ttag.remove(attr.name.substr(1));\n\t\t\t} else {\n\t\t\t\ttag.value(attr.name, r(attr.value));\n\t\t\t}\n\t\t});\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Matches HTML tag under caret and updates its definition\n\t\t * according to given abbreviation\n\t\t * @param {IEmmetEditor} Editor instance\n\t\t * @param {String} abbr Abbreviation to update with\n\t\t */\n\t\tupdateTagAction: function(editor, abbr) {\n\t\t\tabbr = abbr || editor.prompt(\"Enter abbreviation\");\n\n\t\t\tif (!abbr) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar content = editor.getContent();\n\t\t\tvar ctx = actionUtils.captureContext(editor);\n\t\t\tvar tag = this.getUpdatedTag(abbr, ctx, content);\n\n\t\t\tif (!tag) {\n\t\t\t\t// nothing to update\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// check if tag name was updated\n\t\t\tif (tag.name() != ctx.name && ctx.match.close) {\n\t\t\t\teditor.replaceContent('</' + tag.name() + '>', ctx.match.close.range.start, ctx.match.close.range.end, true);\n\t\t\t}\n\n\t\t\teditor.replaceContent(tag.source, ctx.match.open.range.start, ctx.match.open.range.end, true);\n\t\t\treturn true;\n\t\t},\n\n\t\t/**\n\t\t * Returns XMLEditContainer node with updated tag structure\n\t\t * of existing tag context.\n\t\t * This data can be used to modify existing tag\n\t\t * @param  {String} abbr    Abbreviation\n\t\t * @param  {Object} ctx     Tag to be updated (captured with `htmlMatcher`)\n\t\t * @param  {String} content Original editor content\n\t\t * @return {XMLEditContainer}\n\t\t */\n\t\tgetUpdatedTag: function(abbr, ctx, content, options) {\n\t\t\tif (!ctx) {\n\t\t\t\t// nothing to update\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar tree = parser.parse(abbr, options || {});\n\n\t\t\t// for this action some characters in abbreviation has special\n\t\t\t// meaning. For example, `.-c2` means remove `c2` class from\n\t\t\t// element and `.+c3` means append class `c3` to exising one.\n\t\t\t// \n\t\t\t// But `.+c3` abbreviation will actually produce two elements:\n\t\t\t// <div class=\"\"> and <c3>. Thus, we have to walk on each element\n\t\t\t// of parsed tree and use their definitions to update current element\n\t\t\tvar tag = xmlEditTree.parse(ctx.match.open.range.substring(content), {\n\t\t\t\toffset: ctx.match.outerRange.start\n\t\t\t});\n\n\t\t\ttree.children.forEach(function(node, i) {\n\t\t\t\tupdateAttributes(tag, node, i);\n\t\t\t});\n\n\t\t\t// if tag name was resolved by implicit tag name resolver,\n\t\t\t// then user omitted it in abbreviation and wants to keep\n\t\t\t// original tag name\n\t\t\tvar el = tree.children[0];\n\t\t\tif (!el.data('nameResolved')) {\n\t\t\t\ttag.name(el.name());\n\t\t\t}\n\n\t\t\treturn tag;\n\t\t}\n\t};\n});\n},{\"../editTree/xml\":\"editTree\\\\xml.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\wrapWithAbbreviation.js\":[function(require,module,exports){\n/**\n * Action that wraps content with abbreviation. For convenience, action is \n * defined as reusable module\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar range = require('../assets/range');\n\tvar htmlMatcher = require('../assets/htmlMatcher');\n\tvar utils = require('../utils/common');\n\tvar editorUtils = require('../utils/editor');\n\tvar actionUtils = require('../utils/action');\n\tvar parser = require('../parser/abbreviation');\n\t\n\treturn {\n\t\t/**\n\t\t * Wraps content with abbreviation\n\t\t * @param {IEmmetEditor} Editor instance\n\t\t * @param {String} abbr Abbreviation to wrap with\n\t\t * @param {String} syntax Syntax type (html, css, etc.)\n\t\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t\t */\n\t\twrapWithAbbreviationAction: function(editor, abbr, syntax, profile) {\n\t\t\tvar info = editorUtils.outputInfo(editor, syntax, profile);\n\t\t\tabbr = abbr || editor.prompt(\"Enter abbreviation\");\n\t\t\t\n\t\t\tif (!abbr) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tabbr = String(abbr);\n\t\t\t\n\t\t\tvar r = range(editor.getSelectionRange());\n\t\t\t\n\t\t\tif (!r.length()) {\n\t\t\t\t// no selection, find tag pair\n\t\t\t\tvar match = htmlMatcher.tag(info.content, r.start);\n\t\t\t\tif (!match) {  // nothing to wrap\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tr = utils.narrowToNonSpace(info.content, match.range);\n\t\t\t}\n\t\t\t\n\t\t\tvar newContent = utils.escapeText(r.substring(info.content));\n\t\t\tvar result = parser.expand(abbr, {\n\t\t\t\tpastedContent: editorUtils.unindent(editor, newContent),\n\t\t\t\tsyntax: info.syntax,\n\t\t\t\tprofile: info.profile,\n\t\t\t\tcontextNode: actionUtils.captureContext(editor)\n\t\t\t});\n\t\t\t\n\t\t\tif (result) {\n\t\t\t\teditor.replaceContent(result, r.start, r.end);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t};\n});\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"assets\\\\caniuse.js\":[function(require,module,exports){\n/**\n * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.\n * Contains convenient method to get access for snippets with respect of\n * inheritance. Also provides ability to store data in different vocabularies\n * ('system' and 'user') for fast and safe resource update\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar prefs = require('./preferences');\n\tvar utils = require('../utils/common');\n\n\tprefs.define('caniuse.enabled', true, 'Enable support of Can I Use database. When enabled,\\\n\t\tCSS abbreviation resolver will look at Can I Use database first before detecting\\\n\t\tCSS properties that should be resolved');\n\n\tprefs.define('caniuse.vendors', 'all', 'A comma-separated list vendor identifiers\\\n\t\t(as described in Can I Use database) that should be supported\\\n\t\twhen resolving vendor-prefixed properties. Set value to <code>all</code>\\\n\t\tto support all available properties');\n\n\tprefs.define('caniuse.era', 'e-2', 'Browser era, as defined in Can I Use database.\\\n\t\tExamples: <code>e0</code> (current version), <code>e1</code> (near future)\\\n\t\t<code>e-2</code> (2 versions back) and so on.');\n\n\tvar cssSections = {\n\t\t'border-image': ['border-image'],\n\t\t'css-boxshadow': ['box-shadow'],\n\t\t'css3-boxsizing': ['box-sizing'],\n\t\t'multicolumn': ['column-width', 'column-count', 'columns', 'column-gap', 'column-rule-color', 'column-rule-style', 'column-rule-width', 'column-rule', 'column-span', 'column-fill'],\n\t\t'border-radius': ['border-radius', 'border-top-left-radius', 'border-top-right-radius', 'border-bottom-right-radius', 'border-bottom-left-radius'],\n\t\t'transforms2d': ['transform'],\n\t\t'css-hyphens': ['hyphens'],\n\t\t'css-transitions': ['transition', 'transition-property', 'transition-duration', 'transition-timing-function', 'transition-delay'],\n\t\t'font-feature': ['font-feature-settings'],\n\t\t'css-animation': ['animation', 'animation-name', 'animation-duration', 'animation-timing-function', 'animation-iteration-count', 'animation-direction', 'animation-play-state', 'animation-delay', 'animation-fill-mode', '@keyframes'],\n\t\t'css-gradients': ['linear-gradient'],\n\t\t'css-masks': ['mask-image', 'mask-source-type', 'mask-repeat', 'mask-position', 'mask-clip', 'mask-origin', 'mask-size', 'mask', 'mask-type', 'mask-box-image-source', 'mask-box-image-slice', 'mask-box-image-width', 'mask-box-image-outset', 'mask-box-image-repeat', 'mask-box-image', 'clip-path', 'clip-rule'],\n\t\t'css-featurequeries': ['@supports'],\n\t\t'flexbox': ['flex', 'inline-flex', 'flex-direction', 'flex-wrap', 'flex-flow', 'order', 'flex'],\n\t\t'calc': ['calc'],\n\t\t'object-fit': ['object-fit', 'object-position'],\n\t\t'css-grid': ['grid', 'inline-grid', 'grid-template-rows', 'grid-template-columns', 'grid-template-areas', 'grid-template', 'grid-auto-rows', 'grid-auto-columns', ' grid-auto-flow', 'grid-auto-position', 'grid', ' grid-row-start', 'grid-column-start', 'grid-row-end', 'grid-column-end', 'grid-column', 'grid-row', 'grid-area', 'justify-self', 'justify-items', 'align-self', 'align-items'],\n\t\t'css-repeating-gradients': ['repeating-linear-gradient'],\n\t\t'css-filters': ['filter'],\n\t\t'user-select-none': ['user-select'],\n\t\t'intrinsic-width': ['min-content', 'max-content', 'fit-content', 'fill-available'],\n\t\t'css3-tabsize': ['tab-size']\n\t};\n\n\t/** @type {Object} The Can I Use database for CSS */\n\tvar cssDB = null;\n\t/** @type {Object} A list of available vendors (browsers) and their prefixes */\n\tvar vendorsDB = null;\n\tvar erasDB = null;\n\n\tfunction intersection(arr1, arr2) {\n\t\tvar result = [];\n\t\tvar smaller = arr1, larger = arr2;\n\t\tif (smaller.length > larger.length) {\n\t\t\tsmaller = arr2;\n\t\t\tlarger = arr1;\n\t\t}\n\t\tlarger.forEach(function(item) {\n\t\t\tif (~smaller.indexOf(item)) {\n\t\t\t\tresult.push(item);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n\n\t/**\n\t * Parses raw Can I Use database for better lookups\n\t * @param  {String} data Raw database\n\t * @param  {Boolean} optimized Pass `true` if given `data` is already optimized\n\t * @return {Object}\n\t */\n\tfunction parseDB(data, optimized) {\n\t\tif (typeof data == 'string') {\n\t\t\tdata = JSON.parse(data);\n\t\t}\n\n\t\tif (!optimized) {\n\t\t\tdata = optimize(data);\n\t\t}\n\n\t\tvendorsDB = data.vendors;\n\t\tcssDB = data.css;\n\t\terasDB = data.era;\n\t}\n\n\t/**\n\t * Extract required data only from CIU database\n\t * @param  {Object} data Raw Can I Use database\n\t * @return {Object}      Optimized database\n\t */\n\tfunction optimize(data) {\n\t\tif (typeof data == 'string') {\n\t\t\tdata = JSON.parse(data);\n\t\t}\n\n\t\treturn {\n\t\t\tvendors: parseVendors(data),\n\t\t\tcss: parseCSS(data),\n\t\t\tera: parseEra(data)\n\t\t};\n\t}\n\n\t/**\n\t * Parses vendor data\n\t * @param  {Object} data\n\t * @return {Object}\n\t */\n\tfunction parseVendors(data) {\n\t\tvar out = {};\n\t\tObject.keys(data.agents).forEach(function(name) {\n\t\t\tvar agent = data.agents[name];\n\t\t\tout[name] = {\n\t\t\t\tprefix: agent.prefix,\n\t\t\t\tversions: agent.versions\n\t\t\t};\n\t\t});\n\t\treturn out;\n\t}\n\n\t/**\n\t * Parses CSS data from Can I Use raw database\n\t * @param  {Object} data\n\t * @return {Object}\n\t */\n\tfunction parseCSS(data) {\n\t\tvar out = {};\n\t\tvar cssCategories = data.cats.CSS;\n\t\tObject.keys(data.data).forEach(function(name) {\n\t\t\tvar section = data.data[name];\n\t\t\tif (name in cssSections) {\n\t\t\t\tcssSections[name].forEach(function(kw) {\n\t\t\t\t\tout[kw] = section.stats;\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn out;\n\t}\n\n\t/**\n\t * Parses era data from Can I Use raw database\n\t * @param  {Object} data\n\t * @return {Array}\n\t */\n\tfunction parseEra(data) {\n\t\t// some runtimes (like Mozilla Rhino) does not preserves\n\t\t// key order so we have to sort values manually\n\t\treturn Object.keys(data.eras).sort(function(a, b) {\n\t\t\treturn parseInt(a.substr(1)) - parseInt(b.substr(1));\n\t\t});\n\t}\n\n\t/**\n\t * Returs list of supported vendors, depending on user preferences\n\t * @return {Array}\n\t */\n\tfunction getVendorsList() {\n\t\tvar allVendors = Object.keys(vendorsDB);\n\t\tvar vendors = prefs.getArray('caniuse.vendors');\n\t\tif (!vendors || vendors[0] == 'all') {\n\t\t\treturn allVendors;\n\t\t}\n\n\t\treturn intersection(allVendors, vendors);\n\t}\n\n\t/**\n\t * Returns size of version slice as defined by era identifier\n\t * @return {Number}\n\t */\n\tfunction getVersionSlice() {\n\t\tvar era = prefs.get('caniuse.era');\n\t\tvar ix = erasDB.indexOf(era);\n\t\tif (!~ix) {\n\t\t\tix = erasDB.indexOf('e-2');\n\t\t}\n\n\t\treturn ix;\n\t}\n\n\t// try to load caniuse database\n\t// hide it from Require.JS parser\n\tvar db = null;\n\t(function(r) {\n\t\tif (typeof define === 'undefined' || !define.amd) {\n\t\t\ttry {\n\t\t\t\tdb = r('caniuse-db/data.json');\n\t\t\t} catch(e) {}\n\t\t}\n\t})(require);\n\n\tif (db) {\n\t\tparseDB(db);\n\t}\n\n\treturn {\n\t\tload: parseDB,\n\t\toptimize: optimize,\n\n\t\t/**\n\t\t * Resolves prefixes for given property\n\t\t * @param {String} property A property to resolve. It can start with `@` symbol\n\t\t * (CSS section, like `@keyframes`) or `:` (CSS value, like `flex`)\n\t\t * @return {Array} Array of resolved prefixes or <code>null</code>\n\t\t * if prefixes can't be resolved. Empty array means property has no vendor\n\t\t * prefixes\n\t\t */\n\t\tresolvePrefixes: function(property) {\n\t\t\tif (!prefs.get('caniuse.enabled') || !cssDB || !(property in cssDB)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar prefixes = [];\n\t\t\tvar propStats = cssDB[property];\n\t\t\tvar versions = getVersionSlice();\n\n\t\t\tgetVendorsList().forEach(function(vendor) {\n\t\t\t\tvar vendorVesions = vendorsDB[vendor].versions.slice(versions);\n\t\t\t\tfor (var i = 0, v; i < vendorVesions.length; i++) {\n\t\t\t\t\tv = vendorVesions[i];\n\t\t\t\t\tif (!v) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (~propStats[vendor][v].indexOf('x')) {\n\t\t\t\t\t\tprefixes.push(vendorsDB[vendor].prefix);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn utils.unique(prefixes).sort(function(a, b) {\n\t\t\t\treturn b.length - a.length;\n\t\t\t});\n\t\t}\n\t};\n});\n\n},{\"../utils/common\":\"utils\\\\common.js\",\"./preferences\":\"assets\\\\preferences.js\"}],\"assets\\\\elements.js\":[function(require,module,exports){\n/**\n * Module that contains factories for element types used by Emmet\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar factories = {};\n\tvar reAttrs = /([@\\!]?)([\\w\\-:]+)\\s*=\\s*(['\"])(.*?)\\3/g;\n\n\t// register resource references\n\tfunction commonFactory(value) {\n\t\treturn {data: value};\n\t}\n\n\tmodule = module || {};\n\tmodule.exports = {\n\t\t/**\n\t\t * Create new element factory\n\t\t * @param {String} name Element identifier\n\t\t * @param {Function} factory Function that produces element of specified \n\t\t * type. The object generated by this factory is automatically \n\t\t * augmented with <code>type</code> property pointing to element\n\t\t * <code>name</code>\n\t\t * @memberOf elements\n\t\t */\n\t\tadd: function(name, factory) {\n\t\t\tvar that = this;\n\t\t\tfactories[name] = function() {\n\t\t\t\tvar elem = factory.apply(that, arguments);\n\t\t\t\tif (elem)\n\t\t\t\t\telem.type = name;\n\t\t\t\t\n\t\t\t\treturn elem;\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns factory for specified name\n\t\t * @param {String} name\n\t\t * @returns {Function}\n\t\t */\n\t\tget: function(name) {\n\t\t\treturn factories[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates new element with specified type\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tcreate: function(name) {\n\t\t\tvar args = [].slice.call(arguments, 1);\n\t\t\tvar factory = this.get(name);\n\t\t\treturn factory ? factory.apply(this, args) : null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element is of specified type\n\t\t * @param {Object} elem\n\t\t * @param {String} type\n\t\t * @returns {Boolean}\n\t\t */\n\t\tis: function(elem, type) {\n\t\t\treturn this.type(elem) === type;\n\t\t},\n\n\t\t/**\n\t\t * Returns type of element\n\t\t * @param  {Object} elem\n\t\t * @return {String}\n\t\t */\n\t\ttype: function(elem) {\n\t\t\treturn elem && elem.type;\n\t\t}\n\t};\n\t\n\t/**\n\t * Element factory\n\t * @param {String} elementName Name of output element\n\t * @param {String} attrs Attributes definition. You may also pass\n\t * <code>Array</code> where each contains object with <code>name</code> \n\t * and <code>value</code> properties, or <code>Object</code>\n\t * @param {Boolean} isEmpty Is expanded element should be empty\n\t */\n\tmodule.exports.add('element', function(elementName, attrs, isEmpty) {\n\t\tvar ret = {\n\t\t\tname: elementName,\n\t\t\tis_empty: !!isEmpty\n\t\t};\n\n\t\tif (attrs) {\n\t\t\tret.attributes = [];\n\t\t\tif (Array.isArray(attrs)) {\n\t\t\t\tret.attributes = attrs;\n\t\t\t} else if (typeof attrs === 'string') {\n\t\t\t\tvar m;\n\t\t\t\twhile ((m = reAttrs.exec(attrs))) {\n\t\t\t\t\tret.attributes.push({\n\t\t\t\t\t\tname: m[2],\n\t\t\t\t\t\tvalue: m[4],\n\t\t\t\t\t\tisDefault: m[1] == '@',\n\t\t\t\t\t\tisImplied: m[1] == '!'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret.attributes = Object.keys(attrs).map(function(name) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: name, \n\t\t\t\t\t\tvalue: attrs[name]\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t});\n\t\n\tmodule.exports.add('snippet', commonFactory);\n\tmodule.exports.add('reference', commonFactory);\n\tmodule.exports.add('empty', function() {\n\t\treturn {};\n\t});\n\t\n\treturn module.exports;\n});\n},{}],\"assets\\\\handlerList.js\":[function(require,module,exports){\n/**\n * Utility module that provides ordered storage of function handlers. \n * Many Emmet modules' functionality can be extended/overridden by custom\n * function. This modules provides unified storage of handler functions, their \n * management and execution\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\t\n\t/**\n\t * @type HandlerList\n\t * @constructor\n\t */\n\tfunction HandlerList() {\n\t\tthis._list = [];\n\t}\n\t\n\tHandlerList.prototype = {\n\t\t/**\n\t\t * Adds function handler\n\t\t * @param {Function} fn Handler\n\t\t * @param {Object} options Handler options. Possible values are:<br><br>\n\t\t * <b>order</b> : (<code>Number</code>)  order in handler list. Handlers\n\t\t * with higher order value will be executed earlier.\n\t\t */\n\t\tadd: function(fn, options) {\n\t\t\t// TODO hack for stable sort, remove after fixing `list()`\n\t\t\tvar order = this._list.length;\n\t\t\tif (options && 'order' in options) {\n\t\t\t\torder = options.order * 10000;\n\t\t\t}\n\t\t\tthis._list.push(utils.extend({}, options, {order: order, fn: fn}));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes handler from list\n\t\t * @param {Function} fn\n\t\t */\n\t\tremove: function(fn) {\n\t\t\tvar item = utils.find(this._list, function(item) {\n\t\t\t\treturn item.fn === fn;\n\t\t\t});\n\t\t\tif (item) {\n\t\t\t\tthis._list.splice(this._list.indexOf(item), 1);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ordered list of handlers. By default, handlers \n\t\t * with the same <code>order</code> option returned in reverse order, \n\t\t * i.e. the latter function was added into the handlers list, the higher \n\t\t * it will be in the returned array \n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\t// TODO make stable sort\n\t\t\treturn this._list.sort(function(a, b) {\n\t\t\t\treturn b.order - a.order;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ordered list of handler functions\n\t\t * @returns {Array}\n\t\t */\n\t\tlistFn: function() {\n\t\t\treturn this.list().map(function(item) {\n\t\t\t\treturn item.fn;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Executes handler functions in their designated order. If function\n\t\t * returns <code>skipVal</code>, meaning that function was unable to \n\t\t * handle passed <code>args</code>, the next function will be executed\n\t\t * and so on.\n\t\t * @param {Object} skipValue If function returns this value, execute \n\t\t * next handler.\n\t\t * @param {Array} args Arguments to pass to handler function\n\t\t * @returns {Boolean} Whether any of registered handlers performed\n\t\t * successfully  \n\t\t */\n\t\texec: function(skipValue, args) {\n\t\t\targs = args || [];\n\t\t\tvar result = null;\n\t\t\tutils.find(this.list(), function(h) {\n\t\t\t\tresult = h.fn.apply(h, args);\n\t\t\t\tif (result !== skipValue) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Factory method that produces <code>HandlerList</code> instance\n\t\t * @returns {HandlerList}\n\t\t * @memberOf handlerList\n\t\t */\n\t\tcreate: function() {\n\t\t\treturn new HandlerList();\n\t\t}\n\t};\n});\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"assets\\\\htmlMatcher.js\":[function(require,module,exports){\n/**\n * HTML matcher: takes string and searches for HTML tag pairs for given position \n * \n * Unlike classic matchers, it parses content from the specified \n * position, not from the start, so it may work even outside HTML documents\n * (for example, inside strings of programming languages like JavaScript, Python \n * etc.)\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar range = require('./range');\n\n\t// Regular Expressions for parsing tags and attributes\n\tvar reOpenTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\tvar reCloseTag = /^<\\/([\\w\\:\\-]+)[^>]*>/;\n\n\tfunction openTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\tselfClose: !!match[3],\n\t\t\t/** @type Range */\n\t\t\trange: range(i, match[0]),\n\t\t\ttype: 'open'\n\t\t};\n\t}\n\t\n\tfunction closeTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\t/** @type Range */\n\t\t\trange: range(i, match[0]),\n\t\t\ttype: 'close'\n\t\t};\n\t}\n\t\n\tfunction comment(i, match) {\n\t\treturn {\n\t\t\t/** @type Range */\n\t\t\trange: range(i, typeof match == 'number' ? match - i : match[0]),\n\t\t\ttype: 'comment'\n\t\t};\n\t}\n\t\n\t/**\n\t * Creates new tag matcher session\n\t * @param {String} text\n\t */\n\tfunction createMatcher(text) {\n\t\tvar memo = {}, m;\n\t\treturn {\n\t\t\t/**\n\t\t\t * Test if given position matches opening tag\n\t\t\t * @param {Number} i\n\t\t\t * @returns {Object} Matched tag object\n\t\t\t */\n\t\t\topen: function(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'open' ? m : null;\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Test if given position matches closing tag\n\t\t\t * @param {Number} i\n\t\t\t * @returns {Object} Matched tag object\n\t\t\t */\n\t\t\tclose: function(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'close' ? m : null;\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Matches either opening or closing tag for given position\n\t\t\t * @param i\n\t\t\t * @returns\n\t\t\t */\n\t\t\tmatches: function(i) {\n\t\t\t\tvar key = 'p' + i;\n\t\t\t\t\n\t\t\t\tif (!(key in memo)) {\n\t\t\t\t\tmemo[key] = false;\n\t\t\t\t\tif (text.charAt(i) == '<') {\n\t\t\t\t\t\tvar substr = text.slice(i);\n\t\t\t\t\t\tif ((m = substr.match(reOpenTag))) {\n\t\t\t\t\t\t\tmemo[key] = openTag(i, m);\n\t\t\t\t\t\t} else if ((m = substr.match(reCloseTag))) {\n\t\t\t\t\t\t\tmemo[key] = closeTag(i, m);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn memo[key];\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Returns original text\n\t\t\t * @returns {String}\n\t\t\t */\n\t\t\ttext: function() {\n\t\t\t\treturn text;\n\t\t\t},\n\n\t\t\tclean: function() {\n\t\t\t\tmemo = text = m = null;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction matches(text, pos, pattern) {\n\t\treturn text.substring(pos, pos + pattern.length) == pattern;\n\t}\n\t\n\t/**\n\t * Search for closing pair of opening tag\n\t * @param {Object} open Open tag instance\n\t * @param {Object} matcher Matcher instance\n\t */\n\tfunction findClosingPair(open, matcher) {\n\t\tvar stack = [], tag = null;\n\t\tvar text = matcher.text();\n\t\t\n\t\tfor (var pos = open.range.end, len = text.length; pos < len; pos++) {\n\t\t\tif (matches(text, pos, '<!--')) {\n\t\t\t\t// skip to end of comment\n\t\t\t\tfor (var j = pos; j < len; j++) {\n\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\tpos = j + 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ((tag = matcher.matches(pos))) {\n\t\t\t\tif (tag.type == 'open' && !tag.selfClose) {\n\t\t\t\t\tstack.push(tag.name);\n\t\t\t\t} else if (tag.type == 'close') {\n\t\t\t\t\tif (!stack.length) { // found valid pair?\n\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// check if current closing tag matches previously opened one\n\t\t\t\t\tif (stack[stack.length - 1] == tag.name) {\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\twhile (stack.length && !found) {\n\t\t\t\t\t\t\tvar last = stack.pop();\n\t\t\t\t\t\t\tif (last == tag.name) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!stack.length && !found) {\n\t\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpos = tag.range.end - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Main function: search for tag pair in <code>text</code> for given \n\t\t * position\n\t\t * @memberOf htmlMatcher\n\t\t * @param {String} text \n\t\t * @param {Number} pos\n\t\t * @returns {Object}\n\t\t */\n\t\tfind: function(text, pos) {\n\t\t\tvar matcher = createMatcher(text); \n\t\t\tvar open = null, close = null;\n\t\t\tvar j, jl;\n\t\t\t\n\t\t\tfor (var i = pos; i >= 0; i--) {\n\t\t\t\tif ((open = matcher.open(i))) {\n\t\t\t\t\t// found opening tag\n\t\t\t\t\tif (open.selfClose) {\n\t\t\t\t\t\tif (open.range.cmp(pos, 'lt', 'gt')) {\n\t\t\t\t\t\t\t// inside self-closing tag, found match\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// outside self-closing tag, continue\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tclose = findClosingPair(open, matcher);\n\t\t\t\t\tif (close) {\n\t\t\t\t\t\t// found closing tag.\n\t\t\t\t\t\tvar r = range.create2(open.range.start, close.range.end);\n\t\t\t\t\t\tif (r.contains(pos)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (open.range.contains(pos)) {\n\t\t\t\t\t\t// we inside empty HTML tag like <br>\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\topen = null;\n\t\t\t\t} else if (matches(text, i, '-->')) {\n\t\t\t\t\t// skip back to comment start\n\t\t\t\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\t// found another comment end, do nothing\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (matches(text, j, '<!--')) {\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (matches(text, i, '<!--')) {\n\t\t\t\t\t// we're inside comment, match it\n\t\t\t\t\tfor (j = i + 4, jl = text.length; j < jl; j++) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\tj += 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\topen = comment(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmatcher.clean();\n\n\t\t\tif (open) {\n\t\t\t\tvar outerRange = null;\n\t\t\t\tvar innerRange = null;\n\t\t\t\t\n\t\t\t\tif (close) {\n\t\t\t\t\touterRange = range.create2(open.range.start, close.range.end);\n\t\t\t\t\tinnerRange = range.create2(open.range.end, close.range.start);\n\t\t\t\t} else {\n\t\t\t\t\touterRange = innerRange = range.create2(open.range.start, open.range.end);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (open.type == 'comment') {\n\t\t\t\t\t// adjust positions of inner range for comment\n\t\t\t\t\tvar _c = outerRange.substring(text);\n\t\t\t\t\tinnerRange.start += _c.length - _c.replace(/^<\\!--\\s*/, '').length;\n\t\t\t\t\tinnerRange.end -= _c.length - _c.replace(/\\s*-->$/, '').length;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\topen: open,\n\t\t\t\t\tclose: close,\n\t\t\t\t\ttype: open.type == 'comment' ? 'comment' : 'tag',\n\t\t\t\t\tinnerRange: innerRange,\n\t\t\t\t\tinnerContent: function() {\n\t\t\t\t\t\treturn this.innerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\touterRange: outerRange,\n\t\t\t\t\touterContent: function() {\n\t\t\t\t\t\treturn this.outerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\trange: !innerRange.length() || !innerRange.cmp(pos, 'lte', 'gte') ? outerRange : innerRange,\n\t\t\t\t\tcontent: function() {\n\t\t\t\t\t\treturn this.range.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\tsource: text\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * The same as <code>find()</code> method, but restricts matched result \n\t\t * to <code>tag</code> type\n\t\t * @param {String} text \n\t\t * @param {Number} pos\n\t\t * @returns {Object}\n\t\t */\n\t\ttag: function(text, pos) {\n\t\t\tvar result = this.find(text, pos);\n\t\t\tif (result && result.type == 'tag') {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n});\n},{\"./range\":\"assets\\\\range.js\"}],\"assets\\\\logger.js\":[function(require,module,exports){\n/**\n * Simple logger for Emmet\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\treturn {\n\t\tlog: function() {\n\t\t\tif (typeof console != 'undefined' && console.log) {\n\t\t\t\tconsole.log.apply(console, arguments);\n\t\t\t}\n\t\t}\n\t}\n})\n},{}],\"assets\\\\preferences.js\":[function(require,module,exports){\n/**\n * Common module's preferences storage. This module \n * provides general storage for all module preferences, their description and\n * default values.<br><br>\n * \n * This module can also be used to list all available properties to create \n * UI for updating properties\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\n\tvar preferences = {};\n\tvar defaults = {};\n\tvar _dbgDefaults = null;\n\tvar _dbgPreferences = null;\n\n\tfunction toBoolean(val) {\n\t\tif (typeof val === 'string') {\n\t\t\tval = val.toLowerCase();\n\t\t\treturn val == 'yes' || val == 'true' || val == '1';\n\t\t}\n\n\t\treturn !!val;\n\t}\n\t\n\tfunction isValueObj(obj) {\n\t\treturn typeof obj === 'object'\n\t\t\t&& !Array.isArray(obj) \n\t\t\t&& 'value' in obj \n\t\t\t&& Object.keys(obj).length < 3;\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Creates new preference item with default value\n\t\t * @param {String} name Preference name. You can also pass object\n\t\t * with many options\n\t\t * @param {Object} value Preference default value\n\t\t * @param {String} description Item textual description\n\t\t * @memberOf preferences\n\t\t */\n\t\tdefine: function(name, value, description) {\n\t\t\tvar prefs = name;\n\t\t\tif (typeof name === 'string') {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = {\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tdescription: description\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tObject.keys(prefs).forEach(function(k) {\n\t\t\t\tvar v = prefs[k];\n\t\t\t\tdefaults[k] = isValueObj(v) ? v : {value: v};\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Updates preference item value. Preference value should be defined\n\t\t * first with <code>define</code> method.\n\t\t * @param {String} name Preference name. You can also pass object\n\t\t * with many options\n\t\t * @param {Object} value Preference default value\n\t\t * @memberOf preferences\n\t\t */\n\t\tset: function(name, value) {\n\t\t\tvar prefs = name;\n\t\t\tif (typeof name === 'string') {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = value;\n\t\t\t}\n\t\t\t\n\t\t\tObject.keys(prefs).forEach(function(k) {\n\t\t\t\tvar v = prefs[k];\n\t\t\t\tif (!(k in defaults)) {\n\t\t\t\t\tthrow new Error('Property \"' + k + '\" is not defined. You should define it first with `define` method of current module');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// do not set value if it equals to default value\n\t\t\t\tif (v !== defaults[k].value) {\n\t\t\t\t\t// make sure we have value of correct type\n\t\t\t\t\tswitch (typeof defaults[k].value) {\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\t\tv = toBoolean(v);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tv = parseInt(v + '', 10) || 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: // convert to string\n\t\t\t\t\t\t\tif (v !== null) {\n\t\t\t\t\t\t\t\tv += '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpreferences[k] = v;\n\t\t\t\t} else if (k in preferences) {\n\t\t\t\t\tdelete preferences[k];\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns preference value\n\t\t * @param {String} name\n\t\t * @returns {String} Returns <code>undefined</code> if preference is \n\t\t * not defined\n\t\t */\n\t\tget: function(name) {\n\t\t\tif (name in preferences) {\n\t\t\t\treturn preferences[name];\n\t\t\t}\n\t\t\t\n\t\t\tif (name in defaults) {\n\t\t\t\treturn defaults[name].value;\n\t\t\t}\n\t\t\t\n\t\t\treturn void 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns comma-separated preference value as array of values\n\t\t * @param {String} name\n\t\t * @returns {Array} Returns <code>undefined</code> if preference is \n\t\t * not defined, <code>null</code> if string cannot be converted to array\n\t\t */\n\t\tgetArray: function(name) {\n\t\t\tvar val = this.get(name);\n\t\t\tif (typeof val === 'undefined' || val === null || val === '')  {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tval = val.split(',').map(utils.trim);\n\t\t\tif (!val.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\treturn val;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns comma and colon-separated preference value as dictionary\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tgetDict: function(name) {\n\t\t\tvar result = {};\n\t\t\tthis.getArray(name).forEach(function(val) {\n\t\t\t\tvar parts = val.split(':');\n\t\t\t\tresult[parts[0]] = parts[1];\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns description of preference item\n\t\t * @param {String} name Preference name\n\t\t * @returns {Object}\n\t\t */\n\t\tdescription: function(name) {\n\t\t\treturn name in defaults ? defaults[name].description : void 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Completely removes specified preference(s)\n\t\t * @param {String} name Preference name (or array of names)\n\t\t */\n\t\tremove: function(name) {\n\t\t\tif (!Array.isArray(name)) {\n\t\t\t\tname = [name];\n\t\t\t}\n\t\t\t\n\t\t\tname.forEach(function(key) {\n\t\t\t\tif (key in preferences) {\n\t\t\t\t\tdelete preferences[key];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (key in defaults) {\n\t\t\t\t\tdelete defaults[key];\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns sorted list of all available properties\n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn Object.keys(defaults).sort().map(function(key) {\n\t\t\t\treturn {\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: this.get(key),\n\t\t\t\t\ttype: typeof defaults[key].value,\n\t\t\t\t\tdescription: defaults[key].description\n\t\t\t\t};\n\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Loads user-defined preferences from JSON\n\t\t * @param {Object} json\n\t\t * @returns\n\t\t */\n\t\tload: function(json) {\n\t\t\tObject.keys(json).forEach(function(key) {\n\t\t\t\tthis.set(key, json[key]);\n\t\t\t}, this);\n\t\t},\n\n\t\t/**\n\t\t * Returns hash of user-modified preferences\n\t\t * @returns {Object}\n\t\t */\n\t\texportModified: function() {\n\t\t\treturn utils.extend({}, preferences);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Reset to defaults\n\t\t * @returns\n\t\t */\n\t\treset: function() {\n\t\t\tpreferences = {};\n\t\t},\n\t\t\n\t\t/**\n\t\t * For unit testing: use empty storage\n\t\t */\n\t\t_startTest: function() {\n\t\t\t_dbgDefaults = defaults;\n\t\t\t_dbgPreferences = preferences;\n\t\t\tdefaults = {};\n\t\t\tpreferences = {};\n\t\t},\n\t\t\n\t\t/**\n\t\t * For unit testing: restore original storage\n\t\t */\n\t\t_stopTest: function() {\n\t\t\tdefaults = _dbgDefaults;\n\t\t\tpreferences = _dbgPreferences;\n\t\t}\n\t};\n});\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"assets\\\\profile.js\":[function(require,module,exports){\n/**\n * Output profile module.\n * Profile defines how XHTML output data should look like\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar resources = require('./resources');\n\tvar prefs = require('./preferences');\n\n\tprefs.define('profile.allowCompactBoolean', true, \n\t\t'This option can be used to globally disable compact form of boolean ' + \n\t\t'attribues (attributes where name and value are equal). With compact' +\n\t\t'form enabled, HTML tags can be outputted as <code>&lt;div contenteditable&gt;</code> ' +\n\t\t'instead of <code>&lt;div contenteditable=\"contenteditable\"&gt;</code>');\n\n\tprefs.define('profile.booleanAttributes', '^contenteditable|seamless|async|autofocus|autoplay|checked|controls|defer|disabled|formnovalidate|hidden|ismap|loop|multiple|muted|novalidate|readonly|required|reversed|selected|typemustmatch$', \n\t\t'A regular expression for attributes that should be boolean by default.' + \n\t\t'If attribute name matches this expression, you dont have to write dot ' +\n\t\t'after attribute name in Emmet abbreviation to mark it as boolean.');\n\n\tvar profiles = {};\n\t\n\tvar defaultProfile = {\n\t\ttag_case: 'asis',\n\t\tattr_case: 'asis',\n\t\tattr_quotes: 'double',\n\t\t\n\t\t// Each tag on new line\n\t\ttag_nl: 'decide',\n\t\t\n\t\t// With tag_nl === true, defines if leaf node (e.g. node with no children)\n\t\t// should have formatted line breaks\n\t\ttag_nl_leaf: false,\n\t\t\n\t\tplace_cursor: true,\n\t\t\n\t\t// Indent tags\n\t\tindent: true,\n\t\t\n\t\t// How many inline elements should be to force line break \n\t\t// (set to 0 to disable)\n\t\tinline_break: 3,\n\n\t\t// Produce compact notation of boolean attribues:\n\t\t// attributes where name and value are equal.\n\t\t// With this option enabled, HTML filter will\n\t\t// produce <div contenteditable> instead of <div contenteditable=\"contenteditable\">\n\t\tcompact_bool: false,\n\t\t\n\t\t// Use self-closing style for writing empty elements, e.g. <br /> or <br>\n\t\tself_closing_tag: 'xhtml',\n\t\t\n\t\t// Profile-level output filters, re-defines syntax filters \n\t\tfilters: '',\n\t\t\n\t\t// Additional filters applied to abbreviation.\n\t\t// Unlike \"filters\", this preference doesn't override default filters\n\t\t// but add the instead every time given profile is chosen\n\t\textraFilters: ''\n\t};\n\t\n\t/**\n\t * @constructor\n\t * @type OutputProfile\n\t * @param {Object} options\n\t */\n\tfunction OutputProfile(options) {\n\t\tutils.extend(this, defaultProfile, options);\n\t}\n\t\n\tOutputProfile.prototype = {\n\t\t/**\n\t\t * Transforms tag name case depending on current profile settings\n\t\t * @param {String} name String to transform\n\t\t * @returns {String}\n\t\t */\n\t\ttagName: function(name) {\n\t\t\treturn stringCase(name, this.tag_case);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Transforms attribute name case depending on current profile settings \n\t\t * @param {String} name String to transform\n\t\t * @returns {String}\n\t\t */\n\t\tattributeName: function(name) {\n\t\t\treturn stringCase(name, this.attr_case);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns quote character for current profile\n\t\t * @returns {String}\n\t\t */\n\t\tattributeQuote: function() {\n\t\t\treturn this.attr_quotes == 'single' ? \"'\" : '\"';\n\t\t},\n\n\t\t/**\n\t\t * Returns self-closing tag symbol for current profile\n\t\t * @returns {String}\n\t\t */\n\t\tselfClosing: function() {\n\t\t\tif (this.self_closing_tag == 'xhtml')\n\t\t\t\treturn ' /';\n\t\t\t\n\t\t\tif (this.self_closing_tag === true)\n\t\t\t\treturn '/';\n\t\t\t\n\t\t\treturn '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns cursor token based on current profile settings\n\t\t * @returns {String}\n\t\t */\n\t\tcursor: function() {\n\t\t\treturn this.place_cursor ? utils.getCaretPlaceholder() : '';\n\t\t},\n\n\t\t/**\n\t\t * Check if attribute with given name is boolean,\n\t\t * e.g. written as `contenteditable` instead of \n\t\t * `contenteditable=\"contenteditable\"`\n\t\t * @param  {String}  name Attribute name\n\t\t * @return {Boolean}\n\t\t */\n\t\tisBoolean: function(name, value) {\n\t\t\tif (name == value) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar boolAttrs = prefs.get('profile.booleanAttributes');\n\t\t\tif (!value && boolAttrs) {\n\t\t\t\tboolAttrs = new RegExp(boolAttrs, 'i');\n\t\t\t\treturn boolAttrs.test(name);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t/**\n\t\t * Check if compact boolean attribute record is \n\t\t * allowed for current profile\n\t\t * @return {Boolean}\n\t\t */\n\t\tallowCompactBoolean: function() {\n\t\t\treturn this.compact_bool && prefs.get('profile.allowCompactBoolean');\n\t\t}\n\t};\n\t\n\t/**\n\t * Helper function that converts string case depending on \n\t * <code>caseValue</code> \n\t * @param {String} str String to transform\n\t * @param {String} caseValue Case value: can be <i>lower</i>, \n\t * <i>upper</i> and <i>leave</i>\n\t * @returns {String}\n\t */\n\tfunction stringCase(str, caseValue) {\n\t\tswitch (String(caseValue || '').toLowerCase()) {\n\t\t\tcase 'lower':\n\t\t\t\treturn str.toLowerCase();\n\t\t\tcase 'upper':\n\t\t\t\treturn str.toUpperCase();\n\t\t}\n\t\t\n\t\treturn str;\n\t}\n\t\n\t/**\n\t * Creates new output profile\n\t * @param {String} name Profile name\n\t * @param {Object} options Profile options\n\t */\n\tfunction createProfile(name, options) {\n\t\treturn profiles[name.toLowerCase()] = new OutputProfile(options);\n\t}\n\t\n\tfunction createDefaultProfiles() {\n\t\tcreateProfile('xhtml');\n\t\tcreateProfile('html', {self_closing_tag: false, compact_bool: true});\n\t\tcreateProfile('xml', {self_closing_tag: true, tag_nl: true});\n\t\tcreateProfile('plain', {tag_nl: false, indent: false, place_cursor: false});\n\t\tcreateProfile('line', {tag_nl: false, indent: false, extraFilters: 's'});\n\t\tcreateProfile('css', {tag_nl: true});\n\t\tcreateProfile('css_line', {tag_nl: false});\n\t}\n\t\n\tcreateDefaultProfiles();\n\t\n\treturn  {\n\t\t/**\n\t\t * Creates new output profile and adds it into internal dictionary\n\t\t * @param {String} name Profile name\n\t\t * @param {Object} options Profile options\n\t\t * @memberOf emmet.profile\n\t\t * @returns {Object} New profile\n\t\t */\n\t\tcreate: function(name, options) {\n\t\t\tif (arguments.length == 2)\n\t\t\t\treturn createProfile(name, options);\n\t\t\telse\n\t\t\t\t// create profile object only\n\t\t\t\treturn new OutputProfile(utils.defaults(name || {}, defaultProfile));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns profile by its name. If profile wasn't found, returns\n\t\t * 'plain' profile\n\t\t * @param {String} name Profile name. Might be profile itself\n\t\t * @param {String} syntax. Optional. Current editor syntax. If defined,\n\t\t * profile is searched in resources first, then in predefined profiles\n\t\t * @returns {Object}\n\t\t */\n\t\tget: function(name, syntax) {\n\t\t\tif (!name && syntax) {\n\t\t\t\t// search in user resources first\n\t\t\t\tvar profile = resources.findItem(syntax, 'profile');\n\t\t\t\tif (profile) {\n\t\t\t\t\tname = profile;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!name) {\n\t\t\t\treturn profiles.plain;\n\t\t\t}\n\t\t\t\n\t\t\tif (name instanceof OutputProfile) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\t\n\t\t\tif (typeof name === 'string' && name.toLowerCase() in profiles) {\n\t\t\t\treturn profiles[name.toLowerCase()];\n\t\t\t}\n\t\t\t\n\t\t\treturn this.create(name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Deletes profile with specified name\n\t\t * @param {String} name Profile name\n\t\t */\n\t\tremove: function(name) {\n\t\t\tname = (name || '').toLowerCase();\n\t\t\tif (name in profiles)\n\t\t\t\tdelete profiles[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Resets all user-defined profiles\n\t\t */\n\t\treset: function() {\n\t\t\tprofiles = {};\n\t\t\tcreateDefaultProfiles();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that converts string case depending on \n\t\t * <code>caseValue</code> \n\t\t * @param {String} str String to transform\n\t\t * @param {String} caseValue Case value: can be <i>lower</i>, \n\t\t * <i>upper</i> and <i>leave</i>\n\t\t * @returns {String}\n\t\t */\n\t\tstringCase: stringCase\n\t};\n});\n\n},{\"../utils/common\":\"utils\\\\common.js\",\"./preferences\":\"assets\\\\preferences.js\",\"./resources\":\"assets\\\\resources.js\"}],\"assets\\\\range.js\":[function(require,module,exports){\n/**\n * Helper module to work with ranges\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tfunction cmp(a, b, op) {\n\t\tswitch (op) {\n\t\t\tcase 'eq':\n\t\t\tcase '==':\n\t\t\t\treturn a === b;\n\t\t\tcase 'lt':\n\t\t\tcase '<':\n\t\t\t\treturn a < b;\n\t\t\tcase 'lte':\n\t\t\tcase '<=':\n\t\t\t\treturn a <= b;\n\t\t\tcase 'gt':\n\t\t\tcase '>':\n\t\t\t\treturn a > b;\n\t\t\tcase 'gte':\n\t\t\tcase '>=':\n\t\t\t\treturn a >= b;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * @type Range\n\t * @constructor\n\t * @param {Object} start\n\t * @param {Number} len\n\t */\n\tfunction Range(start, len) {\n\t\tif (typeof start === 'object' && 'start' in start) {\n\t\t\t// create range from object stub\n\t\t\tthis.start = Math.min(start.start, start.end);\n\t\t\tthis.end = Math.max(start.start, start.end);\n\t\t} else if (Array.isArray(start)) {\n\t\t\tthis.start = start[0];\n\t\t\tthis.end = start[1];\n\t\t} else {\n\t\t\tlen = typeof len === 'string' ? len.length : +len;\n\t\t\tthis.start = start;\n\t\t\tthis.end = start + len;\n\t\t}\n\t}\n\t\n\tRange.prototype = {\n\t\tlength: function() {\n\t\t\treturn Math.abs(this.end - this.start);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns <code>true</code> if passed range is equals to current one\n\t\t * @param {Range} range\n\t\t * @returns {Boolean}\n\t\t */\n\t\tequal: function(range) {\n\t\t\treturn this.cmp(range, 'eq', 'eq');\n//\t\t\treturn this.start === range.start && this.end === range.end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Shifts indexes position with passed <code>delta</code>\n\t\t * @param {Number} delta\n\t\t * @returns {Range} range itself\n\t\t */\n\t\tshift: function(delta) {\n\t\t\tthis.start += delta;\n\t\t\tthis.end += delta;\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if two ranges are overlapped\n\t\t * @param {Range} range\n\t\t * @returns {Boolean}\n\t\t */\n\t\toverlap: function(range) {\n\t\t\treturn range.start <= this.end && range.end >= this.start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds intersection of two ranges\n\t\t * @param {Range} range\n\t\t * @returns {Range} <code>null</code> if ranges does not overlap\n\t\t */\n\t\tintersection: function(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.max(range.start, this.start);\n\t\t\t\tvar end = Math.min(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the union of the thow ranges.\n\t\t * @param {Range} range\n\t\t * @returns {Range} <code>null</code> if ranges are not overlapped\n\t\t */\n\t\tunion: function(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.min(range.start, this.start);\n\t\t\t\tvar end = Math.max(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns a Boolean value that indicates whether a specified position \n\t\t * is in a given range.\n\t\t * @param {Number} loc\n\t\t */\n\t\tinside: function(loc) {\n\t\t\treturn this.cmp(loc, 'lte', 'gt');\n//\t\t\treturn this.start <= loc && this.end > loc;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns a Boolean value that indicates whether a specified position \n\t\t * is in a given range, but not equals bounds.\n\t\t * @param {Number} loc\n\t\t */\n\t\tcontains: function(loc) {\n\t\t\treturn this.cmp(loc, 'lt', 'gt');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current range completely includes specified one\n\t\t * @param {Range} r\n\t\t * @returns {Boolean} \n\t\t */\n\t\tinclude: function(r) {\n\t\t\treturn this.cmp(r, 'lte', 'gte');\n//\t\t\treturn this.start <= r.start && this.end >= r.end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Low-level comparision method\n\t\t * @param {Number} loc\n\t\t * @param {String} left Left comparison operator\n\t\t * @param {String} right Right comaprison operator\n\t\t */\n\t\tcmp: function(loc, left, right) {\n\t\t\tvar a, b;\n\t\t\tif (loc instanceof Range) {\n\t\t\t\ta = loc.start;\n\t\t\t\tb = loc.end;\n\t\t\t} else {\n\t\t\t\ta = b = loc;\n\t\t\t}\n\t\t\t\n\t\t\treturn cmp(this.start, a, left || '<=') && cmp(this.end, b, right || '>');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns substring of specified <code>str</code> for current range\n\t\t * @param {String} str\n\t\t * @returns {String}\n\t\t */\n\t\tsubstring: function(str) {\n\t\t\treturn this.length() > 0 \n\t\t\t\t? str.substring(this.start, this.end) \n\t\t\t\t: '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates copy of current range\n\t\t * @returns {Range}\n\t\t */\n\t\tclone: function() {\n\t\t\treturn new Range(this.start, this.length());\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {Array}\n\t\t */\n\t\ttoArray: function() {\n\t\t\treturn [this.start, this.end];\n\t\t},\n\t\t\n\t\ttoString: function() {\n\t\t\treturn this.valueOf();\n\t\t},\n\n\t\tvalueOf: function() {\n\t\t\treturn '{' + this.start + ', ' + this.length() + '}';\n\t\t}\n\t};\n\n\t/**\n\t * Creates new range object instance\n\t * @param {Object} start Range start or array with 'start' and 'end'\n\t * as two first indexes or object with 'start' and 'end' properties\n\t * @param {Number} len Range length or string to produce range from\n\t * @returns {Range}\n\t */\n\tmodule.exports = function(start, len) {\n\t\tif (typeof start == 'undefined' || start === null)\n\t\t\treturn null;\n\t\t\t\n\t\tif (start instanceof Range)\n\t\t\treturn start;\n\t\t\n\t\tif (typeof start == 'object' && 'start' in start && 'end' in start) {\n\t\t\tlen = start.end - start.start;\n\t\t\tstart = start.start;\n\t\t}\n\t\t\t\n\t\treturn new Range(start, len);\n\t};\n\n\tmodule.exports.create = module.exports;\n\n\tmodule.exports.isRange = function(val) {\n\t\treturn val instanceof Range;\n\t};\n\n\t/**\n\t * <code>Range</code> object factory, the same as <code>this.create()</code>\n\t * but last argument represents end of range, not length\n\t * @returns {Range}\n\t */\n\tmodule.exports.create2 = function(start, end) {\n\t\tif (typeof start === 'number' && typeof end === 'number') {\n\t\t\tend -= start;\n\t\t}\n\t\t\n\t\treturn this.create(start, end);\n\t};\n\n\t/**\n\t * Helper function that sorts ranges in order as they\n\t * appear in text\n\t * @param  {Array} ranges\n\t * @return {Array}\n\t */\n\tmodule.exports.sort = function(ranges, reverse) {\n\t\tranges = ranges.sort(function(a, b) {\n\t\t\tif (a.start === b.start) {\n\t\t\t\treturn b.end - a.end;\n\t\t\t}\n\n\t\t\treturn a.start - b.start;\n\t\t});\n\n\t\treverse && ranges.reverse();\n\t\treturn ranges;\n\t};\n\n\treturn module.exports;\n});\n},{}],\"assets\\\\resources.js\":[function(require,module,exports){\n/**\n * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.\n * Contains convenient method to get access for snippets with respect of\n * inheritance. Also provides ability to store data in different vocabularies\n * ('system' and 'user') for fast and safe resource update\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar handlerList = require('./handlerList');\n\tvar utils = require('../utils/common');\n\tvar elements = require('./elements');\n\tvar logger = require('../assets/logger');\n\tvar stringScore = require('../vendor/stringScore');\n\tvar cssResolver = require('../resolver/css');\n\n\tvar VOC_SYSTEM = 'system';\n\tvar VOC_USER = 'user';\n\n\tvar cache = {};\n\n\t/** Regular expression for XML tag matching */\n\tvar reTag = /^<(\\w+\\:?[\\w\\-]*)((?:\\s+[@\\!]?[\\w\\:\\-]+\\s*=\\s*(['\"]).*?\\3)*)\\s*(\\/?)>/;\n\n\tvar systemSettings = {};\n\tvar userSettings = {};\n\n\t/** @type HandlerList List of registered abbreviation resolvers */\n\tvar resolvers = handlerList.create();\n\n\tfunction each(obj, fn) {\n\t\tif (!obj) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject.keys(obj).forEach(function(key) {\n\t\t\tfn(obj[key], key);\n\t\t});\n\t}\n\n\t/**\n\t * Normalizes caret plceholder in passed text: replaces | character with\n\t * default caret placeholder\n\t * @param {String} text\n\t * @returns {String}\n\t */\n\tfunction normalizeCaretPlaceholder(text) {\n\t\treturn utils.replaceUnescapedSymbol(text, '|', utils.getCaretPlaceholder());\n\t}\n\n\tfunction parseItem(name, value, type) {\n\t\tvalue = normalizeCaretPlaceholder(value);\n\n\t\tif (type == 'snippets') {\n\t\t\treturn elements.create('snippet', value);\n\t\t}\n\n\t\tif (type == 'abbreviations') {\n\t\t\treturn parseAbbreviation(name, value);\n\t\t}\n\t}\n\n\t/**\n\t * Parses single abbreviation\n\t * @param {String} key Abbreviation name\n\t * @param {String} value Abbreviation value\n\t * @return {Object}\n\t */\n\tfunction parseAbbreviation(key, value) {\n\t\tkey = utils.trim(key);\n\t\tvar m;\n\t\tif ((m = reTag.exec(value))) {\n\t\t\treturn elements.create('element', m[1], m[2], m[4] == '/');\n\t\t} else {\n\t\t\t// assume it's reference to another abbreviation\n\t\t\treturn elements.create('reference', value);\n\t\t}\n\t}\n\n\t/**\n\t * Normalizes snippet key name for better fuzzy search\n\t * @param {String} str\n\t * @returns {String}\n\t */\n\tfunction normalizeName(str) {\n\t\treturn str.replace(/:$/, '').replace(/:/g, '-');\n\t}\n\n\tfunction expandSnippetsDefinition(snippets) {\n\t\tvar out = {};\n\t\teach(snippets, function(val, key) {\n\t\t\tvar items = key.split('|');\n\t\t\t// do not use iterators for better performance\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\t\tout[items[i]] = val;\n\t\t\t}\n\t\t});\n\n\t\treturn out;\n\t}\n\n\tutils.extend(exports, {\n\t\t/**\n\t\t * Sets new unparsed data for specified settings vocabulary\n\t\t * @param {Object} data\n\t\t * @param {String} type Vocabulary type ('system' or 'user')\n\t\t * @memberOf resources\n\t\t */\n\t\tsetVocabulary: function(data, type) {\n\t\t\tcache = {};\n\n\t\t\t// sections like \"snippets\" and \"abbreviations\" could have\n\t\t\t// definitions like `\"f|fs\": \"fieldset\"` which is the same as distinct\n\t\t\t// \"f\" and \"fs\" keys both equals to \"fieldset\".\n\t\t\t// We should parse these definitions first\n\t\t\tvar voc = {};\n\t\t\teach(data, function(section, syntax) {\n\t\t\t\tvar _section = {};\n\t\t\t\teach(section, function(subsection, name) {\n\t\t\t\t\tif (name == 'abbreviations' || name == 'snippets') {\n\t\t\t\t\t\tsubsection = expandSnippetsDefinition(subsection);\n\t\t\t\t\t}\n\t\t\t\t\t_section[name] = subsection;\n\t\t\t\t});\n\n\t\t\t\tvoc[syntax] = _section;\n\t\t\t});\n\n\n\t\t\tif (type == VOC_SYSTEM) {\n\t\t\t\tsystemSettings = voc;\n\t\t\t} else {\n\t\t\t\tuserSettings = voc;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Returns resource vocabulary by its name\n\t\t * @param {String} name Vocabulary name ('system' or 'user')\n\t\t * @return {Object}\n\t\t */\n\t\tgetVocabulary: function(name) {\n\t\t\treturn name == VOC_SYSTEM ? systemSettings : userSettings;\n\t\t},\n\n\t\t/**\n\t\t * Returns resource (abbreviation, snippet, etc.) matched for passed\n\t\t * abbreviation\n\t\t * @param {AbbreviationNode} node\n\t\t * @param {String} syntax\n\t\t * @returns {Object}\n\t\t */\n\t\tgetMatchedResource: function(node, syntax) {\n\t\t\treturn resolvers.exec(null, utils.toArray(arguments))\n\t\t\t\t|| this.findSnippet(syntax, node.name());\n\t\t},\n\n\t\t/**\n\t\t * Returns variable value\n\t\t * @return {String}\n\t\t */\n\t\tgetVariable: function(name) {\n\t\t\treturn (this.getSection('variables') || {})[name];\n\t\t},\n\n\t\t/**\n\t\t * Store runtime variable in user storage\n\t\t * @param {String} name Variable name\n\t\t * @param {String} value Variable value\n\t\t */\n\t\tsetVariable: function(name, value){\n\t\t\tvar voc = this.getVocabulary('user') || {};\n\t\t\tif (!('variables' in voc))\n\t\t\t\tvoc.variables = {};\n\n\t\t\tvoc.variables[name] = value;\n\t\t\tthis.setVocabulary(voc, 'user');\n\t\t},\n\n\t\t/**\n\t\t * Check if there are resources for specified syntax\n\t\t * @param {String} syntax\n\t\t * @return {Boolean}\n\t\t */\n\t\thasSyntax: function(syntax) {\n\t\t\treturn syntax in this.getVocabulary(VOC_USER)\n\t\t\t\t|| syntax in this.getVocabulary(VOC_SYSTEM);\n\t\t},\n\n\t\t/**\n\t\t * Registers new abbreviation resolver.\n\t\t * @param {Function} fn Abbreviation resolver which will receive\n\t\t * abbreviation as first argument and should return parsed abbreviation\n\t\t * object if abbreviation has handled successfully, <code>null</code>\n\t\t * otherwise\n\t\t * @param {Object} options Options list as described in\n\t\t * {@link HandlerList#add()} method\n\t\t */\n\t\taddResolver: function(fn, options) {\n\t\t\tresolvers.add(fn, options);\n\t\t},\n\n\t\tremoveResolver: function(fn) {\n\t\t\tresolvers.remove(fn);\n\t\t},\n\n\t\t/**\n\t\t * Returns actual section data, merged from both\n\t\t * system and user data\n\t\t * @param {String} name Section name (syntax)\n\t\t * @param {String} ...args Subsections\n\t\t * @returns\n\t\t */\n\t\tgetSection: function(name) {\n\t\t\tif (!name)\n\t\t\t\treturn null;\n\n\t\t\tif (!(name in cache)) {\n\t\t\t\tcache[name] = utils.deepMerge({}, systemSettings[name], userSettings[name]);\n\t\t\t}\n\n\t\t\tvar data = cache[name], subsections = utils.toArray(arguments, 1), key;\n\t\t\twhile (data && (key = subsections.shift())) {\n\t\t\t\tif (key in data) {\n\t\t\t\t\tdata = data[key];\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t},\n\n\t\t/**\n\t\t * Recursively searches for a item inside top level sections (syntaxes)\n\t\t * with respect of `extends` attribute\n\t\t * @param {String} topSection Top section name (syntax)\n\t\t * @param {String} subsection Inner section name\n\t\t * @returns {Object}\n\t\t */\n\t\tfindItem: function(topSection, subsection) {\n\t\t\tvar data = this.getSection(topSection);\n\t\t\twhile (data) {\n\t\t\t\tif (subsection in data)\n\t\t\t\t\treturn data[subsection];\n\n\t\t\t\tdata = this.getSection(data['extends']);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Recursively searches for a snippet definition inside syntax section.\n\t\t * Definition is searched inside `snippets` and `abbreviations`\n\t\t * subsections\n\t\t * @param {String} syntax Top-level section name (syntax)\n\t\t * @param {String} name Snippet name\n\t\t * @returns {Object}\n\t\t */\n\t\tfindSnippet: function(syntax, name, memo) {\n\t\t\tif (!syntax || !name)\n\t\t\t\treturn null;\n\n\t\t\tmemo = memo || [];\n\n\t\t\tvar names = [name];\n\t\t\t// create automatic aliases to properties with colons,\n\t\t\t// e.g. pos-a == pos:a\n\t\t\tif (~name.indexOf('-')) {\n\t\t\t\tnames.push(name.replace(/\\-/g, ':'));\n\t\t\t}\n\n\t\t\tvar data = this.getSection(syntax), matchedItem = null;\n\t\t\t['snippets', 'abbreviations'].some(function(sectionName) {\n\t\t\t\tvar data = this.getSection(syntax, sectionName);\n\t\t\t\tif (data) {\n\t\t\t\t\treturn names.some(function(n) {\n\t\t\t\t\t\tif (data[n]) {\n\t\t\t\t\t\t\treturn matchedItem = parseItem(n, data[n], sectionName);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\tmemo.push(syntax);\n\t\t\tif (!matchedItem && data['extends'] && !~memo.indexOf(data['extends'])) {\n\t\t\t\t// try to find item in parent syntax section\n\t\t\t\treturn this.findSnippet(data['extends'], name, memo);\n\t\t\t}\n\n\t\t\treturn matchedItem;\n\t\t},\n\n\t\t/**\n\t\t * Performs fuzzy search of snippet definition\n\t\t * @param {String} syntax Top-level section name (syntax)\n\t\t * @param {String} name Snippet name\n\t\t * @returns\n\t\t */\n\t\tfuzzyFindSnippet: function(syntax, name, minScore) {\n\t\t\tvar result = this.fuzzyFindMatches(syntax, name, minScore)[0];\n\t\t\tif (result) {\n\t\t\t\treturn result.value.parsedValue;\n\t\t\t}\n\t\t},\n\n\t\tfuzzyFindMatches: function(syntax, name, minScore) {\n\t\t\tminScore = minScore || 0.3;\n\t\t\tname = normalizeName(name);\n\t\t\tvar snippets = this.getAllSnippets(syntax);\n\n\t\t\treturn Object.keys(snippets)\n\t\t\t\t.map(function(key) {\n\t\t\t\t\tvar value = snippets[key];\n\t\t\t\t\treturn {\n\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\tscore: stringScore.score(value.nk, name, 0.1),\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t\t.filter(function(item) {\n\t\t\t\t\treturn item.score >= minScore;\n\t\t\t\t})\n\t\t\t\t.sort(function(a, b) {\n\t\t\t\t\treturn a.score - b.score;\n\t\t\t\t})\n\t\t\t\t.reverse();\n\t\t},\n\n\t\t/**\n\t\t * Returns plain dictionary of all available abbreviations and snippets\n\t\t * for specified syntax with respect of inheritance\n\t\t * @param {String} syntax\n\t\t * @returns {Object}\n\t\t */\n\t\tgetAllSnippets: function(syntax) {\n\t\t\tvar cacheKey = 'all-' + syntax;\n\t\t\tif (!cache[cacheKey]) {\n\t\t\t\tvar stack = [], sectionKey = syntax;\n\t\t\t\tvar memo = [];\n\n\t\t\t\tdo {\n\t\t\t\t\tvar section = this.getSection(sectionKey);\n\t\t\t\t\tif (!section)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t['snippets', 'abbreviations'].forEach(function(sectionName) {\n\t\t\t\t\t\tvar stackItem = {};\n\t\t\t\t\t\teach(section[sectionName] || null, function(v, k) {\n\t\t\t\t\t\t\tstackItem[k] = {\n\t\t\t\t\t\t\t\tnk: normalizeName(k),\n\t\t\t\t\t\t\t\tvalue: v,\n\t\t\t\t\t\t\t\tparsedValue: parseItem(k, v, sectionName),\n\t\t\t\t\t\t\t\ttype: sectionName\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tstack.push(stackItem);\n\t\t\t\t\t});\n\n\t\t\t\t\tmemo.push(sectionKey);\n\t\t\t\t\tsectionKey = section['extends'];\n\t\t\t\t} while (sectionKey && !~memo.indexOf(sectionKey));\n\n\n\t\t\t\tcache[cacheKey] = utils.extend.apply(utils, stack.reverse());\n\t\t\t}\n\n\t\t\treturn cache[cacheKey];\n\t\t},\n\n\t\t/**\n\t\t * Returns newline character\n\t\t * @returns {String}\n\t\t */\n\t\tgetNewline: function() {\n\t\t\tvar nl = this.getVariable('newline');\n\t\t\treturn typeof nl === 'string' ? nl : '\\n';\n\t\t},\n\n\t\t/**\n\t\t * Sets new newline character that will be used in output\n\t\t * @param {String} str\n\t\t */\n\t\tsetNewline: function(str) {\n\t\t\tthis.setVariable('newline', str);\n\t\t\tthis.setVariable('nl', str);\n\t\t}\n\t});\n\n\t// XXX add default resolvers\n\texports.addResolver(cssResolver.resolve.bind(cssResolver));\n\n\t// try to load snippets\n\t// hide it from Require.JS parser\n\t(function(r) {\n\t\tif (typeof define === 'undefined' || !define.amd) {\n\t\t\ttry {\n\t\t\t\texports.setVocabulary(r('../snippets.json'), VOC_SYSTEM);\n\t\t\t} catch (e) {}\n\t\t}\n\t})(require);\n\n\n\treturn exports;\n});\n\n},{\"../assets/logger\":\"assets\\\\logger.js\",\"../resolver/css\":\"resolver\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../vendor/stringScore\":\"vendor\\\\stringScore.js\",\"./elements\":\"assets\\\\elements.js\",\"./handlerList\":\"assets\\\\handlerList.js\"}],\"assets\\\\stringStream.js\":[function(require,module,exports){\n/**\n * A trimmed version of CodeMirror's StringStream module for string parsing\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\t/**\n\t * @type StringStream\n\t * @constructor\n\t * @param {String} string Assuming that bound string should be\n\t * immutable\n\t */\n\tfunction StringStream(string) {\n\t\tthis.pos = this.start = 0;\n\t\tthis.string = string;\n\t\tthis._length = string.length;\n\t}\n\t\n\tStringStream.prototype = {\n\t\t/**\n\t\t * Returns true only if the stream is at the end of the line.\n\t\t * @returns {Boolean}\n\t\t */\n\t\teol: function() {\n\t\t\treturn this.pos >= this._length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns true only if the stream is at the start of the line\n\t\t * @returns {Boolean}\n\t\t */\n\t\tsol: function() {\n\t\t\treturn this.pos === 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the next character in the stream without advancing it. \n\t\t * Will return <code>undefined</code> at the end of the line.\n\t\t * @returns {String}\n\t\t */\n\t\tpeek: function() {\n\t\t\treturn this.string.charAt(this.pos);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the next character in the stream and advances it.\n\t\t * Also returns <code>undefined</code> when no more characters are available.\n\t\t * @returns {String}\n\t\t */\n\t\tnext: function() {\n\t\t\tif (this.pos < this._length)\n\t\t\t\treturn this.string.charAt(this.pos++);\n\t\t},\n\t\t\n\t\t/**\n\t\t * match can be a character, a regular expression, or a function that\n\t\t * takes a character and returns a boolean. If the next character in the\n\t\t * stream 'matches' the given argument, it is consumed and returned.\n\t\t * Otherwise, undefined is returned.\n\t\t * @param {Object} match\n\t\t * @returns {String}\n\t\t */\n\t\teat: function(match) {\n\t\t\tvar ch = this.string.charAt(this.pos), ok;\n\t\t\tif (typeof match == \"string\")\n\t\t\t\tok = ch == match;\n\t\t\telse\n\t\t\t\tok = ch && (match.test ? match.test(ch) : match(ch));\n\t\t\t\n\t\t\tif (ok) {\n\t\t\t\t++this.pos;\n\t\t\t\treturn ch;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t\t * fails. Returns <code>true</code> if any characters were eaten.\n\t\t * @param {Object} match\n\t\t * @returns {Boolean}\n\t\t */\n\t\teatWhile: function(match) {\n\t\t\tvar start = this.pos;\n\t\t\twhile (this.eat(match)) {}\n\t\t\treturn this.pos > start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Shortcut for <code>eatWhile</code> when matching white-space.\n\t\t * @returns {Boolean}\n\t\t */\n\t\teatSpace: function() {\n\t\t\tvar start = this.pos;\n\t\t\twhile (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n\t\t\t\t++this.pos;\n\t\t\treturn this.pos > start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Moves the position to the end of the line.\n\t\t */\n\t\tskipToEnd: function() {\n\t\t\tthis.pos = this._length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Skips to the next occurrence of the given character, if found on the\n\t\t * current line (doesn't advance the stream if the character does not\n\t\t * occur on the line). Returns true if the character was found.\n\t\t * @param {String} ch\n\t\t * @returns {Boolean}\n\t\t */\n\t\tskipTo: function(ch) {\n\t\t\tvar found = this.string.indexOf(ch, this.pos);\n\t\t\tif (found > -1) {\n\t\t\t\tthis.pos = found;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Skips to <code>close</code> character which is pair to <code>open</code>\n\t\t * character, considering possible pair nesting. This function is used\n\t\t * to consume pair of characters, like opening and closing braces\n\t\t * @param {String} open\n\t\t * @param {String} close\n\t\t * @returns {Boolean} Returns <code>true</code> if pair was successfully\n\t\t * consumed\n\t\t */\n\t\tskipToPair: function(open, close, skipString) {\n\t\t\tvar braceCount = 0, ch;\n\t\t\tvar pos = this.pos, len = this._length;\n\t\t\twhile (pos < len) {\n\t\t\t\tch = this.string.charAt(pos++);\n\t\t\t\tif (ch == open) {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == close) {\n\t\t\t\t\tbraceCount--;\n\t\t\t\t\tif (braceCount < 1) {\n\t\t\t\t\t\tthis.pos = pos;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (skipString && (ch == '\"' || ch == \"'\")) {\n\t\t\t\t\tthis.skipString(ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\n\t\t/**\n\t\t * A helper function which, in case of either single or\n\t\t * double quote was found in current position, skips entire\n\t\t * string (quoted value)\n\t\t * @return {Boolean} Wether quoted string was skipped\n\t\t */\n\t\tskipQuoted: function(noBackup) {\n\t\t\tvar ch = this.string.charAt(noBackup ? this.pos : this.pos - 1);\n\t\t\tif (ch === '\"' || ch === \"'\") {\n\t\t\t\tif (noBackup) {\n\t\t\t\t\tthis.pos++;\n\t\t\t\t}\n\t\t\t\treturn this.skipString(ch);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * A custom function to skip string literal, e.g. a \"double-quoted\"\n\t\t * or 'single-quoted' value\n\t\t * @param  {String} quote An opening quote\n\t\t * @return {Boolean}\n\t\t */\n\t\tskipString: function(quote) {\n\t\t\tvar pos = this.pos, len = this._length, ch;\n\t\t\twhile (pos < len) {\n\t\t\t\tch = this.string.charAt(pos++);\n\t\t\t\tif (ch == '\\\\') {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ch == quote) {\n\t\t\t\t\tthis.pos = pos;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Backs up the stream n characters. Backing it up further than the\n\t\t * start of the current token will cause things to break, so be careful.\n\t\t * @param {Number} n\n\t\t */\n\t\tbackUp : function(n) {\n\t\t\tthis.pos -= n;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Act like a multi-character <code>eat</code>if <code>consume</code> is true or\n\t\t * not givenor a look-ahead that doesn't update the stream positionif\n\t\t * it is false. <code>pattern</code> can be either a string or a\n\t\t * regular expression starting with ^. When it is a string,\n\t\t * <code>caseInsensitive</code> can be set to true to make the match\n\t\t * case-insensitive. When successfully matching a regular expression,\n\t\t * the returned value will be the array returned by <code>match</code>,\n\t\t * in case you need to extract matched groups.\n\t\t * \n\t\t * @param {RegExp} pattern\n\t\t * @param {Boolean} consume\n\t\t * @param {Boolean} caseInsensitive\n\t\t * @returns\n\t\t */\n\t\tmatch: function(pattern, consume, caseInsensitive) {\n\t\t\tif (typeof pattern == \"string\") {\n\t\t\t\tvar cased = caseInsensitive\n\t\t\t\t\t? function(str) {return str.toLowerCase();}\n\t\t\t\t\t: function(str) {return str;};\n\t\t\t\t\n\t\t\t\tif (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n\t\t\t\t\tif (consume !== false)\n\t\t\t\t\t\tthis.pos += pattern.length;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar match = this.string.slice(this.pos).match(pattern);\n\t\t\t\tif (match && consume !== false)\n\t\t\t\t\tthis.pos += match[0].length;\n\t\t\t\treturn match;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Get the string between the start of the current token and the \n\t\t * current stream position.\n\t\t * @returns {String}\n\t\t */\n\t\tcurrent: function(backUp) {\n\t\t\treturn this.string.slice(this.start, this.pos - (backUp ? 1 : 0));\n\t\t}\n\t};\n\n\tmodule.exports = function(string) {\n\t\treturn new StringStream(string);\n\t};\n\n\t/** @deprecated */\n\tmodule.exports.create = module.exports;\n\treturn module.exports;\n});\n},{}],\"assets\\\\tabStops.js\":[function(require,module,exports){\n/**\n * Utility module for handling tabstops tokens generated by Emmet's \n * \"Expand Abbreviation\" action. The main <code>extract</code> method will take\n * raw text (for example: <i>${0} some ${1:text}</i>), find all tabstops \n * occurrences, replace them with tokens suitable for your editor of choice and \n * return object with processed text and list of found tabstops and their ranges.\n * For sake of portability (Objective-C/Java) the tabstops list is a plain \n * sorted array with plain objects.\n * \n * Placeholders with the same are meant to be <i>linked</i> in your editor.\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar stringStream = require('./stringStream');\n\tvar resources = require('./resources');\n\n\t/**\n\t * Global placeholder value, automatically incremented by \n\t * <code>variablesResolver()</code> function\n\t */\n\tvar startPlaceholderNum = 100;\n\tvar tabstopIndex = 0;\n\t\n\tvar defaultOptions = {\n\t\treplaceCarets: false,\n\t\tescape: function(ch) {\n\t\t\treturn '\\\\' + ch;\n\t\t},\n\t\ttabstop: function(data) {\n\t\t\treturn data.token;\n\t\t},\n\t\tvariable: function(data) {\n\t\t\treturn data.token;\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Main function that looks for a tabstops in provided <code>text</code>\n\t\t * and returns a processed version of <code>text</code> with expanded \n\t\t * placeholders and list of tabstops found.\n\t\t * @param {String} text Text to process\n\t\t * @param {Object} options List of processor options:<br>\n\t\t * \n\t\t * <b>replaceCarets</b> : <code>Boolean</code>  replace all default\n\t\t * caret placeholders (like <i>{%::emmet-caret::%}</i>) with <i>${0:caret}</i><br>\n\t\t * \n\t\t * <b>escape</b> : <code>Function</code>  function that handle escaped\n\t\t * characters (mostly '$'). By default, it returns the character itself \n\t\t * to be displayed as is in output, but sometimes you will use \n\t\t * <code>extract</code> method as intermediate solution for further \n\t\t * processing and want to keep character escaped. Thus, you should override\n\t\t * <code>escape</code> method to return escaped symbol (e.g. '\\\\$')<br>\n\t\t * \n\t\t * <b>tabstop</b> : <code>Function</code>  a tabstop handler. Receives \n\t\t * a single argument  an object describing token: its position, number \n\t\t * group, placeholder and token itself. Should return a replacement \n\t\t * string that will appear in final output\n\t\t * \n\t\t * <b>variable</b> : <code>Function</code>  variable handler. Receives \n\t\t * a single argument  an object describing token: its position, name \n\t\t * and original token itself. Should return a replacement \n\t\t * string that will appear in final output\n\t\t * \n\t\t * @returns {Object} Object with processed <code>text</code> property\n\t\t * and array of <code>tabstops</code> found\n\t\t * @memberOf tabStops\n\t\t */\n\t\textract: function(text, options) {\n\t\t\t// prepare defaults\n\t\t\tvar placeholders = {carets: ''};\n\t\t\tvar marks = [];\n\t\t\t\n\t\t\toptions = utils.extend({}, defaultOptions, options, {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar token = data.token;\n\t\t\t\t\tvar ret = '';\n\t\t\t\t\tif (data.placeholder == 'cursor') {\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: 'carets',\n\t\t\t\t\t\t\tvalue: ''\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unify placeholder value for single group\n\t\t\t\t\t\tif ('placeholder' in data)\n\t\t\t\t\t\t\tplaceholders[data.group] = data.placeholder;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (data.group in placeholders)\n\t\t\t\t\t\t\tret = placeholders[data.group];\n\t\t\t\t\t\t\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: data.group,\n\t\t\t\t\t\t\tvalue: ret\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn token;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tif (options.replaceCarets) {\n\t\t\t\ttext = text.replace(new RegExp( utils.escapeForRegexp( utils.getCaretPlaceholder() ), 'g'), '${0:cursor}');\n\t\t\t}\n\t\t\t\n\t\t\t// locate tabstops and unify group's placeholders\n\t\t\ttext = this.processText(text, options);\n\t\t\t\n\t\t\t// now, replace all tabstops with placeholders\n\t\t\tvar buf = '', lastIx = 0;\n\t\t\tvar tabStops = marks.map(function(mark) {\n\t\t\t\tbuf += text.substring(lastIx, mark.start);\n\t\t\t\t\n\t\t\t\tvar pos = buf.length;\n\t\t\t\tvar ph = placeholders[mark.group] || '';\n\t\t\t\t\n\t\t\t\tbuf += ph;\n\t\t\t\tlastIx = mark.end;\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tgroup: mark.group,\n\t\t\t\t\tstart: pos,\n\t\t\t\t\tend:  pos + ph.length\n\t\t\t\t};\n\t\t\t});\n\t\t\t\n\t\t\tbuf += text.substring(lastIx);\n\t\t\t\n\t\t\treturn {\n\t\t\t\ttext: buf,\n\t\t\t\ttabstops: tabStops.sort(function(a, b) {\n\t\t\t\t\treturn a.start - b.start;\n\t\t\t\t})\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Text processing routine. Locates escaped characters and tabstops and\n\t\t * replaces them with values returned by handlers defined in \n\t\t * <code>options</code>\n\t\t * @param {String} text\n\t\t * @param {Object} options See <code>extract</code> method options \n\t\t * description\n\t\t * @returns {String}\n\t\t */\n\t\tprocessText: function(text, options) {\n\t\t\toptions = utils.extend({}, defaultOptions, options);\n\t\t\t\n\t\t\tvar buf = '';\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = stringStream.create(text);\n\t\t\tvar ch, m, a;\n\t\t\t\n\t\t\twhile ((ch = stream.next())) {\n\t\t\t\tif (ch == '\\\\' && !stream.eol()) {\n\t\t\t\t\t// handle escaped character\n\t\t\t\t\tbuf += options.escape(stream.next());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ta = ch;\n\t\t\t\t\n\t\t\t\tif (ch == '$') {\n\t\t\t\t\t// looks like a tabstop\n\t\t\t\t\tstream.start = stream.pos - 1;\n\t\t\t\t\t\n\t\t\t\t\tif ((m = stream.match(/^[0-9]+/))) {\n\t\t\t\t\t\t// it's $N\n\t\t\t\t\t\ta = options.tabstop({\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tgroup: stream.current().substr(1),\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if ((m = stream.match(/^\\{([a-z_\\-][\\w\\-]*)\\}/))) {\n\t\t\t\t\t\t// ${variable}\n\t\t\t\t\t\ta = options.variable({\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tname: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if ((m = stream.match(/^\\{([0-9]+)(:.+?)?\\}/, false))) {\n\t\t\t\t\t\t// ${N:value} or ${N} placeholder\n\t\t\t\t\t\t// parse placeholder, including nested ones\n\t\t\t\t\t\tstream.skipToPair('{', '}');\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar obj = {\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tgroup: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar placeholder = obj.token.substring(obj.group.length + 2, obj.token.length - 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (placeholder) {\n\t\t\t\t\t\t\tobj.placeholder = placeholder.substr(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ta = options.tabstop(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbuf += a;\n\t\t\t}\n\t\t\t\n\t\t\treturn buf;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Upgrades tabstops in output node in order to prevent naming conflicts\n\t\t * @param {AbbreviationNode} node\n\t\t * @param {Number} offset Tab index offset\n\t\t * @returns {Number} Maximum tabstop index in element\n\t\t */\n\t\tupgrade: function(node, offset) {\n\t\t\tvar maxNum = 0;\n\t\t\tvar options = {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar group = parseInt(data.group, 10);\n\t\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\t\t\t\n\t\t\t\t\tif (data.placeholder)\n\t\t\t\t\t\treturn '${' + (group + offset) + ':' + data.placeholder + '}';\n\t\t\t\t\telse\n\t\t\t\t\t\treturn '${' + (group + offset) + '}';\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\t['start', 'end', 'content'].forEach(function(p) {\n\t\t\t\tnode[p] = this.processText(node[p], options);\n\t\t\t}, this);\n\t\t\t\n\t\t\treturn maxNum;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that produces a callback function for \n\t\t * <code>replaceVariables()</code> method from {@link utils}\n\t\t * module. This callback will replace variable definitions (like \n\t\t * ${var_name}) with their value defined in <i>resource</i> module,\n\t\t * or outputs tabstop with variable name otherwise.\n\t\t * @param {AbbreviationNode} node Context node\n\t\t * @returns {Function}\n\t\t */\n\t\tvariablesResolver: function(node) {\n\t\t\tvar placeholderMemo = {};\n\t\t\treturn function(str, varName) {\n\t\t\t\t// do not mark `child` variable as placeholder  its a reserved\n\t\t\t\t// variable name\n\t\t\t\tif (varName == 'child') {\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (varName == 'cursor') {\n\t\t\t\t\treturn utils.getCaretPlaceholder();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar attr = node.attribute(varName);\n\t\t\t\tif (typeof attr !== 'undefined' && attr !== str) {\n\t\t\t\t\treturn attr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar varValue = resources.getVariable(varName);\n\t\t\t\tif (varValue) {\n\t\t\t\t\treturn varValue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// output as placeholder\n\t\t\t\tif (!placeholderMemo[varName]) {\n\t\t\t\t\tplaceholderMemo[varName] = startPlaceholderNum++;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\treturn '${' + placeholderMemo[varName] + ':' + varName + '}';\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Replace variables like ${var} in string\n\t\t * @param {String} str\n\t\t * @param {Object} vars Variable set (defaults to variables defined in \n\t\t * <code>snippets.json</code>) or variable resolver (<code>Function</code>)\n\t\t * @return {String}\n\t\t */\n\t\treplaceVariables: function(str, vars) {\n\t\t\tvars = vars || {};\n\t\t\tvar resolver = typeof vars === 'function' ? vars : function(str, p1) {\n\t\t\t\treturn p1 in vars ? vars[p1] : null;\n\t\t\t};\n\t\t\t\n\t\t\treturn this.processText(str, {\n\t\t\t\tvariable: function(data) {\n\t\t\t\t\tvar newValue = resolver(data.token, data.name, data);\n\t\t\t\t\tif (newValue === null) {\n\t\t\t\t\t\t// try to find variable in resources\n\t\t\t\t\t\tnewValue = resources.getVariable(data.name);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (newValue === null || typeof newValue === 'undefined')\n\t\t\t\t\t\t// nothing found, return token itself\n\t\t\t\t\t\tnewValue = data.token;\n\t\t\t\t\treturn newValue;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Resets global tabstop index. When parsed tree is converted to output\n\t\t * string (<code>AbbreviationNode.toString()</code>), all tabstops \n\t\t * defined in snippets and elements are upgraded in order to prevent\n\t\t * naming conflicts of nested. For example, <code>${1}</code> of a node\n\t\t * should not be linked with the same placehilder of the child node.\n\t\t * By default, <code>AbbreviationNode.toString()</code> automatically\n\t\t * upgrades tabstops of the same index for each node and writes maximum\n\t\t * tabstop index into the <code>tabstopIndex</code> variable. To keep\n\t\t * this variable at reasonable value, it is recommended to call \n\t\t * <code>resetTabstopIndex()</code> method each time you expand variable \n\t\t * @returns\n\t\t */\n\t\tresetTabstopIndex: function() {\n\t\t\ttabstopIndex = 0;\n\t\t\tstartPlaceholderNum = 100;\n\t\t},\n\n\t\t/**\n\t\t * Output processor for abbreviation parser that will upgrade tabstops \n\t\t * of parsed node in order to prevent tabstop index conflicts\n\t\t */\n\t\tabbrOutputProcessor: function(text, node, type) {\n\t\t\tvar maxNum = 0;\n\t\t\tvar that = this;\n\t\t\t\n\t\t\tvar tsOptions = {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar group = parseInt(data.group, 10);\n\t\t\t\t\tif (group === 0)\n\t\t\t\t\t\treturn '${0}';\n\t\t\t\t\t\n\t\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\t\tif (data.placeholder) {\n\t\t\t\t\t\t// respect nested placeholders\n\t\t\t\t\t\tvar ix = group + tabstopIndex;\n\t\t\t\t\t\tvar placeholder = that.processText(data.placeholder, tsOptions);\n\t\t\t\t\t\treturn '${' + ix + ':' + placeholder + '}';\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn '${' + (group + tabstopIndex) + '}';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\t// upgrade tabstops\n\t\t\ttext = this.processText(text, tsOptions);\n\t\t\t\n\t\t\t// resolve variables\n\t\t\ttext = this.replaceVariables(text, this.variablesResolver(node));\n\t\t\t\n\t\t\ttabstopIndex += maxNum + 1;\n\t\t\treturn text;\n\t\t}\n\t};\n});\n},{\"../utils/common\":\"utils\\\\common.js\",\"./resources\":\"assets\\\\resources.js\",\"./stringStream\":\"assets\\\\stringStream.js\"}],\"assets\\\\tokenIterator.js\":[function(require,module,exports){\n/**\n * Helper class for convenient token iteration\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\t/**\n\t * @type TokenIterator\n\t * @param {Array} tokens\n\t * @type TokenIterator\n\t * @constructor\n\t */\n\tfunction TokenIterator(tokens) {\n\t\t/** @type Array */\n\t\tthis.tokens = tokens;\n\t\tthis._position = 0;\n\t\tthis.reset();\n\t}\n\t\n\tTokenIterator.prototype = {\n\t\tnext: function() {\n\t\t\tif (this.hasNext()) {\n\t\t\t\tvar token = this.tokens[++this._i];\n\t\t\t\tthis._position = token.start;\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\tthis._i = this._il;\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\tcurrent: function() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\n\t\tpeek: function() {\n\t\t\treturn this.tokens[this._i + i];\n\t\t},\n\t\t\n\t\tposition: function() {\n\t\t\treturn this._position;\n\t\t},\n\t\t\n\t\thasNext: function() {\n\t\t\treturn this._i < this._il - 1;\n\t\t},\n\t\t\n\t\treset: function() {\n\t\t\tthis._i = 0;\n\t\t\tthis._il = this.tokens.length;\n\t\t},\n\t\t\n\t\titem: function() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\t\t\n\t\titemNext: function() {\n\t\t\treturn this.tokens[this._i + 1];\n\t\t},\n\t\t\n\t\titemPrev: function() {\n\t\t\treturn this.tokens[this._i - 1];\n\t\t},\n\t\t\n\t\tnextUntil: function(type, callback) {\n\t\t\tvar token;\n\t\t\tvar test = typeof type == 'string' \n\t\t\t\t? function(t){return t.type == type;} \n\t\t\t\t: type;\n\t\t\t\n\t\t\twhile ((token = this.next())) {\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback.call(this, token);\n\t\t\t\tif (test.call(this, token))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\t\n\treturn {\n\t\tcreate: function(tokens) {\n\t\t\treturn new TokenIterator(tokens);\n\t\t}\n\t};\n});\n},{}],\"editTree\\\\base.js\":[function(require,module,exports){\n/**\n * Abstract implementation of edit tree interface.\n * Edit tree is a named container of editable name-value child elements, \n * parsed from <code>source</code>. This container provides convenient methods\n * for editing/adding/removing child elements. All these update actions are\n * instantly reflected in the <code>source</code> code with respect of formatting.\n * <br><br>\n * For example, developer can create an edit tree from CSS rule and add or \n * remove properties from itall changes will be immediately reflected in the \n * original source.\n * <br><br>\n * All classes defined in this module should be extended the same way as in\n * Backbone framework: using <code>extend</code> method to create new class and \n * <code>initialize</code> method to define custom class constructor.\n * \n * @example\n * <pre><code>\n * var MyClass = require('editTree/base').EditElement.extend({\n *     initialize: function() {\n *     // constructor code here\n *   }\n * });\n * \n * var elem = new MyClass(); \n * </code></pre>\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar range = require('../assets/range');\n\tvar utils = require('../utils/common');\n\tvar klass = require('../vendor/klass');\n\t\n\t/**\n\t * Named container of edited source\n\t * @type EditContainer\n\t * @param {String} source\n\t * @param {Object} options\n\t */\n\tfunction EditContainer(source, options) {\n\t\tthis.options = utils.extend({offset: 0}, options);\n\t\t/**\n\t\t * Source code of edited structure. All changes in the structure are \n\t\t * immediately reflected into this property\n\t\t */\n\t\tthis.source = source;\n\t\t\n\t\t/** \n\t\t * List of all editable children\n\t\t * @private \n\t\t */\n\t\tthis._children = [];\n\t\t\n\t\t/**\n\t\t * Hash of all positions of container\n\t\t * @private\n\t\t */\n\t\tthis._positions = {\n\t\t\tname: 0\n\t\t};\n\t\t\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * The self-propagating extend function for classes.\n\t * @type Function\n\t */\n\tEditContainer.extend = klass.extend;\n\t\n\tEditContainer.prototype = {\n\t\ttype: 'container',\n\t\t/**\n\t\t * Child class constructor\n\t\t */\n\t\tinitialize: function() {},\n\n\t\t/**\n\t\t * Make position absolute\n\t\t * @private\n\t\t * @param {Number} num\n\t\t * @param {Boolean} isAbsolute\n\t\t * @returns {Boolean}\n\t\t */\n\t\t_pos: function(num, isAbsolute) {\n\t\t\treturn num + (isAbsolute ? this.options.offset : 0);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replace substring of tag's source\n\t\t * @param {String} value\n\t\t * @param {Number} start\n\t\t * @param {Number} end\n\t\t * @private\n\t\t */\n\t\t_updateSource: function(value, start, end) {\n\t\t\t// create modification range\n\t\t\tvar r = range.create(start, typeof end === 'undefined' ? 0 : end - start);\n\t\t\tvar delta = value.length - r.length();\n\t\t\t\n\t\t\tvar update = function(obj) {\n\t\t\t\tObject.keys(obj).forEach(function(k) {\n\t\t\t\t\tif (obj[k] >= r.end) {\n\t\t\t\t\t\tobj[k] += delta;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\t// update affected positions of current container\n\t\t\tupdate(this._positions);\n\t\t\t\n\t\t\t// update affected positions of children\n\t\t\tvar recursiveUpdate = function(items) {\n\t\t\t\titems.forEach(function(item) {\n\t\t\t\t\tupdate(item._positions);\n\t\t\t\t\tif (item.type == 'container') {\n\t\t\t\t\t\trecursiveUpdate(item.list());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\trecursiveUpdate(this.list());\n\t\t\tthis.source = utils.replaceSubstring(this.source, value, r);\n\t\t},\n\t\t\t\n\t\t\t\n\t\t/**\n\t\t * Adds new attribute \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t * @returns {EditElement} Newly created element\n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\t// this is abstract implementation\n\t\t\tvar item = new EditElement(name, value);\n\t\t\tthis._children.push(item);\n\t\t\treturn item;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns attribute object\n\t\t * @param {String} name Attribute name or its index\n\t\t * @returns {EditElement}\n\t\t */\n\t\tget: function(name) {\n\t\t\tif (typeof name === 'number') {\n\t\t\t\treturn this.list()[name];\n\t\t\t}\n\t\t\t\n\t\t\tif (typeof name === 'string') {\n\t\t\t\treturn utils.find(this.list(), function(prop) {\n\t\t\t\t\treturn prop.name() === name;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all children by name or indexes\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\n\t\t * <code>Array</code>, <code>Number</code>)\n\t\t * @returns {Array}\n\t\t */\n\t\tgetAll: function(name) {\n\t\t\tif (!Array.isArray(name))\n\t\t\t\tname = [name];\n\t\t\t\n\t\t\t// split names and indexes\n\t\t\tvar names = [], indexes = [];\n\t\t\tname.forEach(function(item) {\n\t\t\t\tif (typeof item === 'string') {\n\t\t\t\t\tnames.push(item);\n\t\t\t\t} else if (typeof item === 'number') {\n\t\t\t\t\tindexes.push(item);\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\treturn this.list().filter(function(attribute, i) {\n\t\t\t\treturn ~indexes.indexOf(i) || ~names.indexOf(attribute.name());\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Returns list of all editable child elements\n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn this._children;\n\t\t},\n\n\t\t/**\n\t\t * Remove child element\n\t\t * @param {String} name Property name or its index\n\t\t */\n\t\tremove: function(name) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element) {\n\t\t\t\tthis._updateSource('', element.fullRange());\n\t\t\t\tvar ix = this._children.indexOf(element);\n\t\t\t\tif (~ix) {\n\t\t\t\t\tthis._children.splice(ix, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns index of editble child in list\n\t\t * @param {Object} item\n\t\t * @returns {Number}\n\t\t */\n\t\tindexOf: function(item) {\n\t\t\treturn this.list().indexOf(this.get(item));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns or updates element value. If such element doesn't exists,\n\t\t * it will be created automatically and added at the end of child list.\n\t\t * @param {String} name Element name or its index\n\t\t * @param {String} value New element value\n\t\t * @returns {String}\n\t\t */\n\t\tvalue: function(name, value, pos) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element)\n\t\t\t\treturn element.value(value);\n\t\t\t\n\t\t\tif (typeof value !== 'undefined') {\n\t\t\t\t// no such element  create it\n\t\t\t\treturn this.add(name, value, pos);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all values of child elements found by <code>getAll()</code>\n\t\t * method\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\n\t\t * <code>Array</code>, <code>Number</code>)\n\t\t * @returns {Array}\n\t\t */\n\t\tvalues: function(name) {\n\t\t\treturn this.getAll(name).map(function(element) {\n\t\t\t\treturn element.value();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets or gets container name\n\t\t * @param {String} val New name. If not passed, current \n\t\t * name is returned\n\t\t * @return {String}\n\t\t */\n\t\tname: function(val) {\n\t\t\tif (typeof val !== 'undefined' && this._name !== (val = String(val))) {\n\t\t\t\tthis._updateSource(val, this._positions.name, this._positions.name + this._name.length);\n\t\t\t\tthis._name = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns name range object\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of \n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tnameRange: function(isAbsolute) {\n\t\t\treturn range.create(this._positions.name + (isAbsolute ? this.options.offset : 0), this.name());\n\t\t},\n\n\t\t/**\n\t\t * Returns range of current source\n\t\t * @param {Boolean} isAbsolute\n\t\t */\n\t\trange: function(isAbsolute) {\n\t\t\treturn range.create(isAbsolute ? this.options.offset : 0, this.valueOf());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element that belongs to specified position\n\t\t * @param {Number} pos\n\t\t * @param {Boolean} isAbsolute\n\t\t * @returns {EditElement}\n\t\t */\n\t\titemFromPosition: function(pos, isAbsolute) {\n\t\t\treturn utils.find(this.list(), function(elem) {\n\t\t\t\treturn elem.range(isAbsolute).inside(pos);\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns source code of current container \n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.valueOf();\n\t\t},\n\n\t\tvalueOf: function() {\n\t\t\treturn this.source;\n\t\t}\n\t};\n\t\n\t/**\n\t * @param {EditContainer} parent\n\t * @param {Object} nameToken\n\t * @param {Object} valueToken\n\t */\n\tfunction EditElement(parent, nameToken, valueToken) {\n\t\t/** @type EditContainer */\n\t\tthis.parent = parent;\n\t\t\n\t\tthis._name = nameToken.value;\n\t\tthis._value = valueToken ? valueToken.value : '';\n\t\t\n\t\tthis._positions = {\n\t\t\tname: nameToken.start,\n\t\t\tvalue: valueToken ? valueToken.start : -1\n\t\t};\n\t\t\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * The self-propagating extend function for classes.\n\t * @type Function\n\t */\n\tEditElement.extend = klass.extend;\n\t\n\tEditElement.prototype = {\n\t\ttype: 'element',\n\n\t\t/**\n\t\t * Child class constructor\n\t\t */\n\t\tinitialize: function() {},\n\t\t\n\t\t/**\n\t\t * Make position absolute\n\t\t * @private\n\t\t * @param {Number} num\n\t\t * @param {Boolean} isAbsolute\n\t\t * @returns {Boolean}\n\t\t */\n\t\t_pos: function(num, isAbsolute) {\n\t\t\treturn num + (isAbsolute ? this.parent.options.offset : 0);\n\t\t},\n\t\t\t\n\t\t/**\n\t\t * Sets of gets element value\n\t\t * @param {String} val New element value. If not passed, current \n\t\t * value is returned\n\t\t * @returns {String}\n\t\t */\n\t\tvalue: function(val) {\n\t\t\tif (typeof val !== 'undefined' && this._value !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.valueRange());\n\t\t\t\tthis._value = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets of gets element name\n\t\t * @param {String} val New element name. If not passed, current \n\t\t * name is returned\n\t\t * @returns {String}\n\t\t */\n\t\tname: function(val) {\n\t\t\tif (typeof val !== 'undefined' && this._name !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.nameRange());\n\t\t\t\tthis._name = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns position of element name token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tnamePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.name, isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns position of element value token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tvaluePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.value, isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element name\n\t\t * @param {Boolean} isAbsolute Return absolute range \n\t\t * @returns {Range}\n\t\t */\n\t\trange: function(isAbsolute) {\n\t\t\treturn range.create(this.namePosition(isAbsolute), this.valueOf());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full element range, including possible indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\treturn this.range(isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element name range\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tnameRange: function(isAbsolute) {\n\t\t\treturn range.create(this.namePosition(isAbsolute), this.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element value range\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tvalueRange: function(isAbsolute) {\n\t\t\treturn range.create(this.valuePosition(isAbsolute), this.value());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns current element string representation\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.valueOf();\n\t\t},\n\t\t\n\t\tvalueOf: function() {\n\t\t\treturn this.name() + this.value();\n\t\t}\n\t};\n\t\n\treturn {\n\t\tEditContainer: EditContainer,\n\t\tEditElement: EditElement,\n\t\t\n\t\t/**\n\t\t * Creates token that can be fed to <code>EditElement</code>\n\t\t * @param {Number} start\n\t\t * @param {String} value\n\t\t * @param {String} type\n\t\t * @returns\n\t\t */\n\t\tcreateToken: function(start, value, type) {\n\t\t\tvar obj = {\n\t\t\t\tstart: start || 0,\n\t\t\t\tvalue: value || '',\n\t\t\t\ttype: type\n\t\t\t};\n\t\t\t\n\t\t\tobj.end = obj.start + obj.value.length;\n\t\t\treturn obj;\n\t\t}\n\t};\n});\n},{\"../assets/range\":\"assets\\\\range.js\",\"../utils/common\":\"utils\\\\common.js\",\"../vendor/klass\":\"vendor\\\\klass.js\"}],\"editTree\\\\css.js\":[function(require,module,exports){\n/**\n * CSS EditTree is a module that can parse a CSS rule into a tree with \n * convenient methods for adding, modifying and removing CSS properties. These \n * changes can be written back to string with respect of code formatting.\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar editTree = require('./base');\n\tvar cssParser = require('../parser/css');\n\tvar cssSections = require('../utils/cssSections');\n\tvar range = require('../assets/range');\n\tvar stringStream = require('../assets/stringStream');\n\tvar tokenIterator = require('../assets/tokenIterator');\n\n\tvar defaultOptions = {\n\t\tstyleBefore: '\\n\\t',\n\t\tstyleSeparator: ': ',\n\t\toffset: 0\n\t};\n\t\n\tvar reSpaceStart = /^\\s+/;\n\tvar reSpaceEnd = /\\s+$/;\n\tvar WHITESPACE_REMOVE_FROM_START = 1;\n\tvar WHITESPACE_REMOVE_FROM_END   = 2;\n\t\n\t/**\n\t * Modifies given range to remove whitespace from beginning\n\t * and/or from the end\n\t * @param  {Range} rng Range to modify\n\t * @param  {String} text  Text that range belongs to\n\t * @param  {Number} mask  Mask indicating from which end \n\t * whitespace should be removed\n\t * @return {Range}\n\t */\n\tfunction trimWhitespaceInRange(rng, text, mask) {\n\t\tmask = mask || (WHITESPACE_REMOVE_FROM_START | WHITESPACE_REMOVE_FROM_END);\n\t\ttext = rng.substring(text);\n\t\tvar m;\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_START) && (m = text.match(reSpaceStart))) {\n\t\t\trng.start += m[0].length;\n\t\t}\n\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_END) && (m = text.match(reSpaceEnd))) {\n\t\t\trng.end -= m[0].length;\n\t\t}\n\n\t\t// in case given range is just a whatespace\n\t\tif (rng.end < rng.start) {\n\t\t\trng.end = rng.start;\n\t\t}\n\n\t\treturn rng;\n\t}\n\n\t/**\n\t * Consumes CSS property and value from current token\n\t * iterator state. Offsets iterator pointer into token\n\t * that can be used for next value consmption\n\t * @param  {TokenIterator} it\n\t * @param  {String} text\n\t * @return {Object}    Object with `name` and `value` properties \n\t * ar ranges. Value range can be zero-length.\n\t */\n\tfunction consumeSingleProperty(it, text) {\n\t\tvar name, value, end;\n\t\tvar token = it.current();\n\n\t\tif (!token) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// skip whitespace\n\t\tvar ws = {'white': 1, 'line': 1, 'comment': 1};\n\t\twhile ((token = it.current())) {\n\t\t\tif (!(token.type in ws)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tit.next();\n\t\t}\n\n\t\tif (!it.hasNext()) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// consume property name\n\t\ttoken = it.current();\n\t\tname = range(token.start, token.value);\n\t\tvar isAtProperty = token.value.charAt(0) == '@';\n\t\twhile (token = it.next()) {\n\t\t\tname.end = token.end;\n\t\t\tif (token.type == ':' || token.type == 'white') {\n\t\t\t\tname.end = token.start;\n\t\t\t\tit.next();\n\t\t\t\tif (token.type == ':' || isAtProperty) {\n\t\t\t\t\t// XXX I really ashame of this hardcode, but I need\n\t\t\t\t\t// to stop parsing if this is an SCSS mixin call,\n\t\t\t\t\t// for example: @include border-radius(10px)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (token.type == ';' || token.type == 'line') {\n\t\t\t\t// theres no value, looks like a mixin\n\t\t\t\t// or a special use case:\n\t\t\t\t// user is writing a new property or abbreviation\n\t\t\t\tname.end = token.start;\n\t\t\t\tvalue = range(token.start, 0);\n\t\t\t\tit.next();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttoken = it.current();\n\t\tif (!value && token) {\n\t\t\tif (token.type == 'line') {\n\t\t\t\tlastNewline = token;\n\t\t\t}\n\t\t\t// consume value\n\t\t\tvalue = range(token.start, token.value);\n\t\t\tvar lastNewline;\n\t\t\twhile ((token = it.next())) {\n\t\t\t\tvalue.end = token.end;\n\t\t\t\tif (token.type == 'line') {\n\t\t\t\t\tlastNewline = token;\n\t\t\t\t} else if (token.type == '}' || token.type == ';') {\n\t\t\t\t\tvalue.end = token.start;\n\t\t\t\t\tif (token.type == ';') {\n\t\t\t\t\t\tend = range(token.start, token.value);\n\t\t\t\t\t}\n\t\t\t\t\tit.next();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (token.type == ':' && lastNewline) {\n\t\t\t\t\t// A special case: \n\t\t\t\t\t// user is writing a value before existing\n\t\t\t\t\t// property, but didnt inserted closing semi-colon.\n\t\t\t\t\t// In this case, limit value range to previous\n\t\t\t\t\t// newline\n\t\t\t\t\tvalue.end = lastNewline.start;\n\t\t\t\t\tit._i = it.tokens.indexOf(lastNewline);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!value) {\n\t\t\tvalue = range(name.end, 0);\n\t\t}\n\n\t\treturn {\n\t\t\tname: trimWhitespaceInRange(name, text),\n\t\t\tvalue: trimWhitespaceInRange(value, text, WHITESPACE_REMOVE_FROM_START | (end ? WHITESPACE_REMOVE_FROM_END : 0)),\n\t\t\tend: end || range(value.end, 0)\n\t\t};\n\t}\n\n\t/**\n\t * Finds parts of complex CSS value\n\t * @param {String} str\n\t * @returns {Array} Returns list of <code>Range</code>'s\n\t */\n\tfunction findParts(str) {\n\t\t/** @type StringStream */\n\t\tvar stream = stringStream.create(str);\n\t\tvar ch;\n\t\tvar result = [];\n\t\tvar sep = /[\\s\\u00a0,;]/;\n\t\t\n\t\tvar add = function() {\n\t\t\tstream.next();\n\t\t\tresult.push(range(stream.start, stream.current()));\n\t\t\tstream.start = stream.pos;\n\t\t};\n\t\t\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\t\t\n\t\twhile ((ch = stream.next())) {\n\t\t\tif (ch == '\"' || ch == \"'\") {\n\t\t\t\tstream.next();\n\t\t\t\tif (!stream.skipTo(ch)) break;\n\t\t\t\tadd();\n\t\t\t} else if (ch == '(') {\n\t\t\t\t// function found, may have nested function\n\t\t\t\tstream.backUp(1);\n\t\t\t\tif (!stream.skipToPair('(', ')')) break;\n\t\t\t\tstream.backUp(1);\n\t\t\t\tadd();\n\t\t\t} else {\n\t\t\t\tif (sep.test(ch)) {\n\t\t\t\t\tresult.push(range(stream.start, stream.current().length - 1));\n\t\t\t\t\tstream.eatWhile(sep);\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tadd();\n\n\t\treturn utils.unique(result.filter(function(item) {\n\t\t\treturn !!item.length();\n\t\t}));\n\t}\n\t\n\t/**\n\t * Parses CSS properties from given CSS source\n\t * and adds them to CSSEditContainer node\n\t * @param  {CSSEditContainer} node\n\t * @param  {String} source CSS source\n\t * @param {Number} offset Offset of properties subset from original source\n\t */\n\tfunction consumeProperties(node, source, offset) {\n\t\tvar list = extractPropertiesFromSource(source, offset);\n\n\t\tlist.forEach(function(property) {\n\t\t\tnode._children.push(new CSSEditElement(node,\n\t\t\t\teditTree.createToken(property.name.start, property.nameText),\n\t\t\t\teditTree.createToken(property.value.start, property.valueText),\n\t\t\t\teditTree.createToken(property.end.start, property.endText)\n\t\t\t\t));\n\t\t});\n\t}\n\n\t/**\n\t * Parses given CSS source and returns list of ranges of located CSS properties.\n\t * Normally, CSS source must contain properties only, it must be,\n\t * for example, a content of CSS selector or text between nested\n\t * CSS sections\n\t * @param  {String} source CSS source\n\t * @param {Number} offset Offset of properties subset from original source.\n\t * Used to provide proper ranges of locates items\n\t */\n\tfunction extractPropertiesFromSource(source, offset) {\n\t\toffset = offset || 0;\n\t\tsource = source.replace(reSpaceEnd, '');\n\t\tvar out = [];\n\n\t\tif (!source) {\n\t\t\treturn out;\n\t\t}\n\n\t\tvar tokens = cssParser.parse(source);\n\t\tvar it = tokenIterator.create(tokens);\n\t\tvar property;\n\n\t\twhile ((property = consumeSingleProperty(it, source))) {\n\t\t\tout.push({\n\t\t\t\tnameText: property.name.substring(source),\n\t\t\t\tname: property.name.shift(offset),\n\n\t\t\t\tvalueText: property.value.substring(source),\n\t\t\t\tvalue: property.value.shift(offset),\n\n\t\t\t\tendText: property.end.substring(source),\n\t\t\t\tend: property.end.shift(offset)\n\t\t\t});\n\t\t}\n\n\t\treturn out;\n\t}\n\t\n\t/**\n\t * @class\n\t * @extends EditContainer\n\t */\n\tvar CSSEditContainer = editTree.EditContainer.extend({\n\t\tinitialize: function(source, options) {\n\t\t\tutils.extend(this.options, defaultOptions, options);\n\t\t\t\n\t\t\tif (Array.isArray(source)) {\n\t\t\t\tsource = cssParser.toSource(source);\n\t\t\t}\n\n\t\t\tvar allRules = cssSections.findAllRules(source);\n\t\t\tvar currentRule = allRules.shift();\n\n\t\t\t// keep top-level rules only since they will\n\t\t\t// be parsed by nested CSSEditContainer call\n\t\t\tvar topLevelRules = [];\n\t\t\tallRules.forEach(function(r) {\n\t\t\t\tvar isTopLevel = !utils.find(topLevelRules, function(tr) {\n\t\t\t\t\treturn tr.contains(r);\n\t\t\t\t});\n\n\t\t\t\tif (isTopLevel) {\n\t\t\t\t\ttopLevelRules.push(r);\n\t\t\t\t}\n\t\t\t});\n\n\n\t\t\tvar selectorRange = range.create2(currentRule.start, currentRule._selectorEnd);\n\t\t\tthis._name = selectorRange.substring(source);\n\t\t\tthis._positions.name = selectorRange.start;\n\t\t\tthis._positions.contentStart = currentRule._contentStart + 1;\n\n\t\t\tvar sectionOffset = currentRule._contentStart + 1;\n\t\t\tvar sectionEnd = currentRule.end - 1;\n\n\t\t\t// parse properties between nested rules\n\t\t\t// and add nested rules as children\n\t\t\tvar that = this;\n\t\t\ttopLevelRules.forEach(function(r) {\n\t\t\t\tconsumeProperties(that, source.substring(sectionOffset, r.start), sectionOffset);\n\t\t\t\tvar opt = utils.extend({}, that.options, {offset: r.start + that.options.offset});\n\t\t\t\t// XXX I think I dont need nested containers here\n\t\t\t\t// They should be handled separately\n\t\t\t\t// that._children.push(new CSSEditContainer(r.substring(source), opt));\n\t\t\t\tsectionOffset = r.end;\n\t\t\t});\n\n\t\t\t// consume the rest of data\n\t\t\tconsumeProperties(this, source.substring(sectionOffset, currentRule.end - 1), sectionOffset);\n\t\t\tthis._saveStyle();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remembers all styles of properties\n\t\t * @private\n\t\t */\n\t\t_saveStyle: function() {\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar source = this.source;\n\t\t\t\n\t\t\tthis.list().forEach(function(p) {\n\t\t\t\tif (p.type === 'container') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\t\t\t\t// a small hack here:\n\t\t\t\t// Sometimes users add empty lines before properties to logically\n\t\t\t\t// separate groups of properties. In this case, a blind copy of\n\t\t\t\t// characters between rules may lead to undesired behavior,\n\t\t\t\t// especially when current rule is duplicated or used as a donor\n\t\t\t\t// to create new rule.\n\t\t\t\t// To solve this issue, well take only last newline indentation\n\t\t\t\tvar lines = utils.splitByLines(p.styleBefore);\n\t\t\t\tif (lines.length > 1) {\n\t\t\t\t\tp.styleBefore = '\\n' + lines[lines.length - 1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp.styleSeparator = source.substring(p.nameRange().end, p.valuePosition());\n\t\t\t\t\n\t\t\t\t// graceful and naive comments removal \n\t\t\t\tvar parts = p.styleBefore.split('*/');\n\t\t\t\tp.styleBefore = parts[parts.length - 1];\n\t\t\t\tp.styleSeparator = p.styleSeparator.replace(/\\/\\*.*?\\*\\//g, '');\n\t\t\t\t\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Returns position of element name token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tnamePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.name, isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns position of element value token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tvaluePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.contentStart, isAbsolute);\n\t\t},\n\n\t\t/**\n\t\t * Returns element value range\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tvalueRange: function(isAbsolute) {\n\t\t\treturn range.create2(this.valuePosition(isAbsolute), this._pos(this.valueOf().length, isAbsolute) - 1);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new CSS property \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t * @returns {CSSEditProperty}\n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar styles = utils.pick(this.options, 'styleBefore', 'styleSeparator');\n\t\t\t\n\t\t\tif (typeof pos === 'undefined') {\n\t\t\t\tpos = list.length;\n\t\t\t}\n\t\t\t\n\t\t\t/** @type CSSEditProperty */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if ((donor = list[pos - 1])) {\n\t\t\t\t// make sure that donor has terminating semicolon\n\t\t\t\tdonor.end(';');\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\t\t\t\n\t\t\tif (donor) {\n\t\t\t\tstyles = utils.pick(donor, 'styleBefore', 'styleSeparator');\n\t\t\t}\n\t\t\t\n\t\t\tvar nameToken = editTree.createToken(start + styles.styleBefore.length, name);\n\t\t\tvar valueToken = editTree.createToken(nameToken.end + styles.styleSeparator.length, value);\n\t\t\t\n\t\t\tvar property = new CSSEditElement(this, nameToken, valueToken,\n\t\t\t\t\teditTree.createToken(valueToken.end, ';'));\n\t\t\t\n\t\t\tutils.extend(property, styles);\n\t\t\t\n\t\t\t// write new property into the source\n\t\t\tthis._updateSource(property.styleBefore + property.toString(), start);\n\t\t\t\n\t\t\t// insert new property\n\t\t\tthis._children.splice(pos, 0, property);\n\t\t\treturn property;\n\t\t}\n\t});\n\t\n\t/**\n\t * @class\n\t * @type CSSEditElement\n\t * @constructor\n\t */\n\tvar CSSEditElement = editTree.EditElement.extend({\n\t\tinitialize: function(rule, name, value, end) {\n\t\t\tthis.styleBefore = rule.options.styleBefore;\n\t\t\tthis.styleSeparator = rule.options.styleSeparator;\n\t\t\t\n\t\t\tthis._end = end.value;\n\t\t\tthis._positions.end = end.start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ranges of complex value parts\n\t\t * @returns {Array} Returns <code>null</code> if value is not complex\n\t\t */\n\t\tvalueParts: function(isAbsolute) {\n\t\t\tvar parts = findParts(this.value());\n\t\t\tif (isAbsolute) {\n\t\t\t\tvar offset = this.valuePosition(true);\n\t\t\t\tparts.forEach(function(p) {\n\t\t\t\t\tp.shift(offset);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn parts;\n\t\t},\n\n\t\t/**\n\t\t * Sets of gets element value. \n\t\t * When setting value, this implementation will ensure that your have \n\t\t * proper name-value separator\n\t\t * @param {String} val New element value. If not passed, current \n\t\t * value is returned\n\t\t * @returns {String}\n\t\t */\n\t\tvalue: function(val) {\n\t\t\tvar isUpdating = typeof val !== 'undefined';\n\t\t\tvar allItems = this.parent.list();\n\t\t\tif (isUpdating && this.isIncomplete()) {\n\t\t\t\tvar self = this;\n\t\t\t\tvar donor = utils.find(allItems, function(item) {\n\t\t\t\t\treturn item !== self && !item.isIncomplete();\n\t\t\t\t});\n\n\t\t\t\tthis.styleSeparator = donor \n\t\t\t\t\t? donor.styleSeparator \n\t\t\t\t\t: this.parent.options.styleSeparator;\n\t\t\t\tthis.parent._updateSource(this.styleSeparator, range(this.valueRange().start, 0));\n\t\t\t}\n\n\t\t\tvar value = this.constructor.__super__.value.apply(this, arguments);\n\t\t\tif (isUpdating) {\n\t\t\t\t// make sure current property has terminating semi-colon\n\t\t\t\t// if its not the last one\n\t\t\t\tvar ix = allItems.indexOf(this);\n\t\t\t\tif (ix !== allItems.length - 1 && !this.end()) {\n\t\t\t\t\tthis.end(';');\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\t\t/**\n\t\t * Test if current element is incomplete, e.g. has no explicit\n\t\t * name-value separator\n\t\t * @return {Boolean} [description]\n\t\t */\n\t\tisIncomplete: function() {\n\t\t\treturn this.nameRange().end === this.valueRange().start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets of gets property end value (basically, it's a semicolon)\n\t\t * @param {String} val New end value. If not passed, current \n\t\t * value is returned\n\t\t */\n\t\tend: function(val) {\n\t\t\tif (typeof val !== 'undefined' && this._end !== val) {\n\t\t\t\tthis.parent._updateSource(val, this._positions.end, this._positions.end + this._end.length);\n\t\t\t\tthis._end = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full rule range, with indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns item string representation\n\t\t * @returns {String}\n\t\t */\n\t\tvalueOf: function() {\n\t\t\treturn this.name() + this.styleSeparator + this.value() + this.end();\n\t\t}\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses CSS rule into editable tree\n\t\t * @param {String} source\n\t\t * @param {Object} options\n\t\t * @memberOf emmet.cssEditTree\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparse: function(source, options) {\n\t\t\treturn new CSSEditContainer(source, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract and parse CSS rule from specified position in <code>content</code> \n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparseFromPosition: function(content, pos, isBackward) {\n\t\t\tvar bounds = cssSections.locateRule(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos)) {\n\t\t\t\t// no matching CSS rule or caret outside rule bounds\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Locates CSS property in given CSS code fragment under specified character position\n\t\t * @param  {String} css CSS code or parsed CSSEditContainer\n\t\t * @param  {Number} pos Character position where to search CSS property\n\t\t * @return {CSSEditElement}\n\t\t */\n\t\tpropertyFromPosition: function(css, pos) {\n\t\t\tvar cssProp = null;\n\t\t\t/** @type EditContainer */\n\t\t\tvar cssRule = typeof css === 'string' ? this.parseFromPosition(css, pos, true) : css;\n\t\t\tif (cssRule) {\n\t\t\t\tcssProp = cssRule.itemFromPosition(pos, true);\n\t\t\t\tif (!cssProp) {\n\t\t\t\t\t// in case user just started writing CSS property\n\t\t\t\t\t// and didn't include semicolontry another approach\n\t\t\t\t\tcssProp = utils.find(cssRule.list(), function(elem) {\n\t\t\t\t\t\treturn elem.range(true).end == pos;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn cssProp;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes vendor prefix from CSS property\n\t\t * @param {String} name CSS property\n\t\t * @return {String}\n\t\t */\n\t\tbaseName: function(name) {\n\t\t\treturn name.replace(/^\\s*\\-\\w+\\-/, '');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds parts of complex CSS value\n\t\t * @param {String} str\n\t\t * @returns {Array}\n\t\t */\n\t\tfindParts: findParts,\n\n\t\textractPropertiesFromSource: extractPropertiesFromSource\n\t};\n});\n},{\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../assets/tokenIterator\":\"assets\\\\tokenIterator.js\",\"../parser/css\":\"parser\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/cssSections\":\"utils\\\\cssSections.js\",\"./base\":\"editTree\\\\base.js\"}],\"editTree\\\\xml.js\":[function(require,module,exports){\n/**\n * XML EditTree is a module that can parse an XML/HTML element into a tree with \n * convenient methods for adding, modifying and removing attributes. These \n * changes can be written back to string with respect of code formatting.\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar editTree = require('./base');\n\tvar xmlParser = require('../parser/xml');\n\tvar range = require('../assets/range');\n\tvar utils = require('../utils/common');\n\n\tvar defaultOptions = {\n\t\tstyleBefore: ' ',\n\t\tstyleSeparator: '=',\n\t\tstyleQuote: '\"',\n\t\toffset: 0\n\t};\n\t\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/m;\n\t\n\tvar XMLEditContainer = editTree.EditContainer.extend({\n\t\tinitialize: function(source, options) {\n\t\t\tutils.defaults(this.options, defaultOptions);\n\t\t\tthis._positions.name = 1;\n\t\t\t\n\t\t\tvar attrToken = null;\n\t\t\tvar tokens = xmlParser.parse(source);\n\t\t\t\n\t\t\ttokens.forEach(function(token) {\n\t\t\t\ttoken.value = range.create(token).substring(source);\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'tag':\n\t\t\t\t\t\tif (/^<[^\\/]+/.test(token.value)) {\n\t\t\t\t\t\t\tthis._name = token.value.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 'attribute':\n\t\t\t\t\t\t// add empty attribute\n\t\t\t\t\t\tif (attrToken) {\n\t\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tattrToken = token;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken, token));\n\t\t\t\t\t\tattrToken = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\tif (attrToken) {\n\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t}\n\t\t\t\n\t\t\tthis._saveStyle();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remembers all styles of properties\n\t\t * @private\n\t\t */\n\t\t_saveStyle: function() {\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar source = this.source;\n\t\t\t\n\t\t\tthis.list().forEach(function(p) {\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\t\t\t\t\n\t\t\t\tif (p.valuePosition() !== -1) {\n\t\t\t\t\tp.styleSeparator = source.substring(p.namePosition() + p.name().length, p.valuePosition() - p.styleQuote.length);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new attribute \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar styles = utils.pick(this.options, 'styleBefore', 'styleSeparator', 'styleQuote');\n\t\t\t\n\t\t\tif (typeof pos === 'undefined') {\n\t\t\t\tpos = list.length;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t/** @type XMLEditAttribute */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if ((donor = list[pos - 1])) {\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\t\t\t\n\t\t\tif (donor) {\n\t\t\t\tstyles = utils.pick(donor, 'styleBefore', 'styleSeparator', 'styleQuote');\n\t\t\t}\n\t\t\t\n\t\t\tvalue = styles.styleQuote + value + styles.styleQuote;\n\t\t\t\n\t\t\tvar attribute = new XMLEditElement(this, \n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length, name),\n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length + name.length \n\t\t\t\t\t\t\t+ styles.styleSeparator.length, value)\n\t\t\t\t\t);\n\t\t\t\n\t\t\tutils.extend(attribute, styles);\n\t\t\t\n\t\t\t// write new attribute into the source\n\t\t\tthis._updateSource(attribute.styleBefore + attribute.toString(), start);\n\t\t\t\n\t\t\t// insert new attribute\n\t\t\tthis._children.splice(pos, 0, attribute);\n\t\t\treturn attribute;\n\t\t},\n\n\t\t/**\n\t\t * A special case of attribute editing: adds class value to existing\n\t\t * `class` attribute\n\t\t * @param {String} value\n\t\t */\n\t\taddClass: function(value) {\n\t\t\tvar attr = this.get('class');\n\t\t\tvalue = utils.trim(value);\n\t\t\tif (!attr) {\n\t\t\t\treturn this.add('class', value);\n\t\t\t}\n\n\t\t\tvar classVal = attr.value();\n\t\t\tvar classList = ' ' + classVal.replace(/\\n/g, ' ') + ' ';\n\t\t\tif (!~classList.indexOf(' ' + value + ' ')) {\n\t\t\t\tattr.value(classVal + ' ' + value);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * A special case of attribute editing: removes class value from existing\n\t\t * `class` attribute\n\t\t * @param {String} value\n\t\t */\n\t\tremoveClass: function(value) {\n\t\t\tvar attr = this.get('class');\n\t\t\tvalue = utils.trim(value);\n\t\t\tif (!attr) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar reClass = new RegExp('(^|\\\\s+)' + utils.escapeForRegexp(value));\n\t\t\tvar classVal = attr.value().replace(reClass, '');\n\t\t\tif (!utils.trim(classVal)) {\n\t\t\t\tthis.remove('class');\n\t\t\t} else {\n\t\t\t\tattr.value(classVal);\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar XMLEditElement = editTree.EditElement.extend({\n\t\tinitialize: function(parent, nameToken, valueToken) {\n\t\t\tthis.styleBefore = parent.options.styleBefore;\n\t\t\tthis.styleSeparator = parent.options.styleSeparator;\n\t\t\t\n\t\t\tvar value = '', quote = parent.options.styleQuote;\n\t\t\tif (valueToken) {\n\t\t\t\tvalue = valueToken.value;\n\t\t\t\tquote = value.charAt(0);\n\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\tvalue = value.substring(1);\n\t\t\t\t} else {\n\t\t\t\t\tquote = '';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (quote && value.charAt(value.length - 1) == quote) {\n\t\t\t\t\tvalue = value.substring(0, value.length - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.styleQuote = quote;\n\t\t\t\n\t\t\tthis._value = value;\n\t\t\tthis._positions.value = valueToken ? valueToken.start + quote.length : -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full rule range, with indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\t\t\n\t\tvalueOf: function() {\n\t\t\treturn this.name() + this.styleSeparator\n\t\t\t\t+ this.styleQuote + this.value() + this.styleQuote;\n\t\t}\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses HTML element into editable tree\n\t\t * @param {String} source\n\t\t * @param {Object} options\n\t\t * @memberOf emmet.htmlEditTree\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparse: function(source, options) {\n\t\t\treturn new XMLEditContainer(source, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract and parse HTML from specified position in <code>content</code> \n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {XMLEditElement}\n\t\t */\n\t\tparseFromPosition: function(content, pos, isBackward) {\n\t\t\tvar bounds = this.extractTag(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos))\n\t\t\t\t// no matching HTML tag or caret outside tag bounds\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts nearest HTML tag range from <code>content</code>, starting at \n\t\t * <code>pos</code> position\n\t\t * @param {String} content\n\t\t * @param {Number} pos\n\t\t * @param {Boolean} isBackward\n\t\t * @returns {Range}\n\t\t */\n\t\textractTag: function(content, pos, isBackward) {\n\t\t\tvar len = content.length, i;\n\t\t\t\n\t\t\t// max extraction length. I don't think there may be tags larger \n\t\t\t// than 2000 characters length\n\t\t\tvar maxLen = Math.min(2000, len);\n\t\t\t\n\t\t\t/** @type Range */\n\t\t\tvar r = null;\n\t\t\t\n\t\t\tvar match = function(pos) {\n\t\t\t\tvar m;\n\t\t\t\tif (content.charAt(pos) == '<' && (m = content.substr(pos, maxLen).match(startTag)))\n\t\t\t\t\treturn range.create(pos, m[0]);\n\t\t\t};\n\t\t\t\n\t\t\t// lookup backward, in case we are inside tag already\n\t\t\tfor (i = pos; i >= 0; i--) {\n\t\t\t\tif ((r = match(i))) break;\n\t\t\t}\n\t\t\t\n\t\t\tif (r && (r.inside(pos) || isBackward))\n\t\t\t\treturn r;\n\t\t\t\n\t\t\tif (!r && isBackward)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\t// search forward\n\t\t\tfor (i = pos; i < len; i++) {\n\t\t\t\tif ((r = match(i)))\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t};\n});\n},{\"../assets/range\":\"assets\\\\range.js\",\"../parser/xml\":\"parser\\\\xml.js\",\"../utils/common\":\"utils\\\\common.js\",\"./base\":\"editTree\\\\base.js\"}],\"filter\\\\bem.js\":[function(require,module,exports){\n/**\n * Filter for aiding of writing elements with complex class names as described\n * in Yandex's BEM (Block, Element, Modifier) methodology. This filter will\n * automatically inherit block and element names from parent elements and insert\n * them into child element classes\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar htmlFilter = require('./html');\n\tvar prefs = require('../assets/preferences');\n\tvar abbreviationUtils = require('../utils/abbreviation');\n\tvar utils = require('../utils/common');\n\n\tprefs.define('bem.elementSeparator', '__', 'Class names element separator.');\n\tprefs.define('bem.modifierSeparator', '_', 'Class names modifier separator.');\n\tprefs.define('bem.shortElementPrefix', '-', \n\t\t\t'Symbol for describing short block-element notation. Class names '\n\t\t\t+ 'prefixed with this symbol will be treated as element name for parents '\n\t\t\t+ 'block name. Each symbol instance traverses one level up in parsed ' \n\t\t\t+ 'tree for block name lookup. Empty value will disable short notation.');\n\t\n\tvar shouldRunHtmlFilter = false;\n\t\n\tfunction getSeparators() {\n\t\treturn {\n\t\t\telement: prefs.get('bem.elementSeparator'),\n\t\t\tmodifier: prefs.get('bem.modifierSeparator')\n\t\t};\n\t}\n\n\t/**\n\t * @param {AbbreviationNode} item\n\t */\n\tfunction bemParse(item) {\n\t\tif (abbreviationUtils.isSnippet(item))\n\t\t\treturn item;\n\t\t\n\t\t// save BEM stuff in cache for faster lookups\n\t\titem.__bem = {\n\t\t\tblock: '',\n\t\t\telement: '',\n\t\t\tmodifier: ''\n\t\t};\n\t\t\n\t\tvar classNames = normalizeClassName(item.attribute('class')).split(' ');\n\t\t\n\t\t// guess best match for block name\n\t\tvar reBlockName = /^[a-z]\\-/i;\n\t\titem.__bem.block = utils.find(classNames, function(name) {\n\t\t\treturn reBlockName.test(name);\n\t\t});\n\t\t\n\t\t// guessing doesn't worked, pick first class name as block name\n\t\tif (!item.__bem.block) {\n\t\t\treBlockName = /^[a-z]/i;\n\t\t\titem.__bem.block = utils.find(classNames, function(name) {\n\t\t\t\treturn reBlockName.test(name);\n\t\t\t}) || '';\n\t\t}\n\n\t\tclassNames = classNames.map(function(name) {\n\t\t\treturn processClassName(name, item);\n\t\t});\n\n\t\tclassNames = utils.unique(utils.flatten(classNames)).join(' ');\n\t\tif (classNames) {\n\t\t\titem.attribute('class', classNames);\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * @param {String} className\n\t * @returns {String}\n\t */\n\tfunction normalizeClassName(className) {\n\t\tclassName = (' ' + (className || '') + ' ').replace(/\\s+/g, ' ');\n\t\t\n\t\tvar shortSymbol = prefs.get('bem.shortElementPrefix');\n\t\tif (shortSymbol) {\n\t\t\tvar re = new RegExp('\\\\s(' + utils.escapeForRegexp(shortSymbol) + '+)', 'g');\n\t\t\tclassName = className.replace(re, function(str, p1) {\n\t\t\t\treturn ' ' + utils.repeatString(getSeparators().element, p1.length);\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn utils.trim(className);\n\t}\n\t\n\t/**\n\t * Processes class name\n\t * @param {String} name Class name item to process\n\t * @param {AbbreviationNode} item Host node for provided class name\n\t * @returns Processed class name. May return <code>Array</code> of\n\t * class names \n\t */\n\tfunction processClassName(name, item) {\n\t\tname = transformClassName(name, item, 'element');\n\t\tname = transformClassName(name, item, 'modifier');\n\t\t\n\t\t// expand class name\n\t\t// possible values:\n\t\t// * block__element\n\t\t// * block__element_modifier\n\t\t// * block__element_modifier1_modifier2\n\t\t// * block_modifier\n\t\tvar block = '', element = '', modifier = '';\n\t\tvar separators = getSeparators();\n\t\tif (~name.indexOf(separators.element)) {\n\t\t\tvar elements = name.split(separators.element);\n\t\t\tblock = elements.shift();\n\n\t\t\tvar modifiers = elements.pop().split(separators.modifier);\n\t\t\telements.push(modifiers.shift());\n\t\t\telement = elements.join(separators.element);\n\t\t\tmodifier = modifiers.join(separators.modifier);\n\t\t} else if (~name.indexOf(separators.modifier)) {\n\t\t\tvar blockModifiers = name.split(separators.modifier);\n\t\t\t\n\t\t\tblock = blockModifiers.shift();\n\t\t\tmodifier = blockModifiers.join(separators.modifier);\n\t\t}\n\t\t\n\t\tif (block || element || modifier) {\n\t\t\tif (!block) {\n\t\t\t\tblock = item.__bem.block;\n\t\t\t}\n\t\t\t\n\t\t\t// inherit parent bem element, if exists\n//\t\t\tif (item.parent && item.parent.__bem && item.parent.__bem.element)\n//\t\t\t\telement = item.parent.__bem.element + separators.element + element;\n\t\t\t\n\t\t\t// produce multiple classes\n\t\t\tvar prefix = block;\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tif (element) {\n\t\t\t\tprefix += separators.element + element;\n\t\t\t\tresult.push(prefix);\n\t\t\t} else {\n\t\t\t\tresult.push(prefix);\n\t\t\t}\n\t\t\t\n\t\t\tif (modifier) {\n\t\t\t\tresult.push(prefix + separators.modifier + modifier);\n\t\t\t}\n\t\t\t\n\t\t\tif (!item.__bem.block || modifier) {\n\t\t\t\titem.__bem.block = block;\n\t\t\t}\n\t\t\t\n\t\t\titem.__bem.element = element;\n\t\t\titem.__bem.modifier = modifier;\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\t// ...otherwise, return processed or original class name\n\t\treturn name;\n\t}\n\t\n\t/**\n\t * Low-level function to transform user-typed class name into full BEM class\n\t * @param {String} name Class name item to process\n\t * @param {AbbreviationNode} item Host node for provided class name\n\t * @param {String} entityType Type of entity to be tried to transform \n\t * ('element' or 'modifier')\n\t * @returns {String} Processed class name or original one if it can't be\n\t * transformed\n\t */\n\tfunction transformClassName(name, item, entityType) {\n\t\tvar separators = getSeparators();\n\t\tvar reSep = new RegExp('^(' + separators[entityType] + ')+', 'g');\n\t\tif (reSep.test(name)) {\n\t\t\tvar depth = 0; // parent lookup depth\n\t\t\tvar cleanName = name.replace(reSep, function(str) {\n\t\t\t\tdepth = str.length / separators[entityType].length;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\t// find donor element\n\t\t\tvar donor = item;\n\t\t\twhile (donor.parent && depth--) {\n\t\t\t\tdonor = donor.parent;\n\t\t\t}\n\t\t\t\n\t\t\tif (!donor || !donor.__bem)\n\t\t\t\tdonor = item;\n\t\t\t\n\t\t\tif (donor && donor.__bem) {\n\t\t\t\tvar prefix = donor.__bem.block;\n\t\t\t\t\n\t\t\t\t// decide if we should inherit element name\n//\t\t\t\tif (entityType == 'element') {\n//\t\t\t\t\tvar curElem = cleanName.split(separators.modifier, 1)[0];\n//\t\t\t\t\tif (donor.__bem.element && donor.__bem.element != curElem)\n//\t\t\t\t\t\tprefix += separators.element + donor.__bem.element;\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (entityType == 'modifier' &&  donor.__bem.element)\n\t\t\t\t\tprefix += separators.element + donor.__bem.element;\n\t\t\t\t\n\t\t\t\treturn prefix + separators[entityType] + cleanName;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn name;\n\t}\n\t\n\t/**\n\t * Recursive function for processing tags, which extends class names \n\t * according to BEM specs: http://bem.github.com/bem-method/pages/beginning/beginning.ru.html\n\t * <br><br>\n\t * It does several things:<br>\n\t * <ul>\n\t * <li>Expands complex class name (according to BEM symbol semantics):\n\t * .block__elem_modifier  .block.block__elem.block__elem_modifier\n\t * </li>\n\t * <li>Inherits block name on child elements: \n\t * .b-block > .__el > .__el  .b-block > .b-block__el > .b-block__el__el\n\t * </li>\n\t * <li>Treats first dash symbol as '__'</li>\n\t * <li>Double underscore (or typographic '') is also treated as an element \n\t * level lookup, e.g. ____el will search for element definition in parents \n\t * parent element:\n\t * .b-block > .__el1 > .____el2  .b-block > .b-block__el1 > .b-block__el2\n\t * </li>\n\t * </ul>\n\t * \n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t */\n\tfunction process(tree, profile) {\n\t\tif (tree.name) {\n\t\t\tbemParse(tree, profile);\n\t\t}\n\t\t\n\t\ttree.children.forEach(function(item) {\n\t\t\tprocess(item, profile);\n\t\t\tif (!abbreviationUtils.isSnippet(item) && item.start) {\n\t\t\t\tshouldRunHtmlFilter = true;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn tree;\n\t}\n\n\treturn function(tree, profile) {\n\t\tshouldRunHtmlFilter = false;\n\t\ttree = process(tree, profile);\n\t\t// in case 'bem' filter is applied after 'html' filter: run it again\n\t\t// to update output\n\t\tif (shouldRunHtmlFilter) {\n\t\t\ttree = htmlFilter(tree, profile);\n\t\t}\n\t\t\n\t\treturn tree;\n\t};\n});\n\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./html\":\"filter\\\\html.js\"}],\"filter\\\\comment.js\":[function(require,module,exports){\n/**\n * Comment important tags (with 'id' and 'class' attributes)\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar prefs = require('../assets/preferences');\n\tvar utils = require('../utils/common');\n\tvar template = require('../utils/template');\n\tvar abbrUtils = require('../utils/abbreviation');\n\tvar filterCore = require('./main');\n\t\n\tprefs.define('filter.commentAfter', \n\t\t\t'\\n<!-- /<%= attr(\"id\", \"#\") %><%= attr(\"class\", \".\") %> -->',\n\t\t\t'A definition of comment that should be placed <i>after</i> matched '\n\t\t\t+ 'element when <code>comment</code> filter is applied. This definition '\n\t\t\t+ 'is an ERB-style template passed to <code>_.template()</code> '\n\t\t\t+ 'function (see Underscore.js docs for details). In template context, '\n\t\t\t+ 'the following properties and functions are availabe:\\n'\n\t\t\t+ '<ul>'\n\t\t\t\n\t\t\t+ '<li><code>attr(name, before, after)</code>  a function that outputs' \n\t\t\t+ 'specified attribute value concatenated with <code>before</code> ' \n\t\t\t+ 'and <code>after</code> strings. If attribute doesn\\'t exists, the ' \n\t\t\t+ 'empty string will be returned.</li>'\n\t\t\t\n\t\t\t+ '<li><code>node</code>  current node (instance of <code>AbbreviationNode</code>)</li>'\n\t\t\t\n\t\t\t+ '<li><code>name</code>  name of current tag</li>'\n\t\t\t\n\t\t\t+ '<li><code>padding</code>  current string padding, can be used ' \n\t\t\t+ 'for formatting</li>'\n\t\t\t\n\t\t\t+'</ul>');\n\t\n\tprefs.define('filter.commentBefore', \n\t\t\t'',\n\t\t\t'A definition of comment that should be placed <i>before</i> matched '\n\t\t\t+ 'element when <code>comment</code> filter is applied. '\n\t\t\t+ 'For more info, read description of <code>filter.commentAfter</code> '\n\t\t\t+ 'property');\n\t\n\tprefs.define('filter.commentTrigger', 'id, class',\n\t\t\t'A comma-separated list of attribute names that should exist in abbreviatoin '\n\t\t\t+ 'where comment should be added. If you wish to add comment for '\n\t\t\t+ 'every element, set this option to <code>*</code>');\n\t\n\t/**\n\t * Add comments to tag\n\t * @param {AbbreviationNode} node\n\t */\n\tfunction addComments(node, templateBefore, templateAfter) {\n\t\t// check if comments should be added\n\t\tvar trigger = prefs.get('filter.commentTrigger');\n\t\tif (trigger != '*') {\n\t\t\tvar shouldAdd = utils.find(trigger.split(','), function(name) {\n\t\t\t\treturn !!node.attribute(utils.trim(name));\n\t\t\t});\n\n\t\t\tif (!shouldAdd) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar ctx = {\n\t\t\tnode: node,\n\t\t\tname: node.name(),\n\t\t\tpadding: node.parent ? node.parent.padding : '',\n\t\t\tattr: function(name, before, after) {\n\t\t\t\tvar attr = node.attribute(name);\n\t\t\t\tif (attr) {\n\t\t\t\t\treturn (before || '') + attr + (after || '');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn '';\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar nodeBefore = templateBefore ? templateBefore(ctx) : '';\n\t\tvar nodeAfter = templateAfter ? templateAfter(ctx) : '';\n\t\t\n\t\tnode.start = node.start.replace(/</, nodeBefore + '<');\n\t\tnode.end = node.end.replace(/>/, '>' + nodeAfter);\n\t}\n\t\n\tfunction process(tree, before, after) {\n\t\ttree.children.forEach(function(item) {\n\t\t\tif (abbrUtils.isBlock(item)) {\n\t\t\t\taddComments(item, before, after);\n\t\t\t}\n\t\t\t\n\t\t\tprocess(item, before, after);\n\t\t});\n\t\t\t\n\t\treturn tree;\n\t}\n\n\treturn function(tree) {\n\t\tvar templateBefore = template(prefs.get('filter.commentBefore'));\n\t\tvar templateAfter = template(prefs.get('filter.commentAfter'));\n\t\t\n\t\treturn process(tree, templateBefore, templateAfter);\n\t};\n});\n\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/template\":\"utils\\\\template.js\",\"./main\":\"filter\\\\main.js\"}],\"filter\\\\css.js\":[function(require,module,exports){\n/**\n * Filter for outputting CSS and alike\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\t/**\n\t * Test if passed item is very first child in parsed tree\n\t * @param {AbbreviationNode} item\n\t */\n\tfunction isVeryFirstChild(item) {\n\t\treturn item.parent && !item.parent.parent && !item.index();\n\t}\n\n\treturn function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\t\n\t\ttree.children.forEach(function(item) {\n\t\t\tif (!isVeryFirstChild(item) && profile.tag_nl !== false) {\n\t\t\t\titem.start = '\\n' + item.start;\n\t\t\t}\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n});\n},{}],\"filter\\\\escape.js\":[function(require,module,exports){\n/**\n * Filter for escaping unsafe XML characters: <, >, &\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar charMap = {\n\t\t'<': '&lt;',\n\t\t'>': '&gt;',\n\t\t'&': '&amp;'\n\t};\n\t\n\tfunction escapeChars(str) {\n\t\treturn str.replace(/([<>&])/g, function(str, p1){\n\t\t\treturn charMap[p1];\n\t\t});\n\t}\n\t\n\treturn function process(tree) {\n\t\ttree.children.forEach(function(item) {\n\t\t\titem.start = escapeChars(item.start);\n\t\t\titem.end = escapeChars(item.end);\n\t\t\titem.content = escapeChars(item.content);\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n});\n},{}],\"filter\\\\format.js\":[function(require,module,exports){\n/**\n * Generic formatting filter: creates proper indentation for each tree node,\n * placing \"%s\" placeholder where the actual output should be. You can use\n * this filter to preformat tree and then replace %s placeholder to whatever you\n * need. This filter should't be called directly from editor as a part \n * of abbreviation.\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar abbrUtils = require('../utils/abbreviation');\n\tvar prefs = require('../assets/preferences');\n\tvar resources = require('../assets/resources');\n\n\tprefs.define('format.noIndentTags', 'html', \n\t\t\t'A comma-separated list of tag names that should not get inner indentation.');\n\t\n\tprefs.define('format.forceIndentationForTags', 'body', \n\t\t'A comma-separated list of tag names that should <em>always</em> get inner indentation.');\n\n\tvar placeholder = '%s';\n\t\n\t/**\n\t * Get indentation for given node\n\t * @param {AbbreviationNode} node\n\t * @returns {String}\n\t */\n\tfunction getIndentation(node) {\n\t\tvar items = prefs.getArray('format.noIndentTags') || [];\n\t\tif (~items.indexOf(node.name())) {\n\t\t\treturn '';\n\t\t}\n\t\t\n\t\treturn '\\t';\n\t}\n\t\n\t/**\n\t * Test if passed node has block-level sibling element\n\t * @param {AbbreviationNode} item\n\t * @return {Boolean}\n\t */\n\tfunction hasBlockSibling(item) {\n\t\treturn item.parent && abbrUtils.hasBlockChildren(item.parent);\n\t}\n\t\n\t/**\n\t * Test if passed item is very first child in parsed tree\n\t * @param {AbbreviationNode} item\n\t */\n\tfunction isVeryFirstChild(item) {\n\t\treturn item.parent && !item.parent.parent && !item.index();\n\t}\n\t\n\t/**\n\t * Check if a newline should be added before element\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t * @return {Boolean}\n\t */\n\tfunction shouldAddLineBreak(node, profile) {\n\t\tif (profile.tag_nl === true || abbrUtils.isBlock(node))\n\t\t\treturn true;\n\t\t\n\t\tif (!node.parent || !profile.inline_break)\n\t\t\treturn false;\n\t\t\n\t\t// check if there are required amount of adjacent inline element\n\t\treturn shouldFormatInline(node.parent, profile);\n}\n\t\n\t/**\n\t * Need to add newline because <code>item</code> has too many inline children\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t */\n\tfunction shouldBreakChild(node, profile) {\n\t\t// we need to test only one child element, because \n\t\t// hasBlockChildren() method will do the rest\n\t\treturn node.children.length && shouldAddLineBreak(node.children[0], profile);\n\t}\n\t\n\tfunction shouldFormatInline(node, profile) {\n\t\tvar nodeCount = 0;\n\t\treturn !!utils.find(node.children, function(child) {\n\t\t\tif (child.isTextNode() || !abbrUtils.isInline(child))\n\t\t\t\tnodeCount = 0;\n\t\t\telse if (abbrUtils.isInline(child))\n\t\t\t\tnodeCount++;\n\t\t\t\n\t\t\tif (nodeCount >= profile.inline_break)\n\t\t\t\treturn true;\n\t\t});\n\t}\n\t\n\tfunction isRoot(item) {\n\t\treturn !item.parent;\n\t}\n\t\n\t/**\n\t * Processes element with matched resource of type <code>snippet</code>\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t */\n\tfunction processSnippet(item, profile) {\n\t\titem.start = item.end = '';\n\t\tif (!isVeryFirstChild(item) && profile.tag_nl !== false && shouldAddLineBreak(item, profile)) {\n\t\t\t// check if were not inside inline element\n\t\t\tif (isRoot(item.parent) || !abbrUtils.isInline(item.parent)) {\n\t\t\t\titem.start = '\\n' + item.start;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Check if we should add line breaks inside inline element\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t * @return {Boolean}\n\t */\n\tfunction shouldBreakInsideInline(node, profile) {\n\t\tvar hasBlockElems = node.children.some(function(child) {\n\t\t\tif (abbrUtils.isSnippet(child))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\treturn !abbrUtils.isInline(child);\n\t\t});\n\t\t\n\t\tif (!hasBlockElems) {\n\t\t\treturn shouldFormatInline(node, profile);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t */\n\tfunction processTag(item, profile) {\n\t\titem.start = item.end = placeholder;\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar nl = '\\n';\n\t\tvar indent = getIndentation(item);\n\t\t\t\n\t\t// formatting output\n\t\tif (profile.tag_nl !== false) {\n\t\t\tvar forceNl = profile.tag_nl === true && (profile.tag_nl_leaf || item.children.length);\n\t\t\tif (!forceNl) {\n\t\t\t\tvar forceIndentTags = prefs.getArray('format.forceIndentationForTags') || [];\n\t\t\t\tforceNl = ~forceIndentTags.indexOf(item.name());\n\t\t\t}\n\t\t\t\n\t\t\t// formatting block-level elements\n\t\t\tif (!item.isTextNode()) {\n\t\t\t\tif (shouldAddLineBreak(item, profile)) {\n\t\t\t\t\t// - do not indent the very first element\n\t\t\t\t\t// - do not indent first child of a snippet\n\t\t\t\t\tif (!isVeryFirstChild(item) && (!abbrUtils.isSnippet(item.parent) || item.index()))\n\t\t\t\t\t\titem.start = nl + item.start;\n\t\t\t\t\t\t\n\t\t\t\t\tif (abbrUtils.hasBlockChildren(item) || shouldBreakChild(item, profile) || (forceNl && !isUnary))\n\t\t\t\t\t\titem.end = nl + item.end;\n\t\t\t\t\t\t\n\t\t\t\t\tif (abbrUtils.hasTagsInContent(item) || (forceNl && !item.children.length && !isUnary))\n\t\t\t\t\t\titem.start += nl + indent;\n\t\t\t\t} else if (abbrUtils.isInline(item) && hasBlockSibling(item) && !isVeryFirstChild(item)) {\n\t\t\t\t\titem.start = nl + item.start;\n\t\t\t\t} else if (abbrUtils.isInline(item) && shouldBreakInsideInline(item, profile)) {\n\t\t\t\t\titem.end = nl + item.end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\titem.padding = indent;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\treturn function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\n\t\ttree.children.forEach(function(item) {\n\t\t\tif (abbrUtils.isSnippet(item)) {\n\t\t\t\tprocessSnippet(item, profile, level);\n\t\t\t} else {\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t}\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n});\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\"}],\"filter\\\\haml.js\":[function(require,module,exports){\n/**\n * Filter for producing HAML code from abbreviation.\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar abbrUtils = require('../utils/abbreviation');\n\tvar formatFilter = require('./format');\n\n\tfunction transformClassName(className) {\n\t\treturn utils.trim(className).replace(/\\s+/g, '.');\n\t}\n\n\t/**\n\t * Condenses all \"data-\" attributes into a single entry.\n\t * HAML allows data attributes to be ouputted as a sub-hash\n\t * of `:data` key\n\t * @param  {Array} attrs\n\t * @return {Array}\n\t */\n\tfunction condenseDataAttrs(attrs) {\n\t\tvar out = [], data = null;\n\t\tvar reData = /^data-/i;\n\t\tattrs.forEach(function(attr) {\n\t\t\tif (reData.test(attr.name)) {\n\t\t\t\tif (!data) {\n\t\t\t\t\tdata = [];\n\t\t\t\t\tout.push({\n\t\t\t\t\t\tname: 'data',\n\t\t\t\t\t\tvalue: data\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tdata.push(utils.extend({}, attr, {name: attr.name.replace(reData, '')}));\n\t\t\t} else {\n\t\t\t\tout.push(attr);\n\t\t\t}\n\t\t});\n\n\t\treturn out;\n\t}\n\n\tfunction stringifyAttrs(attrs, profile) {\n\t\tvar attrQuote = profile.attributeQuote();\n\t\treturn '{' + attrs.map(function(attr) {\n\t\t\tvar value = attrQuote + attr.value + attrQuote;\n\t\t\tif (Array.isArray(attr.value)) {\n\t\t\t\tvalue = stringifyAttrs(attr.value, profile);\n\t\t\t} else if (attr.isBoolean) {\n\t\t\t\tvalue = 'true';\n\t\t\t}\n\n\t\t\treturn ':' + attr.name + ' => ' + value\n\t\t}).join(', ') + '}';\n\t}\n\t\n\t/**\n\t * Creates HAML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} tag\n\t * @param {Object} profile\n\t */\n\tfunction makeAttributesString(tag, profile) {\n\t\tvar attrs = '';\n\t\tvar otherAttrs = [];\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\ttag.attributeList().forEach(function(a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\tswitch (attrName.toLowerCase()) {\n\t\t\t\t// use short notation for ID and CLASS attributes\n\t\t\t\tcase 'id':\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'class':\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\t// process other attributes\n\t\t\t\tdefault:\n\t\t\t\t\totherAttrs.push({\n\t\t\t\t\t\tname: attrName,\n\t\t\t\t\t\tvalue: a.value || cursor,\n\t\t\t\t\t\tisBoolean: profile.isBoolean(a.name, a.value)\n\t\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (otherAttrs.length) {\n\t\t\tattrs += stringifyAttrs(condenseDataAttrs(otherAttrs), profile);\n\t\t}\n\t\t\n\t\treturn attrs;\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t */\n\tfunction processTag(item, profile) {\n\t\tif (!item.parent)\n\t\t\t// looks like it's root element\n\t\t\treturn item;\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile);\n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar selfClosing = profile.self_closing_tag && isUnary ? '/' : '';\n\t\tvar start= '';\n\t\t\t\n\t\t// define tag name\n\t\tvar tagName = '%' + profile.tagName(item.name());\n\t\tif (tagName.toLowerCase() == '%div' && attrs && attrs.indexOf('{') == -1)\n\t\t\t// omit div tag\n\t\t\ttagName = '';\n\t\t\t\n\t\titem.end = '';\n\t\tstart = tagName + attrs + selfClosing;\n\t\tif (item.content && !/^\\s/.test(item.content)) {\n\t\t\titem.content = ' ' + item.content;\n\t\t}\n\t\t\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\t\n\t\tif (!item.children.length && !isUnary)\n\t\t\titem.start += cursor;\n\t\t\n\t\treturn item;\n\t}\n\n\treturn function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\t\n\t\tif (!level) {\n\t\t\ttree = formatFilter(tree, '_format', profile);\n\t\t}\n\t\t\n\t\ttree.children.forEach(function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) {\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t}\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n});\n},{\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\html.js\":[function(require,module,exports){\n/**\n * Filter that produces HTML tree\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar abbrUtils = require('../utils/abbreviation');\n\tvar utils = require('../utils/common');\n\tvar tabStops = require('../assets/tabStops');\n\tvar formatFilter = require('./format');\n\n\t/**\n\t * Creates HTML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t */\n\tfunction makeAttributesString(node, profile) {\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\treturn node.attributeList().map(function(a) {\n\t\t\tvar isBoolean = profile.isBoolean(a.name, a.value);\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\tvar attrValue = isBoolean ? attrName : a.value;\n\t\t\tif (isBoolean && profile.allowCompactBoolean()) {\n\t\t\t\treturn ' ' + attrName;\n\t\t\t}\n\t\t\treturn ' ' + attrName + '=' + attrQuote + (attrValue || cursor) + attrQuote;\n\t\t}).join('');\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t */\n\tfunction processTag(item, profile) {\n\t\tif (!item.parent) { // looks like it's root element\n\t\t\treturn item;\n\t\t}\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile); \n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar start = '';\n\t\tvar end = '';\n\t\t\t\n\t\t// define opening and closing tags\n\t\tif (!item.isTextNode()) {\n\t\t\tvar tagName = profile.tagName(item.name());\n\t\t\tif (isUnary) {\n\t\t\t\tstart = '<' + tagName + attrs + profile.selfClosing() + '>';\n\t\t\t\titem.end = '';\n\t\t\t} else {\n\t\t\t\tstart = '<' + tagName + attrs + '>';\n\t\t\t\tend = '</' + tagName + '>';\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\titem.end = utils.replaceSubstring(item.end, end, item.end.indexOf(placeholder), placeholder);\n\t\t\n\t\t// should we put caret placeholder after opening tag?\n\t\tif (\n\t\t\t\t!item.children.length \n\t\t\t\t&& !isUnary \n\t\t\t\t&& !~item.content.indexOf(cursor)\n\t\t\t\t&& !tabStops.extract(item.content).tabstops.length\n\t\t\t) {\n\t\t\titem.start += cursor;\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\n\treturn function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\t\n\t\tif (!level) {\n\t\t\ttree = formatFilter(tree, profile, level)\n\t\t}\n\t\t\n\t\ttree.children.forEach(function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) {\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t}\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n});\n},{\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\jade.js\":[function(require,module,exports){\n/**\n * Filter for producing Jade code from abbreviation.\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar abbrUtils = require('../utils/abbreviation');\n\tvar formatFilter = require('./format');\n\tvar tabStops = require('../assets/tabStops');\n\tvar profile = require('../assets/profile');\n\n\tvar reNl = /[\\n\\r]/;\n\tvar reIndentedText = /^\\s*\\|/;\n\tvar reSpace = /^\\s/;\n\n\tfunction transformClassName(className) {\n\t\treturn utils.trim(className).replace(/\\s+/g, '.');\n\t}\n\n\tfunction stringifyAttrs(attrs, profile) {\n\t\tvar attrQuote = profile.attributeQuote();\n\t\treturn '(' + attrs.map(function(attr) {\n\t\t\tif (attr.isBoolean) {\n\t\t\t\treturn attr.name;\n\t\t\t}\n\n\t\t\treturn attr.name + '=' + attrQuote + attr.value + attrQuote;\n\t\t}).join(', ') + ')';\n\t}\n\t\n\t/**\n\t * Creates HAML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} tag\n\t * @param {Object} profile\n\t */\n\tfunction makeAttributesString(tag, profile) {\n\t\tvar attrs = '';\n\t\tvar otherAttrs = [];\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\ttag.attributeList().forEach(function(a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\tswitch (attrName.toLowerCase()) {\n\t\t\t\t// use short notation for ID and CLASS attributes\n\t\t\t\tcase 'id':\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'class':\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\t// process other attributes\n\t\t\t\tdefault:\n\t\t\t\t\totherAttrs.push({\n\t\t\t\t\t\tname: attrName,\n\t\t\t\t\t\tvalue: a.value || cursor,\n\t\t\t\t\t\tisBoolean: profile.isBoolean(a.name, a.value)\n\t\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (otherAttrs.length) {\n\t\t\tattrs += stringifyAttrs(otherAttrs, profile);\n\t\t}\n\t\t\n\t\treturn attrs;\n\t}\n\n\tfunction processTagContent(item) {\n\t\tif (!item.content) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar content = tabStops.replaceVariables(item.content, function(str, name) {\n\t\t\tif (name === 'nl' || name === 'newline') {\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t\treturn str;\n\t\t});\n\n\t\tif (reNl.test(content) && !reIndentedText.test(content)) {\n\t\t\t// multiline content: pad it with indentation and pipe\n\t\t\tvar pad = '| ';\n\t\t\titem.content = '\\n' + pad + utils.padString(content, pad);\n\t\t} else if (!reSpace.test(content)) {\n\t\t\titem.content = ' ' + content;\n\t\t}\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t */\n\tfunction processTag(item, profile) {\n\t\tif (!item.parent)\n\t\t\t// looks like it's a root (empty) element\n\t\t\treturn item;\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile);\n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\t\t\n\t\t// define tag name\n\t\tvar tagName = profile.tagName(item.name());\n\t\tif (tagName.toLowerCase() == 'div' && attrs && attrs.charAt(0) != '(')\n\t\t\t// omit div tag\n\t\t\ttagName = '';\n\t\t\t\n\t\titem.end = '';\n\t\tvar start = tagName + attrs;\n\t\tprocessTagContent(item);\n\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\t\n\t\tif (!item.children.length && !isUnary)\n\t\t\titem.start += cursor;\n\t\t\n\t\treturn item;\n\t}\n\n\treturn function process(tree, curProfile, level) {\n\t\tlevel = level || 0;\n\t\t\n\t\tif (!level) {\n\t\t\t// always format with `xml` profile since\n\t\t\t// Jade requires all tags to be on separate lines\n\t\t\ttree = formatFilter(tree, profile.get('xml'));\n\t\t}\n\t\t\n\t\ttree.children.forEach(function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) {\n\t\t\t\tprocessTag(item, curProfile, level);\n\t\t\t}\n\t\t\t\n\t\t\tprocess(item, curProfile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n});\n},{\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\jsx.js\":[function(require,module,exports){\n/**\n * A filter for React.js (JSX):\n * ranames attributes like `class` and `for`\n * for proper representation in JSX\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar attrMap = {\n\t\t'class': 'className',\n\t\t'for': 'htmlFor'\n\t};\n\n\treturn function process(tree) {\n\t\ttree.children.forEach(function(item) {\n\t\t\titem._attributes.forEach(function(attr) {\n\t\t\t\tif (attr.name in attrMap) {\n\t\t\t\t\tattr.name = attrMap[attr.name]\n\t\t\t\t}\n\t\t\t});\n\t\t\tprocess(item);\n\t\t});\n\n\t\treturn tree;\n\t};\n});\n},{}],\"filter\\\\main.js\":[function(require,module,exports){\n/**\n * Module for handling filters\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar profile = require('../assets/profile');\n\tvar resources = require('../assets/resources');\n\n\t/** List of registered filters */\n\tvar registeredFilters = {\n\t\thtml: require('./html'),\n\t\thaml: require('./haml'),\n\t\tjade: require('./jade'),\n\t\tjsx: require('./jsx'),\n\t\tslim: require('./slim'),\n\t\txsl: require('./xsl'),\n\t\tcss: require('./css'),\n\t\tbem: require('./bem'),\n\t\tc: require('./comment'),\n\t\te: require('./escape'),\n\t\ts: require('./singleLine'),\n\t\tt: require('./trim')\n\t};\n\t\n\t/** Filters that will be applied for unknown syntax */\n\tvar basicFilters = 'html';\n\t\n\tfunction list(filters) {\n\t\tif (!filters)\n\t\t\treturn [];\n\t\t\n\t\tif (typeof filters === 'string') {\n\t\t\treturn filters.split(/[\\|,]/g);\n\t\t}\n\t\t\n\t\treturn filters;\n\t}\n\t\n\treturn  {\n\t\t/**\n\t\t * Register new filter\n\t\t * @param {String} name Filter name\n\t\t * @param {Function} fn Filter function\n\t\t */\n\t\tadd: function(name, fn) {\n\t\t\tregisteredFilters[name] = fn;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Apply filters for final output tree\n\t\t * @param {AbbreviationNode} tree Output tree\n\t\t * @param {Array} filters List of filters to apply. Might be a \n\t\t * <code>String</code>\n\t\t * @param {Object} profile Output profile, defined in <i>profile</i> \n\t\t * module. Filters defined it profile are not used, <code>profile</code>\n\t\t * is passed to filter function\n\t\t * @memberOf emmet.filters\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tapply: function(tree, filters, profileName) {\n\t\t\tprofileName = profile.get(profileName);\n\t\t\t\n\t\t\tlist(filters).forEach(function(filter) {\n\t\t\t\tvar name = utils.trim(filter.toLowerCase());\n\t\t\t\tif (name && name in registeredFilters) {\n\t\t\t\t\ttree = registeredFilters[name](tree, profileName);\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\treturn tree;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Composes list of filters that should be applied to a tree, based on \n\t\t * passed data\n\t\t * @param {String} syntax Syntax name ('html', 'css', etc.)\n\t\t * @param {Object} profile Output profile\n\t\t * @param {String} additionalFilters List or pipe-separated\n\t\t * string of additional filters to apply\n\t\t * @returns {Array}\n\t\t */\n\t\tcomposeList: function(syntax, profileName, additionalFilters) {\n\t\t\tprofileName = profile.get(profileName);\n\t\t\tvar filters = list(profileName.filters || resources.findItem(syntax, 'filters') || basicFilters);\n\t\t\t\n\t\t\tif (profileName.extraFilters) {\n\t\t\t\tfilters = filters.concat(list(profileName.extraFilters));\n\t\t\t}\n\t\t\t\t\n\t\t\tif (additionalFilters) {\n\t\t\t\tfilters = filters.concat(list(additionalFilters));\n\t\t\t}\n\t\t\t\t\n\t\t\tif (!filters || !filters.length) {\n\t\t\t\t// looks like unknown syntax, apply basic filters\n\t\t\t\tfilters = list(basicFilters);\n\t\t\t}\n\t\t\t\t\n\t\t\treturn filters;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts filter list from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Array} Array with cleaned abbreviation and list of \n\t\t * extracted filters\n\t\t */\n\t\textract: function(abbr) {\n\t\t\tvar filters = '';\n\t\t\tabbr = abbr.replace(/\\|([\\w\\|\\-]+)$/, function(str, p1){\n\t\t\t\tfilters = p1;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\treturn [abbr, list(filters)];\n\t\t}\n\t};\n});\n},{\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/common\":\"utils\\\\common.js\",\"./bem\":\"filter\\\\bem.js\",\"./comment\":\"filter\\\\comment.js\",\"./css\":\"filter\\\\css.js\",\"./escape\":\"filter\\\\escape.js\",\"./haml\":\"filter\\\\haml.js\",\"./html\":\"filter\\\\html.js\",\"./jade\":\"filter\\\\jade.js\",\"./jsx\":\"filter\\\\jsx.js\",\"./singleLine\":\"filter\\\\singleLine.js\",\"./slim\":\"filter\\\\slim.js\",\"./trim\":\"filter\\\\trim.js\",\"./xsl\":\"filter\\\\xsl.js\"}],\"filter\\\\singleLine.js\":[function(require,module,exports){\n/**\n * Output abbreviation on a single line (i.e. no line breaks)\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar abbrUtils = require('../utils/abbreviation');\n\tvar rePad = /^\\s+/;\n\tvar reNl = /[\\n\\r]/g;\n\n\treturn function process(tree) {\n\t\ttree.children.forEach(function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) {\n\t\t\t\t// remove padding from item \n\t\t\t\titem.start = item.start.replace(rePad, '');\n\t\t\t\titem.end = item.end.replace(rePad, '');\n\t\t\t}\n\t\t\t\n\t\t\t// remove newlines \n\t\t\titem.start = item.start.replace(reNl, '');\n\t\t\titem.end = item.end.replace(reNl, '');\n\t\t\titem.content = item.content.replace(reNl, '');\n\t\t\t\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n});\n\n},{\"../utils/abbreviation\":\"utils\\\\abbreviation.js\"}],\"filter\\\\slim.js\":[function(require,module,exports){\n/**\n * Filter for producing Jade code from abbreviation.\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar abbrUtils = require('../utils/abbreviation');\n\tvar formatFilter = require('./format');\n\tvar tabStops = require('../assets/tabStops');\n\tvar prefs = require('../assets/preferences');\n\tvar profile = require('../assets/profile');\n\n\tvar reNl = /[\\n\\r]/;\n\tvar reIndentedText = /^\\s*\\|/;\n\tvar reSpace = /^\\s/;\n\n\tprefs.define('slim.attributesWrapper', 'none', \n\t\t'Defines how attributes will be wrapped:' +\n\t\t'<ul>' +\n\t\t'<li><code>none</code>  no wrapping;</li>' +\n\t\t'<li><code>round</code>  wrap attributes with round braces;</li>' +\n\t\t'<li><code>square</code>  wrap attributes with round braces;</li>' +\n\t\t'<li><code>curly</code>  wrap attributes with curly braces.</li>' +\n\t\t'</ul>');\n\n\tfunction transformClassName(className) {\n\t\treturn utils.trim(className).replace(/\\s+/g, '.');\n\t}\n\n\tfunction getAttrWrapper() {\n\t\tvar start = ' ', end = '';\n\t\tswitch (prefs.get('slim.attributesWrapper')) {\n\t\t\tcase 'round':\n\t\t\t\tstart = '(';\n\t\t\t\tend = ')';\n\t\t\t\tbreak;\n\t\t\tcase 'square':\n\t\t\t\tstart = '[';\n\t\t\t\tend = ']';\n\t\t\t\tbreak;\n\t\t\tcase 'curly':\n\t\t\t\tstart = '{';\n\t\t\t\tend = '}';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn {\n\t\t\tstart: start,\n\t\t\tend: end\n\t\t};\n\t}\n\n\tfunction stringifyAttrs(attrs, profile) {\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar attrWrap = getAttrWrapper();\n\t\treturn attrWrap.start + attrs.map(function(attr) {\n\t\t\tvar value = attrQuote + attr.value + attrQuote;\n\t\t\tif (attr.isBoolean) {\n\t\t\t\tif (!attrWrap.end) {\n\t\t\t\t\tvalue = 'true';\n\t\t\t\t} else {\n\t\t\t\t\treturn attr.name;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn attr.name + '=' + value;\n\t\t}).join(' ') + attrWrap.end;\n\t}\n\t\n\t/**\n\t * Creates HAML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} tag\n\t * @param {Object} profile\n\t */\n\tfunction makeAttributesString(tag, profile) {\n\t\tvar attrs = '';\n\t\tvar otherAttrs = [];\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\ttag.attributeList().forEach(function(a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\tswitch (attrName.toLowerCase()) {\n\t\t\t\t// use short notation for ID and CLASS attributes\n\t\t\t\tcase 'id':\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'class':\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\t// process other attributes\n\t\t\t\tdefault:\n\t\t\t\t\totherAttrs.push({\n\t\t\t\t\t\tname: attrName,\n\t\t\t\t\t\tvalue: a.value || cursor,\n\t\t\t\t\t\tisBoolean: profile.isBoolean(a.name, a.value)\n\t\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (otherAttrs.length) {\n\t\t\tattrs += stringifyAttrs(otherAttrs, profile);\n\t\t}\n\t\t\n\t\treturn attrs;\n\t}\n\n\tfunction processTagContent(item) {\n\t\tif (!item.content) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar content = tabStops.replaceVariables(item.content, function(str, name) {\n\t\t\tif (name === 'nl' || name === 'newline') {\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t\treturn str;\n\t\t});\n\n\t\tif (reNl.test(content) && !reIndentedText.test(content)) {\n\t\t\t// multiline content: pad it with indentation and pipe\n\t\t\tvar pad = '  ';\n\t\t\titem.content = '\\n| ' + utils.padString(content, pad);\n\t\t} else if (!reSpace.test(content)) {\n\t\t\titem.content = ' ' + content;\n\t\t}\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t */\n\tfunction processTag(item, profile) {\n\t\tif (!item.parent)\n\t\t\t// looks like it's a root (empty) element\n\t\t\treturn item;\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile);\n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar selfClosing = profile.self_closing_tag && isUnary ? '/' : '';\n\t\t\t\n\t\t// define tag name\n\t\tvar tagName = profile.tagName(item.name());\n\t\tif (tagName.toLowerCase() == 'div' && attrs && '([{'.indexOf(attrs.charAt(0)) == -1)\n\t\t\t// omit div tag\n\t\t\ttagName = '';\n\t\t\t\n\t\titem.end = '';\n\t\tvar start = tagName + attrs + selfClosing;\n\t\tprocessTagContent(item);\n\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\t\n\t\tif (!item.children.length && !isUnary)\n\t\t\titem.start += cursor;\n\t\t\n\t\treturn item;\n\t}\n\n\treturn function process(tree, curProfile, level) {\n\t\tlevel = level || 0;\n\t\t\n\t\tif (!level) {\n\t\t\t// always format with `xml` profile since\n\t\t\t// Slim requires all tags to be on separate lines\n\t\t\ttree = formatFilter(tree, profile.get('xml'));\n\t\t}\n\t\t\n\t\ttree.children.forEach(function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) {\n\t\t\t\tprocessTag(item, curProfile, level);\n\t\t\t}\n\t\t\t\n\t\t\tprocess(item, curProfile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n});\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\trim.js\":[function(require,module,exports){\n/**\n * Trim filter: removes characters at the beginning of the text\n * content that indicates lists: numbers, #, *, -, etc.\n * \n * Useful for wrapping lists with abbreviation.\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar prefs = require('../assets/preferences');\n\tprefs.define('filter.trimRegexp', \n\t\t'[\\\\s|\\\\u00a0]*[\\\\d|#|\\\\-|\\*|\\\\u2022]+\\\\.?\\\\s*',\n\t\t'Regular expression used to remove list markers (numbers, dashes, ' \n\t\t+ 'bullets, etc.) in <code>t</code> (trim) filter. The trim filter '\n\t\t+ 'is useful for wrapping with abbreviation lists, pased from other ' \n\t\t+ 'documents (for example, Word documents).');\n\t\n\tfunction process(tree, re) {\n\t\ttree.children.forEach(function(item) {\n\t\t\tif (item.content) {\n\t\t\t\titem.content = item.content.replace(re, '');\n\t\t\t}\n\t\t\t\n\t\t\tprocess(item, re);\n\t\t});\n\t\t\n\t\treturn tree;\n\t}\n\n\treturn function(tree) {\n\t\tvar re = new RegExp(prefs.get('filter.trimRegexp'));\n\t\treturn process(tree, re);\n\t};\n});\n\n},{\"../assets/preferences\":\"assets\\\\preferences.js\"}],\"filter\\\\xsl.js\":[function(require,module,exports){\n/**\n * Filter for trimming \"select\" attributes from some tags that contains\n * child elements\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar abbrUtils = require('../utils/abbreviation');\n\n\tvar tags = {\n\t\t'xsl:variable': 1,\n\t\t'xsl:with-param': 1\n\t};\n\t\n\t/**\n\t * Removes \"select\" attribute from node\n\t * @param {AbbreviationNode} node\n\t */\n\tfunction trimAttribute(node) {\n\t\tnode.start = node.start.replace(/\\s+select\\s*=\\s*(['\"]).*?\\1/, '');\n\t}\n\n\treturn function process(tree) {\n\t\ttree.children.forEach(function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)\n\t\t\t\t\t&& (item.name() || '').toLowerCase() in tags \n\t\t\t\t\t&& item.children.length)\n\t\t\t\ttrimAttribute(item);\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n});\n},{\"../utils/abbreviation\":\"utils\\\\abbreviation.js\"}],\"generator\\\\lorem.js\":[function(require,module,exports){\n/**\n * \"Lorem ipsum\" text generator. Matches <code>lipsum(num)?</code> or \n * <code>lorem(num)?</code> abbreviation.\n * This code is based on Django's contribution: \n * https://code.djangoproject.com/browser/django/trunk/django/contrib/webdesign/lorem_ipsum.py\n * <br><br>\n * Examples to test:<br>\n * <code>lipsum</code>  generates 30 words text.<br>\n * <code>lipsum*6</code>  generates 6 paragraphs (autowrapped with &lt;p&gt; element) of text.<br>\n * <code>ol>lipsum10*5</code>  generates ordered list with 5 list items (autowrapped with &lt;li&gt; tag)\n * with text of 10 words on each line.<br>\n * <code>span*3>lipsum20</code>  generates 3 paragraphs of 20-words text, each wrapped with &lt;span&gt; element.\n * Each paragraph phrase is unique.   \n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar prefs = require('../assets/preferences');\n\n\tvar langs = {\n\t\ten: {\n\t\t\tcommon: ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipisicing', 'elit'],\n\t\t\twords: ['exercitationem', 'perferendis', 'perspiciatis', 'laborum', 'eveniet',\n\t\t\t\t'sunt', 'iure', 'nam', 'nobis', 'eum', 'cum', 'officiis', 'excepturi',\n\t\t\t\t'odio', 'consectetur', 'quasi', 'aut', 'quisquam', 'vel', 'eligendi',\n\t\t\t\t'itaque', 'non', 'odit', 'tempore', 'quaerat', 'dignissimos',\n\t\t\t\t'facilis', 'neque', 'nihil', 'expedita', 'vitae', 'vero', 'ipsum',\n\t\t\t\t'nisi', 'animi', 'cumque', 'pariatur', 'velit', 'modi', 'natus',\n\t\t\t\t'iusto', 'eaque', 'sequi', 'illo', 'sed', 'ex', 'et', 'voluptatibus',\n\t\t\t\t'tempora', 'veritatis', 'ratione', 'assumenda', 'incidunt', 'nostrum',\n\t\t\t\t'placeat', 'aliquid', 'fuga', 'provident', 'praesentium', 'rem',\n\t\t\t\t'necessitatibus', 'suscipit', 'adipisci', 'quidem', 'possimus',\n\t\t\t\t'voluptas', 'debitis', 'sint', 'accusantium', 'unde', 'sapiente',\n\t\t\t\t'voluptate', 'qui', 'aspernatur', 'laudantium', 'soluta', 'amet',\n\t\t\t\t'quo', 'aliquam', 'saepe', 'culpa', 'libero', 'ipsa', 'dicta',\n\t\t\t\t'reiciendis', 'nesciunt', 'doloribus', 'autem', 'impedit', 'minima',\n\t\t\t\t'maiores', 'repudiandae', 'ipsam', 'obcaecati', 'ullam', 'enim',\n\t\t\t\t'totam', 'delectus', 'ducimus', 'quis', 'voluptates', 'dolores',\n\t\t\t\t'molestiae', 'harum', 'dolorem', 'quia', 'voluptatem', 'molestias',\n\t\t\t\t'magni', 'distinctio', 'omnis', 'illum', 'dolorum', 'voluptatum', 'ea',\n\t\t\t\t'quas', 'quam', 'corporis', 'quae', 'blanditiis', 'atque', 'deserunt',\n\t\t\t\t'laboriosam', 'earum', 'consequuntur', 'hic', 'cupiditate',\n\t\t\t\t'quibusdam', 'accusamus', 'ut', 'rerum', 'error', 'minus', 'eius',\n\t\t\t\t'ab', 'ad', 'nemo', 'fugit', 'officia', 'at', 'in', 'id', 'quos',\n\t\t\t\t'reprehenderit', 'numquam', 'iste', 'fugiat', 'sit', 'inventore',\n\t\t\t\t'beatae', 'repellendus', 'magnam', 'recusandae', 'quod', 'explicabo',\n\t\t\t\t'doloremque', 'aperiam', 'consequatur', 'asperiores', 'commodi',\n\t\t\t\t'optio', 'dolor', 'labore', 'temporibus', 'repellat', 'veniam',\n\t\t\t\t'architecto', 'est', 'esse', 'mollitia', 'nulla', 'a', 'similique',\n\t\t\t\t'eos', 'alias', 'dolore', 'tenetur', 'deleniti', 'porro', 'facere',\n\t\t\t\t'maxime', 'corrupti']\n\t\t},\n\t\tsp: {\n\t\t\tcommon: ['mujer', 'uno', 'dolor', 'ms', 'de', 'poder', 'mismo', 'si'],\n\t\t\twords: ['ejercicio', 'preferencia', 'perspicacia', 'laboral', 'pao',\n\t\t\t\t'suntuoso', 'molde', 'namibia', 'planeador', 'mirar', 'dems', 'oficinista', 'excepcin',\n\t\t\t\t'odio', 'consecuencia', 'casi', 'auto', 'chicharra', 'velo', 'elixir',\n\t\t\t\t'ataque', 'no', 'odio', 'temporal', 'curum', 'dignsimo',\n\t\t\t\t'facilismo', 'letra', 'nihilista', 'expedicin', 'alma', 'alveolar', 'aparte',\n\t\t\t\t'len', 'animal', 'como', 'paria', 'belleza', 'modo', 'natividad',\n\t\t\t\t'justo', 'ataque', 'squito', 'pillo', 'sed', 'ex', 'y', 'voluminoso',\n\t\t\t\t'temporalidad', 'verdades', 'racional', 'asuncin', 'incidente', 'marejada',\n\t\t\t\t'placenta', 'amanecer', 'fuga', 'previsor', 'presentacin', 'lejos',\n\t\t\t\t'necesariamente', 'sospechoso', 'adiposidad', 'quindo', 'pcima',\n\t\t\t\t'voluble', 'dbito', 'sinti', 'accesorio', 'falda', 'sapiencia',\n\t\t\t\t'volutas', 'queso', 'permacultura', 'laudo', 'soluciones', 'entero',\n\t\t\t\t'pan', 'litro', 'tonelada', 'culpa', 'libertario', 'mosca', 'dictado',\n\t\t\t\t'reincidente', 'nascimiento', 'dolor', 'escolar', 'impedimento', 'mnima',\n\t\t\t\t'mayores', 'repugnante', 'dulce', 'obcecado', 'montaa', 'enigma',\n\t\t\t\t'total', 'deletreo', 'dcima', 'cbala', 'fotografa', 'dolores',\n\t\t\t\t'molesto', 'olvido', 'paciencia', 'resiliencia', 'voluntad', 'molestias',\n\t\t\t\t'magnfico', 'distincin', 'ovni', 'marejada', 'cerro', 'torre', 'y',\n\t\t\t\t'abogada', 'manantial', 'corporal', 'agua', 'crepsculo', 'ataque', 'desierto',\n\t\t\t\t'laboriosamente', 'angustia', 'afortunado', 'alma', 'encefalograma',\n\t\t\t\t'materialidad', 'cosas', 'o', 'renuncia', 'error', 'menos', 'conejo',\n\t\t\t\t'abada', 'analfabeto', 'remo', 'fugacidad', 'oficio', 'en', 'almcigo', 'vos', 'pan',\n\t\t\t\t'represin', 'nmeros', 'triste', 'refugiado', 'trote', 'inventor',\n\t\t\t\t'corchea', 'repelente', 'magma', 'recusado', 'patrn', 'explcito',\n\t\t\t\t'paloma', 'sndrome', 'inmune', 'autoinmune', 'comodidad',\n\t\t\t\t'ley', 'vietnamita', 'demonio', 'tasmania', 'repeler', 'apndice',\n\t\t\t\t'arquitecto', 'columna', 'yugo', 'computador', 'mula', 'a', 'propsito',\n\t\t\t\t'fantasa', 'alias', 'rayo', 'tenedor', 'deleznable', 'ventana', 'cara',\n\t\t\t\t'anemia', 'corrupto']\n\t\t},\n\t\tru: {\n\t\t\tcommon: ['-', '', '', '', ' ', '', ' ', '', '', ''],\n\t\t\twords: ['', ' ', '', '', '', ' ', '', \n\t\t\t\t'', '', '', '', '', '', \n\t\t\t\t'', ' ', '', '','', '', \n\t\t\t\t'', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', \n\t\t\t\t'', '','', '', '', 'lorem', 'ipsum', \n\t\t\t\t'', '', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', '', \n\t\t\t\t'', '',  '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', \n\t\t\t\t'', '', '', '', '', '', '', '']\n\t\t}\n\t};\n\n\t\n\tprefs.define('lorem.defaultLang', 'en', \n\t\t'Default language of generated dummy text. Currently, <code>en</code>\\\n\t\tand <code>ru</code> are supported, but users can add their own syntaxes\\\n\t\tsee <a href=\"http://docs.emmet.io/abbreviations/lorem-ipsum/\">docs</a>.');\n\tprefs.define('lorem.omitCommonPart', false,\n\t\t'Omit commonly used part (e.g. Lorem ipsum dolor sit amet) from generated text.');\n\t\n\t/**\n\t * Returns random integer between <code>from</code> and <code>to</code> values\n\t * @param {Number} from\n\t * @param {Number} to\n\t * @returns {Number}\n\t */\n\tfunction randint(from, to) {\n\t\treturn Math.round(Math.random() * (to - from) + from);\n\t}\n\t\n\t/**\n\t * @param {Array} arr\n\t * @param {Number} count\n\t * @returns {Array}\n\t */\n\tfunction sample(arr, count) {\n\t\tvar len = arr.length;\n\t\tvar iterations = Math.min(len, count);\n\t\tvar result = [];\n\t\twhile (result.length < iterations) {\n\t\t\tvar randIx = randint(0, len - 1);\n\t\t\tif (!~result.indexOf(randIx)) {\n\t\t\t\tresult.push(randIx);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result.map(function(ix) {\n\t\t\treturn arr[ix];\n\t\t});\n\t}\n\t\n\tfunction choice(val) {\n\t\tif (typeof val === 'string')\n\t\t\treturn val.charAt(randint(0, val.length - 1));\n\t\t\n\t\treturn val[randint(0, val.length - 1)];\n\t}\n\t\n\tfunction sentence(words, end) {\n\t\tif (words.length) {\n\t\t\twords[0] = words[0].charAt(0).toUpperCase() + words[0].substring(1);\n\t\t}\n\t\t\n\t\treturn words.join(' ') + (end || choice('?!...')); // more dots than question marks\n\t}\n\t\n\t/**\n\t * Insert commas at randomly selected words. This function modifies values\n\t * inside <code>words</code> array \n\t * @param {Array} words\n\t */\n\tfunction insertCommas(words) {\n\t\tvar len = words.length;\n\n\t\tif (len < 2) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar totalCommas = 0;\n\t\tif (len > 3 && len <= 6) {\n\t\t\ttotalCommas = randint(0, 1);\n\t\t} else if (len > 6 && len <= 12) {\n\t\t\ttotalCommas = randint(0, 2);\n\t\t} else {\n\t\t\ttotalCommas = randint(1, 4);\n\t\t}\n\n\t\tfor (var i = 0, pos, word; i < totalCommas; i++) {\n\t\t\tpos = randint(0, words.length - 2);\n\t\t\tword = words[pos];\n\t\t\tif (word.charAt(word.length - 1) !== ',') {\n\t\t\t\twords[pos] += ',';\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Generate a paragraph of \"Lorem ipsum\" text\n\t * @param {Number} wordCount Words count in paragraph\n\t * @param {Boolean} startWithCommon Should paragraph start with common \n\t * \"lorem ipsum\" sentence.\n\t * @returns {String}\n\t */\n\tfunction paragraph(lang, wordCount, startWithCommon) {\n\t\tvar data = langs[lang];\n\t\tif (!data) {\n\t\t\treturn '';\n\t\t}\n\n\t\tvar result = [];\n\t\tvar totalWords = 0;\n\t\tvar words;\n\t\t\n\t\twordCount = parseInt(wordCount, 10);\n\t\t\n\t\tif (startWithCommon && data.common) {\n\t\t\twords = data.common.slice(0, wordCount);\n\t\t\tif (words.length > 5) {\n\t\t\t\twords[4] += ',';\n\t\t\t}\n\t\t\ttotalWords += words.length;\n\t\t\tresult.push(sentence(words, '.'));\n\t\t}\n\t\t\n\t\twhile (totalWords < wordCount) {\n\t\t\twords = sample(data.words, Math.min(randint(2, 30), wordCount - totalWords));\n\t\t\ttotalWords += words.length;\n\t\t\tinsertCommas(words);\n\t\t\tresult.push(sentence(words));\n\t\t}\n\t\t\n\t\treturn result.join(' ');\n\t}\n\n\treturn {\n\t\t/**\n\t\t * Adds new language words for Lorem Ipsum generator\n\t\t * @param {String} lang Two-letter lang definition\n\t\t * @param {Object} data Words for language. Maight be either a space-separated \n\t\t * list of words (String), Array of words or object with <code>text</code> and\n\t\t * <code>common</code> properties\n\t\t */\n\t\taddLang: function(lang, data) {\n\t\t\tif (typeof data === 'string') {\n\t\t\t\tdata = {\n\t\t\t\t\twords: data.split(' ').filter(function(item) {\n\t\t\t\t\t\treturn !!item;\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t} else if (Array.isArray(data)) {\n\t\t\t\tdata = {words: data};\n\t\t\t}\n\n\t\t\tlangs[lang] = data;\n\t\t},\n\t\tpreprocessor: function(tree) {\n\t\t\tvar re = /^(?:lorem|lipsum)([a-z]{2})?(\\d*)$/i, match;\n\t\t\tvar allowCommon = !prefs.get('lorem.omitCommonPart');\n\t\t\t\n\t\t\t/** @param {AbbreviationNode} node */\n\t\t\ttree.findAll(function(node) {\n\t\t\t\tif (node._name && (match = node._name.match(re))) {\n\t\t\t\t\tvar wordCound = match[2] || 30;\n\t\t\t\t\tvar lang = match[1] || prefs.get('lorem.defaultLang') || 'en';\n\t\t\t\t\t\n\t\t\t\t\t// force node name resolving if node should be repeated\n\t\t\t\t\t// or contains attributes. In this case, node should be outputed\n\t\t\t\t\t// as tag, otherwise as text-only node\n\t\t\t\t\tnode._name = '';\n\t\t\t\t\tnode.data('forceNameResolving', node.isRepeating() || node.attributeList().length);\n\t\t\t\t\tnode.data('pasteOverwrites', true);\n\t\t\t\t\tnode.data('paste', function(i) {\n\t\t\t\t\t\treturn paragraph(lang, wordCound, !i && allowCommon);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n});\n\n},{\"../assets/preferences\":\"assets\\\\preferences.js\"}],\"parser\\\\abbreviation.js\":[function(require,module,exports){\n/**\n * Emmet abbreviation parser.\n * Takes string abbreviation and recursively parses it into a tree. The parsed \n * tree can be transformed into a string representation with \n * <code>toString()</code> method. Note that string representation is defined\n * by custom processors (called <i>filters</i>), not by abbreviation parser \n * itself.\n * \n * This module can be extended with custom pre-/post-processors to shape-up\n * final tree or its representation. Actually, many features of abbreviation \n * engine are defined in other modules as tree processors\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar tabStops = require('../assets/tabStops');\n\tvar profile = require('../assets/profile');\n\tvar filters = require('../filter/main');\n\tvar utils = require('../utils/common');\n\tvar abbreviationUtils = require('../utils/abbreviation');\n\tvar stringStream = require('../assets/stringStream');\n\n\t// pre- and post-processorcs\n\tvar lorem = require('../generator/lorem');\n\tvar procPastedContent = require('./processor/pastedContent');\n\tvar procTagName = require('./processor/tagName');\n\tvar procResourceMatcher = require('./processor/resourceMatcher');\n\tvar procAttributes = require('./processor/attributes');\n\tvar procHref = require('./processor/href');\n\n\tvar reValidName = /^[\\w\\-\\$\\:@\\!%]+\\+?$/i;\n\tvar reWord = /[\\w\\-:\\$@]/;\n\tvar DEFAULT_ATTR_NAME = '%default';\n\t\n\tvar pairs = {\n\t\t'[': ']',\n\t\t'(': ')',\n\t\t'{': '}'\n\t};\n\t\n\tvar spliceFn = Array.prototype.splice;\n\t\n\tvar preprocessors = [];\n\tvar postprocessors = [];\n\tvar outputProcessors = [];\n\t\n\t/**\n\t * @type AbbreviationNode\n\t */\n\tfunction AbbreviationNode(parent) {\n\t\t/** @type AbbreviationNode */\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\t\tthis._attributes = [];\n\t\t\n\t\t/** @type String Raw abbreviation for current node */\n\t\tthis.abbreviation = '';\n\t\tthis.counter = 1;\n\t\tthis._name = null;\n\t\tthis._text = '';\n\t\tthis.repeatCount = 1;\n\t\tthis.hasImplicitRepeat = false;\n\t\t\n\t\t/** Custom data dictionary */\n\t\tthis._data = {};\n\t\t\n\t\t// output properties\n\t\tthis.start = '';\n\t\tthis.end = '';\n\t\tthis.content = '';\n\t\tthis.padding = '';\n\t}\n\t\n\tAbbreviationNode.prototype = {\n\t\t/**\n\t\t * Adds passed node as child or creates new child\n\t\t * @param {AbbreviationNode} child\n\t\t * @param {Number} position Index in children array where child should \n\t\t * be inserted\n\t\t * @return {AbbreviationNode}\n\t\t */\n\t\taddChild: function(child, position) {\n\t\t\tchild = child || new AbbreviationNode();\n\t\t\tchild.parent = this;\n\t\t\t\n\t\t\tif (typeof position === 'undefined') {\n\t\t\t\tthis.children.push(child);\n\t\t\t} else {\n\t\t\t\tthis.children.splice(position, 0, child);\n\t\t\t}\n\t\t\t\n\t\t\treturn child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates a deep copy of current node\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tclone: function() {\n\t\t\tvar node = new AbbreviationNode();\n\t\t\tvar attrs = ['abbreviation', 'counter', '_name', '_text', 'repeatCount', 'hasImplicitRepeat', 'start', 'end', 'content', 'padding'];\n\t\t\tattrs.forEach(function(a) {\n\t\t\t\tnode[a] = this[a];\n\t\t\t}, this);\n\t\t\t\n\t\t\t// clone attributes\n\t\t\tnode._attributes = this._attributes.map(function(attr) {\n\t\t\t\treturn utils.extend({}, attr);\n\t\t\t});\n\t\t\t\n\t\t\tnode._data = utils.extend({}, this._data);\n\t\t\t\n\t\t\t// clone children\n\t\t\tnode.children = this.children.map(function(child) {\n\t\t\t\tchild = child.clone();\n\t\t\t\tchild.parent = node;\n\t\t\t\treturn child;\n\t\t\t});\n\t\t\t\n\t\t\treturn node;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes current node from parents child list\n\t\t * @returns {AbbreviationNode} Current node itself\n\t\t */\n\t\tremove: function() {\n\t\t\tif (this.parent) {\n\t\t\t\tvar ix = this.parent.children.indexOf(this);\n\t\t\t\tif (~ix) {\n\t\t\t\t\tthis.parent.children.splice(ix, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces current node in parents children list with passed nodes\n\t\t * @param {AbbreviationNode} node Replacement node or array of nodes\n\t\t */\n\t\treplace: function() {\n\t\t\tvar parent = this.parent;\n\t\t\tvar ix = parent.children.indexOf(this);\n\t\t\tvar items = utils.flatten(arguments);\n\t\t\tspliceFn.apply(parent.children, [ix, 1].concat(items));\n\t\t\t\n\t\t\t// update parent\n\t\t\titems.forEach(function(item) {\n\t\t\t\titem.parent = parent;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively sets <code>property</code> to <code>value</code> of current\n\t\t * node and its children \n\t\t * @param {String} name Property to update\n\t\t * @param {Object} value New property value\n\t\t */\n\t\tupdateProperty: function(name, value) {\n\t\t\tthis[name] = value;\n\t\t\tthis.children.forEach(function(child) {\n\t\t\t\tchild.updateProperty(name, value);\n\t\t\t});\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds first child node that matches truth test for passed \n\t\t * <code>fn</code> function\n\t\t * @param {Function} fn\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tfind: function(fn) {\n\t\t\treturn this.findAll(fn, {amount: 1})[0];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds all child nodes that matches truth test for passed \n\t\t * <code>fn</code> function\n\t\t * @param {Function} fn\n\t\t * @returns {Array}\n\t\t */\n\t\tfindAll: function(fn, state) {\n\t\t\tstate = utils.extend({amount: 0, found: 0}, state || {});\n\n\t\t\tif (typeof fn !== 'function') {\n\t\t\t\tvar elemName = fn.toLowerCase();\n\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\n\t\t\t}\n\t\t\t\t\n\t\t\tvar result = [];\n\t\t\tthis.children.forEach(function(child) {\n\t\t\t\tif (fn(child)) {\n\t\t\t\t\tresult.push(child);\n\t\t\t\t\tstate.found++;\n\t\t\t\t\tif (state.amount && state.found >= state.amount) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult = result.concat(child.findAll(fn));\n\t\t\t});\n\t\t\t\n\t\t\treturn result.filter(function(item) {\n\t\t\t\treturn !!item;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets/gets custom data\n\t\t * @param {String} name\n\t\t * @param {Object} value\n\t\t * @returns {Object}\n\t\t */\n\t\tdata: function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tthis._data[name] = value;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._data[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns name of current node\n\t\t * @returns {String}\n\t\t */\n\t\tname: function() {\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of attributes for current node\n\t\t * @returns {Array}\n\t\t */\n\t\tattributeList: function() {\n\t\t\treturn optimizeAttributes(this._attributes.slice(0));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns or sets attribute value\n\t\t * @param {String} name Attribute name\n\t\t * @param {String} value New attribute value. `Null` value \n\t\t * will remove attribute\n\t\t * @returns {String}\n\t\t */\n\t\tattribute: function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tif (value === null) {\n\t\t\t\t\t// remove attribute\n\t\t\t\t\tvar vals = this._attributes.filter(function(attr) {\n\t\t\t\t\t\treturn attr.name === name;\n\t\t\t\t\t});\n\n\t\t\t\t\tvar that = this;\n\t\t\t\t\tvals.forEach(function(attr) {\n\t\t\t\t\t\tvar ix = that._attributes.indexOf(attr);\n\t\t\t\t\t\tif (~ix) {\n\t\t\t\t\t\t\tthat._attributes.splice(ix, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// modify attribute\n\t\t\t\tvar attrNames = this._attributes.map(function(attr) {\n\t\t\t\t\treturn attr.name;\n\t\t\t\t});\n\t\t\t\tvar ix = attrNames.indexOf(name.toLowerCase());\n\t\t\t\tif (~ix) {\n\t\t\t\t\tthis._attributes[ix].value = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis._attributes.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn (utils.find(this.attributeList(), function(attr) {\n\t\t\t\treturn attr.name == name;\n\t\t\t}) || {}).value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns index of current node in parents children list\n\t\t * @returns {Number}\n\t\t */\n\t\tindex: function() {\n\t\t\treturn this.parent ? this.parent.children.indexOf(this) : -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets how many times current element should be repeated\n\t\t * @private\n\t\t */\n\t\t_setRepeat: function(count) {\n\t\t\tif (count) {\n\t\t\t\tthis.repeatCount = parseInt(count, 10) || 1;\n\t\t\t} else {\n\t\t\t\tthis.hasImplicitRepeat = true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets abbreviation that belongs to current node\n\t\t * @param {String} abbr\n\t\t */\n\t\tsetAbbreviation: function(abbr) {\n\t\t\tabbr = abbr || '';\n\t\t\t\n\t\t\tvar that = this;\n\t\t\t\n\t\t\t// find multiplier\n\t\t\tabbr = abbr.replace(/\\*(\\d+)?$/, function(str, repeatCount) {\n\t\t\t\tthat._setRepeat(repeatCount);\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\tthis.abbreviation = abbr;\n\t\t\t\n\t\t\tvar abbrText = extractText(abbr);\n\t\t\tif (abbrText) {\n\t\t\t\tabbr = abbrText.element;\n\t\t\t\tthis.content = this._text = abbrText.text;\n\t\t\t}\n\t\t\t\n\t\t\tvar abbrAttrs = parseAttributes(abbr);\n\t\t\tif (abbrAttrs) {\n\t\t\t\tabbr = abbrAttrs.element;\n\t\t\t\tthis._attributes = abbrAttrs.attributes;\n\t\t\t}\n\t\t\t\n\t\t\tthis._name = abbr;\n\t\t\t\n\t\t\t// validate name\n\t\t\tif (this._name && !reValidName.test(this._name)) {\n\t\t\t\tthrow new Error('Invalid abbreviation');\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns string representation of current node\n\t\t * @return {String}\n\t\t */\n\t\tvalueOf: function() {\n\t\t\tvar start = this.start;\n\t\t\tvar end = this.end;\n\t\t\tvar content = this.content;\n\t\t\t\n\t\t\t// apply output processors\n\t\t\tvar node = this;\n\t\t\toutputProcessors.forEach(function(fn) {\n\t\t\t\tstart = fn(start, node, 'start');\n\t\t\t\tcontent = fn(content, node, 'content');\n\t\t\t\tend = fn(end, node, 'end');\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t\tvar innerContent = this.children.map(function(child) {\n\t\t\t\treturn child.valueOf();\n\t\t\t}).join('');\n\t\t\t\n\t\t\tcontent = abbreviationUtils.insertChildContent(content, innerContent, {\n\t\t\t\tkeepVariable: false\n\t\t\t});\n\t\t\t\n\t\t\treturn start + utils.padString(content, this.padding) + end;\n\t\t},\n\n\t\ttoString: function() {\n\t\t\treturn this.valueOf();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node contains children with empty <code>expr</code>\n\t\t * property\n\t\t * @return {Boolean}\n\t\t */\n\t\thasEmptyChildren: function() {\n\t\t\treturn !!utils.find(this.children, function(child) {\n\t\t\t\treturn child.isEmpty();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node has implied name that should be resolved\n\t\t * @returns {Boolean}\n\t\t */\n\t\thasImplicitName: function() {\n\t\t\treturn !this._name && !this.isTextNode();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates that current element is a grouping one, e.g. has no \n\t\t * representation but serves as a container for other nodes\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisGroup: function() {\n\t\t\treturn !this.abbreviation;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates empty node (i.e. without abbreviation). It may be a \n\t\t * grouping node and should not be outputted\n\t\t * @return {Boolean}\n\t\t */\n\t\tisEmpty: function() {\n\t\t\treturn !this.abbreviation && !this.children.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates that current node should be repeated\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisRepeating: function() {\n\t\t\treturn this.repeatCount > 1 || this.hasImplicitRepeat;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node is a text-only node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTextNode: function() {\n\t\t\treturn !this.name() && !this.attributeList().length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates whether this node may be used to build elements or snippets\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisElement: function() {\n\t\t\treturn !this.isEmpty() && !this.isTextNode();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns latest and deepest child of current tree\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tdeepestChild: function() {\n\t\t\tif (!this.children.length)\n\t\t\t\treturn null;\n\t\t\t\t\n\t\t\tvar deepestChild = this;\n\t\t\twhile (deepestChild.children.length) {\n\t\t\t\tdeepestChild = deepestChild.children[deepestChild.children.length - 1];\n\t\t\t}\n\t\t\t\n\t\t\treturn deepestChild;\n\t\t}\n\t};\n\t\n\t/**\n\t * Returns stripped string: a string without first and last character.\n\t * Used for unquoting strings\n\t * @param {String} str\n\t * @returns {String}\n\t */\n\tfunction stripped(str) {\n\t\treturn str.substring(1, str.length - 1);\n\t}\n\t\n\tfunction consumeQuotedValue(stream, quote) {\n\t\tvar ch;\n\t\twhile ((ch = stream.next())) {\n\t\t\tif (ch === quote)\n\t\t\t\treturn true;\n\t\t\t\n\t\t\tif (ch == '\\\\')\n\t\t\t\tcontinue;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Parses abbreviation into a tree\n\t * @param {String} abbr\n\t * @returns {AbbreviationNode}\n\t */\n\tfunction parseAbbreviation(abbr) {\n\t\tabbr = utils.trim(abbr);\n\t\t\n\t\tvar root = new AbbreviationNode();\n\t\tvar context = root.addChild(), ch;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = stringStream.create(abbr);\n\t\tvar loopProtector = 1000, multiplier;\n\t\tvar addChild = function(child) {\n\t\t\tcontext.addChild(child);\n\t\t};\n\n\t\tvar consumeAbbr = function() {\n\t\t\tstream.start = stream.pos;\n\t\t\tstream.eatWhile(function(c) {\n\t\t\t\tif (c == '[' || c == '{') {\n\t\t\t\t\tif (stream.skipToPair(c, pairs[c])) {\n\t\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthrow new Error('Invalid abbreviation: mo matching \"' + pairs[c] + '\" found for character at ' + stream.pos);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (c == '+') {\n\t\t\t\t\t// let's see if this is an expando marker\n\t\t\t\t\tstream.next();\n\t\t\t\t\tvar isMarker = stream.eol() ||  ~'+>^*'.indexOf(stream.peek());\n\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\treturn isMarker;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn c != '(' && isAllowedChar(c);\n\t\t\t});\n\t\t};\n\t\t\n\t\twhile (!stream.eol() && --loopProtector > 0) {\n\t\t\tch = stream.peek();\n\t\t\t\n\t\t\tswitch (ch) {\n\t\t\t\tcase '(': // abbreviation group\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (stream.skipToPair('(', ')')) {\n\t\t\t\t\t\tvar inner = parseAbbreviation(stripped(stream.current()));\n\t\t\t\t\t\tif ((multiplier = stream.match(/^\\*(\\d+)?/, true))) {\n\t\t\t\t\t\t\tcontext._setRepeat(multiplier[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tinner.children.forEach(addChild);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Invalid abbreviation: mo matching \")\" found for character at ' + stream.pos);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '>': // child operator\n\t\t\t\t\tcontext = context.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '+': // sibling operator\n\t\t\t\t\tcontext = context.parent.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '^': // climb up operator\n\t\t\t\t\tvar parent = context.parent || context;\n\t\t\t\t\tcontext = (parent.parent || parent).addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault: // consume abbreviation\n\t\t\t\t\tconsumeAbbr();\n\t\t\t\t\tcontext.setAbbreviation(stream.current());\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (loopProtector < 1) {\n\t\t\tthrow new Error('Endless loop detected');\n\t\t}\n\t\t\n\t\treturn root;\n\t}\n\n\t/**\n\t * Splits attribute set into a list of attributes string\n\t * @param  {String} attrSet \n\t * @return {Array}\n\t */\n\tfunction splitAttributes(attrSet) {\n\t\tattrSet = utils.trim(attrSet);\n\t\tvar parts = [];\n\n\t\t// split attribute set by spaces\n\t\tvar stream = stringStream(attrSet), ch;\n\t\twhile ((ch = stream.next())) {\n\t\t\tif (ch == ' ') {\n\t\t\t\tparts.push(utils.trim(stream.current()));\n\t\t\t\t// skip spaces\n\t\t\t\twhile (stream.peek() == ' ') {\n\t\t\t\t\tstream.next();\n\t\t\t\t}\n\n\t\t\t\tstream.start = stream.pos;\n\t\t\t} else if (ch == '\"' || ch == \"'\") {\n\t\t\t\t// skip values in strings\n\t\t\t\tif (!stream.skipString(ch)) {\n\t\t\t\t\tthrow new Error('Invalid attribute set');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tparts.push(utils.trim(stream.current()));\n\t\treturn parts;\n\t}\n\n\t/**\n\t * Removes opening and closing quotes from given string\n\t * @param  {String} str\n\t * @return {String}\n\t */\n\tfunction unquote(str) {\n\t\tvar ch = str.charAt(0);\n\t\tif (ch == '\"' || ch == \"'\") {\n\t\t\tstr = str.substr(1);\n\t\t\tvar last = str.charAt(str.length - 1);\n\t\t\tif (last === ch) {\n\t\t\t\tstr = str.substr(0, str.length - 1);\n\t\t\t}\n\t\t}\n\n\t\treturn str;\n\t}\n\n\t/**\n\t * Extract attributes and their values from attribute set: \n\t * <code>[attr col=3 title=\"Quoted string\"]</code> (without square braces)\n\t * @param {String} attrSet\n\t * @returns {Array}\n\t */\n\tfunction extractAttributes(attrSet) {\n\t\tvar reAttrName = /^[\\w\\-:\\$@]+\\.?$/;\n\t\treturn splitAttributes(attrSet).map(function(attr) {\n\t\t\t// attribute name: [attr]\n\t\t\tif (reAttrName.test(attr)) {\n\t\t\t\tvar value = '';\n\t\t\t\tif (attr.charAt(attr.length - 1) == '.') {\n\t\t\t\t\t// a boolean attribute\n\t\t\t\t\tattr = attr.substr(0, attr.length - 1);\n\t\t\t\t\tvalue = attr;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tname: attr,\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// attribute with value: [name=val], [name=\"val\"]\n\t\t\tif (~attr.indexOf('=')) {\n\t\t\t\tvar parts = attr.split('=');\n\t\t\t\treturn {\n\t\t\t\t\tname: parts.shift(),\n\t\t\t\t\tvalue: unquote(parts.join('='))\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// looks like its implied attribute\n\t\t\treturn {\n\t\t\t\tname: DEFAULT_ATTR_NAME,\n\t\t\t\tvalue: unquote(attr)\n\t\t\t};\n\t\t});\n\t}\n\t\n\t/**\n\t * Parses tag attributes extracted from abbreviation. If attributes found, \n\t * returns object with <code>element</code> and <code>attributes</code>\n\t * properties\n\t * @param {String} abbr\n\t * @returns {Object} Returns <code>null</code> if no attributes found in \n\t * abbreviation\n\t */\n\tfunction parseAttributes(abbr) {\n\t\t/*\n\t\t * Example of incoming data:\n\t\t * #header\n\t\t * .some.data\n\t\t * .some.data#header\n\t\t * [attr]\n\t\t * #item[attr=Hello other=\"World\"].class\n\t\t */\n\t\tvar result = [];\n\t\tvar attrMap = {'#': 'id', '.': 'class'};\n\t\tvar nameEnd = null;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = stringStream.create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '#': // id\n\t\t\t\tcase '.': // class\n\t\t\t\t\tif (nameEnd === null)\n\t\t\t\t\t\tnameEnd = stream.pos;\n\t\t\t\t\t\n\t\t\t\t\tvar attrName = attrMap[stream.peek()];\n\t\t\t\t\t\n\t\t\t\t\tstream.next();\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.eatWhile(reWord);\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tname: attrName, \n\t\t\t\t\t\tvalue: stream.current()\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[': //begin attribute set\n\t\t\t\t\tif (nameEnd === null)\n\t\t\t\t\t\tnameEnd = stream.pos;\n\t\t\t\t\t\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (!stream.skipToPair('[', ']')) {\n\t\t\t\t\t\tthrow new Error('Invalid attribute set definition');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tresult = result.concat(\n\t\t\t\t\t\textractAttributes(stripped(stream.current()))\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!result.length)\n\t\t\treturn null;\n\t\t\n\t\treturn {\n\t\t\telement: abbr.substring(0, nameEnd),\n\t\t\tattributes: optimizeAttributes(result)\n\t\t};\n\t}\n\t\n\t/**\n\t * Optimize attribute set: remove duplicates and merge class attributes\n\t * @param attrs\n\t */\n\tfunction optimizeAttributes(attrs) {\n\t\t// clone all attributes to make sure that original objects are \n\t\t// not modified\n\t\tattrs = attrs.map(function(attr) {\n\t\t\treturn utils.clone(attr);\n\t\t});\n\t\t\n\t\tvar lookup = {};\n\n\t\treturn attrs.filter(function(attr) {\n\t\t\tif (!(attr.name in lookup)) {\n\t\t\t\treturn lookup[attr.name] = attr;\n\t\t\t}\n\t\t\t\n\t\t\tvar la = lookup[attr.name];\n\t\t\t\n\t\t\tif (attr.name.toLowerCase() == 'class') {\n\t\t\t\tla.value += (la.value.length ? ' ' : '') + attr.value;\n\t\t\t} else {\n\t\t\t\tla.value = attr.value;\n\t\t\t\tla.isImplied = !!attr.isImplied;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t});\n\t}\n\t\n\t/**\n\t * Extract text data from abbreviation: if <code>a{hello}</code> abbreviation\n\t * is passed, returns object <code>{element: 'a', text: 'hello'}</code>.\n\t * If nothing found, returns <code>null</code>\n\t * @param {String} abbr\n\t * \n\t */\n\tfunction extractText(abbr) {\n\t\tif (!~abbr.indexOf('{'))\n\t\t\treturn null;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = stringStream.create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '[':\n\t\t\t\tcase '(':\n\t\t\t\t\tstream.skipToPair(stream.peek(), pairs[stream.peek()]); break;\n\t\t\t\t\t\n\t\t\t\tcase '{':\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.skipToPair('{', '}');\n\t\t\t\t\treturn {\n\t\t\t\t\t\telement: abbr.substring(0, stream.start),\n\t\t\t\t\t\ttext: stripped(stream.current())\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Un-rolls contents of current node: recursively replaces all repeating \n\t * children with their repeated clones\n\t * @param {AbbreviationNode} node\n\t * @returns {AbbreviationNode}\n\t */\n\tfunction unroll(node) {\n\t\tfor (var i = node.children.length - 1, j, child, maxCount; i >= 0; i--) {\n\t\t\tchild = node.children[i];\n\t\t\t\n\t\t\tif (child.isRepeating()) {\n\t\t\t\tmaxCount = j = child.repeatCount;\n\t\t\t\tchild.repeatCount = 1;\n\t\t\t\tchild.updateProperty('counter', 1);\n\t\t\t\tchild.updateProperty('maxCount', maxCount);\n\t\t\t\twhile (--j > 0) {\n\t\t\t\t\tchild.parent.addChild(child.clone(), i + 1)\n\t\t\t\t\t\t.updateProperty('counter', j + 1)\n\t\t\t\t\t\t.updateProperty('maxCount', maxCount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// to keep proper 'counter' property, we need to walk\n\t\t// on children once again\n\t\tnode.children.forEach(unroll);\n\t\t\n\t\treturn node;\n\t}\n\t\n\t/**\n\t * Optimizes tree node: replaces empty nodes with their children\n\t * @param {AbbreviationNode} node\n\t * @return {AbbreviationNode}\n\t */\n\tfunction squash(node) {\n\t\tfor (var i = node.children.length - 1; i >= 0; i--) {\n\t\t\t/** @type AbbreviationNode */\n\t\t\tvar n = node.children[i];\n\t\t\tif (n.isGroup()) {\n\t\t\t\tn.replace(squash(n).children);\n\t\t\t} else if (n.isEmpty()) {\n\t\t\t\tn.remove();\n\t\t\t}\n\t\t}\n\t\t\n\t\tnode.children.forEach(squash);\n\t\t\n\t\treturn node;\n\t}\n\t\n\tfunction isAllowedChar(ch) {\n\t\tvar charCode = ch.charCodeAt(0);\n\t\tvar specialChars = '#.*:$-_!@|%';\n\t\t\n\t\treturn (charCode > 64 && charCode < 91)       // uppercase letter\n\t\t\t\t|| (charCode > 96 && charCode < 123)  // lowercase letter\n\t\t\t\t|| (charCode > 47 && charCode < 58)   // number\n\t\t\t\t|| specialChars.indexOf(ch) != -1;    // special character\n\t}\n\n\t// XXX add counter replacer function as output processor\n\toutputProcessors.push(function(text, node) {\n\t\treturn utils.replaceCounter(text, node.counter, node.maxCount);\n\t});\n\n\t// XXX add tabstop updater\n\toutputProcessors.push(tabStops.abbrOutputProcessor.bind(tabStops));\n\n\t// include default pre- and postprocessors\n\t[lorem, procResourceMatcher, procAttributes, procPastedContent, procTagName, procHref].forEach(function(mod) {\n\t\tif (mod.preprocessor) {\n\t\t\tpreprocessors.push(mod.preprocessor.bind(mod));\n\t\t}\n\n\t\tif (mod.postprocessor) {\n\t\t\tpostprocessors.push(mod.postprocessor.bind(mod));\n\t\t}\n\t});\n\n\treturn {\n\t\tDEFAULT_ATTR_NAME: DEFAULT_ATTR_NAME,\n\n\t\t/**\n\t\t * Parses abbreviation into tree with respect of groups, \n\t\t * text nodes and attributes. Each node of the tree is a single \n\t\t * abbreviation. Tree represents actual structure of the outputted \n\t\t * result\n\t\t * @memberOf abbreviationParser\n\t\t * @param {String} abbr Abbreviation to parse\n\t\t * @param {Object} options Additional options for parser and processors\n\t\t * \n\t\t * @return {AbbreviationNode}\n\t\t */\n\t\tparse: function(abbr, options) {\n\t\t\toptions = options || {};\n\t\t\t\n\t\t\tvar tree = parseAbbreviation(abbr);\n\t\t\tvar that = this;\n\t\t\t\n\t\t\tif (options.contextNode) {\n\t\t\t\t// add info about context node \n\t\t\t\t// a parent XHTML node in editor inside which abbreviation is \n\t\t\t\t// expanded\n\t\t\t\ttree._name = options.contextNode.name;\n\t\t\t\tvar attrLookup = {};\n\t\t\t\ttree._attributes.forEach(function(attr) {\n\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\toptions.contextNode.attributes.forEach(function(attr) {\n\t\t\t\t\tif (attr.name in attrLookup) {\n\t\t\t\t\t\tattrLookup[attr.name].value = attr.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tattr = utils.clone(attr);\n\t\t\t\t\t\ttree._attributes.push(attr);\n\t\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t// apply preprocessors\n\t\t\tpreprocessors.forEach(function(fn) {\n\t\t\t\tfn(tree, options, that);\n\t\t\t});\n\n\t\t\tif ('counter' in options) {\n\t\t\t\ttree.updateProperty('counter', options.counter);\n\t\t\t}\n\t\t\t\n\t\t\ttree = squash(unroll(tree));\n\t\t\t\n\t\t\t// apply postprocessors\n\t\t\tpostprocessors.forEach(function(fn) {\n\t\t\t\tfn(tree, options, that);\n\t\t\t});\n\t\t\t\n\t\t\treturn tree;\n\t\t},\n\n\t\t/**\n\t\t * Expands given abbreviation into a formatted code structure.\n\t\t * This is the main method that is used for expanding abbreviation\n\t\t * @param {String} abbr Abbreviation to expand\n\t\t * @param {Options} options Additional options for abbreviation\n\t\t * expanding and transformation: `syntax`, `profile`, `contextNode` etc.\n\t\t * @return {String}\n\t\t */\n\t\texpand: function(abbr, options) {\n\t\t\tif (!abbr) return '';\n\t\t\tif (typeof options == 'string') {\n\t\t\t\tthrow new Error('Deprecated use of `expand` method: `options` must be object');\n\t\t\t}\n\n\t\t\toptions = options || {};\n\n\t\t\tif (!options.syntax) {\n\t\t\t\toptions.syntax = utils.defaultSyntax();\n\t\t\t}\n\n\t\t\tvar p = profile.get(options.profile, options.syntax);\n\t\t\ttabStops.resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extract(abbr);\n\t\t\tvar outputTree = this.parse(data[0], options);\n\n\t\t\tvar filtersList = filters.composeList(options.syntax, p, data[1]);\n\t\t\tfilters.apply(outputTree, filtersList, p);\n\n\t\t\treturn outputTree.valueOf();\n\t\t},\n\t\t\n\t\tAbbreviationNode: AbbreviationNode,\n\t\t\n\t\t/**\n\t\t * Add new abbreviation preprocessor. <i>Preprocessor</i> is a function\n\t\t * that applies to a parsed abbreviation tree right after it get parsed.\n\t\t * The passed tree is in unoptimized state.\n\t\t * @param {Function} fn Preprocessor function. This function receives\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\n\t\t * method\n\t\t */\n\t\taddPreprocessor: function(fn) {\n\t\t\tif (!~preprocessors.indexOf(fn)) {\n\t\t\t\tpreprocessors.push(fn);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered preprocessor\n\t\t */\n\t\tremoveFilter: function(fn) {\n\t\t\tvar ix = preprocessors.indexOf(fn);\n\t\t\tif (~ix) {\n\t\t\t\tpreprocessors.splice(ix, 1);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new abbreviation postprocessor. <i>Postprocessor</i> is a \n\t\t * functinon that applies to <i>optimized</i> parsed abbreviation tree\n\t\t * right before it returns from <code>parse()</code> method\n\t\t * @param {Function} fn Postprocessor function. This function receives\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\n\t\t * method\n\t\t */\n\t\taddPostprocessor: function(fn) {\n\t\t\tif (!~postprocessors.indexOf(fn)) {\n\t\t\t\tpostprocessors.push(fn);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered postprocessor function\n\t\t */\n\t\tremovePostprocessor: function(fn) {\n\t\t\tvar ix = postprocessors.indexOf(fn);\n\t\t\tif (~ix) {\n\t\t\t\tpostprocessors.splice(ix, 1);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Registers output postprocessor. <i>Output processor</i> is a \n\t\t * function that applies to output part (<code>start</code>, \n\t\t * <code>end</code> and <code>content</code>) when \n\t\t * <code>AbbreviationNode.toString()</code> method is called\n\t\t */\n\t\taddOutputProcessor: function(fn) {\n\t\t\tif (!~outputProcessors.indexOf(fn)) {\n\t\t\t\toutputProcessors.push(fn);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered output processor\n\t\t */\n\t\tremoveOutputProcessor: function(fn) {\n\t\t\tvar ix = outputProcessors.indexOf(fn);\n\t\t\tif (~ix) {\n\t\t\t\toutputProcessors.splice(ix, 1);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed symbol is valid symbol for abbreviation expression\n\t\t * @param {String} ch\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedChar: function(ch) {\n\t\t\tch = String(ch); // convert Java object to JS\n\t\t\treturn isAllowedChar(ch) || ~'>+^[](){}'.indexOf(ch);\n\t\t}\n\t};\n});\n},{\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../filter/main\":\"filter\\\\main.js\",\"../generator/lorem\":\"generator\\\\lorem.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./processor/attributes\":\"parser\\\\processor\\\\attributes.js\",\"./processor/href\":\"parser\\\\processor\\\\href.js\",\"./processor/pastedContent\":\"parser\\\\processor\\\\pastedContent.js\",\"./processor/resourceMatcher\":\"parser\\\\processor\\\\resourceMatcher.js\",\"./processor/tagName\":\"parser\\\\processor\\\\tagName.js\"}],\"parser\\\\css.js\":[function(require,module,exports){\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar session = {tokens: null};\n\t\n\t// walks around the source\n\tvar walker = {\n\t\tinit: function (source) {\n\t\t\t// this.source = source.replace(/\\r\\n?/g, '\\n');\n\t\t\tthis.source = source;\n\t\t\tthis.ch = '';\n\t\t\tthis.chnum = -1;\n\t\t\n\t\t\t// advance\n\t\t\tthis.nextChar();\n\t\t},\n\t\tnextChar: function () {\n\t\t\treturn this.ch = this.source.charAt(++this.chnum);\n\t\t},\n\t\tpeek: function() {\n\t\t\treturn this.source.charAt(this.chnum + 1);\n\t\t}\n\t};\n\n\t// utility helpers\n\tfunction isNameChar(c, cc) {\n\t\tcc = cc || c.charCodeAt(0);\n\t\treturn (\n\t\t\t(cc >= 97 && cc <= 122 /* a-z */) || \n\t\t\t(cc >= 65 && cc <= 90 /* A-Z */) || \n\t\t\t/* \n\t\t\tExperimental: include cyrillic ranges \n\t\t\tsince some letters, similar to latin ones, can \n\t\t\taccidentally appear in CSS tokens\n\t\t\t*/\n\t\t\t(cc >= 1024 && cc <= 1279) || \n\t\t\tc === '&' || /* selector placeholder (LESS, SCSS) */\n\t\t\tc === '_' || \n\t\t\tc === '<' || /* comparisons (LESS, SCSS) */\n\t\t\tc === '>' || \n\t\t\tc === '=' || \n\t\t\tc === '-'\n\t\t);\n\t}\n\n\tfunction isDigit(c, cc) {\n\t\tcc = cc || c.charCodeAt(0);\n\t\treturn (cc >= 48 && cc <= 57);\n\t}\n\n\tvar isOp = (function () {\n\t\tvar opsa = \"{}[]()+*=.,;:>~|\\\\%$#@^!\".split(''),\n\t\t\topsmatcha = \"*^|$~\".split(''),\n\t\t\tops = {},\n\t\t\topsmatch = {},\n\t\t\ti = 0;\n\t\tfor (; i < opsa.length; i += 1) {\n\t\t\tops[opsa[i]] = true;\n\t\t}\n\t\tfor (i = 0; i < opsmatcha.length; i += 1) {\n\t\t\topsmatch[opsmatcha[i]] = true;\n\t\t}\n\t\treturn function (ch, matchattr) {\n\t\t\tif (matchattr) {\n\t\t\t\treturn ch in opsmatch;\n\t\t\t}\n\t\t\treturn ch in ops;\n\t\t};\n\t}());\n\t\n\t// creates token objects and pushes them to a list\n\tfunction tokener(value, type) {\n\t\tsession.tokens.push({\n\t\t\tvalue: value,\n\t\t\ttype:  type || value,\n\t\t\tstart: null,\n\t\t\tend:   null\n\t\t});\n\t}\n\n\tfunction getPosInfo(w) {\n\t\tvar errPos = w.chnum;\n\t\tvar source = w.source.replace(/\\r\\n?/g, '\\n');\n\t\tvar part = w.source.substring(0, errPos + 1).replace(/\\r\\n?/g, '\\n');\n\t\tvar lines = part.split('\\n');\n\t\tvar ch = (lines[lines.length - 1] || '').length;\n\t\tvar fullLine = source.split('\\n')[lines.length - 1] || '';\n\t\t\n\t\tvar chunkSize = 100;\n\t\tvar offset = Math.max(0, ch - chunkSize);\n\t\tvar formattedLine = fullLine.substr(offset, chunkSize * 2) + '\\n';\n\t\tfor (var i = 0; i < ch - offset - 1; i++) {\n\t\t\tformattedLine += '-';\n\t\t}\n\t\tformattedLine += '^';\n\n\t\treturn {\n\t\t\tline: lines.length,\n\t\t\tch: ch,\n\t\t\ttext: fullLine,\n\t\t\thint: formattedLine\n\t\t};\n\t}\n\n\tfunction raiseError(message) {\n\t\tvar err = error(message);\n\t\tvar errObj = new Error(err.message, '', err.line);\n\t\terrObj.line = err.line;\n\t\terrObj.ch = err.ch;\n\t\terrObj.name = err.name;\n\t\terrObj.hint = err.hint;\n\n\t\tthrow errObj;\n\t}\n\t\n\t// oops\n\tfunction error(m) { \n\t\tvar w = walker;\n\t\tvar info = getPosInfo(walker);\n\t\tvar tokens = session.tokens;\n\t\tsession.tokens = null;\n\n\t\tvar message = 'CSS parsing error at line ' + info.line + ', char ' + info.ch + ': ' + m;\n\t\tmessage += '\\n' +  info.hint;\n\t\treturn {\n\t\t\tname: \"ParseError\",\n\t\t\tmessage: message,\n\t\t\thint: info.hint,\n\t\t\tline: info.line,\n\t\t\tch: info.ch\n\t\t};\n\t}\n\n\n\t// token handlers follow for:\n\t// white space, comment, string, identifier, number, operator\n\tfunction white() {\n\t\tvar c = walker.ch,\n\t\t\ttoken = '';\n\t\n\t\twhile (c === \" \" || c === \"\\t\") {\n\t\t\ttoken += c;\n\t\t\tc = walker.nextChar();\n\t\t}\n\t\n\t\ttokener(token, 'white');\n\t\n\t}\n\n\tfunction comment() {\n\t\tvar w = walker,\n\t\t\tc = w.ch,\n\t\t\ttoken = c,\n\t\t\tcnext;\n\t \n\t\tcnext = w.nextChar();\n\n\t\tif (cnext === '/') {\n\t\t\t// inline comment in SCSS and LESS\n\t\t\twhile (c && !(cnext === \"\\n\" || cnext === \"\\r\")) {\n\t\t\t\ttoken += cnext;\n\t\t\t\tc = cnext;\n\t\t\t\tcnext = w.nextChar();\n\t\t\t}\n\t\t} else if (cnext === '*') {\n\t\t\t// multiline CSS commment\n\t\t\twhile (c && !(c === \"*\" && cnext === \"/\")) {\n\t\t\t\ttoken += cnext;\n\t\t\t\tc = cnext;\n\t\t\t\tcnext = w.nextChar();\n\t\t\t}\n\t\t} else {\n\t\t\t// oops, not a comment, just a /\n\t\t\treturn tokener(token, token);\n\t\t}\n\t\t\n\t\ttoken += cnext;\n\t\tw.nextChar();\n\t\ttokener(token, 'comment');\n\t}\n\n\tfunction eatString() {\n\t\tvar w = walker,\n\t\t\tc = w.ch,\n\t\t\tq = c,\n\t\t\ttoken = c,\n\t\t\tcnext;\n\t\n\t\tc = w.nextChar();\n\n\t\twhile (c !== q) {\n\t\t\tif (c === '\\n') {\n\t\t\t\tcnext = w.nextChar();\n\t\t\t\tif (cnext === \"\\\\\") {\n\t\t\t\t\ttoken += c + cnext;\n\t\t\t\t} else {\n\t\t\t\t\t// end of line with no \\ escape = bad\n\t\t\t\t\traiseError(\"Unterminated string\");\n\t\t\t\t}\n\t\t\t} else if (c === '') {\n\t\t\t\traiseError(\"Unterminated string\");\n\t\t\t} else {\n\t\t\t\tif (c === \"\\\\\") {\n\t\t\t\t\ttoken += c + w.nextChar();\n\t\t\t\t} else {\n\t\t\t\t\ttoken += c;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tc = w.nextChar();\n\t\t}\n\n\t\ttoken += c;\n\n\t\treturn token;\n\t}\n\n\tfunction str() {\n\t\tvar token = eatString();\n\t\twalker.nextChar();\n\t\ttokener(token, 'string');\n\t}\n\t\n\tfunction brace() {\n\t\tvar w = walker,\n\t\t\tc = w.ch,\n\t\t\tdepth = 1,\n\t\t\ttoken = c,\n\t\t\tstop = false;\n\t\n\t\tc = w.nextChar();\n\t\n\t\twhile (c && !stop) {\n\t\t\tif (c === '(') {\n\t\t\t\tdepth++;\n\t\t\t} else if (c === ')') {\n\t\t\t\tdepth--;\n\t\t\t\tif (!depth) {\n\t\t\t\t\tstop = true;\n\t\t\t\t}\n\t\t\t} else if (c === '\"' || c === \"'\") {\n\t\t\t\tc = eatString();\n\t\t\t} else if (c === '') {\n\t\t\t\traiseError(\"Unterminated brace\");\n\t\t\t}\n\t\t\t\n\t\t\ttoken += c;\n\t\t\tc = w.nextChar();\n\t\t}\n\t\t\n\t\ttokener(token, 'brace');\n\t}\n\n\tfunction identifier(pre) {\n\t\tvar c = walker.ch;\n\t\tvar token = pre ? pre + c : c;\n\t\t\t\n\t\tc = walker.nextChar();\n\t\tvar cc = c.charCodeAt(0);\n\t\twhile (isNameChar(c, cc) || isDigit(c, cc)) {\n\t\t\ttoken += c;\n\t\t\tc = walker.nextChar();\n\t\t\tcc = c.charCodeAt(0);\n\t\t}\n\t\n\t\ttokener(token, 'identifier');\n\t}\n\n\tfunction num() {\n\t\tvar w = walker,\n\t\t\tc = w.ch,\n\t\t\ttoken = c,\n\t\t\tpoint = token === '.',\n\t\t\tnondigit;\n\t\t\n\t\tc = w.nextChar();\n\t\tnondigit = !isDigit(c);\n\t\n\t\t// .2px or .classname?\n\t\tif (point && nondigit) {\n\t\t\t// meh, NaN, could be a class name, so it's an operator for now\n\t\t\treturn tokener(token, '.');    \n\t\t}\n\t\t\n\t\t// -2px or -moz-something\n\t\tif (token === '-' && nondigit) {\n\t\t\treturn identifier('-');\n\t\t}\n\t\n\t\twhile (c !== '' && (isDigit(c) || (!point && c === '.'))) { // not end of source && digit or first instance of .\n\t\t\tif (c === '.') {\n\t\t\t\tpoint = true;\n\t\t\t}\n\t\t\ttoken += c;\n\t\t\tc = w.nextChar();\n\t\t}\n\n\t\ttokener(token, 'number');    \n\t\n\t}\n\n\tfunction op() {\n\t\tvar w = walker,\n\t\t\tc = w.ch,\n\t\t\ttoken = c,\n\t\t\tnext = w.nextChar();\n\t\t\t\n\t\tif (next === \"=\" && isOp(token, true)) {\n\t\t\ttoken += next;\n\t\t\ttokener(token, 'match');\n\t\t\tw.nextChar();\n\t\t\treturn;\n\t\t} \n\t\t\n\t\ttokener(token, token);\n\t}\n\n\n\t// call the appropriate handler based on the first character in a token suspect\n\tfunction tokenize() {\n\t\tvar ch = walker.ch;\n\t\n\t\tif (ch === \" \" || ch === \"\\t\") {\n\t\t\treturn white();\n\t\t}\n\n\t\tif (ch === '/') {\n\t\t\treturn comment();\n\t\t} \n\n\t\tif (ch === '\"' || ch === \"'\") {\n\t\t\treturn str();\n\t\t}\n\t\t\n\t\tif (ch === '(') {\n\t\t\treturn brace();\n\t\t}\n\t\n\t\tif (ch === '-' || ch === '.' || isDigit(ch)) { // tricky - char: minus (-1px) or dash (-moz-stuff)\n\t\t\treturn num();\n\t\t}\n\t\n\t\tif (isNameChar(ch)) {\n\t\t\treturn identifier();\n\t\t}\n\n\t\tif (isOp(ch)) {\n\t\t\treturn op();\n\t\t}\n\n\t\tif (ch === '\\r') {\n\t\t\tif (walker.peek() === '\\n') {\n\t\t\t\tch += walker.nextChar();\n\t\t\t}\n\n\t\t\ttokener(ch, 'line');\n\t\t\twalker.nextChar();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (ch === '\\n') {\n\t\t\ttokener(ch, 'line');\n\t\t\twalker.nextChar();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\traiseError(\"Unrecognized character '\" + ch + \"'\");\n\t}\n\n\treturn {\n\t\t/**\n\t\t * Sprits given source into tokens\n\t\t * @param {String} source\n\t\t * @returns {Array}\n\t\t */\n\t\tlex: function (source) {\n\t\t\twalker.init(source);\n\t\t\tsession.tokens = [];\n\n\t\t\t// for empty source, return single space token\n\t\t\tif (!source) {\n\t\t\t\tsession.tokens.push(this.white());\n\t\t\t} else {\n\t\t\t\twhile (walker.ch !== '') {\n\t\t\t\t\ttokenize();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar tokens = session.tokens;\n\t\t\tsession.tokens = null;\n\t\t\treturn tokens;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Tokenizes CSS source. It's like `lex()` method,\n\t\t * but also stores proper token indexes in source, \n\t\t * so it's a bit slower\n\t\t * @param {String} source\n\t\t * @returns {Array}\n\t\t */\n\t\tparse: function(source) {\n\t\t\t// transform tokens\n\t\t\tvar tokens = this.lex(source), pos = 0, token;\n\t\t\tfor (var i = 0, il = tokens.length; i < il; i++) {\n\t\t\t\ttoken = tokens[i];\n\t\t\t\ttoken.start = pos;\n\t\t\t\ttoken.end = (pos += token.value.length);\n\t\t\t}\n\t\t\treturn tokens;\n\t\t},\n\n\t\twhite: function() {\n\t\t\treturn {\n\t\t\t\tvalue: '',\n\t\t\t\ttype:  'white',\n\t\t\t\tstart: 0,\n\t\t\t\tend:   0\n\t\t\t};\n\t\t},\n\t\t\n\t\ttoSource: function(toks) {\n\t\t\tvar i = 0, max = toks.length, src = '';\n\t\t\tfor (; i < max; i++) {\n\t\t\t\tsrc += toks[i].value;\n\t\t\t}\n\t\t\treturn src;\n\t\t}\n\t};\n});\n},{}],\"parser\\\\processor\\\\attributes.js\":[function(require,module,exports){\n/**\n * Resolves node attribute names: moves `default` attribute value\n * from stub to real attribute.\n *\n * This resolver should be applied *after* resource matcher\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../../utils/common');\n\n\tvar findDefault = function(attr) {\n\t\treturn attr.isDefault;\n\t};\n\n\tvar findImplied = function(attr) {\n\t\treturn attr.isImplied;\n\t};\n\n\tvar findEmpty = function(attr) {\n\t\treturn !attr.value;\n\t};\n\n\tfunction resolveDefaultAttrs(node, parser) {\n\t\tnode.children.forEach(function(item) {\n\t\t\tvar attrList = item.attributeList();\n\t\t\tvar defaultAttrValue = item.attribute(parser.DEFAULT_ATTR_NAME);\n\t\t\tif (typeof defaultAttrValue !== 'undefined') {\n\t\t\t\t// remove stub attribute\n\t\t\t\titem.attribute(parser.DEFAULT_ATTR_NAME, null);\n\t\t\t\t\n\t\t\t\tif (attrList.length) {\n\t\t\t\t\t// target for default value:\n\t\t\t\t\t// 1. default attribute\n\t\t\t\t\t// 2. implied attribute\n\t\t\t\t\t// 3. first empty attribute\n\t\t\t\t\n\t\t\t\t\t// find attribute marked as default\n\t\t\t\t\tvar defaultAttr = utils.find(attrList, findDefault) \n\t\t\t\t\t\t|| utils.find(attrList, findImplied) \n\t\t\t\t\t\t|| utils.find(attrList, findEmpty);\n\n\t\t\t\t\tif (defaultAttr) {\n\t\t\t\t\t\tvar oldVal = item.attribute(defaultAttr.name);\n\t\t\t\t\t\tvar newVal = utils.replaceUnescapedSymbol(oldVal, '|', defaultAttrValue);\n\t\t\t\t\t\t// no replacement, e.g. default value does not contains | symbol\n\t\t\t\t\t\tif (oldVal == newVal) {\n\t\t\t\t\t\t\tnewVal = defaultAttrValue\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\titem.attribute(defaultAttr.name, newVal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if no default attribute value, remove implied attributes\n\t\t\t\tattrList.forEach(function(attr) {\n\t\t\t\t\tif (attr.isImplied) {\n\t\t\t\t\t\titem.attribute(attr.name, null);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tresolveDefaultAttrs(item, parser);\n\t\t});\n\t}\n\n\treturn {\n\t\t/**\n\t\t * @param  {AbbreviationNode} tree\n\t\t * @param  {Object} options\n\t\t * @param  {abbreviation} parser\n\t\t */\n\t\tpreprocessor: function(tree, options, parser) {\n\t\t\tresolveDefaultAttrs(tree, parser);\n\t\t}\n\t};\n});\n},{\"../../utils/common\":\"utils\\\\common.js\"}],\"parser\\\\processor\\\\href.js\":[function(require,module,exports){\n/**\n * A preptocessor for &lt;a&gt; tag: tests wrapped content\n * for common URL patterns and, if matched, inserts it as \n * `href` attribute\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar prefs = require('../../assets/preferences');\n\tvar utils = require('../../utils/common');\n\tvar pc = require('./pastedContent');\n\n\tprefs.define('href.autodetect', true, \n\t\t'Enables or disables automatic URL recognition when wrapping\\\n\t\ttext with <code>&lt;a&gt;</code> tag. With this option enabled,\\\n\t\tif wrapped text matches URL or e-mail pattern it will be automatically\\\n\t\tinserted into <code>href</code> attribute.');\n\tprefs.define('href.urlPattern', '^(?:(?:https?|ftp|file)://|www\\\\.|ftp\\\\.)(?:\\\\([-A-Z0-9+&@#/%=~_|$?!:,.]*\\\\)|[-A-Z0-9+&@#/%=~_|$?!:,.])*(?:\\\\([-A-Z0-9+&@#/%=~_|$?!:,.]*\\\\)|[A-Z0-9+&@#/%=~_|$])', \n\t\t'RegExp pattern to match wrapped URLs. Matched content will be inserts\\\n\t\tas-is into <code>href</code> attribute, only whitespace will be trimmed.');\n\n\tprefs.define('href.emailPattern', '^[a-z0-9._%+-]+@[a-z0-9.-]+\\\\.[a-z]{2,5}$', \n\t\t'RegExp pattern to match wrapped e-mails. Unlike <code>href.urlPattern</code>,\\\n\t\twrapped content will be prefixed with <code>mailto:</code> in <code>href</code>\\\n\t\tattribute');\n\n\treturn {\n\t\t/**\n\t\t * @param {AbbreviationNode} tree\n\t\t * @param {Object} options\n\t\t */\n\t\tpostprocessor: function(tree, options) {\n\t\t\tif (!prefs.get('href.autodetect')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar reUrl = new RegExp(prefs.get('href.urlPattern'), 'i');\n\t\t\tvar reEmail = new RegExp(prefs.get('href.emailPattern'), 'i');\n\t\t\tvar reProto = /^([a-z]+:)?\\/\\//i;\n\n\t\t\ttree.findAll(function(item) {\n\t\t\t\tif (item.name().toLowerCase() != 'a' || item.attribute('href')) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar pastedContent = utils.trim(pc.pastedContent(item) || options.pastedContent);\n\t\t\t\tif (pastedContent) {\n\t\t\t\t\tif (reUrl.test(pastedContent)) {\n\t\t\t\t\t\t// do we have protocol?\n\t\t\t\t\t\tif (!reProto.test(pastedContent)) {\n\t\t\t\t\t\t\tpastedContent = 'http://' + pastedContent;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titem.attribute('href', pastedContent);\n\t\t\t\t\t} else if (reEmail.test(pastedContent)) {\n\t\t\t\t\t\titem.attribute('href', 'mailto:' + pastedContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n});\n},{\"../../assets/preferences\":\"assets\\\\preferences.js\",\"../../utils/common\":\"utils\\\\common.js\",\"./pastedContent\":\"parser\\\\processor\\\\pastedContent.js\"}],\"parser\\\\processor\\\\pastedContent.js\":[function(require,module,exports){\n/**\n * Pasted content abbreviation processor. A pasted content is a content that\n * should be inserted into implicitly repeated abbreviation nodes.\n * This processor powers Wrap With Abbreviation action\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../../utils/common');\n\tvar abbrUtils = require('../../utils/abbreviation');\n\tvar stringStream = require('../../assets/stringStream');\n\tvar range = require('../../assets/range');\n\n\tvar outputPlaceholder = '$#';\n\t\n\t/**\n\t * Locates output placeholders inside text\n\t * @param {String} text\n\t * @returns {Array} Array of ranges of output placeholder in text\n\t */\n\tfunction locateOutputPlaceholder(text) {\n\t\tvar result = [];\n\t\t\n\t\tvar stream = stringStream.create(text);\n\t\t\n\t\twhile (!stream.eol()) {\n\t\t\tif (stream.peek() == '\\\\') {\n\t\t\t\tstream.next();\n\t\t\t} else {\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tif (stream.match(outputPlaceholder, true)) {\n\t\t\t\t\tresult.push(range.create(stream.start, outputPlaceholder));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstream.next();\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Replaces output placeholders inside <code>source</code> with \n\t * <code>value</code>\n\t * @param {String} source\n\t * @param {String} value\n\t * @returns {String}\n\t */\n\tfunction replaceOutputPlaceholders(source, value) {\n\t\tvar ranges = locateOutputPlaceholder(source);\n\t\t\n\t\tranges.reverse().forEach(function(r) {\n\t\t\tsource = utils.replaceSubstring(source, value, r);\n\t\t});\n\t\t\n\t\treturn source;\n\t}\n\t\n\t/**\n\t * Check if parsed node contains output placeholder  a target where\n\t * pasted content should be inserted\n\t * @param {AbbreviationNode} node\n\t * @returns {Boolean}\n\t */\n\tfunction hasOutputPlaceholder(node) {\n\t\tif (locateOutputPlaceholder(node.content).length)\n\t\t\treturn true;\n\t\t\n\t\t// check if attributes contains placeholder\n\t\treturn !!utils.find(node.attributeList(), function(attr) {\n\t\t\treturn !!locateOutputPlaceholder(attr.value).length;\n\t\t});\n\t}\n\t\n\t/**\n\t * Insert pasted content into correct positions of parsed node\n\t * @param {AbbreviationNode} node\n\t * @param {String} content\n\t * @param {Boolean} overwrite Overwrite node content if no value placeholders\n\t * found instead of appending to existing content\n\t */\n\tfunction insertPastedContent(node, content, overwrite) {\n\t\tvar nodesWithPlaceholders = node.findAll(function(item) {\n\t\t\treturn hasOutputPlaceholder(item);\n\t\t});\n\t\t\n\t\tif (hasOutputPlaceholder(node))\n\t\t\tnodesWithPlaceholders.unshift(node);\n\t\t\n\t\tif (nodesWithPlaceholders.length) {\n\t\t\tnodesWithPlaceholders.forEach(function(item) {\n\t\t\t\titem.content = replaceOutputPlaceholders(item.content, content);\n\t\t\t\titem._attributes.forEach(function(attr) {\n\t\t\t\t\tattr.value = replaceOutputPlaceholders(attr.value, content);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\t// on output placeholders in subtree, insert content in the deepest\n\t\t\t// child node\n\t\t\tvar deepest = node.deepestChild() || node;\n\t\t\tif (overwrite) {\n\t\t\t\tdeepest.content = content;\n\t\t\t} else {\n\t\t\t\tdeepest.content = abbrUtils.insertChildContent(deepest.content, content);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tpastedContent: function(item) {\n\t\t\tvar content = item.data('paste');\n\t\t\tif (Array.isArray(content)) {\n\t\t\t\treturn content[item.counter - 1];\n\t\t\t} else if (typeof content === 'function') {\n\t\t\t\treturn content(item.counter - 1, item.content);\n\t\t\t} else if (content) {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @param {AbbreviationNode} tree\n\t\t * @param {Object} options\n\t\t */\n\t\tpreprocessor: function(tree, options) {\n\t\t\tif (options.pastedContent) {\n\t\t\t\tvar lines = utils.splitByLines(options.pastedContent, true).map(utils.trim);\n\t\t\t\t\n\t\t\t\t// set repeat count for implicitly repeated elements before\n\t\t\t\t// tree is unrolled\n\t\t\t\ttree.findAll(function(item) {\n\t\t\t\t\tif (item.hasImplicitRepeat) {\n\t\t\t\t\t\titem.data('paste', lines);\n\t\t\t\t\t\treturn item.repeatCount = lines.length;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @param {AbbreviationNode} tree\n\t\t * @param {Object} options\n\t\t */\n\t\tpostprocessor: function(tree, options) {\n\t\t\tvar that = this;\n\t\t\t// for each node with pasted content, update text data\n\t\t\tvar targets = tree.findAll(function(item) {\n\t\t\t\tvar pastedContent = that.pastedContent(item);\n\t\t\t\tif (pastedContent) {\n\t\t\t\t\tinsertPastedContent(item, pastedContent, !!item.data('pasteOverwrites'));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn !!pastedContent;\n\t\t\t});\n\t\t\t\n\t\t\tif (!targets.length && options.pastedContent) {\n\t\t\t\t// no implicitly repeated elements, put pasted content in\n\t\t\t\t// the deepest child\n\t\t\t\tinsertPastedContent(tree, options.pastedContent);\n\t\t\t}\n\t\t}\n\t};\n});\n},{\"../../assets/range\":\"assets\\\\range.js\",\"../../assets/stringStream\":\"assets\\\\stringStream.js\",\"../../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../../utils/common\":\"utils\\\\common.js\"}],\"parser\\\\processor\\\\resourceMatcher.js\":[function(require,module,exports){\n/**\n * Processor function that matches parsed <code>AbbreviationNode</code>\n * against resources defined in <code>resource</code> module\n */ \nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar resources = require('../../assets/resources');\n\tvar elements = require('../../assets/elements');\n\tvar utils = require('../../utils/common');\n\tvar abbreviationUtils = require('../../utils/abbreviation');\n\n\t/**\n\t * Finds matched resources for child nodes of passed <code>node</code> \n\t * element. A matched resource is a reference to <i>snippets.json</i> entry\n\t * that describes output of parsed node \n\t * @param {AbbreviationNode} node\n\t * @param {String} syntax\n\t */\n\tfunction matchResources(node, syntax, parser) {\n\t\t// do a shallow copy because the children list can be modified during\n\t\t// resource matching\n\t\tnode.children.slice(0).forEach(function(child) {\n\t\t\tvar r = resources.getMatchedResource(child, syntax);\n\t\t\tif (typeof r === 'string') {\n\t\t\t\tr = elements.create('snippet', r);\n\t\t\t}\n\n\t\t\tchild.data('resource', r);\n\t\t\tvar elemType = elements.type(r);\n\n\t\t\tif (elemType == 'snippet') {\n\t\t\t\tvar content = r.data;\n\t\t\t\tvar curContent = child._text || child.content;\n\t\t\t\tif (curContent) {\n\t\t\t\t\tcontent = abbreviationUtils.insertChildContent(content, curContent);\n\t\t\t\t}\n\n\t\t\t\tchild.content = content;\n\t\t\t} else if (elemType == 'element') {\n\t\t\t\tchild._name = r.name;\n\t\t\t\tif (Array.isArray(r.attributes)) {\n\t\t\t\t\tchild._attributes = [].concat(r.attributes, child._attributes);\n\t\t\t\t}\n\t\t\t} else if (elemType == 'reference') {\n\t\t\t\t// its a reference to another abbreviation:\n\t\t\t\t// parse it and insert instead of current child\n\t\t\t\t/** @type AbbreviationNode */\n\t\t\t\tvar subtree = parser.parse(r.data, {\n\t\t\t\t\tsyntax: syntax\n\t\t\t\t});\n\n\t\t\t\t// if context element should be repeated, check if we need to \n\t\t\t\t// transfer repeated element to specific child node\n\t\t\t\tif (child.repeatCount > 1) {\n\t\t\t\t\tvar repeatedChildren = subtree.findAll(function(node) {\n\t\t\t\t\t\treturn node.hasImplicitRepeat;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!repeatedChildren.length) {\n\t\t\t\t\t\trepeatedChildren = subtree.children\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\trepeatedChildren.forEach(function(node) {\n\t\t\t\t\t\tnode.repeatCount = child.repeatCount;\n\t\t\t\t\t\tnode.hasImplicitRepeat = false;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// move childs children into the deepest child of new subtree\n\t\t\t\tvar deepestChild = subtree.deepestChild();\n\t\t\t\tif (deepestChild) {\n\t\t\t\t\tchild.children.forEach(function(c) {\n\t\t\t\t\t\tdeepestChild.addChild(c);\n\t\t\t\t\t});\n\t\t\t\t\tdeepestChild.content = child.content;\n\t\t\t\t}\n\n\t\t\t\t// copy current attributes to children\n\t\t\t\tsubtree.children.forEach(function(node) {\n\t\t\t\t\tchild.attributeList().forEach(function(attr) {\n\t\t\t\t\t\tnode.attribute(attr.name, attr.value);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tchild.replace(subtree.children);\n\t\t\t}\n\t\t\t\n\t\t\tmatchResources(child, syntax, parser);\n\t\t});\n\t}\n\t\n\treturn {\n\t\tpreprocessor: function(tree, options, parser) {\n\t\t\tvar syntax = options.syntax || utils.defaultSyntax();\n\t\t\tmatchResources(tree, syntax, parser);\n\t\t}\n\t};\n});\n},{\"../../assets/elements\":\"assets\\\\elements.js\",\"../../assets/resources\":\"assets\\\\resources.js\",\"../../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../../utils/common\":\"utils\\\\common.js\"}],\"parser\\\\processor\\\\tagName.js\":[function(require,module,exports){\n/**\n * Resolves tag names in abbreviations with implied name\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar tagName = require('../../resolver/tagName');\n\n\t/**\n\t * Resolves implicit node names in parsed tree\n\t * @param {AbbreviationNode} tree\n\t */\n\tfunction resolveNodeNames(tree) {\n\t\ttree.children.forEach(function(node) {\n\t\t\tif (node.hasImplicitName() || node.data('forceNameResolving')) {\n\t\t\t\tnode._name = tagName.resolve(node.parent.name());\n\t\t\t\tnode.data('nameResolved', true);\n\t\t\t}\n\t\t\tresolveNodeNames(node);\n\t\t});\n\t\t\n\t\treturn tree;\n\t}\n\n\treturn {\n\t\tpostprocessor: resolveNodeNames\n\t};\n});\n},{\"../../resolver/tagName\":\"resolver\\\\tagName.js\"}],\"parser\\\\xml.js\":[function(require,module,exports){\n/**\n * HTML tokenizer by Marijn Haverbeke\n * http://codemirror.net/\n * @constructor\n * @memberOf __xmlParseDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar stringStream = require('../assets/stringStream');\n\n\tvar Kludges = {\n\t\tautoSelfClosers : {},\n\t\timplicitlyClosed : {},\n\t\tcontextGrabbers : {},\n\t\tdoNotIndent : {},\n\t\tallowUnquoted : true,\n\t\tallowMissing : true\n\t};\n\n\t// Return variables for tokenizers\n\tvar tagName = null, type = null;\n\n\tfunction inText(stream, state) {\n\t\tfunction chain(parser) {\n\t\t\tstate.tokenize = parser;\n\t\t\treturn parser(stream, state);\n\t\t}\n\n\t\tvar ch = stream.next();\n\t\tif (ch == \"<\") {\n\t\t\tif (stream.eat(\"!\")) {\n\t\t\t\tif (stream.eat(\"[\")) {\n\t\t\t\t\tif (stream.match(\"CDATA[\"))\n\t\t\t\t\t\treturn chain(inBlock(\"atom\", \"]]>\"));\n\t\t\t\t\telse\n\t\t\t\t\t\treturn null;\n\t\t\t\t} else if (stream.match(\"--\"))\n\t\t\t\t\treturn chain(inBlock(\"comment\", \"-->\"));\n\t\t\t\telse if (stream.match(\"DOCTYPE\", true, true)) {\n\t\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\t\treturn chain(doctype(1));\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t} else if (stream.eat(\"?\")) {\n\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\tstate.tokenize = inBlock(\"meta\", \"?>\");\n\t\t\t\treturn \"meta\";\n\t\t\t} else {\n\t\t\t\ttype = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n\t\t\t\tstream.eatSpace();\n\t\t\t\ttagName = \"\";\n\t\t\t\tvar c;\n\t\t\t\twhile ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)))\n\t\t\t\t\ttagName += c;\n\t\t\t\tstate.tokenize = inTag;\n\t\t\t\treturn \"tag\";\n\t\t\t}\n\t\t} else if (ch == \"&\") {\n\t\t\tvar ok;\n\t\t\tif (stream.eat(\"#\")) {\n\t\t\t\tif (stream.eat(\"x\")) {\n\t\t\t\t\tok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n\t\t\t\t} else {\n\t\t\t\t\tok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n\t\t\t}\n\t\t\treturn ok ? \"atom\" : \"error\";\n\t\t} else {\n\t\t\tstream.eatWhile(/[^&<]/);\n\t\t\treturn \"text\";\n\t\t}\n\t}\n\n\tfunction inTag(stream, state) {\n\t\tvar ch = stream.next();\n\t\tif (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n\t\t\tstate.tokenize = inText;\n\t\t\ttype = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n\t\t\treturn \"tag\";\n\t\t} else if (ch == \"=\") {\n\t\t\ttype = \"equals\";\n\t\t\treturn null;\n\t\t} else if (/[\\'\\\"]/.test(ch)) {\n\t\t\tstate.tokenize = inAttribute(ch);\n\t\t\treturn state.tokenize(stream, state);\n\t\t} else {\n\t\t\tstream.eatWhile(/[^\\s\\u00a0=<>\\\"\\'\\/?]/);\n\t\t\treturn \"word\";\n\t\t}\n\t}\n\n\tfunction inAttribute(quote) {\n\t\treturn function(stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.next() == quote) {\n\t\t\t\t\tstate.tokenize = inTag;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"string\";\n\t\t};\n\t}\n\n\tfunction inBlock(style, terminator) {\n\t\treturn function(stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.match(terminator)) {\n\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t\treturn style;\n\t\t};\n\t}\n\t\n\tfunction doctype(depth) {\n\t\treturn function(stream, state) {\n\t\t\tvar ch;\n\t\t\twhile ((ch = stream.next()) !== null) {\n\t\t\t\tif (ch == \"<\") {\n\t\t\t\t\tstate.tokenize = doctype(depth + 1);\n\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t} else if (ch == \">\") {\n\t\t\t\t\tif (depth == 1) {\n\t\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.tokenize = doctype(depth - 1);\n\t\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"meta\";\n\t\t};\n\t}\n\n\tvar curState = null, setStyle;\n\tfunction pass() {\n\t\tfor (var i = arguments.length - 1; i >= 0; i--)\n\t\t\tcurState.cc.push(arguments[i]);\n\t}\n\t\n\tfunction cont() {\n\t\tpass.apply(null, arguments);\n\t\treturn true;\n\t}\n\n\tfunction pushContext(tagName, startOfLine) {\n\t\tvar noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) \n\t\t\t|| (curState.context && curState.context.noIndent);\n\t\tcurState.context = {\n\t\t\tprev : curState.context,\n\t\t\ttagName : tagName,\n\t\t\tindent : curState.indented,\n\t\t\tstartOfLine : startOfLine,\n\t\t\tnoIndent : noIndent\n\t\t};\n\t}\n\t\n\tfunction popContext() {\n\t\tif (curState.context)\n\t\t\tcurState.context = curState.context.prev;\n\t}\n\n\tfunction element(type) {\n\t\tif (type == \"openTag\") {\n\t\t\tcurState.tagName = tagName;\n\t\t\treturn cont(attributes, endtag(curState.startOfLine));\n\t\t} else if (type == \"closeTag\") {\n\t\t\tvar err = false;\n\t\t\tif (curState.context) {\n\t\t\t\tif (curState.context.tagName != tagName) {\n\t\t\t\t\tif (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {\n\t\t\t\t\t\tpopContext();\n\t\t\t\t\t}\n\t\t\t\t\terr = !curState.context || curState.context.tagName != tagName;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (err)\n\t\t\t\tsetStyle = \"error\";\n\t\t\treturn cont(endclosetag(err));\n\t\t}\n\t\treturn cont();\n\t}\n\t\n\tfunction endtag(startOfLine) {\n\t\treturn function(type) {\n\t\t\tif (type == \"selfcloseTag\"\n\t\t\t\t\t|| (type == \"endTag\" && Kludges.autoSelfClosers\n\t\t\t\t\t\t\t.hasOwnProperty(curState.tagName\n\t\t\t\t\t\t\t\t\t.toLowerCase()))) {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\tpushContext(curState.tagName, startOfLine);\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\treturn cont();\n\t\t};\n\t}\n\t\n\tfunction endclosetag(err) {\n\t\treturn function(type) {\n\t\t\tif (err)\n\t\t\t\tsetStyle = \"error\";\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tpopContext();\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tsetStyle = \"error\";\n\t\t\treturn cont(arguments.callee);\n\t\t};\n\t}\n\t\n\tfunction maybePopContext(nextTagName) {\n\t\tvar parentTagName;\n\t\twhile (true) {\n\t\t\tif (!curState.context) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparentTagName = curState.context.tagName.toLowerCase();\n\t\t\tif (!Kludges.contextGrabbers.hasOwnProperty(parentTagName)\n\t\t\t\t\t|| !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpopContext();\n\t\t}\n\t}\n\n\tfunction attributes(type) {\n\t\tif (type == \"word\") {\n\t\t\tsetStyle = \"attribute\";\n\t\t\treturn cont(attribute, attributes);\n\t\t}\n\t\tif (type == \"endTag\" || type == \"selfcloseTag\")\n\t\t\treturn pass();\n\t\tsetStyle = \"error\";\n\t\treturn cont(attributes);\n\t}\n\t\n\tfunction attribute(type) {\n\t\tif (type == \"equals\")\n\t\t\treturn cont(attvalue, attributes);\n\t\tif (!Kludges.allowMissing)\n\t\t\tsetStyle = \"error\";\n\t\treturn (type == \"endTag\" || type == \"selfcloseTag\") ? pass()\n\t\t\t\t: cont();\n\t}\n\t\n\tfunction attvalue(type) {\n\t\tif (type == \"string\")\n\t\t\treturn cont(attvaluemaybe);\n\t\tif (type == \"word\" && Kludges.allowUnquoted) {\n\t\t\tsetStyle = \"string\";\n\t\t\treturn cont();\n\t\t}\n\t\tsetStyle = \"error\";\n\t\treturn (type == \"endTag\" || type == \"selfCloseTag\") ? pass()\n\t\t\t\t: cont();\n\t}\n\t\n\tfunction attvaluemaybe(type) {\n\t\tif (type == \"string\")\n\t\t\treturn cont(attvaluemaybe);\n\t\telse\n\t\t\treturn pass();\n\t}\n\t\n\tfunction startState() {\n\t\treturn {\n\t\t\ttokenize : inText,\n\t\t\tcc : [],\n\t\t\tindented : 0,\n\t\t\tstartOfLine : true,\n\t\t\ttagName : null,\n\t\t\tcontext : null\n\t\t};\n\t}\n\t\n\tfunction token(stream, state) {\n\t\tif (stream.sol()) {\n\t\t\tstate.startOfLine = true;\n\t\t\tstate.indented = 0;\n\t\t}\n\t\t\n\t\tif (stream.eatSpace())\n\t\t\treturn null;\n\n\t\tsetStyle = type = tagName = null;\n\t\tvar style = state.tokenize(stream, state);\n\t\tstate.type = type;\n\t\tif ((style || type) && style != \"comment\") {\n\t\t\tcurState = state;\n\t\t\twhile (true) {\n\t\t\t\tvar comb = state.cc.pop() || element;\n\t\t\t\tif (comb(type || style))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstate.startOfLine = false;\n\t\treturn setStyle || style;\n\t}\n\n\treturn {\n\t\t/**\n\t\t * @memberOf emmet.xmlParser\n\t\t * @returns\n\t\t */\n\t\tparse: function(data, offset) {\n\t\t\toffset = offset || 0;\n\t\t\tvar state = startState();\n\t\t\tvar stream = stringStream.create(data);\n\t\t\tvar tokens = [];\n\t\t\twhile (!stream.eol()) {\n\t\t\t\ttokens.push({\n\t\t\t\t\ttype: token(stream, state),\n\t\t\t\t\tstart: stream.start + offset,\n\t\t\t\t\tend: stream.pos + offset\n\t\t\t\t});\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t\t\n\t\t\treturn tokens;\n\t\t}\t\t\n\t};\n});\n\n},{\"../assets/stringStream\":\"assets\\\\stringStream.js\"}],\"plugin\\\\file.js\":[function(require,module,exports){\n/**\n * Module for working with file. Shall implement\n * IEmmetFile interface.\n *\n * Since implementation of this module depends\n * greatly on current runtime, this module must be\n * initialized with actual implementation first\n * before use. E.g.\n * require('./plugin/file')({\n * \tread: function() {...}\n * })\n *\n * By default, this module provides Node.JS implementation\n */\n\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\tvar _transport = {};\n\n\t// hide it from Require.JS parser\n\t(function(r) {\n\t\tif (typeof define === 'undefined' || !define.amd) {\n\t\t\ttry {\n\t\t\t\tfs = r('fs');\n\t\t\t\tpath = r('path');\n\t\t\t\t_transport.http = r('http');\n\t\t\t\t_transport.https = r('https');\n\t\t\t} catch(e) { }\n\t\t}\n\t})(require);\n\n\t// module is a function that can extend itself\n\tmodule.exports = function(obj) {\n\t\tif (obj) {\n\t\t\tutils.extend(module.exports, obj);\n\t\t}\n\t};\n\n\tfunction bts(bytes) {\n\t\tvar out = [];\n\t\tfor (var i = 0, il = bytes.length; i < il; i++) {\n\t\t\tout.push(String.fromCharCode(bytes[i]));\n\t\t}\n\t\treturn out.join('');\n\t}\n\n\tfunction isURL(path) {\n\t\tvar re = /^https?:\\/\\//;\n\t\treturn re.test(path);\n\t}\n\n\treturn utils.extend(module.exports, {\n\t\t_parseParams: function(args) {\n\t\t\tvar params = {\n\t\t\t\tpath: args[0],\n\t\t\t\tsize: 0\n\t\t\t};\n\n\t\t\targs = utils.toArray(args, 1);\n\t\t\tparams.callback = args[args.length - 1];\n\t\t\targs = args.slice(0, args.length - 1);\n\t\t\tif (args.length) {\n\t\t\t\tparams.size = args[0];\n\t\t\t}\n\n\t\t\treturn params;\n\t\t},\n\n\t\t_read: function(params, callback) {\n\t\t\tif (isURL(params.path)) {\n\t\t\t\tvar req = _transport[/^https:/.test(params.path) ? 'https' : 'http'].get(params.path, function(res) {\n\t\t\t\t\tvar bufs = [];\n\t\t\t\t\tvar totalLength = 0;\n\t\t\t\t\tvar finished = false;\n\t\t\t\t\tres\n\t\t\t\t\t\t.on('data', function(chunk) {\n\t\t\t\t\t\t\ttotalLength += chunk.length;\n\t\t\t\t\t\t\tbufs.push(chunk);\n\t\t\t\t\t\t\tif (params.size && totalLength >= params.size) {\n\t\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\t\tcallback(null, Buffer.concat(bufs));\n\t\t\t\t\t\t\t\treq.abort();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.on('end', function() {\n\t\t\t\t\t\t\tif (!finished) {\n\t\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\t\tcallback(null, Buffer.concat(bufs));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}).on('error', callback);\n\t\t\t} else {\n\t\t\t\tif (params.size) {\n\t\t\t\t\tvar fd = fs.openSync(params.path, 'r');\n\t\t\t\t\tvar buf = new Buffer(params.size);\n\t\t\t\t\tfs.read(fd, buf, 0, params.size, null, function(err, bytesRead) {\n\t\t\t\t\t\tcallback(err, buf)\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback(null, fs.readFileSync(params.path));\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Reads binary file content and return it\n\t\t * @param {String} path File's relative or absolute path\n\t\t * @return {String}\n\t\t */\n\t\tread: function(path, size, callback) {\n\t\t\tvar params = this._parseParams(arguments);\n\t\t\tthis._read(params, function(err, buf) {\n\t\t\t\tparams.callback(err, err ? '' : bts(buf));\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Read file content and return it\n\t\t * @param {String} path File's relative or absolute path\n\t\t * @return {String}\n\t\t */\n\t\treadText: function(path, size, callback) {\n\t\t\tvar params = this._parseParams(arguments);\n\t\t\tthis._read(params, function(err, buf) {\n\t\t\t\tparams.callback(err, err ? '' : buf.toString());\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Locate <code>file_name</code> file that relates to <code>editor_file</code>.\n\t\t * File name may be absolute or relative path\n\t\t *\n\t\t * <b>Dealing with absolute path.</b>\n\t\t * Many modern editors have a \"project\" support as information unit, but you\n\t\t * should not rely on project path to find file with absolute path. First,\n\t\t * it requires user to create a project before using this method (and this\n\t\t * is not very convenient). Second, project path doesn't always points to\n\t\t * to website's document root folder: it may point, for example, to an\n\t\t * upper folder which contains server-side scripts.\n\t\t *\n\t\t * For better result, you should use the following algorithm in locating\n\t\t * absolute resources:\n\t\t * 1) Get parent folder for <code>editorFile</code> as a start point\n\t\t * 2) Append required <code>fileName</code> to start point and test if\n\t\t * file exists\n\t\t * 3) If it doesn't exists, move start point one level up (to parent folder)\n\t\t * and repeat step 2.\n\t\t *\n\t\t * @param {String} editorFile\n\t\t * @param {String} fileName\n\t\t * @return {String} Returns null if <code>fileName</code> cannot be located\n\t\t */\n\t\tlocateFile: function(editorFile, fileName, callback) {\n\t\t\tif (isURL(fileName)) {\n\t\t\t\treturn callback(fileName);\n\t\t\t}\n\n\t\t\tvar dirname = editorFile\n\t\t\tvar filepath;\n\t\t\tfileName = fileName.replace(/^\\/+/, '');\n\t\t\twhile (dirname && dirname !== path.dirname(dirname)) {\n\t\t\t\tdirname = path.dirname(dirname);\n\t\t\t\tfilepath = path.join(dirname, fileName);\n\t\t\t\tif (fs.existsSync(filepath))\n\t\t\t\t\treturn callback(filepath);\n\t\t\t}\n\n\t\t\tcallback(null);\n\t\t},\n\n\t\t/**\n\t\t * Creates absolute path by concatenating <code>parent</code> and <code>fileName</code>.\n\t\t * If <code>parent</code> points to file, its parent directory is used\n\t\t * @param {String} parent\n\t\t * @param {String} fileName\n\t\t * @return {String}\n\t\t */\n\t\tcreatePath: function(parent, fileName, callback) {\n\t\t\tfs.stat(parent, function(err, stat) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\tif (stat.isFile()) {\n\t\t\t\t\tparent = path.dirname(parent);\n\t\t\t\t}\n\n\t\t\t\tvar filepath = path.resolve(parent, fileName);\n\t\t\t\tcallback(null, filepath);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Saves <code>content</code> as <code>file</code>\n\t\t * @param {String} file File's absolute path\n\t\t * @param {String} content File content\n\t\t */\n\t\tsave: function(file, content, callback) {\n\t\t\tfs.writeFile(file, content, 'ascii', function(err) {\n\t\t\t\tcallback(err ? err : null);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Returns file extension in lower case\n\t\t * @param {String} file\n\t\t * @return {String}\n\t\t */\n\t\tgetExt: function(file) {\n\t\t\tvar m = (file || '').match(/\\.([\\w\\-]+)$/);\n\t\t\treturn m ? m[1].toLowerCase() : '';\n\t\t}\n\n\t});\n});\n\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"resolver\\\\css.js\":[function(require,module,exports){\n/**\n * Resolver for fast CSS typing. Handles abbreviations with the following \n * notation:<br>\n * \n * <code>(-vendor prefix)?property(value)*(!)?</code>\n * \n * <br><br>\n * <b>Abbreviation handling</b><br>\n * \n * By default, Emmet searches for matching snippet definition for provided abbreviation.\n * If snippet wasn't found, Emmet automatically generates element with \n * abbreviation's name. For example, <code>foo</code> abbreviation will generate\n * <code>&lt;foo&gt;&lt;/foo&gt;</code> output.\n * <br><br>\n * This module will capture all expanded properties and upgrade them with values, \n * vendor prefixes and !important declarations. All unmatched abbreviations will \n * be automatically transformed into <code>property-name: ${1}</code> snippets. \n * \n * <b>Vendor prefixes<b><br>\n * \n * If CSS-property is preceded with dash, resolver should output property with\n * all <i>known</i> vendor prefixes. For example, if <code>brad</code> \n * abbreviation generates <code>border-radius: ${value};</code> snippet,\n * the <code>-brad</code> abbreviation should generate:\n * <pre><code>\n * -webkit-border-radius: ${value};\n * -moz-border-radius: ${value};\n * border-radius: ${value};\n * </code></pre>\n * Note that <i>o</i> and <i>ms</i> prefixes are omitted since Opera and IE \n * supports unprefixed property.<br><br>\n * \n * Users can also provide an explicit list of one-character prefixes for any\n * CSS property. For example, <code>-wm-float</code> will produce\n * \n * <pre><code>\n * -webkit-float: ${1};\n * -moz-float: ${1};\n * float: ${1};\n * </code></pre>\n * \n * Although this example looks pointless, users can use this feature to write\n * cutting-edge properties implemented by browser vendors recently.  \n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar prefs = require('../assets/preferences');\n\tvar resources = require('../assets/resources');\n\tvar stringStream = require('../assets/stringStream');\n\tvar ciu = require('../assets/caniuse');\n\tvar utils = require('../utils/common');\n\tvar template = require('../utils/template');\n\tvar cssEditTree = require('../editTree/css');\n\n\tvar prefixObj = {\n\t\t/** Real vendor prefix name */\n\t\tprefix: 'emmet',\n\t\t\n\t\t/** \n\t\t * Indicates this prefix is obsolete and should't be used when user \n\t\t * wants to generate all-prefixed properties\n\t\t */\n\t\tobsolete: false,\n\t\t\n\t\t/**\n\t\t * Returns prefixed CSS property name\n\t\t * @param {String} name Unprefixed CSS property\n\t\t */\n\t\ttransformName: function(name) {\n\t\t\treturn '-' + this.prefix + '-' + name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * List of unprefixed CSS properties that supported by \n\t\t * current prefix. This list is used to generate all-prefixed property\n\t\t * @returns {Array} \n\t\t */\n\t\tproperties: function() {\n\t\t\treturn getProperties('css.' + this.prefix + 'Properties') || [];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if given property is supported by current prefix\n\t\t * @param name\n\t\t */\n\t\tsupports: function(name) {\n\t\t\treturn ~this.properties().indexOf(name);\n\t\t}\n\t};\n\t\n\t\n\t/** \n\t * List of registered one-character prefixes. Key is a one-character prefix, \n\t * value is an <code>prefixObj</code> object\n\t */\n\tvar vendorPrefixes = {};\n\t\n\tvar defaultValue = '${1};';\n\t\n\t// XXX module preferences\n\tprefs.define('css.valueSeparator', ': ',\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \n\t\t\t+ 'value when expanding CSS abbreviations.');\n\tprefs.define('css.propertyEnd', ';',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations.');\n\t\n\tprefs.define('stylus.valueSeparator', ' ',\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \n\t\t\t+ 'value when expanding CSS abbreviations in Stylus dialect.');\n\tprefs.define('stylus.propertyEnd', '',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations in Stylus dialect.');\n\t\n\tprefs.define('sass.propertyEnd', '',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations in SASS dialect.');\n\n\tprefs.define('css.syntaxes', 'css, less, sass, scss, stylus, styl',\n\t\t\t'List of syntaxes that should be treated as CSS dialects.');\n\t\n\tprefs.define('css.autoInsertVendorPrefixes', true,\n\t\t\t'Automatically generate vendor-prefixed copies of expanded CSS ' \n\t\t\t+ 'property. By default, Emmet will generate vendor-prefixed '\n\t\t\t+ 'properties only when you put dash before abbreviation ' \n\t\t\t+ '(e.g. <code>-bxsh</code>). With this option enabled, you dont ' \n\t\t\t+ 'need dashes before abbreviations: Emmet will produce ' \n\t\t\t+ 'vendor-prefixed properties for you.');\n\n\tprefs.define('less.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for LESS syntax');\n\tprefs.define('scss.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for SCSS syntax');\n\tprefs.define('sass.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for SASS syntax');\n\tprefs.define('stylus.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for Stylus syntax');\n\t\n\tvar descTemplate = template('A comma-separated list of CSS properties that may have ' \n\t\t+ '<code><%= vendor %></code> vendor prefix. This list is used to generate '\n\t\t+ 'a list of prefixed properties when expanding <code>-property</code> '\n\t\t+ 'abbreviations. Empty list means that all possible CSS values may ' \n\t\t+ 'have <code><%= vendor %></code> prefix.');\n\t\n\tvar descAddonTemplate = template('A comma-separated list of <em>additional</em> CSS properties ' \n\t\t\t+ 'for <code>css.<%= vendor %>Preperties</code> preference. ' \n\t\t\t+ 'You should use this list if you want to add or remove a few CSS ' \n\t\t\t+ 'properties to original set. To add a new property, simply write its name, '\n\t\t\t+ 'to remove it, precede property with hyphen.<br>'\n\t\t\t+ 'For example, to add <em>foo</em> property and remove <em>border-radius</em> one, '\n\t\t\t+ 'the preference value will look like this: <code>foo, -border-radius</code>.');\n\t\n\t// properties list is created from cssFeatures.html file\n\tvar props = {\n\t\t'webkit': 'animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-clip, background-composite, background-origin, background-size, border-fit, border-horizontal-spacing, border-image, border-vertical-spacing, box-align, box-direction, box-flex, box-flex-group, box-lines, box-ordinal-group, box-orient, box-pack, box-reflect, box-shadow, color-correction, column-break-after, column-break-before, column-break-inside, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, dashboard-region, font-smoothing, highlight, hyphenate-character, hyphenate-limit-after, hyphenate-limit-before, hyphens, line-box-contain, line-break, line-clamp, locale, margin-before-collapse, margin-after-collapse, marquee-direction, marquee-increment, marquee-repetition, marquee-style, mask-attachment, mask-box-image, mask-box-image-outset, mask-box-image-repeat, mask-box-image-slice, mask-box-image-source, mask-box-image-width, mask-clip, mask-composite, mask-image, mask-origin, mask-position, mask-repeat, mask-size, nbsp-mode, perspective, perspective-origin, rtl-ordering, text-combine, text-decorations-in-effect, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-fill-color, text-orientation, text-security, text-stroke-color, text-stroke-width, transform, transition, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, user-drag, user-modify, user-select, writing-mode, svg-shadow, box-sizing, border-radius',\n\t\t'moz': 'animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-inline-policy, binding, border-bottom-colors, border-image, border-left-colors, border-right-colors, border-top-colors, box-align, box-direction, box-flex, box-ordinal-group, box-orient, box-pack, box-shadow, box-sizing, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-width, float-edge, font-feature-settings, font-language-override, force-broken-image-icon, hyphens, image-region, orient, outline-radius-bottomleft, outline-radius-bottomright, outline-radius-topleft, outline-radius-topright, perspective, perspective-origin, stack-sizing, tab-size, text-blink, text-decoration-color, text-decoration-line, text-decoration-style, text-size-adjust, transform, transform-origin, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-focus, user-input, user-modify, user-select, window-shadow, background-clip, border-radius',\n\t\t'ms': 'accelerator, backface-visibility, background-position-x, background-position-y, behavior, block-progression, box-align, box-direction, box-flex, box-line-progression, box-lines, box-ordinal-group, box-orient, box-pack, content-zoom-boundary, content-zoom-boundary-max, content-zoom-boundary-min, content-zoom-chaining, content-zoom-snap, content-zoom-snap-points, content-zoom-snap-type, content-zooming, filter, flow-from, flow-into, font-feature-settings, grid-column, grid-column-align, grid-column-span, grid-columns, grid-layer, grid-row, grid-row-align, grid-row-span, grid-rows, high-contrast-adjust, hyphenate-limit-chars, hyphenate-limit-lines, hyphenate-limit-zone, hyphens, ime-mode, interpolation-mode, layout-flow, layout-grid, layout-grid-char, layout-grid-line, layout-grid-mode, layout-grid-type, line-break, overflow-style, perspective, perspective-origin, perspective-origin-x, perspective-origin-y, scroll-boundary, scroll-boundary-bottom, scroll-boundary-left, scroll-boundary-right, scroll-boundary-top, scroll-chaining, scroll-rails, scroll-snap-points-x, scroll-snap-points-y, scroll-snap-type, scroll-snap-x, scroll-snap-y, scrollbar-arrow-color, scrollbar-base-color, scrollbar-darkshadow-color, scrollbar-face-color, scrollbar-highlight-color, scrollbar-shadow-color, scrollbar-track-color, text-align-last, text-autospace, text-justify, text-kashida-space, text-overflow, text-size-adjust, text-underline-position, touch-action, transform, transform-origin, transform-origin-x, transform-origin-y, transform-origin-z, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-select, word-break, wrap-flow, wrap-margin, wrap-through, writing-mode',\n\t\t'o': 'dashboard-region, animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, border-image, link, link-source, object-fit, object-position, tab-size, table-baseline, transform, transform-origin, transition, transition-delay, transition-duration, transition-property, transition-timing-function, accesskey, input-format, input-required, marquee-dir, marquee-loop, marquee-speed, marquee-style'\n\t};\n\t\n\tObject.keys(props).forEach(function(k) {\n\t\tprefs.define('css.' + k + 'Properties', props[k], descTemplate({vendor: k}));\n\t\tprefs.define('css.' + k + 'PropertiesAddon', '', descAddonTemplate({vendor: k}));\n\t});\n\t\n\tprefs.define('css.unitlessProperties', 'z-index, line-height, opacity, font-weight, zoom', \n\t\t\t'The list of properties whose values must not contain units.');\n\t\n\tprefs.define('css.intUnit', 'px', 'Default unit for integer values');\n\tprefs.define('css.floatUnit', 'em', 'Default unit for float values');\n\t\n\tprefs.define('css.keywords', 'auto, inherit, all', \n\t\t\t'A comma-separated list of valid keywords that can be used in CSS abbreviations.');\n\t\n\tprefs.define('css.keywordAliases', 'a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent', \n\t\t\t'A comma-separated list of keyword aliases, used in CSS abbreviation. '\n\t\t\t+ 'Each alias should be defined as <code>alias:keyword_name</code>.');\n\t\n\tprefs.define('css.unitAliases', 'e:em, p:%, x:ex, r:rem', \n\t\t\t'A comma-separated list of unit aliases, used in CSS abbreviation. '\n\t\t\t+ 'Each alias should be defined as <code>alias:unit_value</code>.');\n\t\n\tprefs.define('css.color.short', true, \n\t\t\t'Should color values like <code>#ffffff</code> be shortened to '\n\t\t\t+ '<code>#fff</code> after abbreviation with color was expanded.');\n\t\n\tprefs.define('css.color.case', 'keep', \n\t\t\t'Letter case of color values generated by abbreviations with color '\n\t\t\t+ '(like <code>c#0</code>). Possible values are <code>upper</code>, '\n\t\t\t+ '<code>lower</code> and <code>keep</code>.');\n\t\n\tprefs.define('css.fuzzySearch', true, \n\t\t\t'Enable fuzzy search among CSS snippet names. When enabled, every ' \n\t\t\t+ '<em>unknown</em> snippet will be scored against available snippet '\n\t\t\t+ 'names (not values or CSS properties!). The match with best score '\n\t\t\t+ 'will be used to resolve snippet value. For example, with this ' \n\t\t\t+ 'preference enabled, the following abbreviations are equal: '\n\t\t\t+ '<code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == '\n\t\t\t+ '<code>oh</code>');\n\t\n\tprefs.define('css.fuzzySearchMinScore', 0.3, \n\t\t\t'The minium score (from 0 to 1) that fuzzy-matched abbreviation should ' \n\t\t\t+ 'achive. Lower values may produce many false-positive matches, '\n\t\t\t+ 'higher values may reduce possible matches.');\n\t\n\tprefs.define('css.alignVendor', false, \n\t\t\t'If set to <code>true</code>, all generated vendor-prefixed properties ' \n\t\t\t+ 'will be aligned by real property name.');\n\t\n\t\n\tfunction isNumeric(ch) {\n\t\tvar code = ch && ch.charCodeAt(0);\n\t\treturn (ch && ch == '.' || (code > 47 && code < 58));\n\t}\n\t\n\t/**\n\t * Check if provided snippet contains only one CSS property and value.\n\t * @param {String} snippet\n\t * @returns {Boolean}\n\t */\n\tfunction isSingleProperty(snippet) {\n\t\tsnippet = utils.trim(snippet);\n\t\t\n\t\t// check if it doesn't contain a comment and a newline\n\t\tif (/\\/\\*|\\n|\\r/.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// check if it's a valid snippet definition\n\t\tif (!/^[a-z0-9\\-]+\\s*\\:/i.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn snippet.replace(/\\$\\{.+?\\}/g, '').split(':').length == 2;\n\t}\n\t\n\t/**\n\t * Normalizes abbreviated value to final CSS one\n\t * @param {String} value\n\t * @returns {String}\n\t */\n\tfunction normalizeValue(value) {\n\t\tif (value.charAt(0) == '-' && !/^\\-[\\.\\d]/.test(value)) {\n\t\t\tvalue = value.replace(/^\\-+/, '');\n\t\t}\n\t\t\n\t\tvar ch = value.charAt(0);\n\t\tif (ch == '#') {\n\t\t\treturn normalizeHexColor(value);\n\t\t}\n\n\t\tif (ch == '$') {\n\t\t\treturn utils.escapeText(value);\n\t\t}\n\n\t\treturn getKeyword(value);\n\t}\n\t\n\tfunction normalizeHexColor(value) {\n\t\tvar hex = value.replace(/^#+/, '') || '0';\n\t\tif (hex.toLowerCase() == 't') {\n\t\t\treturn 'transparent';\n\t\t}\n\n\t\tvar opacity = '';\n\t\thex = hex.replace(/\\.(\\d+)$/, function(str) {\n\t\t\topacity = '0' + str;\n\t\t\treturn '';\n\t\t});\n\t\t\n\t\tvar repeat = utils.repeatString;\n\t\tvar color = null;\n\t\tswitch (hex.length) {\n\t\t\tcase 1:\n\t\t\t\tcolor = repeat(hex, 6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcolor = repeat(hex, 3);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcolor = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tcolor = hex + hex.substr(0, 2);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tcolor = hex + hex.charAt(0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcolor = hex.substr(0, 6);\n\t\t}\n\n\t\tif (opacity) {\n\t\t\treturn toRgba(color, opacity);\n\t\t}\n\t\t\n\t\t// color must be shortened?\n\t\tif (prefs.get('css.color.short')) {\n\t\t\tvar p = color.split('');\n\t\t\tif (p[0] == p[1] && p[2] == p[3] && p[4] == p[5]) {\n\t\t\t\tcolor = p[0] + p[2] + p[4];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// should transform case?\n\t\tswitch (prefs.get('css.color.case')) {\n\t\t\tcase 'upper':\n\t\t\t\tcolor = color.toUpperCase();\n\t\t\t\tbreak;\n\t\t\tcase 'lower':\n\t\t\t\tcolor = color.toLowerCase();\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn '#' + color;\n\t}\n\n\t/**\n\t * Transforms HEX color definition into RGBA one\n\t * @param  {String} color   HEX color, 6 characters\n\t * @param  {String} opacity Opacity value\n\t * @return {String}\n\t */\n\tfunction toRgba(color, opacity) {\n\t\tvar r = parseInt(color.substr(0, 2), 16);\n\t\tvar g = parseInt(color.substr(2, 2), 16);\n\t\tvar b = parseInt(color.substr(4, 2), 16);\n\n\t\treturn 'rgba(' + [r, g, b, opacity].join(', ') + ')';\n\t}\n\t\n\tfunction getKeyword(name) {\n\t\tvar aliases = prefs.getDict('css.keywordAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\t\n\tfunction getUnit(name) {\n\t\tvar aliases = prefs.getDict('css.unitAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\t\n\tfunction isValidKeyword(keyword) {\n\t\treturn ~prefs.getArray('css.keywords').indexOf(getKeyword(keyword));\n\t}\n\t\n\t/**\n\t * Check if passed CSS property support specified vendor prefix \n\t * @param {String} property\n\t * @param {String} prefix\n\t */\n\tfunction hasPrefix(property, prefix) {\n\t\tvar info = vendorPrefixes[prefix];\n\t\t\n\t\tif (!info)\n\t\t\tinfo = utils.find(vendorPrefixes, function(data) {\n\t\t\t\treturn data.prefix == prefix;\n\t\t\t});\n\t\t\n\t\treturn info && info.supports(property);\n\t}\n\n\t/**\n\t * Finds available vendor prefixes for given CSS property.\n\t * Search is performed within Can I Use database and internal\n\t * property list\n\t * @param  {String} property CSS property name\n\t * @return {Array} Array of resolved prefixes or null if\n\t * prefixes are not available for this property at all.\n\t * Empty array means prefixes are not available for current\n\t * user-define era\n\t */\n\tfunction findVendorPrefixes(property) {\n\t\tvar prefixes = ciu.resolvePrefixes(property);\n\t\tif (!prefixes) {\n\t\t\t// Can I Use database is disabled or prefixes are not\n\t\t\t// available for this property\n\t\t\tprefixes = [];\n\t\t\tObject.keys(vendorPrefixes).forEach(function(key) {\n\t\t\t\tif (hasPrefix(property, key)) {\n\t\t\t\t\tprefixes.push(vendorPrefixes[key].prefix);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!prefixes.length) {\n\t\t\t\tprefixes = null;\n\t\t\t}\n\t\t}\n\n\t\treturn prefixes;\n\t}\n\t\n\t/**\n\t * Search for a list of supported prefixes for CSS property. This list\n\t * is used to generate all-prefixed snippet\n\t * @param {String} property CSS property name\n\t * @returns {Array}\n\t */\n\tfunction findInternalPrefixes(property, noAutofill) {\n\t\tvar result = [];\n\t\tvar prefixes = findVendorPrefixes(property);\n\t\t\n\t\tif (prefixes) {\n\t\t\tvar prefixMap = {};\n\t\t\tObject.keys(vendorPrefixes).forEach(function(key) {\n\t\t\t\tprefixMap[vendorPrefixes[key].prefix] = key;\n\t\t\t});\n\n\t\t\tresult = prefixes.map(function(prefix) {\n\t\t\t\treturn prefixMap[prefix];\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (!result.length && !noAutofill) {\n\t\t\t// add all non-obsolete prefixes\n\t\t\tObject.keys(vendorPrefixes).forEach(function(prefix) {\n\t\t\t\tif (!vendorPrefixes[prefix].obsolete) {\n\t\t\t\t\tresult.push(prefix);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tfunction addPrefix(name, obj) {\n\t\tif (typeof obj === 'string') {\n\t\t\tobj = {prefix: obj};\n\t\t}\n\t\t\n\t\tvendorPrefixes[name] = utils.extend({}, prefixObj, obj);\n\t}\n\t\n\tfunction getSyntaxPreference(name, syntax) {\n\t\tif (syntax) {\n\t\t\t// hacky alias for Stylus dialect\n\t\t\tif (syntax == 'styl') {\n\t\t\t\tsyntax = 'stylus';\n\t\t\t}\n\n\t\t\tvar val = prefs.get(syntax + '.' + name);\n\t\t\tif (typeof val !== 'undefined') {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn prefs.get('css.' + name);\n\t}\n\t\n\t/**\n\t * Format CSS property according to current syntax dialect\n\t * @param {String} property\n\t * @param {String} syntax\n\t * @returns {String}\n\t */\n\tfunction formatProperty(property, syntax) {\n\t\tvar ix = property.indexOf(':');\n\t\tproperty = property.substring(0, ix).replace(/\\s+$/, '') \n\t\t\t+ getSyntaxPreference('valueSeparator', syntax)\n\t\t\t+ utils.trim(property.substring(ix + 1));\n\t\t\n\t\treturn property.replace(/\\s*;\\s*$/, getSyntaxPreference('propertyEnd', syntax));\n\t}\n\t\n\t/**\n\t * Transforms snippet value if required. For example, this transformation\n\t * may add <i>!important</i> declaration to CSS property\n\t * @param {String} snippet\n\t * @param {Boolean} isImportant\n\t * @returns {String}\n\t */\n\tfunction transformSnippet(snippet, isImportant, syntax) {\n\t\tif (typeof snippet !== 'string') {\n\t\t\tsnippet = snippet.data;\n\t\t}\n\t\t\n\t\tif (!isSingleProperty(snippet)) {\n\t\t\treturn snippet;\n\t\t}\n\t\t\n\t\tif (isImportant) {\n\t\t\tif (~snippet.indexOf(';')) {\n\t\t\t\tsnippet = snippet.split(';').join(' !important;');\n\t\t\t} else {\n\t\t\t\tsnippet += ' !important';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn formatProperty(snippet, syntax);\n\t}\n\t\n\tfunction getProperties(key) {\n\t\tvar list = prefs.getArray(key);\n\t\tvar addon = prefs.getArray(key + 'Addon');\n\t\tif (addon) {\n\t\t\taddon.forEach(function(prop) {\n\t\t\t\tif (prop.charAt(0) == '-') {\n\t\t\t\t\tlist = utils.without(list, prop.substr(1));\n\t\t\t\t} else {\n\t\t\t\t\tif (prop.charAt(0) == '+')\n\t\t\t\t\t\tprop = prop.substr(1);\n\t\t\t\t\t\n\t\t\t\t\tlist.push(prop);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn list;\n\t}\n\n\t/**\n\t * Tries to produce properties with vendor-prefixed value\n\t * @param  {Object} snippetObj Parsed snippet object\n\t * @return {Array} Array of properties with prefixed values\n\t */\n\tfunction resolvePrefixedValues(snippetObj, isImportant, syntax) {\n\t\tvar prefixes = [];\n\t\tvar lookup = {};\n\n\t\tvar parts = cssEditTree.findParts(snippetObj.value);\n\t\tparts.reverse();\n\t\tparts.forEach(function(p) {\n\t\t\tvar partValue = p.substring(snippetObj.value);\n\t\t\t(findVendorPrefixes(partValue) || []).forEach(function(prefix) {\n\t\t\t\tif (!lookup[prefix]) {\n\t\t\t\t\tlookup[prefix] = snippetObj.value;\n\t\t\t\t\tprefixes.push(prefix);\n\t\t\t\t}\n\n\t\t\t\tlookup[prefix] = utils.replaceSubstring(lookup[prefix], '-' + prefix + '-' + partValue, p);\n\t\t\t});\n\t\t});\n\n\t\treturn prefixes.map(function(prefix) {\n\t\t\treturn transformSnippet(snippetObj.name + ':' + lookup[prefix], isImportant, syntax);\n\t\t});\n\t}\n\t\n\t\n\t// TODO refactor, this looks awkward now\n\taddPrefix('w', {\n\t\tprefix: 'webkit'\n\t});\n\taddPrefix('m', {\n\t\tprefix: 'moz'\n\t});\n\taddPrefix('s', {\n\t\tprefix: 'ms'\n\t});\n\taddPrefix('o', {\n\t\tprefix: 'o'\n\t});\n\t\n\t\n\tmodule = module || {};\n\tmodule.exports = {\n\t\t/**\n\t\t * Adds vendor prefix\n\t\t * @param {String} name One-character prefix name\n\t\t * @param {Object} obj Object describing vendor prefix\n\t\t * @memberOf cssResolver\n\t\t */\n\t\taddPrefix: addPrefix,\n\t\t\n\t\t/**\n\t\t * Check if passed CSS property supports specified vendor prefix\n\t\t * @param {String} property\n\t\t * @param {String} prefix\n\t\t */\n\t\tsupportsPrefix: hasPrefix,\n\n\t\tresolve: function(node, syntax) {\n\t\t\tvar cssSyntaxes = prefs.getArray('css.syntaxes');\n\t\t\tif (cssSyntaxes && ~cssSyntaxes.indexOf(syntax) && node.isElement()) {\n\t\t\t\treturn this.expandToSnippet(node.abbreviation, syntax);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\n\t\t/**\n\t\t * Returns prefixed version of passed CSS property, only if this\n\t\t * property supports such prefix\n\t\t * @param {String} property\n\t\t * @param {String} prefix\n\t\t * @returns\n\t\t */\n\t\tprefixed: function(property, prefix) {\n\t\t\treturn hasPrefix(property, prefix) \n\t\t\t\t? '-' + prefix + '-' + property \n\t\t\t\t: property;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of all registered vendor prefixes\n\t\t * @returns {Array}\n\t\t */\n\t\tlistPrefixes: function() {\n\t\t\treturn vendorPrefixes.map(function(obj) {\n\t\t\t\treturn obj.prefix;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns object describing vendor prefix\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tgetPrefix: function(name) {\n\t\t\treturn vendorPrefixes[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes prefix object\n\t\t * @param {String} name\n\t\t */\n\t\tremovePrefix: function(name) {\n\t\t\tif (name in vendorPrefixes)\n\t\t\t\tdelete vendorPrefixes[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract vendor prefixes from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Object} Object containing array of prefixes and clean \n\t\t * abbreviation name\n\t\t */\n\t\textractPrefixes: function(abbr) {\n\t\t\tif (abbr.charAt(0) != '-') {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tprefixes: null\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\t// abbreviation may either contain sequence of one-character prefixes\n\t\t\t// or just dash, meaning that user wants to produce all possible\n\t\t\t// prefixed properties\n\t\t\tvar i = 1, il = abbr.length, ch;\n\t\t\tvar prefixes = [];\n\t\t\t\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (ch == '-') {\n\t\t\t\t\t// end-sequence character found, stop searching\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ch in vendorPrefixes) {\n\t\t\t\t\tprefixes.push(ch);\n\t\t\t\t} else {\n\t\t\t\t\t// no prefix found, meaning user want to produce all\n\t\t\t\t\t// vendor-prefixed properties\n\t\t\t\t\tprefixes.length = 0;\n\t\t\t\t\ti = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\t// reached end of abbreviation and no property name left\n\t\t\tif (i == il -1) {\n\t\t\t\ti = 1;\n\t\t\t\tprefixes.length = 1;\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(i),\n\t\t\t\tprefixes: prefixes.length ? prefixes : 'all'\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Search for value substring in abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {String} Value substring\n\t\t */\n\t\tfindValuesInAbbreviation: function(abbr, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\t\t\t\n\t\t\tvar i = 0, il = abbr.length, value = '', ch;\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (isNumeric(ch) || ch == '#' || ch == '$' || (ch == '-' && isNumeric(abbr.charAt(i + 1)))) {\n\t\t\t\t\tvalue = abbr.substring(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\t// try to find keywords in abbreviation\n\t\t\tvar property = abbr.substring(0, abbr.length - value.length);\n\t\t\tvar keywords = [];\n\t\t\t// try to extract some commonly-used properties\n\t\t\twhile (~property.indexOf('-') && !resources.findSnippet(syntax, property)) {\n\t\t\t\tvar parts = property.split('-');\n\t\t\t\tvar lastPart = parts.pop();\n\t\t\t\tif (!isValidKeyword(lastPart)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tkeywords.unshift(lastPart);\n\t\t\t\tproperty = parts.join('-');\n\t\t\t}\n\n\t\t\treturn keywords.join('-') + value;\n\t\t},\n\t\t\n\t\tparseValues: function(str) {\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = stringStream.create(str);\n\t\t\tvar values = [];\n\t\t\tvar ch = null;\n\t\t\t\n\t\t\twhile ((ch = stream.next())) {\n\t\t\t\tif (ch == '$') {\n\t\t\t\t\tstream.match(/^[^\\$]+/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else if (ch == '#') {\n\t\t\t\t\tstream.match(/^t|[0-9a-f]+(\\.\\d+)?/i, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else if (ch == '-') {\n\t\t\t\t\tif (isValidKeyword(utils.last(values)) || \n\t\t\t\t\t\t\t( stream.start && isNumeric(str.charAt(stream.start - 1)) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstream.match(/^\\-?[0-9]*(\\.[0-9]+)?[a-z%\\.]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else {\n\t\t\t\t\tstream.match(/^[0-9]*(\\.[0-9]*)?[a-z%]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t\t\n\t\t\treturn values\n\t\t\t\t.filter(function(item) {\n\t\t\t\t\treturn !!item;\n\t\t\t\t})\n\t\t\t\t.map(normalizeValue);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts values from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Object} Object containing array of values and clean \n\t\t * abbreviation name\n\t\t */\n\t\textractValues: function(abbr) {\n\t\t\t// search for value start\n\t\t\tvar abbrValues = this.findValuesInAbbreviation(abbr);\n\t\t\tif (!abbrValues) {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tvalues: null\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(0, abbr.length - abbrValues.length).replace(/-$/, ''),\n\t\t\t\tvalues: this.parseValues(abbrValues)\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Normalizes value, defined in abbreviation.\n\t\t * @param {String} value\n\t\t * @param {String} property\n\t\t * @returns {String}\n\t\t */\n\t\tnormalizeValue: function(value, property) {\n\t\t\tproperty = (property || '').toLowerCase();\n\t\t\tvar unitlessProps = prefs.getArray('css.unitlessProperties');\n\t\t\treturn value.replace(/^(\\-?[0-9\\.]+)([a-z]*)$/, function(str, val, unit) {\n\t\t\t\tif (!unit && (val == '0' || ~unitlessProps.indexOf(property)))\n\t\t\t\t\treturn val;\n\t\t\t\t\n\t\t\t\tif (!unit)\n\t\t\t\t\treturn val.replace(/\\.$/, '') + prefs.get(~val.indexOf('.') ? 'css.floatUnit' : 'css.intUnit');\n\t\t\t\t\n\t\t\t\treturn val + getUnit(unit);\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Expands abbreviation into a snippet\n\t\t * @param {String} abbr Abbreviation name to expand\n\t\t * @param {String} value Abbreviation value\n\t\t * @param {String} syntax Currect syntax or dialect. Default is 'css'\n\t\t * @returns {Object} Array of CSS properties and values or predefined\n\t\t * snippet (string or element)\n\t\t */\n\t\texpand: function(abbr, value, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\t\t\tvar autoInsertPrefixes = prefs.get(syntax + '.autoInsertVendorPrefixes');\n\t\t\t\n\t\t\t// check if snippet should be transformed to !important\n\t\t\tvar isImportant = /^(.+)\\!$/.test(abbr);\n\t\t\tif (isImportant) {\n\t\t\t\tabbr = RegExp.$1;\n\t\t\t}\n\n\t\t\t// check if we have abbreviated resource\n\t\t\tvar snippet = resources.findSnippet(syntax, abbr);\n\t\t\tif (snippet && !autoInsertPrefixes) {\n\t\t\t\treturn transformSnippet(snippet, isImportant, syntax);\n\t\t\t}\n\t\t\t\n\t\t\t// no abbreviated resource, parse abbreviation\n\t\t\tvar prefixData = this.extractPrefixes(abbr);\n\t\t\tvar valuesData = this.extractValues(prefixData.property);\n\t\t\tvar abbrData = utils.extend(prefixData, valuesData);\n\n\t\t\tif (!snippet) {\n\t\t\t\tsnippet = resources.findSnippet(syntax, abbrData.property);\n\t\t\t} else {\n\t\t\t\tabbrData.values = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\t\t// lets try fuzzy search\n\t\t\t\tsnippet = resources.fuzzyFindSnippet(syntax, abbrData.property, parseFloat(prefs.get('css.fuzzySearchMinScore')));\n\t\t\t}\n\t\t\t\n\t\t\tif (!snippet) {\n\t\t\t\tif (!abbrData.property || abbrData.property.endsWith(':')) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tsnippet = abbrData.property + ':' + defaultValue;\n\t\t\t} else if (typeof snippet !== 'string') {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\t\t\t\n\t\t\tif (!isSingleProperty(snippet)) {\n\t\t\t\treturn snippet;\n\t\t\t}\n\t\t\t\n\t\t\tvar snippetObj = this.splitSnippet(snippet);\n\t\t\tvar result = [];\n\t\t\tif (!value && abbrData.values) {\n\t\t\t\tvalue = abbrData.values.map(function(val) {\n\t\t\t\t\treturn this.normalizeValue(val, snippetObj.name);\n\t\t\t\t}, this).join(' ') + ';';\n\t\t\t}\n\t\t\t\n\t\t\tsnippetObj.value = value || snippetObj.value;\n\n\t\t\tvar prefixes = abbrData.prefixes == 'all' || (!abbrData.prefixes && autoInsertPrefixes) \n\t\t\t\t? findInternalPrefixes(snippetObj.name, autoInsertPrefixes && abbrData.prefixes != 'all')\n\t\t\t\t: abbrData.prefixes;\n\t\t\t\t\n\t\t\t\t\n\t\t\tvar names = [], propName;\n\t\t\t(prefixes || []).forEach(function(p) {\n\t\t\t\tif (p in vendorPrefixes) {\n\t\t\t\t\tpropName = vendorPrefixes[p].transformName(snippetObj.name);\n\t\t\t\t\tnames.push(propName);\n\t\t\t\t\tresult.push(transformSnippet(propName + ':' + snippetObj.value,\n\t\t\t\t\t\t\tisImportant, syntax));\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// put the original property\n\t\t\tresult.push(transformSnippet(snippetObj.name + ':' + snippetObj.value, isImportant, syntax));\n\t\t\tnames.push(snippetObj.name);\n\n\t\t\tresult = resolvePrefixedValues(snippetObj, isImportant, syntax).concat(result);\n\t\t\t\n\t\t\tif (prefs.get('css.alignVendor')) {\n\t\t\t\tvar pads = utils.getStringsPads(names);\n\t\t\t\tresult = result.map(function(prop, i) {\n\t\t\t\t\treturn pads[i] + prop;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Same as <code>expand</code> method but transforms output into \n\t\t * Emmet snippet\n\t\t * @param {String} abbr\n\t\t * @param {String} syntax\n\t\t * @returns {String}\n\t\t */\n\t\texpandToSnippet: function(abbr, syntax) {\n\t\t\tvar snippet = this.expand(abbr, null, syntax);\n\t\t\tif (snippet === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (Array.isArray(snippet)) {\n\t\t\t\treturn snippet.join('\\n');\n\t\t\t}\n\t\t\t\n\t\t\tif (typeof snippet !== 'string') {\n\t\t\t\treturn snippet.data;\n\t\t\t}\n\t\t\t\n\t\t\treturn snippet + '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Split snippet into a CSS property-value pair\n\t\t * @param {String} snippet\n\t\t */\n\t\tsplitSnippet: function(snippet) {\n\t\t\tsnippet = utils.trim(snippet);\n\t\t\tif (snippet.indexOf(':') == -1) {\n\t\t\t\treturn {\n\t\t\t\t\tname: snippet,\n\t\t\t\t\tvalue: defaultValue\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tvar pair = snippet.split(':');\n\t\t\t\n\t\t\treturn {\n\t\t\t\tname: utils.trim(pair.shift()),\n\t\t\t\t// replace ${0} tabstop to produce valid vendor-prefixed values\n\t\t\t\t// where possible\n\t\t\t\tvalue: utils.trim(pair.join(':')).replace(/^(\\$\\{0\\}|\\$0)(\\s*;?)$/, '${1}$2')\n\t\t\t};\n\t\t},\n\t\t\n\t\tgetSyntaxPreference: getSyntaxPreference,\n\t\ttransformSnippet: transformSnippet,\n\t\tvendorPrefixes: findVendorPrefixes\n\t};\n\n\treturn module.exports;\n});\n},{\"../assets/caniuse\":\"assets\\\\caniuse.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/template\":\"utils\\\\template.js\"}],\"resolver\\\\cssGradient.js\":[function(require,module,exports){\n/**\n * 'Expand Abbreviation' handler that parses gradient definition from under \n * cursor and updates CSS rule with vendor-prefixed values.\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar prefs = require('../assets/preferences');\n\tvar resources = require('../assets/resources');\n\tvar utils = require('../utils/common');\n\tvar stringStream = require('../assets/stringStream');\n\tvar cssResolver = require('./css');\n\tvar range = require('../assets/range');\n\tvar cssEditTree = require('../editTree/css');\n\tvar editorUtils = require('../utils/editor');\n\tvar linearGradient = require('./gradient/linear');\n\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus', 'styl'];\n\t\n\t// XXX define preferences\n\tprefs.define('css.gradient.prefixes', 'webkit, moz, o',\n\t\t\t'A comma-separated list of vendor-prefixes for which values should ' \n\t\t\t+ 'be generated.');\n\t\n\tprefs.define('css.gradient.oldWebkit', false,\n\t\t\t'Generate gradient definition for old Webkit implementations');\n\t\n\tprefs.define('css.gradient.omitDefaultDirection', true,\n\t\t'Do not output default direction definition in generated gradients.');\n\t\n\tprefs.define('css.gradient.defaultProperty', 'background-image',\n\t\t'When gradient expanded outside CSS value context, it will produce '\n\t\t\t+ 'properties with this name.');\n\t\n\tprefs.define('css.gradient.fallback', false,\n\t\t\t'With this option enabled, CSS gradient generator will produce '\n\t\t\t+ '<code>background-color</code> property with gradient first color '\n\t\t\t+ 'as fallback for old browsers.');\n\n\t/**\n\t * Resolves property name (abbreviation): searches for snippet definition in \n\t * 'resources' and returns new name of matched property\n\t */\n\tfunction resolvePropertyName(name, syntax) {\n\t\tvar snippet = resources.findSnippet(syntax, name);\n\t\t\n\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\tvar minScore = parseFloat(prefs.get('css.fuzzySearchMinScore'));\n\t\t\tsnippet = resources.fuzzyFindSnippet(syntax, name, minScore);\n\t\t}\n\t\t\n\t\tif (snippet) {\n\t\t\tif (typeof snippet !== 'string') {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\t\t\t\n\t\t\treturn cssResolver.splitSnippet(snippet).name;\n\t\t}\n\t}\n\n\t/**\n\t * Returns vendor prefixes for given gradient type\n\t * @param {String} type Gradient type (currently, 'linear-gradient' \n\t * is the only supported value)\n\t * @return {Array}\n\t */\n\tfunction getGradientPrefixes(type) {\n\t\tvar prefixes = cssResolver.vendorPrefixes(type);\n\t\tif (!prefixes) {\n\t\t\t// disabled Can I Use, fallback to property list\n\t\t\tprefixes = prefs.getArray('css.gradient.prefixes');\n\t\t}\n\n\t\treturn prefixes || [];\n\t}\n\t\n\tfunction getPrefixedNames(type) {\n\t\tvar prefixes = getGradientPrefixes(type);\n\t\tvar names = prefixes \n\t\t\t? prefixes.map(function(p) {\n\t\t\t\treturn '-' + p + '-' + type;\n\t\t\t}) \n\t\t\t: [];\n\t\t\n\t\tnames.push(type);\n\t\t\n\t\treturn names;\n\t}\n\t\n\t/**\n\t * Returns list of CSS properties with gradient\n\t * @param {Array} gradient List of gradient objects\n\t * @param {CSSEditElement} property Original CSS property\n\t * @returns {Array}\n\t */\n\tfunction getPropertiesForGradient(gradients, property) {\n\t\tvar props = [];\n\t\tvar propertyName = property.name();\n\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\n\t\t\n\t\tif (prefs.get('css.gradient.fallback') && ~propertyName.toLowerCase().indexOf('background')) {\n\t\t\tprops.push({\n\t\t\t\tname: 'background-color',\n\t\t\t\tvalue: '${1:' + gradients[0].gradient.colorStops[0].color + '}'\n\t\t\t});\n\t\t}\n\t\t\n\t\tvar value = property.value();\n\t\tgetGradientPrefixes('linear-gradient').forEach(function(prefix) {\n\t\t\tvar name = cssResolver.prefixed(propertyName, prefix);\n\t\t\tif (prefix == 'webkit' && prefs.get('css.gradient.oldWebkit')) {\n\t\t\t\ttry {\n\t\t\t\t\tprops.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: insertGradientsIntoCSSValue(gradients, value, {\n\t\t\t\t\t\t\tprefix: prefix, \n\t\t\t\t\t\t\toldWebkit: true,\n\t\t\t\t\t\t\tomitDefaultDirection: omitDir\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\t\t\t\n\t\t\tprops.push({\n\t\t\t\tname: name,\n\t\t\t\tvalue: insertGradientsIntoCSSValue(gradients, value, {\n\t\t\t\t\tprefix: prefix,\n\t\t\t\t\tomitDefaultDirection: omitDir\n\t\t\t\t})\n\t\t\t});\n\t\t});\n\t\t\n\t\treturn props.sort(function(a, b) {\n\t\t\treturn b.name.length - a.name.length;\n\t\t});\n\t}\n\n\t/**\n\t * Replaces old gradient definitions in given CSS property value\n\t * with new ones, preserving original formatting\n\t * @param  {Array} gradients List of CSS gradients\n\t * @param  {String} value     Original CSS value\n\t * @param  {Object} options   Options for gradients stringify() method\n\t * @return {String}\n\t */\n\tfunction insertGradientsIntoCSSValue(gradients, value, options) {\n\t\t// gradients *should* passed in order they actually appear in CSS property\n\t\t// iterate over it in backward direction to preserve gradient locations\n\t\toptions = options || {};\n\t\tgradients = utils.clone(gradients);\n\t\tgradients.reverse().forEach(function(item, i) {\n\t\t\tvar suffix = !i && options.placeholder ? options.placeholder : '';\n\t\t\tvar str = options.oldWebkit ? item.gradient.stringifyOldWebkit(options) : item.gradient.stringify(options);\n\t\t\tvalue = utils.replaceSubstring(value, str + suffix, item.matchedPart);\n\t\t});\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * Returns list of properties with the same meaning \n\t * (e.g. vendor-prefixed + original name)\n\t * @param  {String} property CSS property name\n\t * @return {Array}\n\t */\n\tfunction similarPropertyNames(property) {\n\t\tif (typeof property !== 'string') {\n\t\t\tproperty = property.name();\n\t\t}\n\n\t\tvar similarProps = (cssResolver.vendorPrefixes(property) || []).map(function(prefix) {\n\t\t\treturn '-' + prefix + '-' + property;\n\t\t});\n\t\tsimilarProps.push(property);\n\t\treturn similarProps;\n\t}\n\t\n\t/**\n\t * Pastes gradient definition into CSS rule with correct vendor-prefixes\n\t * @param {EditElement} property Matched CSS property\n\t * @param {Array} gradients List of gradients to insert\n\t */\n\tfunction pasteGradient(property, gradients) {\n\t\tvar rule = property.parent;\n\t\tvar alignVendor = prefs.get('css.alignVendor');\n\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\n\t\t\n\t\t// we may have aligned gradient definitions: find the smallest value\n\t\t// separator\n\t\tvar sep = property.styleSeparator;\n\t\tvar before = property.styleBefore;\n\t\t\n\t\t// first, remove all properties within CSS rule with the same name and\n\t\t// gradient definition\n\t\trule.getAll(similarPropertyNames(property)).forEach(function(item) {\n\t\t\tif (item != property && /gradient/i.test(item.value())) {\n\t\t\t\tif (item.styleSeparator.length < sep.length) {\n\t\t\t\t\tsep = item.styleSeparator;\n\t\t\t\t}\n\t\t\t\tif (item.styleBefore.length < before.length) {\n\t\t\t\t\tbefore = item.styleBefore;\n\t\t\t\t}\n\t\t\t\trule.remove(item);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (alignVendor) {\n\t\t\t// update prefix\n\t\t\tif (before != property.styleBefore) {\n\t\t\t\tvar fullRange = property.fullRange();\n\t\t\t\trule._updateSource(before, fullRange.start, fullRange.start + property.styleBefore.length);\n\t\t\t\tproperty.styleBefore = before;\n\t\t\t}\n\t\t\t\n\t\t\t// update separator value\n\t\t\tif (sep != property.styleSeparator) {\n\t\t\t\trule._updateSource(sep, property.nameRange().end, property.valueRange().start);\n\t\t\t\tproperty.styleSeparator = sep;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar value = property.value();\n\n\t\t// create list of properties to insert\n\t\tvar propsToInsert = getPropertiesForGradient(gradients, property);\n\t\t\n\t\t// align prefixed values\n\t\tif (alignVendor) {\n\t\t\tvar names = [], values = [];\n\t\t\tpropsToInsert.forEach(function(item) {\n\t\t\t\tnames.push(item.name);\n\t\t\t\tvalues.push(item.value);\n\t\t\t});\n\t\t\tvalues.push(property.value());\n\t\t\tnames.push(property.name());\n\t\t\t\n\t\t\tvar valuePads = utils.getStringsPads(values.map(function(v) {\n\t\t\t\treturn v.substring(0, v.indexOf('('));\n\t\t\t}));\n\t\t\t\n\t\t\tvar namePads = utils.getStringsPads(names);\n\t\t\tproperty.name(namePads[namePads.length - 1] + property.name());\n\t\t\t\n\t\t\tpropsToInsert.forEach(function(prop, i) {\n\t\t\t\tprop.name = namePads[i] + prop.name;\n\t\t\t\tprop.value = valuePads[i] + prop.value;\n\t\t\t});\n\t\t\t\n\t\t\tproperty.value(valuePads[valuePads.length - 1] + property.value());\n\t\t}\n\t\t\n\t\t// put vendor-prefixed definitions before current rule\n\t\tpropsToInsert.forEach(function(prop) {\n\t\t\trule.add(prop.name, prop.value, rule.indexOf(property));\n\t\t});\n\n\t\t// put vanilla-clean gradient definition into current rule\n\t\tproperty.value(insertGradientsIntoCSSValue(gradients, value, {\n\t\t\tplaceholder: '${2}',\n\t\t\tomitDefaultDirection: omitDir\n\t\t}));\n\t}\n\n\t/**\n\t * Validates caret position relatively to located gradients\n\t * in CSS rule. In other words, it checks if its safe to \n\t * expand gradients for current caret position or not.\n\t * \n\t * See issue https://github.com/sergeche/emmet-sublime/issues/411\n\t * \n\t * @param  {Array} gradients List of parsed gradients\n\t * @param  {Number} caretPos  Current caret position\n\t * @param  {String} syntax    Current document syntax\n\t * @return {Boolean}\n\t */\n\tfunction isValidCaretPosition(gradients, caretPos, syntax) {\n\t\tsyntax = syntax || 'css';\n\t\tif (syntax == 'css' || syntax == 'less' || syntax == 'scss') {\n\t\t\treturn true;\n\t\t}\n\n\t\tvar offset = gradients.property.valueRange(true).start;\n\t\tvar parts = gradients.gradients;\n\n\t\t// in case of preprocessors where properties are separated with\n\t\t// newlines, make sure theres no gradient definition past\n\t\t// current caret position. \n\t\tfor (var i = parts.length - 1; i >= 0; i--) {\n\t\t\tif (parts[i].matchedPart.start + offset >= caretPos) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\t\n\tmodule = module || {};\n\treturn module.exports = {\n\t\t/**\n\t\t * Search for gradient definitions inside CSS property value\n\t\t * @returns {Array} Array of matched gradients\n\t\t */\n\t\tfindGradients: function(cssProp) {\n\t\t\tvar value = cssProp.value();\n\t\t\tvar gradients = [];\n\t\t\tvar that = this;\n\t\t\tcssProp.valueParts().forEach(function(part) {\n\t\t\t\tvar partValue = part.substring(value);\n\t\t\t\tif (linearGradient.isLinearGradient(partValue)) {\n\t\t\t\t\tvar gradient = linearGradient.parse(partValue);\n\t\t\t\t\tif (gradient) {\n\t\t\t\t\t\tgradients.push({\n\t\t\t\t\t\t\tgradient: gradient,\n\t\t\t\t\t\t\tmatchedPart: part\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\treturn gradients.length ? gradients : null;\n\t\t},\n\n\t\t/**\n\t\t * Returns list of gradients found in CSS property\n\t\t * of given CSS code in specified (caret) position\n\t\t * @param  {String} css CSS code snippet\n\t\t * @param  {Number} pos Character index where to start searching for CSS property\n\t\t * @return {Array}\n\t\t */\n\t\tgradientsFromCSSProperty: function(css, pos) {\n\t\t\tvar cssProp = cssEditTree.propertyFromPosition(css, pos);\n\t\t\tif (cssProp) {\n\t\t\t\tvar grd = this.findGradients(cssProp);\n\t\t\t\tif (grd) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tproperty: cssProp,\n\t\t\t\t\t\tgradients: grd\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\t/**\n\t\t * Handler for Expand Abbreviation action\n\t\t * @param  {IEmmetEditor} editor\n\t\t * @param  {String} syntax\n\t\t * @param  {String} profile\n\t\t * return {Boolean}\n\t\t */\n\t\texpandAbbreviationHandler: function(editor, syntax, profile) {\n\t\t\tvar info = editorUtils.outputInfo(editor, syntax, profile);\n\t\t\tif (!~cssSyntaxes.indexOf(info.syntax)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t// let's see if we are expanding gradient definition\n\t\t\tvar caret = editor.getCaretPos();\n\t\t\tvar content = info.content;\n\t\t\tvar gradients = this.gradientsFromCSSProperty(content, caret);\n\t\t\tif (gradients) {\n\t\t\t\tif (!isValidCaretPosition(gradients, caret, info.syntax)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar cssProperty = gradients.property;\n\t\t\t\tvar cssRule = cssProperty.parent;\n\t\t\t\tvar ruleStart = cssRule.options.offset || 0;\n\t\t\t\tvar ruleEnd = ruleStart + cssRule.toString().length;\n\t\t\t\t\n\t\t\t\t// Handle special case:\n\t\t\t\t// user wrote gradient definition between existing CSS \n\t\t\t\t// properties and did not finished it with semicolon.\n\t\t\t\t// In this case, we have semicolon right after gradient \n\t\t\t\t// definition and re-parse rule again\n\t\t\t\tif (/[\\n\\r]/.test(cssProperty.value())) {\n\t\t\t\t\t// insert semicolon at the end of gradient definition\n\t\t\t\t\tvar insertPos = cssProperty.valueRange(true).start + utils.last(gradients.gradients).matchedPart.end;\n\t\t\t\t\tcontent = utils.replaceSubstring(content, ';', insertPos);\n\t\t\t\t\t\n\t\t\t\t\tvar _gradients = this.gradientsFromCSSProperty(content, caret);\n\t\t\t\t\tif (_gradients) {\n\t\t\t\t\t\tgradients = _gradients;\n\t\t\t\t\t\tcssProperty = gradients.property;\n\t\t\t\t\t\tcssRule = cssProperty.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// make sure current property has terminating semicolon\n\t\t\t\tcssProperty.end(';');\n\t\t\t\t\n\t\t\t\t// resolve CSS property name\n\t\t\t\tvar resolvedName = resolvePropertyName(cssProperty.name(), syntax);\n\t\t\t\tif (resolvedName) {\n\t\t\t\t\tcssProperty.name(resolvedName);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpasteGradient(cssProperty, gradients.gradients);\n\t\t\t\teditor.replaceContent(cssRule.toString(), ruleStart, ruleEnd, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn this.expandGradientOutsideValue(editor, syntax);\n\t\t},\n\n\t\t/**\n\t\t * Tries to expand gradient outside CSS value \n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {String} syntax\n\t\t */\n\t\texpandGradientOutsideValue: function(editor, syntax) {\n\t\t\tvar propertyName = prefs.get('css.gradient.defaultProperty');\n\t\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\n\t\t\t\n\t\t\tif (!propertyName) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t// assuming that gradient definition is written on new line,\n\t\t\t// do a simplified parsing\n\t\t\tvar content = String(editor.getContent());\n\t\t\t/** @type Range */\n\t\t\tvar lineRange = range.create(editor.getCurrentLineRange());\n\t\t\t\n\t\t\t// get line content and adjust range with padding\n\t\t\tvar line = lineRange.substring(content)\n\t\t\t\t.replace(/^\\s+/, function(pad) {\n\t\t\t\t\tlineRange.start += pad.length;\n\t\t\t\t\treturn '';\n\t\t\t\t})\n\t\t\t\t.replace(/\\s+$/, function(pad) {\n\t\t\t\t\tlineRange.end -= pad.length;\n\t\t\t\t\treturn '';\n\t\t\t\t});\n\n\t\t\t// trick parser: make it think that were parsing actual CSS property\n\t\t\tvar fakeCSS = 'a{' + propertyName + ': ' + line + ';}';\n\t\t\tvar gradients = this.gradientsFromCSSProperty(fakeCSS, fakeCSS.length - 2);\n\t\t\tif (gradients) {\n\t\t\t\tvar props = getPropertiesForGradient(gradients.gradients, gradients.property);\n\t\t\t\tprops.push({\n\t\t\t\t\tname: gradients.property.name(),\n\t\t\t\t\tvalue: insertGradientsIntoCSSValue(gradients.gradients, gradients.property.value(), {\n\t\t\t\t\t\tplaceholder: '${2}',\n\t\t\t\t\t\tomitDefaultDirection: omitDir\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tvar sep = cssResolver.getSyntaxPreference('valueSeparator', syntax);\n\t\t\t\tvar end = cssResolver.getSyntaxPreference('propertyEnd', syntax);\n\t\t\t\t\n\t\t\t\tif (prefs.get('css.alignVendor')) {\n\t\t\t\t\tvar pads = utils.getStringsPads(props.map(function(prop) {\n\t\t\t\t\t\treturn prop.value.substring(0, prop.value.indexOf('('));\n\t\t\t\t\t}));\n\t\t\t\t\tprops.forEach(function(prop, i) {\n\t\t\t\t\t\tprop.value = pads[i] + prop.value;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprops = props.map(function(item) {\n\t\t\t\t\treturn item.name + sep + item.value + end;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\teditor.replaceContent(props.join('\\n'), lineRange.start, lineRange.end);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\n\t\t/**\n\t\t * Handler for Reflect CSS Value action\n\t\t * @param  {String} property\n\t\t */\n\t\treflectValueHandler: function(property) {\n\t\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\n\t\t\tvar gradients = this.findGradients(property);\n\t\t\tif (!gradients) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tvar that = this;\n\t\t\tvar value = property.value();\n\t\t\t\n\t\t\t// reflect value for properties with the same name\n\t\t\tproperty.parent.getAll(similarPropertyNames(property)).forEach(function(prop) {\n\t\t\t\tif (prop === property) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// make sure current property contains gradient definition,\n\t\t\t\t// otherwise  skip it\n\t\t\t\tvar localGradients = that.findGradients(prop);\n\t\t\t\tif (localGradients) {\n\t\t\t\t\t// detect vendor prefix for current property\n\t\t\t\t\tvar localValue = prop.value();\n\t\t\t\t\tvar dfn = localGradients[0].matchedPart.substring(localValue);\n\t\t\t\t\tvar prefix = '';\n\t\t\t\t\tif (/^\\s*\\-([a-z]+)\\-/.test(dfn)) {\n\t\t\t\t\t\tprefix = RegExp.$1;\n\t\t\t\t\t}\n\n\t\t\t\t\tprop.value(insertGradientsIntoCSSValue(gradients, value, {\n\t\t\t\t\t\tprefix: prefix,\n\t\t\t\t\t\tomitDefaultDirection: omitDir\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t};\n});\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/range\":\"assets\\\\range.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\",\"./css\":\"resolver\\\\css.js\",\"./gradient/linear\":\"resolver\\\\gradient\\\\linear.js\"}],\"resolver\\\\gradient\\\\linear.js\":[function(require,module,exports){\n/**\n * CSS linear gradient definition\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar stringStream = require('../../assets/stringStream');\n\tvar utils = require('../../utils/common');\n\n\t// all directions are expressed in new style degrees\n\tvar directions = {\n\t\t'bottom': 0,\n\t\t'bottom left': 45,\n\t\t'left': 90,\n\t\t'top left': 135,\n\t\t'top': 180,\n\t\t'top right': 225,\n\t\t'right': 270,\n\t\t'bottom right': 315,\n\t\t\n\t\t'to top': 0,\n\t\t'to top right': 45,\n\t\t'to right': 90,\n\t\t'to bottom right': 135,\n\t\t'to bottom': 180,\n\t\t'to bottom left': 225,\n\t\t'to left': 270,\n\t\t'to top left': 315\n\t};\n\n\tvar defaultDirections = ['top', 'to bottom', '0deg'];\n\n\n\tvar reLinearGradient = /^\\s*(\\-[a-z]+\\-)?(lg|linear\\-gradient)\\s*\\(/i;\n\tvar reDeg = /(\\d+)deg/i;\n\tvar reKeyword = /top|bottom|left|right/i;\n\n\tfunction LinearGradient(dfn) {\n\t\tthis.colorStops = [];\n\t\tthis.direction = 180;\n\n\t\t// extract tokens\n\t\tvar stream = stringStream.create(utils.trim(dfn));\n\t\tvar ch, cur;\n\t\twhile ((ch = stream.next())) {\n\t\t\tif (stream.peek() == ',') {\n\t\t\t\t// Is it a first entry? Check if its a direction\n\t\t\t\tcur = stream.current();\n\n\t\t\t\tif (!this.colorStops.length && (reDeg.test(cur) || reKeyword.test(cur))) {\n\t\t\t\t\tthis.direction = resolveDirection(cur);\n\t\t\t\t} else {\n\t\t\t\t\tthis.addColorStop(cur);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstream.next();\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t} else if (ch == '(') { // color definition, like 'rgb(0,0,0)'\n\t\t\t\tstream.skipTo(')');\n\t\t\t}\n\t\t}\n\t\t\n\t\t// add last token\n\t\tthis.addColorStop(stream.current());\t\t\n\t}\n\n\tLinearGradient.prototype = {\n\t\ttype: 'linear-gradient',\n\t\taddColorStop: function(color, ix) {\n\t\t\tcolor = normalizeSpace(color || '');\n\t\t\tif (!color) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcolor = this.parseColorStop(color);\n\n\t\t\tif (typeof ix === 'undefined') {\n\t\t\t\tthis.colorStops.push(color);\n\t\t\t} else {\n\t\t\t\tthis.colorStops.splice(ix, 0, color);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Parses color stop definition\n\t\t * @param {String} colorStop\n\t\t * @returns {Object}\n\t\t */\n\t\tparseColorStop: function(colorStop) {\n\t\t\tcolorStop = normalizeSpace(colorStop);\n\t\t\t\n\t\t\t// find color declaration\n\t\t\t// first, try complex color declaration, like rgb(0,0,0)\n\t\t\tvar color = null;\n\t\t\tcolorStop = colorStop.replace(/^(\\w+\\(.+?\\))\\s*/, function(str, c) {\n\t\t\t\tcolor = c;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\tif (!color) {\n\t\t\t\t// try simple declaration, like yellow, #fco, #ffffff, etc.\n\t\t\t\tvar parts = colorStop.split(' ');\n\t\t\t\tcolor = parts[0];\n\t\t\t\tcolorStop = parts[1] || '';\n\t\t\t}\n\t\t\t\n\t\t\tvar result = {\n\t\t\t\tcolor: color\n\t\t\t};\n\t\t\t\n\t\t\tif (colorStop) {\n\t\t\t\t// there's position in color stop definition\n\t\t\t\tcolorStop.replace(/^(\\-?[\\d\\.]+)([a-z%]+)?$/, function(str, pos, unit) {\n\t\t\t\t\tresult.position = pos;\n\t\t\t\t\tif (~pos.indexOf('.')) {\n\t\t\t\t\t\tunit = '';\n\t\t\t\t\t} else if (!unit) {\n\t\t\t\t\t\tunit = '%';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (unit) {\n\t\t\t\t\t\tresult.unit = unit;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\n\t\tstringify: function(options) {\n\t\t\toptions = options || {};\n\t\t\tvar fn = 'linear-gradient';\n\t\t\tif (options.prefix) {\n\t\t\t\tfn = '-' + options.prefix + '-' + fn;\n\t\t\t}\n\t\t\t\t\n\t\t\t// transform color-stops\n\t\t\tvar parts = this.colorStops.map(function(cs) {\n\t\t\t\tvar pos = cs.position ? ' ' + cs.position + (cs.unit || '') : '';\n\t\t\t\treturn cs.color + pos;\n\t\t\t});\n\n\t\t\tvar dir = stringifyDirection(this.direction, !!options.prefix);\n\t\t\tif (!options.omitDefaultDirection || !~defaultDirections.indexOf(dir)) {\n\t\t\t\tparts.unshift(dir);\n\t\t\t}\n\n\t\t\treturn fn + '(' + parts.join(', ') + ')';\n\t\t},\n\n\t\tstringifyOldWebkit: function() {\n\t\t\tvar colorStops = this.colorStops.map(function(item) {\n\t\t\t\treturn utils.clone(item);\n\t\t\t});\n\t\t\t\n\t\t\t// normalize color-stops position\n\t\t\tcolorStops.forEach(function(cs) {\n\t\t\t\tif (!('position' in cs)) // implied position\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tif (~cs.position.indexOf('.') || cs.unit == '%') {\n\t\t\t\t\tcs.position = parseFloat(cs.position) / (cs.unit == '%' ? 100 : 1);\n\t\t\t\t} else {\n\t\t\t\t\tthrow \"Can't convert color stop '\" + (cs.position + (cs.unit || '')) + \"'\";\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tthis._fillImpliedPositions(colorStops);\n\t\t\t\n\t\t\t// transform color-stops into string representation\n\t\t\tcolorStops = colorStops.map(function(cs, i) {\n\t\t\t\tif (!cs.position && !i) {\n\t\t\t\t\treturn 'from(' + cs.color + ')';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (cs.position == 1 && i == colorStops.length - 1) {\n\t\t\t\t\treturn 'to(' + cs.color + ')';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn 'color-stop(' + (cs.position.toFixed(2).replace(/\\.?0+$/, '')) + ', ' + cs.color + ')';\n\t\t\t});\n\t\t\t\n\t\t\treturn '-webkit-gradient(linear, ' \n\t\t\t\t+ oldWebkitDirection((this.direction + 180) % 360)\n\t\t\t\t+ ', '\n\t\t\t\t+ colorStops.join(', ')\n\t\t\t\t+ ')';\n\t\t},\n\n\t\t/**\n\t\t * Fills-out implied positions in color-stops. This function is useful for\n\t\t * old Webkit gradient definitions\n\t\t */\n\t\t_fillImpliedPositions: function(colorStops) {\n\t\t\tvar from = 0;\n\t\t\t\n\t\t\tcolorStops.forEach(function(cs, i) {\n\t\t\t\t// make sure that first and last positions are defined\n\t\t\t\tif (!i) {\n\t\t\t\t\treturn cs.position = cs.position || 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (i == colorStops.length - 1 && !('position' in cs)) {\n\t\t\t\t\tcs.position = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ('position' in cs) {\n\t\t\t\t\tvar start = colorStops[from].position || 0;\n\t\t\t\t\tvar step = (cs.position - start) / (i - from);\n\t\t\t\t\tcolorStops.slice(from, i).forEach(function(cs2, j) {\n\t\t\t\t\t\tcs2.position = start + step * j;\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tfrom = i;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tvalueOf: function() {\n\t\t\treturn this.stringify();\n\t\t}\n\t};\n\n\tfunction normalizeSpace(str) {\n\t\treturn utils.trim(str).replace(/\\s+/g, ' ');\n\t}\n\n\t/**\n\t * Resolves textual direction to degrees\n\t * @param  {String} dir Direction to resolve\n\t * @return {Number}\n\t */\n\tfunction resolveDirection(dir) {\n\t\tif (typeof dir == 'number') {\n\t\t\treturn dir;\n\t\t}\n\n\t\tdir = normalizeSpace(dir).toLowerCase();\n\t\tif (reDeg.test(dir)) {\n\t\t\treturn +RegExp.$1;\n\t\t}\n\n\t\tvar prefix = /^to\\s/.test(dir) ? 'to ' : '';\n\t\tvar left   = ~dir.indexOf('left')   && 'left';\n\t\tvar right  = ~dir.indexOf('right')  && 'right';\n\t\tvar top    = ~dir.indexOf('top')    && 'top';\n\t\tvar bottom = ~dir.indexOf('bottom') && 'bottom';\n\n\t\tvar key = normalizeSpace(prefix + (top || bottom || '') + ' ' + (left || right || ''));\n\t\treturn directions[key] || 0;\n\t}\n\n\t/**\n\t * Tries to find keyword for given direction, expressed in degrees\n\t * @param  {Number} dir Direction (degrees)\n\t * @param {Boolean} oldStyle Use old style keywords (e.g. \"top\" instead of \"to bottom\")\n\t * @return {String}     Keyword or <code>Ndeg</code> expression\n\t */\n\tfunction stringifyDirection(dir, oldStyle) {\n\t\tvar reNewStyle = /^to\\s/;\n\t\tvar keys = Object.keys(directions).filter(function(k) {\n\t\t\tvar hasPrefix = reNewStyle.test(k);\n\t\t\treturn oldStyle ? !hasPrefix : hasPrefix;\n\t\t});\n\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (directions[keys[i]] == dir) {\n\t\t\t\treturn keys[i];\n\t\t\t}\n\t\t}\n\n\t\tif (oldStyle) {\n\t\t\tdir = (dir + 270) % 360;\n\t\t}\n\n\t\treturn dir + 'deg';\n\t}\n\n\t/**\n\t * Creates direction definition for old Webkit gradients\n\t * @param {String} direction\n\t * @returns {String}\n\t */\n\tfunction oldWebkitDirection(dir) {\n\t\tdir = stringifyDirection(dir, true);\n\t\t\n\t\tif(reDeg.test(dir)) {\n\t\t\tthrow \"The direction is an angle that cant be converted.\";\n\t\t}\n\t\t\n\t\tvar v = function(pos) {\n\t\t\treturn ~dir.indexOf(pos) ? '100%' : '0';\n\t\t};\n\t\t\n\t\treturn v('left') + ' ' + v('top') + ', ' + v('right') + ' ' + v('bottom');\n\t}\n\n\treturn {\n\t\t/**\n\t\t * Parses gradient definition into an object.\n\t\t * This object can be used to transform gradient into various\n\t\t * forms\n\t\t * @param  {String} gradient Gradient definition\n\t\t * @return {LinearGradient}\n\t\t */\n\t\tparse: function(gradient) {\n\t\t\t// cut out all redundant data\n\t\t\tif (this.isLinearGradient(gradient)) {\n\t\t\t\tgradient = gradient.replace(/^\\s*[\\-a-z]+\\s*\\(|\\)\\s*$/ig, '');\n\t\t\t} else {\n\t\t\t\tthrow 'Invalid linear gradient definition:\\n' + gradient;\n\t\t\t}\n\n\t\t\treturn new LinearGradient(gradient);\n\t\t},\n\n\t\t/**\n\t\t * Check if given string can be parsed as linear gradient\n\t\t * @param  {String}  str\n\t\t * @return {Boolean}\n\t\t */\n\t\tisLinearGradient: function(str) {\n\t\t\treturn reLinearGradient.test(str);\n\t\t},\n\n\t\tresolveDirection: resolveDirection,\n\t\tstringifyDirection: stringifyDirection\n\t};\n});\n},{\"../../assets/stringStream\":\"assets\\\\stringStream.js\",\"../../utils/common\":\"utils\\\\common.js\"}],\"resolver\\\\tagName.js\":[function(require,module,exports){\n/**\n * Module for resolving tag names: returns best matched tag name for child\n * element based on passed parent's tag name. Also provides utility function\n * for element type detection (inline, block-level, empty)\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\t\n\tvar elementTypes = {\n//\t\tempty: 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command'.split(','),\n\t\tempty: [],\n\t\tblockLevel: 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6'.split(','),\n\t\tinlineLevel: 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(',')\n\t};\n\t\n\tvar elementMap = {\n\t\t'p': 'span',\n\t\t'ul': 'li',\n\t\t'ol': 'li',\n\t\t'table': 'tr',\n\t\t'tr': 'td',\n\t\t'tbody': 'tr',\n\t\t'thead': 'tr',\n\t\t'tfoot': 'tr',\n\t\t'colgroup': 'col',\n\t\t'select': 'option',\n\t\t'optgroup': 'option',\n\t\t'audio': 'source',\n\t\t'video': 'source',\n\t\t'object': 'param',\n\t\t'map': 'area'\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Returns best matched child element name for passed parent's\n\t\t * tag name\n\t\t * @param {String} name\n\t\t * @returns {String}\n\t\t * @memberOf tagName\n\t\t */\n\t\tresolve: function(name) {\n\t\t\tname = (name || '').toLowerCase();\n\t\t\t\n\t\t\tif (name in elementMap)\n\t\t\t\treturn this.getMapping(name);\n\t\t\t\n\t\t\tif (this.isInlineLevel(name))\n\t\t\t\treturn 'span';\n\t\t\t\n\t\t\treturn 'div';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns mapped child element name for passed parent's name \n\t\t * @param {String} name\n\t\t * @returns {String}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\treturn elementMap[name.toLowerCase()];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element name belongs to inline-level element\n\t\t * @param {String} name\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisInlineLevel: function(name) {\n\t\t\treturn this.isTypeOf(name, 'inlineLevel');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element belongs to block-level element.\n\t\t * For better matching of unknown elements (for XML, for example), \n\t\t * you should use <code>!this.isInlineLevel(name)</code>\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisBlockLevel: function(name) {\n\t\t\treturn this.isTypeOf(name, 'blockLevel');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element is void (i.e. should not have closing tag).\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisEmptyElement: function(name) {\n\t\t\treturn this.isTypeOf(name, 'empty');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Generic function for testing if element name belongs to specified\n\t\t * elements collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} type Collection name\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisTypeOf: function(name, type) {\n\t\t\treturn ~elementTypes[type].indexOf(name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new parentchild mapping\n\t\t * @param {String} parent\n\t\t * @param {String} child\n\t\t */\n\t\taddMapping: function(parent, child) {\n\t\t\telementMap[parent] = child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes parent-child mapping\n\t\t */\n\t\tremoveMapping: function(parent) {\n\t\t\tif (parent in elementMap)\n\t\t\t\tdelete elementMap[parent];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new element into collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} collection Collection name\n\t\t */\n\t\taddElementToCollection: function(name, collection) {\n\t\t\tif (!elementTypes[collection])\n\t\t\t\telementTypes[collection] = [];\n\t\t\t\n\t\t\tvar col = this.getCollection(collection);\n\t\t\tif (!~col.indexOf(name)) {\n\t\t\t\tcol.push(name);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes element name from specified collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} collection Collection name\n\t\t * @returns\n\t\t */\n\t\tremoveElementFromCollection: function(name, collection) {\n\t\t\tif (collection in elementTypes) {\n\t\t\t\telementTypes[collection] = utils.without(this.getCollection(collection), name);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns elements name collection\n\t\t * @param {String} name Collection name\n\t\t * @returns {Array}\n\t\t */\n\t\tgetCollection: function(name) {\n\t\t\treturn elementTypes[name];\n\t\t}\n\t};\n});\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"snippets.json\":[function(require,module,exports){\nmodule.exports={\n\t\"variables\": {\n\t\t\"lang\": \"en\",\n\t\t\"locale\": \"en-US\",\n\t\t\"charset\": \"UTF-8\",\n\t\t\"indentation\": \"\\t\",\n\t\t\"newline\": \"\\n\"\n\t},\n\t\n\t\"css\": {\n\t\t\"filters\": \"css\",\n\t\t\"profile\": \"css\",\n\t\t\"snippets\": {\n\t\t\t\"@i\": \"@import url(|);\",\n\t\t\t\"@import\": \"@import url(|);\",\n\t\t\t\"@m\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\"@media\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\"@f\": \"@font-face {\\n\\tfont-family:|;\\n\\tsrc:url(|);\\n}\",\n\t\t\t\"@f+\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\n\t\t\t\"@kf\": \"@-webkit-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-o-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-moz-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\",\n\n\t\t\t\"anim\": \"animation:|;\",\n\t\t\t\"anim-\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};\",\n\t\t\t\"animdel\": \"animation-delay:${1:time};\",\n\t\t\t\n\t\t\t\"animdir\": \"animation-direction:${1:normal};\",\n\t\t\t\"animdir:n\": \"animation-direction:normal;\",\n\t\t\t\"animdir:r\": \"animation-direction:reverse;\",\n\t\t\t\"animdir:a\": \"animation-direction:alternate;\",\n\t\t\t\"animdir:ar\": \"animation-direction:alternate-reverse;\",\n\t\t\t\n\t\t\t\"animdur\": \"animation-duration:${1:0}s;\",\n\t\t\t\n\t\t\t\"animfm\": \"animation-fill-mode:${1:both};\",\n\t\t\t\"animfm:f\": \"animation-fill-mode:forwards;\",\n\t\t\t\"animfm:b\": \"animation-fill-mode:backwards;\",\n\t\t\t\"animfm:bt\": \"animation-fill-mode:both;\",\n\t\t\t\"animfm:bh\": \"animation-fill-mode:both;\",\n\t\t\t\n\t\t\t\"animic\": \"animation-iteration-count:${1:1};\",\n\t\t\t\"animic:i\": \"animation-iteration-count:infinite;\",\n\t\t\t\n\t\t\t\"animn\": \"animation-name:${1:none};\",\n\n\t\t\t\"animps\": \"animation-play-state:${1:running};\",\n\t\t\t\"animps:p\": \"animation-play-state:paused;\",\n\t\t\t\"animps:r\": \"animation-play-state:running;\",\n\n\t\t\t\"animtf\": \"animation-timing-function:${1:linear};\",\n\t\t\t\"animtf:e\": \"animation-timing-function:ease;\",\n\t\t\t\"animtf:ei\": \"animation-timing-function:ease-in;\",\n\t\t\t\"animtf:eo\": \"animation-timing-function:ease-out;\",\n\t\t\t\"animtf:eio\": \"animation-timing-function:ease-in-out;\",\n\t\t\t\"animtf:l\": \"animation-timing-function:linear;\",\n\t\t\t\"animtf:cb\": \"animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});\",\n\t\t\t\n\t\t\t\"ap\": \"appearance:${none};\",\n\n\t\t\t\"!\": \"!important\",\n\t\t\t\"pos\": \"position:${1:relative};\",\n\t\t\t\"pos:s\": \"position:static;\",\n\t\t\t\"pos:a\": \"position:absolute;\",\n\t\t\t\"pos:r\": \"position:relative;\",\n\t\t\t\"pos:f\": \"position:fixed;\",\n\t\t\t\"t\": \"top:|;\",\n\t\t\t\"t:a\": \"top:auto;\",\n\t\t\t\"r\": \"right:|;\",\n\t\t\t\"r:a\": \"right:auto;\",\n\t\t\t\"b\": \"bottom:|;\",\n\t\t\t\"b:a\": \"bottom:auto;\",\n\t\t\t\"l\": \"left:|;\",\n\t\t\t\"l:a\": \"left:auto;\",\n\t\t\t\"z\": \"z-index:|;\",\n\t\t\t\"z:a\": \"z-index:auto;\",\n\t\t\t\"fl\": \"float:${1:left};\",\n\t\t\t\"fl:n\": \"float:none;\",\n\t\t\t\"fl:l\": \"float:left;\",\n\t\t\t\"fl:r\": \"float:right;\",\n\t\t\t\"cl\": \"clear:${1:both};\",\n\t\t\t\"cl:n\": \"clear:none;\",\n\t\t\t\"cl:l\": \"clear:left;\",\n\t\t\t\"cl:r\": \"clear:right;\",\n\t\t\t\"cl:b\": \"clear:both;\",\n\n\t\t\t\"colm\": \"columns:|;\",\n\t\t\t\"colmc\": \"column-count:|;\",\n\t\t\t\"colmf\": \"column-fill:|;\",\n\t\t\t\"colmg\": \"column-gap:|;\",\n\t\t\t\"colmr\": \"column-rule:|;\",\n\t\t\t\"colmrc\": \"column-rule-color:|;\",\n\t\t\t\"colmrs\": \"column-rule-style:|;\",\n\t\t\t\"colmrw\": \"column-rule-width:|;\",\n\t\t\t\"colms\": \"column-span:|;\",\n\t\t\t\"colmw\": \"column-width:|;\",\n\n\t\t\t\"d\": \"display:${1:block};\",\n\t\t\t\"d:n\": \"display:none;\",\n\t\t\t\"d:b\": \"display:block;\",\n\t\t\t\"d:f\": \"display:flex;\",\n\t\t\t\"d:if\": \"display:inline-flex;\",\n\t\t\t\"d:i\": \"display:inline;\",\n\t\t\t\"d:ib\": \"display:inline-block;\",\n\t\t\t\"d:ib+\": \"display: inline-block;\\n*display: inline;\\n*zoom: 1;\",\n\t\t\t\"d:li\": \"display:list-item;\",\n\t\t\t\"d:ri\": \"display:run-in;\",\n\t\t\t\"d:cp\": \"display:compact;\",\n\t\t\t\"d:tb\": \"display:table;\",\n\t\t\t\"d:itb\": \"display:inline-table;\",\n\t\t\t\"d:tbcp\": \"display:table-caption;\",\n\t\t\t\"d:tbcl\": \"display:table-column;\",\n\t\t\t\"d:tbclg\": \"display:table-column-group;\",\n\t\t\t\"d:tbhg\": \"display:table-header-group;\",\n\t\t\t\"d:tbfg\": \"display:table-footer-group;\",\n\t\t\t\"d:tbr\": \"display:table-row;\",\n\t\t\t\"d:tbrg\": \"display:table-row-group;\",\n\t\t\t\"d:tbc\": \"display:table-cell;\",\n\t\t\t\"d:rb\": \"display:ruby;\",\n\t\t\t\"d:rbb\": \"display:ruby-base;\",\n\t\t\t\"d:rbbg\": \"display:ruby-base-group;\",\n\t\t\t\"d:rbt\": \"display:ruby-text;\",\n\t\t\t\"d:rbtg\": \"display:ruby-text-group;\",\n\t\t\t\"v\": \"visibility:${1:hidden};\",\n\t\t\t\"v:v\": \"visibility:visible;\",\n\t\t\t\"v:h\": \"visibility:hidden;\",\n\t\t\t\"v:c\": \"visibility:collapse;\",\n\t\t\t\"ov\": \"overflow:${1:hidden};\",\n\t\t\t\"ov:v\": \"overflow:visible;\",\n\t\t\t\"ov:h\": \"overflow:hidden;\",\n\t\t\t\"ov:s\": \"overflow:scroll;\",\n\t\t\t\"ov:a\": \"overflow:auto;\",\n\t\t\t\"ovx\": \"overflow-x:${1:hidden};\",\n\t\t\t\"ovx:v\": \"overflow-x:visible;\",\n\t\t\t\"ovx:h\": \"overflow-x:hidden;\",\n\t\t\t\"ovx:s\": \"overflow-x:scroll;\",\n\t\t\t\"ovx:a\": \"overflow-x:auto;\",\n\t\t\t\"ovy\": \"overflow-y:${1:hidden};\",\n\t\t\t\"ovy:v\": \"overflow-y:visible;\",\n\t\t\t\"ovy:h\": \"overflow-y:hidden;\",\n\t\t\t\"ovy:s\": \"overflow-y:scroll;\",\n\t\t\t\"ovy:a\": \"overflow-y:auto;\",\n\t\t\t\"ovs\": \"overflow-style:${1:scrollbar};\",\n\t\t\t\"ovs:a\": \"overflow-style:auto;\",\n\t\t\t\"ovs:s\": \"overflow-style:scrollbar;\",\n\t\t\t\"ovs:p\": \"overflow-style:panner;\",\n\t\t\t\"ovs:m\": \"overflow-style:move;\",\n\t\t\t\"ovs:mq\": \"overflow-style:marquee;\",\n\t\t\t\"zoo\": \"zoom:1;\",\n\t\t\t\"zm\": \"zoom:1;\",\n\t\t\t\"cp\": \"clip:|;\",\n\t\t\t\"cp:a\": \"clip:auto;\",\n\t\t\t\"cp:r\": \"clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});\",\n\t\t\t\"bxz\": \"box-sizing:${1:border-box};\",\n\t\t\t\"bxz:cb\": \"box-sizing:content-box;\",\n\t\t\t\"bxz:bb\": \"box-sizing:border-box;\",\n\t\t\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};\",\n\t\t\t\"bxsh:r\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});\",\n\t\t\t\"bxsh:ra\": \"box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});\",\n\t\t\t\"bxsh:n\": \"box-shadow:none;\",\n\t\t\t\"m\": \"margin:|;\",\n\t\t\t\"m:a\": \"margin:auto;\",\n\t\t\t\"mt\": \"margin-top:|;\",\n\t\t\t\"mt:a\": \"margin-top:auto;\",\n\t\t\t\"mr\": \"margin-right:|;\",\n\t\t\t\"mr:a\": \"margin-right:auto;\",\n\t\t\t\"mb\": \"margin-bottom:|;\",\n\t\t\t\"mb:a\": \"margin-bottom:auto;\",\n\t\t\t\"ml\": \"margin-left:|;\",\n\t\t\t\"ml:a\": \"margin-left:auto;\",\n\t\t\t\"p\": \"padding:|;\",\n\t\t\t\"pt\": \"padding-top:|;\",\n\t\t\t\"pr\": \"padding-right:|;\",\n\t\t\t\"pb\": \"padding-bottom:|;\",\n\t\t\t\"pl\": \"padding-left:|;\",\n\t\t\t\"w\": \"width:|;\",\n\t\t\t\"w:a\": \"width:auto;\",\n\t\t\t\"h\": \"height:|;\",\n\t\t\t\"h:a\": \"height:auto;\",\n\t\t\t\"maw\": \"max-width:|;\",\n\t\t\t\"maw:n\": \"max-width:none;\",\n\t\t\t\"mah\": \"max-height:|;\",\n\t\t\t\"mah:n\": \"max-height:none;\",\n\t\t\t\"miw\": \"min-width:|;\",\n\t\t\t\"mih\": \"min-height:|;\",\n\t\t\t\"mar\": \"max-resolution:${1:res};\",\n\t\t\t\"mir\": \"min-resolution:${1:res};\",\n\t\t\t\"ori\": \"orientation:|;\",\n\t\t\t\"ori:l\": \"orientation:landscape;\",\n\t\t\t\"ori:p\": \"orientation:portrait;\",\n\t\t\t\"ol\": \"outline:|;\",\n\t\t\t\"ol:n\": \"outline:none;\",\n\t\t\t\"olo\": \"outline-offset:|;\",\n\t\t\t\"olw\": \"outline-width:|;\",\n\t\t\t\"olw:tn\": \"outline-width:thin;\",\n\t\t\t\"olw:m\": \"outline-width:medium;\",\n\t\t\t\"olw:tc\": \"outline-width:thick;\",\n\t\t\t\"ols\": \"outline-style:|;\",\n\t\t\t\"ols:n\": \"outline-style:none;\",\n\t\t\t\"ols:dt\": \"outline-style:dotted;\",\n\t\t\t\"ols:ds\": \"outline-style:dashed;\",\n\t\t\t\"ols:s\": \"outline-style:solid;\",\n\t\t\t\"ols:db\": \"outline-style:double;\",\n\t\t\t\"ols:g\": \"outline-style:groove;\",\n\t\t\t\"ols:r\": \"outline-style:ridge;\",\n\t\t\t\"ols:i\": \"outline-style:inset;\",\n\t\t\t\"ols:o\": \"outline-style:outset;\",\n\t\t\t\"olc\": \"outline-color:#${1:000};\",\n\t\t\t\"olc:i\": \"outline-color:invert;\",\n\t\t\t\"bfv\": \"backface-visibility:|;\",\n\t\t\t\"bfv:h\": \"backface-visibility:hidden;\",\n\t\t\t\"bfv:v\": \"backface-visibility:visible;\",\n\t\t\t\"bd\": \"border:|;\",\n\t\t\t\"bd+\": \"border:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bd:n\": \"border:none;\",\n\t\t\t\"bdbk\": \"border-break:${1:close};\",\n\t\t\t\"bdbk:c\": \"border-break:close;\",\n\t\t\t\"bdcl\": \"border-collapse:|;\",\n\t\t\t\"bdcl:c\": \"border-collapse:collapse;\",\n\t\t\t\"bdcl:s\": \"border-collapse:separate;\",\n\t\t\t\"bdc\": \"border-color:#${1:000};\",\n\t\t\t\"bdc:t\": \"border-color:transparent;\",\n\t\t\t\"bdi\": \"border-image:url(|);\",\n\t\t\t\"bdi:n\": \"border-image:none;\",\n\t\t\t\"bdti\": \"border-top-image:url(|);\",\n\t\t\t\"bdti:n\": \"border-top-image:none;\",\n\t\t\t\"bdri\": \"border-right-image:url(|);\",\n\t\t\t\"bdri:n\": \"border-right-image:none;\",\n\t\t\t\"bdbi\": \"border-bottom-image:url(|);\",\n\t\t\t\"bdbi:n\": \"border-bottom-image:none;\",\n\t\t\t\"bdli\": \"border-left-image:url(|);\",\n\t\t\t\"bdli:n\": \"border-left-image:none;\",\n\t\t\t\"bdci\": \"border-corner-image:url(|);\",\n\t\t\t\"bdci:n\": \"border-corner-image:none;\",\n\t\t\t\"bdci:c\": \"border-corner-image:continue;\",\n\t\t\t\"bdtli\": \"border-top-left-image:url(|);\",\n\t\t\t\"bdtli:n\": \"border-top-left-image:none;\",\n\t\t\t\"bdtli:c\": \"border-top-left-image:continue;\",\n\t\t\t\"bdtri\": \"border-top-right-image:url(|);\",\n\t\t\t\"bdtri:n\": \"border-top-right-image:none;\",\n\t\t\t\"bdtri:c\": \"border-top-right-image:continue;\",\n\t\t\t\"bdbri\": \"border-bottom-right-image:url(|);\",\n\t\t\t\"bdbri:n\": \"border-bottom-right-image:none;\",\n\t\t\t\"bdbri:c\": \"border-bottom-right-image:continue;\",\n\t\t\t\"bdbli\": \"border-bottom-left-image:url(|);\",\n\t\t\t\"bdbli:n\": \"border-bottom-left-image:none;\",\n\t\t\t\"bdbli:c\": \"border-bottom-left-image:continue;\",\n\t\t\t\"bdf\": \"border-fit:${1:repeat};\",\n\t\t\t\"bdf:c\": \"border-fit:clip;\",\n\t\t\t\"bdf:r\": \"border-fit:repeat;\",\n\t\t\t\"bdf:sc\": \"border-fit:scale;\",\n\t\t\t\"bdf:st\": \"border-fit:stretch;\",\n\t\t\t\"bdf:ow\": \"border-fit:overwrite;\",\n\t\t\t\"bdf:of\": \"border-fit:overflow;\",\n\t\t\t\"bdf:sp\": \"border-fit:space;\",\n\t\t\t\"bdlen\": \"border-length:|;\",\n\t\t\t\"bdlen:a\": \"border-length:auto;\",\n\t\t\t\"bdsp\": \"border-spacing:|;\",\n\t\t\t\"bds\": \"border-style:|;\",\n\t\t\t\"bds:n\": \"border-style:none;\",\n\t\t\t\"bds:h\": \"border-style:hidden;\",\n\t\t\t\"bds:dt\": \"border-style:dotted;\",\n\t\t\t\"bds:ds\": \"border-style:dashed;\",\n\t\t\t\"bds:s\": \"border-style:solid;\",\n\t\t\t\"bds:db\": \"border-style:double;\",\n\t\t\t\"bds:dtds\": \"border-style:dot-dash;\",\n\t\t\t\"bds:dtdtds\": \"border-style:dot-dot-dash;\",\n\t\t\t\"bds:w\": \"border-style:wave;\",\n\t\t\t\"bds:g\": \"border-style:groove;\",\n\t\t\t\"bds:r\": \"border-style:ridge;\",\n\t\t\t\"bds:i\": \"border-style:inset;\",\n\t\t\t\"bds:o\": \"border-style:outset;\",\n\t\t\t\"bdw\": \"border-width:|;\",\n\t\t\t\"bdtw\": \"border-top-width:|;\",\n\t\t\t\"bdrw\": \"border-right-width:|;\",\n\t\t\t\"bdbw\": \"border-bottom-width:|;\",\n\t\t\t\"bdlw\": \"border-left-width:|;\",\n\t\t\t\"bdt\": \"border-top:|;\",\n\t\t\t\"bt\": \"border-top:|;\",\n\t\t\t\"bdt+\": \"border-top:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdt:n\": \"border-top:none;\",\n\t\t\t\"bdts\": \"border-top-style:|;\",\n\t\t\t\"bdts:n\": \"border-top-style:none;\",\n\t\t\t\"bdtc\": \"border-top-color:#${1:000};\",\n\t\t\t\"bdtc:t\": \"border-top-color:transparent;\",\n\t\t\t\"bdr\": \"border-right:|;\",\n\t\t\t\"br\": \"border-right:|;\",\n\t\t\t\"bdr+\": \"border-right:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdr:n\": \"border-right:none;\",\n\t\t\t\"bdrst\": \"border-right-style:|;\",\n\t\t\t\"bdrst:n\": \"border-right-style:none;\",\n\t\t\t\"bdrc\": \"border-right-color:#${1:000};\",\n\t\t\t\"bdrc:t\": \"border-right-color:transparent;\",\n\t\t\t\"bdb\": \"border-bottom:|;\",\n\t\t\t\"bb\": \"border-bottom:|;\",\n\t\t\t\"bdb+\": \"border-bottom:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdb:n\": \"border-bottom:none;\",\n\t\t\t\"bdbs\": \"border-bottom-style:|;\",\n\t\t\t\"bdbs:n\": \"border-bottom-style:none;\",\n\t\t\t\"bdbc\": \"border-bottom-color:#${1:000};\",\n\t\t\t\"bdbc:t\": \"border-bottom-color:transparent;\",\n\t\t\t\"bdl\": \"border-left:|;\",\n\t\t\t\"bl\": \"border-left:|;\",\n\t\t\t\"bdl+\": \"border-left:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdl:n\": \"border-left:none;\",\n\t\t\t\"bdls\": \"border-left-style:|;\",\n\t\t\t\"bdls:n\": \"border-left-style:none;\",\n\t\t\t\"bdlc\": \"border-left-color:#${1:000};\",\n\t\t\t\"bdlc:t\": \"border-left-color:transparent;\",\n\t\t\t\"bdrs\": \"border-radius:|;\",\n\t\t\t\"bdtrrs\": \"border-top-right-radius:|;\",\n\t\t\t\"bdtlrs\": \"border-top-left-radius:|;\",\n\t\t\t\"bdbrrs\": \"border-bottom-right-radius:|;\",\n\t\t\t\"bdblrs\": \"border-bottom-left-radius:|;\",\n\t\t\t\"bg\": \"background:#${1:000};\",\n\t\t\t\"bg+\": \"background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};\",\n\t\t\t\"bg:n\": \"background:none;\",\n\t\t\t\"bg:ie\": \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');\",\n\t\t\t\"bgc\": \"background-color:#${1:fff};\",\n\t\t\t\"bgc:t\": \"background-color:transparent;\",\n\t\t\t\"bgi\": \"background-image:url(|);\",\n\t\t\t\"bgi:n\": \"background-image:none;\",\n\t\t\t\"bgr\": \"background-repeat:|;\",\n\t\t\t\"bgr:n\": \"background-repeat:no-repeat;\",\n\t\t\t\"bgr:x\": \"background-repeat:repeat-x;\",\n\t\t\t\"bgr:y\": \"background-repeat:repeat-y;\",\n\t\t\t\"bgr:sp\": \"background-repeat:space;\",\n\t\t\t\"bgr:rd\": \"background-repeat:round;\",\n\t\t\t\"bga\": \"background-attachment:|;\",\n\t\t\t\"bga:f\": \"background-attachment:fixed;\",\n\t\t\t\"bga:s\": \"background-attachment:scroll;\",\n\t\t\t\"bgp\": \"background-position:${1:0} ${2:0};\",\n\t\t\t\"bgpx\": \"background-position-x:|;\",\n\t\t\t\"bgpy\": \"background-position-y:|;\",\n\t\t\t\"bgbk\": \"background-break:|;\",\n\t\t\t\"bgbk:bb\": \"background-break:bounding-box;\",\n\t\t\t\"bgbk:eb\": \"background-break:each-box;\",\n\t\t\t\"bgbk:c\": \"background-break:continuous;\",\n\t\t\t\"bgcp\": \"background-clip:${1:padding-box};\",\n\t\t\t\"bgcp:bb\": \"background-clip:border-box;\",\n\t\t\t\"bgcp:pb\": \"background-clip:padding-box;\",\n\t\t\t\"bgcp:cb\": \"background-clip:content-box;\",\n\t\t\t\"bgcp:nc\": \"background-clip:no-clip;\",\n\t\t\t\"bgo\": \"background-origin:|;\",\n\t\t\t\"bgo:pb\": \"background-origin:padding-box;\",\n\t\t\t\"bgo:bb\": \"background-origin:border-box;\",\n\t\t\t\"bgo:cb\": \"background-origin:content-box;\",\n\t\t\t\"bgsz\": \"background-size:|;\",\n\t\t\t\"bgsz:a\": \"background-size:auto;\",\n\t\t\t\"bgsz:ct\": \"background-size:contain;\",\n\t\t\t\"bgsz:cv\": \"background-size:cover;\",\n\t\t\t\"c\": \"color:#${1:000};\",\n\t\t\t\"c:r\": \"color:rgb(${1:0}, ${2:0}, ${3:0});\",\n\t\t\t\"c:ra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});\",\n\t\t\t\"cm\": \"/* |${child} */\",\n\t\t\t\"cnt\": \"content:'|';\",\n\t\t\t\"cnt:n\": \"content:normal;\",\n\t\t\t\"cnt:oq\": \"content:open-quote;\",\n\t\t\t\"cnt:noq\": \"content:no-open-quote;\",\n\t\t\t\"cnt:cq\": \"content:close-quote;\",\n\t\t\t\"cnt:ncq\": \"content:no-close-quote;\",\n\t\t\t\"cnt:a\": \"content:attr(|);\",\n\t\t\t\"cnt:c\": \"content:counter(|);\",\n\t\t\t\"cnt:cs\": \"content:counters(|);\",\n\n\t\t\t\"tbl\": \"table-layout:|;\",\n\t\t\t\"tbl:a\": \"table-layout:auto;\",\n\t\t\t\"tbl:f\": \"table-layout:fixed;\",\n\t\t\t\"cps\": \"caption-side:|;\",\n\t\t\t\"cps:t\": \"caption-side:top;\",\n\t\t\t\"cps:b\": \"caption-side:bottom;\",\n\t\t\t\"ec\": \"empty-cells:|;\",\n\t\t\t\"ec:s\": \"empty-cells:show;\",\n\t\t\t\"ec:h\": \"empty-cells:hide;\",\n\t\t\t\"lis\": \"list-style:|;\",\n\t\t\t\"lis:n\": \"list-style:none;\",\n\t\t\t\"lisp\": \"list-style-position:|;\",\n\t\t\t\"lisp:i\": \"list-style-position:inside;\",\n\t\t\t\"lisp:o\": \"list-style-position:outside;\",\n\t\t\t\"list\": \"list-style-type:|;\",\n\t\t\t\"list:n\": \"list-style-type:none;\",\n\t\t\t\"list:d\": \"list-style-type:disc;\",\n\t\t\t\"list:c\": \"list-style-type:circle;\",\n\t\t\t\"list:s\": \"list-style-type:square;\",\n\t\t\t\"list:dc\": \"list-style-type:decimal;\",\n\t\t\t\"list:dclz\": \"list-style-type:decimal-leading-zero;\",\n\t\t\t\"list:lr\": \"list-style-type:lower-roman;\",\n\t\t\t\"list:ur\": \"list-style-type:upper-roman;\",\n\t\t\t\"lisi\": \"list-style-image:|;\",\n\t\t\t\"lisi:n\": \"list-style-image:none;\",\n\t\t\t\"q\": \"quotes:|;\",\n\t\t\t\"q:n\": \"quotes:none;\",\n\t\t\t\"q:ru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C';\",\n\t\t\t\"q:en\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019';\",\n\t\t\t\"ct\": \"content:|;\",\n\t\t\t\"ct:n\": \"content:normal;\",\n\t\t\t\"ct:oq\": \"content:open-quote;\",\n\t\t\t\"ct:noq\": \"content:no-open-quote;\",\n\t\t\t\"ct:cq\": \"content:close-quote;\",\n\t\t\t\"ct:ncq\": \"content:no-close-quote;\",\n\t\t\t\"ct:a\": \"content:attr(|);\",\n\t\t\t\"ct:c\": \"content:counter(|);\",\n\t\t\t\"ct:cs\": \"content:counters(|);\",\n\t\t\t\"coi\": \"counter-increment:|;\",\n\t\t\t\"cor\": \"counter-reset:|;\",\n\t\t\t\"va\": \"vertical-align:${1:top};\",\n\t\t\t\"va:sup\": \"vertical-align:super;\",\n\t\t\t\"va:t\": \"vertical-align:top;\",\n\t\t\t\"va:tt\": \"vertical-align:text-top;\",\n\t\t\t\"va:m\": \"vertical-align:middle;\",\n\t\t\t\"va:bl\": \"vertical-align:baseline;\",\n\t\t\t\"va:b\": \"vertical-align:bottom;\",\n\t\t\t\"va:tb\": \"vertical-align:text-bottom;\",\n\t\t\t\"va:sub\": \"vertical-align:sub;\",\n\t\t\t\"ta\": \"text-align:${1:left};\",\n\t\t\t\"ta:l\": \"text-align:left;\",\n\t\t\t\"ta:c\": \"text-align:center;\",\n\t\t\t\"ta:r\": \"text-align:right;\",\n\t\t\t\"ta:j\": \"text-align:justify;\",\n\t\t\t\"ta-lst\": \"text-align-last:|;\",\n\t\t\t\"tal:a\": \"text-align-last:auto;\",\n\t\t\t\"tal:l\": \"text-align-last:left;\",\n\t\t\t\"tal:c\": \"text-align-last:center;\",\n\t\t\t\"tal:r\": \"text-align-last:right;\",\n\t\t\t\"td\": \"text-decoration:${1:none};\",\n\t\t\t\"td:n\": \"text-decoration:none;\",\n\t\t\t\"td:u\": \"text-decoration:underline;\",\n\t\t\t\"td:o\": \"text-decoration:overline;\",\n\t\t\t\"td:l\": \"text-decoration:line-through;\",\n\t\t\t\"te\": \"text-emphasis:|;\",\n\t\t\t\"te:n\": \"text-emphasis:none;\",\n\t\t\t\"te:ac\": \"text-emphasis:accent;\",\n\t\t\t\"te:dt\": \"text-emphasis:dot;\",\n\t\t\t\"te:c\": \"text-emphasis:circle;\",\n\t\t\t\"te:ds\": \"text-emphasis:disc;\",\n\t\t\t\"te:b\": \"text-emphasis:before;\",\n\t\t\t\"te:a\": \"text-emphasis:after;\",\n\t\t\t\"th\": \"text-height:|;\",\n\t\t\t\"th:a\": \"text-height:auto;\",\n\t\t\t\"th:f\": \"text-height:font-size;\",\n\t\t\t\"th:t\": \"text-height:text-size;\",\n\t\t\t\"th:m\": \"text-height:max-size;\",\n\t\t\t\"ti\": \"text-indent:|;\",\n\t\t\t\"ti:-\": \"text-indent:-9999px;\",\n\t\t\t\"tj\": \"text-justify:|;\",\n\t\t\t\"tj:a\": \"text-justify:auto;\",\n\t\t\t\"tj:iw\": \"text-justify:inter-word;\",\n\t\t\t\"tj:ii\": \"text-justify:inter-ideograph;\",\n\t\t\t\"tj:ic\": \"text-justify:inter-cluster;\",\n\t\t\t\"tj:d\": \"text-justify:distribute;\",\n\t\t\t\"tj:k\": \"text-justify:kashida;\",\n\t\t\t\"tj:t\": \"text-justify:tibetan;\",\n\t\t\t\"tov\": \"text-overflow:${ellipsis};\",\n\t\t\t\"tov:e\": \"text-overflow:ellipsis;\",\n\t\t\t\"tov:c\": \"text-overflow:clip;\",\n\t\t\t\"to\": \"text-outline:|;\",\n\t\t\t\"to+\": \"text-outline:${1:0} ${2:0} ${3:#000};\",\n\t\t\t\"to:n\": \"text-outline:none;\",\n\t\t\t\"tr\": \"text-replace:|;\",\n\t\t\t\"tr:n\": \"text-replace:none;\",\n\t\t\t\"tt\": \"text-transform:${1:uppercase};\",\n\t\t\t\"tt:n\": \"text-transform:none;\",\n\t\t\t\"tt:c\": \"text-transform:capitalize;\",\n\t\t\t\"tt:u\": \"text-transform:uppercase;\",\n\t\t\t\"tt:l\": \"text-transform:lowercase;\",\n\t\t\t\"tw\": \"text-wrap:|;\",\n\t\t\t\"tw:n\": \"text-wrap:normal;\",\n\t\t\t\"tw:no\": \"text-wrap:none;\",\n\t\t\t\"tw:u\": \"text-wrap:unrestricted;\",\n\t\t\t\"tw:s\": \"text-wrap:suppress;\",\n\t\t\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};\",\n\t\t\t\"tsh:r\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});\",\n\t\t\t\"tsh:ra\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});\",\n\t\t\t\"tsh+\": \"text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};\",\n\t\t\t\"tsh:n\": \"text-shadow:none;\",\n\t\t\t\"trf\": \"transform:|;\",\n\t\t\t\"trf:skx\": \"transform: skewX(${1:angle});\",\n\t\t\t\"trf:sky\": \"transform: skewY(${1:angle});\",\n\t\t\t\"trf:sc\": \"transform: scale(${1:x}, ${2:y});\",\n\t\t\t\"trf:scx\": \"transform: scaleX(${1:x});\",\n\t\t\t\"trf:scy\": \"transform: scaleY(${1:y});\",\n\t\t\t\"trf:scz\": \"transform: scaleZ(${1:z});\",\n\t\t\t\"trf:sc3\": \"transform: scale3d(${1:x}, ${2:y}, ${3:z});\",\n\t\t\t\"trf:r\": \"transform: rotate(${1:angle});\",\n\t\t\t\"trf:rx\": \"transform: rotateX(${1:angle});\",\n\t\t\t\"trf:ry\": \"transform: rotateY(${1:angle});\",\n\t\t\t\"trf:rz\": \"transform: rotateZ(${1:angle});\",\n\t\t\t\"trf:t\": \"transform: translate(${1:x}, ${2:y});\",\n\t\t\t\"trf:tx\": \"transform: translateX(${1:x});\",\n\t\t\t\"trf:ty\": \"transform: translateY(${1:y});\",\n\t\t\t\"trf:tz\": \"transform: translateZ(${1:z});\",\n\t\t\t\"trf:t3\": \"transform: translate3d(${1:tx}, ${2:ty}, ${3:tz});\",\n\t\t\t\"trfo\": \"transform-origin:|;\",\n\t\t\t\"trfs\": \"transform-style:${1:preserve-3d};\",\n\t\t\t\"trs\": \"transition:${1:prop} ${2:time};\",\n\t\t\t\"trsde\": \"transition-delay:${1:time};\",\n\t\t\t\"trsdu\": \"transition-duration:${1:time};\",\n\t\t\t\"trsp\": \"transition-property:${1:prop};\",\n\t\t\t\"trstf\": \"transition-timing-function:${1:tfunc};\",\n\t\t\t\"lh\": \"line-height:|;\",\n\t\t\t\"whs\": \"white-space:|;\",\n\t\t\t\"whs:n\": \"white-space:normal;\",\n\t\t\t\"whs:p\": \"white-space:pre;\",\n\t\t\t\"whs:nw\": \"white-space:nowrap;\",\n\t\t\t\"whs:pw\": \"white-space:pre-wrap;\",\n\t\t\t\"whs:pl\": \"white-space:pre-line;\",\n\t\t\t\"whsc\": \"white-space-collapse:|;\",\n\t\t\t\"whsc:n\": \"white-space-collapse:normal;\",\n\t\t\t\"whsc:k\": \"white-space-collapse:keep-all;\",\n\t\t\t\"whsc:l\": \"white-space-collapse:loose;\",\n\t\t\t\"whsc:bs\": \"white-space-collapse:break-strict;\",\n\t\t\t\"whsc:ba\": \"white-space-collapse:break-all;\",\n\t\t\t\"wob\": \"word-break:|;\",\n\t\t\t\"wob:n\": \"word-break:normal;\",\n\t\t\t\"wob:k\": \"word-break:keep-all;\",\n\t\t\t\"wob:ba\": \"word-break:break-all;\",\n\t\t\t\"wos\": \"word-spacing:|;\",\n\t\t\t\"wow\": \"word-wrap:|;\",\n\t\t\t\"wow:nm\": \"word-wrap:normal;\",\n\t\t\t\"wow:n\": \"word-wrap:none;\",\n\t\t\t\"wow:u\": \"word-wrap:unrestricted;\",\n\t\t\t\"wow:s\": \"word-wrap:suppress;\",\n\t\t\t\"wow:b\": \"word-wrap:break-word;\",\n\t\t\t\"wm\": \"writing-mode:${1:lr-tb};\",\n\t\t\t\"wm:lrt\": \"writing-mode:lr-tb;\",\n\t\t\t\"wm:lrb\": \"writing-mode:lr-bt;\",\n\t\t\t\"wm:rlt\": \"writing-mode:rl-tb;\",\n\t\t\t\"wm:rlb\": \"writing-mode:rl-bt;\",\n\t\t\t\"wm:tbr\": \"writing-mode:tb-rl;\",\n\t\t\t\"wm:tbl\": \"writing-mode:tb-lr;\",\n\t\t\t\"wm:btl\": \"writing-mode:bt-lr;\",\n\t\t\t\"wm:btr\": \"writing-mode:bt-rl;\",\n\t\t\t\"lts\": \"letter-spacing:|;\",\n\t\t\t\"lts-n\": \"letter-spacing:normal;\",\n\t\t\t\"f\": \"font:|;\",\n\t\t\t\"f+\": \"font:${1:1em} ${2:Arial,sans-serif};\",\n\t\t\t\"fw\": \"font-weight:|;\",\n\t\t\t\"fw:n\": \"font-weight:normal;\",\n\t\t\t\"fw:b\": \"font-weight:bold;\",\n\t\t\t\"fw:br\": \"font-weight:bolder;\",\n\t\t\t\"fw:lr\": \"font-weight:lighter;\",\n\t\t\t\"fs\": \"font-style:${italic};\",\n\t\t\t\"fs:n\": \"font-style:normal;\",\n\t\t\t\"fs:i\": \"font-style:italic;\",\n\t\t\t\"fs:o\": \"font-style:oblique;\",\n\t\t\t\"fv\": \"font-variant:|;\",\n\t\t\t\"fv:n\": \"font-variant:normal;\",\n\t\t\t\"fv:sc\": \"font-variant:small-caps;\",\n\t\t\t\"fz\": \"font-size:|;\",\n\t\t\t\"fza\": \"font-size-adjust:|;\",\n\t\t\t\"fza:n\": \"font-size-adjust:none;\",\n\t\t\t\"ff\": \"font-family:|;\",\n\t\t\t\"ff:s\": \"font-family:serif;\",\n\t\t\t\"ff:ss\": \"font-family:sans-serif;\",\n\t\t\t\"ff:c\": \"font-family:cursive;\",\n\t\t\t\"ff:f\": \"font-family:fantasy;\",\n\t\t\t\"ff:m\": \"font-family:monospace;\",\n\t\t\t\"ff:a\": \"font-family: Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif;\",\n\t\t\t\"ff:t\": \"font-family: \\\"Times New Roman\\\", Times, Baskerville, Georgia, serif;\",\n\t\t\t\"ff:v\": \"font-family: Verdana, Geneva, sans-serif;\",\n\t\t\t\"fef\": \"font-effect:|;\",\n\t\t\t\"fef:n\": \"font-effect:none;\",\n\t\t\t\"fef:eg\": \"font-effect:engrave;\",\n\t\t\t\"fef:eb\": \"font-effect:emboss;\",\n\t\t\t\"fef:o\": \"font-effect:outline;\",\n\t\t\t\"fem\": \"font-emphasize:|;\",\n\t\t\t\"femp\": \"font-emphasize-position:|;\",\n\t\t\t\"femp:b\": \"font-emphasize-position:before;\",\n\t\t\t\"femp:a\": \"font-emphasize-position:after;\",\n\t\t\t\"fems\": \"font-emphasize-style:|;\",\n\t\t\t\"fems:n\": \"font-emphasize-style:none;\",\n\t\t\t\"fems:ac\": \"font-emphasize-style:accent;\",\n\t\t\t\"fems:dt\": \"font-emphasize-style:dot;\",\n\t\t\t\"fems:c\": \"font-emphasize-style:circle;\",\n\t\t\t\"fems:ds\": \"font-emphasize-style:disc;\",\n\t\t\t\"fsm\": \"font-smooth:|;\",\n\t\t\t\"fsm:a\": \"font-smooth:auto;\",\n\t\t\t\"fsm:n\": \"font-smooth:never;\",\n\t\t\t\"fsm:aw\": \"font-smooth:always;\",\n\t\t\t\"fst\": \"font-stretch:|;\",\n\t\t\t\"fst:n\": \"font-stretch:normal;\",\n\t\t\t\"fst:uc\": \"font-stretch:ultra-condensed;\",\n\t\t\t\"fst:ec\": \"font-stretch:extra-condensed;\",\n\t\t\t\"fst:c\": \"font-stretch:condensed;\",\n\t\t\t\"fst:sc\": \"font-stretch:semi-condensed;\",\n\t\t\t\"fst:se\": \"font-stretch:semi-expanded;\",\n\t\t\t\"fst:e\": \"font-stretch:expanded;\",\n\t\t\t\"fst:ee\": \"font-stretch:extra-expanded;\",\n\t\t\t\"fst:ue\": \"font-stretch:ultra-expanded;\",\n\t\t\t\"op\": \"opacity:|;\",\n\t\t\t\"op+\": \"opacity: $1;\\nfilter: alpha(opacity=$2);\",\n\t\t\t\"op:ie\": \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);\",\n\t\t\t\"op:ms\": \"-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';\",\n\t\t\t\"rsz\": \"resize:|;\",\n\t\t\t\"rsz:n\": \"resize:none;\",\n\t\t\t\"rsz:b\": \"resize:both;\",\n\t\t\t\"rsz:h\": \"resize:horizontal;\",\n\t\t\t\"rsz:v\": \"resize:vertical;\",\n\t\t\t\"cur\": \"cursor:${pointer};\",\n\t\t\t\"cur:a\": \"cursor:auto;\",\n\t\t\t\"cur:d\": \"cursor:default;\",\n\t\t\t\"cur:c\": \"cursor:crosshair;\",\n\t\t\t\"cur:ha\": \"cursor:hand;\",\n\t\t\t\"cur:he\": \"cursor:help;\",\n\t\t\t\"cur:m\": \"cursor:move;\",\n\t\t\t\"cur:p\": \"cursor:pointer;\",\n\t\t\t\"cur:t\": \"cursor:text;\",\n\t\t\t\"fxd\": \"flex-direction:|;\",\n\t\t\t\"fxd:r\": \"flex-direction:row;\",\n\t\t\t\"fxd:rr\": \"flex-direction:row-reverse;\",\n\t\t\t\"fxd:c\": \"flex-direction:column;\",\n\t\t\t\"fxd:cr\": \"flex-direction:column-reverse;\",\n\t\t\t\"fxw\": \"flex-wrap: |;\",\n\t\t\t\"fxw:n\": \"flex-wrap:nowrap;\",\n\t\t\t\"fxw:w\": \"flex-wrap:wrap;\",\n\t\t\t\"fxw:wr\": \"flex-wrap:wrap-reverse;\",\n\t\t\t\"fxf\": \"flex-flow:|;\",\n\t\t\t\"jc\": \"justify-content:|;\",\n\t\t\t\"jc:fs\": \"justify-content:flex-start;\",\n\t\t\t\"jc:fe\": \"justify-content:flex-end;\",\n\t\t\t\"jc:c\": \"justify-content:center;\",\n\t\t\t\"jc:sb\": \"justify-content:space-between;\",\n\t\t\t\"jc:sa\": \"justify-content:space-around;\",\n\t\t\t\"ai\": \"align-items:|;\",\n\t\t\t\"ai:fs\": \"align-items:flex-start;\",\n\t\t\t\"ai:fe\": \"align-items:flex-end;\",\n\t\t\t\"ai:c\": \"align-items:center;\",\n\t\t\t\"ai:b\": \"align-items:baseline;\",\n\t\t\t\"ai:s\": \"align-items:stretch;\",\n\t\t\t\"ac\": \"align-content:|;\",\n\t\t\t\"ac:fs\": \"align-content:flex-start;\",\n\t\t\t\"ac:fe\": \"align-content:flex-end;\",\n\t\t\t\"ac:c\": \"align-content:center;\",\n\t\t\t\"ac:sb\": \"align-content:space-between;\",\n\t\t\t\"ac:sa\": \"align-content:space-around;\",\n\t\t\t\"ac:s\": \"align-content:stretch;\",\n\t\t\t\"ord\": \"order:|;\",\n\t\t\t\"fxg\": \"flex-grow:|;\",\n\t\t\t\"fxsh\": \"flex-shrink:|;\",\n\t\t\t\"fxb\": \"flex-basis:|;\",\n\t\t\t\"fx\": \"flex:|;\",\n\t\t\t\"as\": \"align-self:|;\",\n\t\t\t\"as:a\": \"align-self:auto;\",\n\t\t\t\"as:fs\": \"align-self:flex-start;\",\n\t\t\t\"as:fe\": \"align-self:flex-end;\",\n\t\t\t\"as:c\": \"align-self:center;\",\n\t\t\t\"as:b\": \"align-self:baseline;\",\n\t\t\t\"as:s\": \"align-self:stretch;\",\n\t\t\t\"pgbb\": \"page-break-before:|;\",\n\t\t\t\"pgbb:au\": \"page-break-before:auto;\",\n\t\t\t\"pgbb:al\": \"page-break-before:always;\",\n\t\t\t\"pgbb:l\": \"page-break-before:left;\",\n\t\t\t\"pgbb:r\": \"page-break-before:right;\",\n\t\t\t\"pgbi\": \"page-break-inside:|;\",\n\t\t\t\"pgbi:au\": \"page-break-inside:auto;\",\n\t\t\t\"pgbi:av\": \"page-break-inside:avoid;\",\n\t\t\t\"pgba\": \"page-break-after:|;\",\n\t\t\t\"pgba:au\": \"page-break-after:auto;\",\n\t\t\t\"pgba:al\": \"page-break-after:always;\",\n\t\t\t\"pgba:l\": \"page-break-after:left;\",\n\t\t\t\"pgba:r\": \"page-break-after:right;\",\n\t\t\t\"orp\": \"orphans:|;\",\n\t\t\t\"us\": \"user-select:${none};\",\n\t\t\t\"wid\": \"widows:|;\",\n\t\t\t\"wfsm\": \"-webkit-font-smoothing:${antialiased};\",\n\t\t\t\"wfsm:a\": \"-webkit-font-smoothing:antialiased;\",\n\t\t\t\"wfsm:s\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\"wfsm:sa\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\"wfsm:n\": \"-webkit-font-smoothing:none;\"\n\t\t}\n\t},\n\t\n\t\"html\": {\n\t\t\"filters\": \"html\",\n\t\t\"profile\": \"html\",\n\t\t\"snippets\": {\n\t\t\t\"!!!\":    \"<!DOCTYPE html>\",\n\t\t\t\"!!!4t\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\",\n\t\t\t\"!!!4s\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\" \\\"http://www.w3.org/TR/html4/strict.dtd\\\">\",\n\t\t\t\"!!!xt\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\",\n\t\t\t\"!!!xs\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\",\n\t\t\t\"!!!xxs\": \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\",\n\n\t\t\t\"c\": \"<!-- |${child} -->\",\n\t\t\t\"cc:ie6\": \"<!--[if lte IE 6]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\"cc:ie\": \"<!--[if IE]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\"cc:noie\": \"<!--[if !IE]><!-->\\n\\t${child}|\\n<!--<![endif]-->\"\n\t\t},\n\t\t\n\t\t\"abbreviations\": {\n\t\t\t\"!\": \"html:5\",\n\t\t\t\"a\": \"<a href=\\\"\\\">\",\n\t\t\t\"a:link\": \"<a href=\\\"http://|\\\">\",\n\t\t\t\"a:mail\": \"<a href=\\\"mailto:|\\\">\",\n\t\t\t\"abbr\": \"<abbr title=\\\"\\\">\",\n\t\t\t\"acr|acronym\": \"<acronym title=\\\"\\\">\",\n\t\t\t\"base\": \"<base href=\\\"\\\" />\",\n\t\t\t\"basefont\": \"<basefont/>\",\n\t\t\t\"br\": \"<br/>\",\n\t\t\t\"frame\": \"<frame/>\",\n\t\t\t\"hr\": \"<hr/>\",\n\t\t\t\"bdo\": \"<bdo dir=\\\"\\\">\",\n\t\t\t\"bdo:r\": \"<bdo dir=\\\"rtl\\\">\",\n\t\t\t\"bdo:l\": \"<bdo dir=\\\"ltr\\\">\",\n\t\t\t\"col\": \"<col/>\",\n\t\t\t\"link\": \"<link rel=\\\"stylesheet\\\" href=\\\"\\\" />\",\n\t\t\t\"link:css\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:style}.css\\\" />\",\n\t\t\t\"link:print\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:print}.css\\\" media=\\\"print\\\" />\",\n\t\t\t\"link:favicon\": \"<link rel=\\\"shortcut icon\\\" type=\\\"image/x-icon\\\" href=\\\"${1:favicon.ico}\\\" />\",\n\t\t\t\"link:touch\": \"<link rel=\\\"apple-touch-icon\\\" href=\\\"${1:favicon.png}\\\" />\",\n\t\t\t\"link:rss\": \"<link rel=\\\"alternate\\\" type=\\\"application/rss+xml\\\" title=\\\"RSS\\\" href=\\\"${1:rss.xml}\\\" />\",\n\t\t\t\"link:atom\": \"<link rel=\\\"alternate\\\" type=\\\"application/atom+xml\\\" title=\\\"Atom\\\" href=\\\"${1:atom.xml}\\\" />\",\n\t\t\t\"link:im|link:import\": \"<link rel=\\\"import\\\" href=\\\"${1:component}.html\\\" />\",\n\t\t\t\"meta\": \"<meta/>\",\n\t\t\t\"meta:utf\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=UTF-8\\\" />\",\n\t\t\t\"meta:win\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=windows-1251\\\" />\",\n\t\t\t\"meta:edge\": \"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"${1:ie=edge}\\\" />\",\n\t\t\t\"meta:vp\": \"<meta name=\\\"viewport\\\" content=\\\"width=${1:device-width}, initial-scale=${3:1.0}\\\" />\",\n\t\t\t\"meta:compat\": \"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"${1:IE=7}\\\" />\",\n\t\t\t\"meta:redirect\": \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=${1:http://example.com}\\\" />\",\n\t\t\t\"style\": \"<style>\",\n\t\t\t\"script\": \"<script !src=\\\"\\\">\",\n\t\t\t\"script:src\": \"<script src=\\\"\\\">\",\n\t\t\t\"img\": \"<img src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"img:s|img:srcset\": \"<img srcset=\\\"\\\" src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"img:z|img:sizes\": \"<img sizes=\\\"\\\" srcset=\\\"\\\" src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"picture\": \"<picture>\",\n\t\t\t\"src|source\": \"<source/>\",\n\t\t\t\"src:sc|source:src\": \"<source src=\\\"\\\" type=\\\"\\\"/>\",\n\t\t\t\"src:s|source:srcset\": \"<source srcset=\\\"\\\"/>\",\n\t\t\t\"src:m|source:media\": \"<source media=\\\"(${1:min-width: })\\\" srcset=\\\"\\\"/>\",\n\t\t\t\"src:t|source:type\": \"<source srcset=\\\"|\\\" type=\\\"${1:image/}\\\"/>\",\n\t\t\t\"src:z|source:sizes\": \"<source sizes=\\\"\\\" srcset=\\\"\\\"/>\",\n\t\t\t\"src:mt|source:media:type\": \"<source media=\\\"(${1:min-width: })\\\" srcset=\\\"\\\" type=\\\"${2:image/}\\\"/>\",\n\t\t\t\"src:mz|source:media:sizes\": \"<source media=\\\"(${1:min-width: })\\\" sizes=\\\"\\\" srcset=\\\"\\\"/>\",\n\t\t\t\"src:zt|source:sizes:type\": \"<source sizes=\\\"\\\" srcset=\\\"\\\" type=\\\"${1:image/}\\\"/>\",\n\t\t\t\"iframe\": \"<iframe src=\\\"\\\" frameborder=\\\"0\\\">\",\n\t\t\t\"embed\": \"<embed src=\\\"\\\" type=\\\"\\\" />\",\n\t\t\t\"object\": \"<object data=\\\"\\\" type=\\\"\\\">\",\n\t\t\t\"param\": \"<param name=\\\"\\\" value=\\\"\\\" />\",\n\t\t\t\"map\": \"<map name=\\\"\\\">\",\n\t\t\t\"area\": \"<area shape=\\\"\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:d\": \"<area shape=\\\"default\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:c\": \"<area shape=\\\"circle\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:r\": \"<area shape=\\\"rect\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:p\": \"<area shape=\\\"poly\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"form\": \"<form action=\\\"\\\">\",\n\t\t\t\"form:get\": \"<form action=\\\"\\\" method=\\\"get\\\">\",\n\t\t\t\"form:post\": \"<form action=\\\"\\\" method=\\\"post\\\">\",\n\t\t\t\"label\": \"<label for=\\\"\\\">\",\n\t\t\t\"input\": \"<input type=\\\"${1:text}\\\" />\",\n\t\t\t\"inp\": \"<input type=\\\"${1:text}\\\" name=\\\"\\\" id=\\\"\\\" />\",\n\t\t\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\t\t\"input:t|input:text\": \"inp\",\n\t\t\t\"input:search\": \"inp[type=search]\",\n\t\t\t\"input:email\": \"inp[type=email]\",\n\t\t\t\"input:url\": \"inp[type=url]\",\n\t\t\t\"input:p|input:password\": \"inp[type=password]\",\n\t\t\t\"input:datetime\": \"inp[type=datetime]\",\n\t\t\t\"input:date\": \"inp[type=date]\",\n\t\t\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\t\t\"input:month\": \"inp[type=month]\",\n\t\t\t\"input:week\": \"inp[type=week]\",\n\t\t\t\"input:time\": \"inp[type=time]\",\n\t\t\t\"input:tel\": \"inp[type=tel]\",\n\t\t\t\"input:number\": \"inp[type=number]\",\n\t\t\t\"input:color\": \"inp[type=color]\",\n\t\t\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\t\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\t\t\"input:range\": \"inp[type=range]\",\n\t\t\t\"input:f|input:file\": \"inp[type=file]\",\n\t\t\t\"input:s|input:submit\": \"<input type=\\\"submit\\\" value=\\\"\\\" />\",\n\t\t\t\"input:i|input:image\": \"<input type=\\\"image\\\" src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"input:b|input:button\": \"<input type=\\\"button\\\" value=\\\"\\\" />\",\n\t\t\t\"isindex\": \"<isindex/>\",\n\t\t\t\"input:reset\": \"input:button[type=reset]\",\n\t\t\t\"select\": \"<select name=\\\"\\\" id=\\\"\\\">\",\n\t\t\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\t\t\"opt|option\": \"<option value=\\\"\\\">\",\n\t\t\t\"textarea\": \"<textarea name=\\\"\\\" id=\\\"\\\" cols=\\\"${1:30}\\\" rows=\\\"${2:10}\\\">\",\n\t\t\t\"marquee\": \"<marquee behavior=\\\"\\\" direction=\\\"\\\">\",\n\t\t\t\"menu:c|menu:context\": \"menu[type=context]>\",\n\t\t\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]>\",\n\t\t\t\"video\": \"<video src=\\\"\\\">\",\n\t\t\t\"audio\": \"<audio src=\\\"\\\">\",\n\t\t\t\"html:xml\": \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\",\n\t\t\t\"keygen\": \"<keygen/>\",\n\t\t\t\"command\": \"<command/>\",\n\t\t\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\t\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\t\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\t\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\t\t\t\n\t\t\t\"bq\": \"blockquote\",\n\t\t\t\"fig\": \"figure\",\n\t\t\t\"figc\": \"figcaption\",\n\t\t\t\"pic\": \"picture\",\n\t\t\t\"ifr\": \"iframe\",\n\t\t\t\"emb\": \"embed\",\n\t\t\t\"obj\": \"object\",\n\t\t\t\"cap\": \"caption\",\n\t\t\t\"colg\": \"colgroup\",\n\t\t\t\"fst\": \"fieldset\",\n\t\t\t\"btn\": \"button\",\n\t\t\t\"optg\": \"optgroup\",\n\t\t\t\"tarea\": \"textarea\",\n\t\t\t\"leg\": \"legend\",\n\t\t\t\"sect\": \"section\",\n\t\t\t\"art\": \"article\",\n\t\t\t\"hdr\": \"header\",\n\t\t\t\"ftr\": \"footer\",\n\t\t\t\"adr\": \"address\",\n\t\t\t\"dlg\": \"dialog\",\n\t\t\t\"str\": \"strong\",\n\t\t\t\"prog\": \"progress\",\n\t\t\t\"mn\": \"main\",\n\t\t\t\"tem\": \"template\",\n\t\t\t\"fset\": \"fieldset\",\n\t\t\t\"datag\": \"datagrid\",\n\t\t\t\"datal\": \"datalist\",\n\t\t\t\"kg\": \"keygen\",\n\t\t\t\"out\": \"output\",\n\t\t\t\"det\": \"details\",\n\t\t\t\"cmd\": \"command\",\n\n\t\t\t\"doc\": \"html>(head>meta[charset=${charset}]+meta:vp+meta:edge+title{${1:Document}})+body\",\n\t\t\t\"doc4\": \"html>(head>meta[http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=${charset}\\\"]+title{${1:Document}})+body\",\n\n\t\t\t\"ri:d|ri:dpr\": \"img:s\",\n\t\t\t\"ri:v|ri:viewport\": \"img:z\",\n\t\t\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\t\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\t\t\"html:4t\":  \"!!!4t+doc4[lang=${lang}]\",\n\t\t\t\"html:4s\":  \"!!!4s+doc4[lang=${lang}]\",\n\t\t\t\"html:xt\":  \"!!!xt+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:xs\":  \"!!!xs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:xxs\": \"!!!xxs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:5\":   \"!!!+doc[lang=${lang}]\",\n\t\t\t\n\t\t\t\"ol+\": \"ol>li\",\n\t\t\t\"ul+\": \"ul>li\",\n\t\t\t\"dl+\": \"dl>dt+dd\",\n\t\t\t\"map+\": \"map>area\",\n\t\t\t\"table+\": \"table>tr>td\",\n\t\t\t\"colgroup+\": \"colgroup>col\",\n\t\t\t\"colg+\": \"colgroup>col\",\n\t\t\t\"tr+\": \"tr>td\",\n\t\t\t\"select+\": \"select>option\",\n\t\t\t\"optgroup+\": \"optgroup>option\",\n\t\t\t\"optg+\": \"optgroup>option\",\n\t\t\t\"pic+\": \"picture>source:srcset+img\"\n\t\t}\n\t},\n\t\n\t\"xml\": {\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\",\n\t\t\"filters\": \"html\"\n\t},\n\t\n\t\"svg\": {\n\t\t\"filters\": \"html\",\n\t\t\"profile\": \"xml\",\n\t\t\"snippets\": {\n\t\t\t\"!!!\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\",\n\t\t\t\"svgdoc\": \"<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\"\n\t\t},\n\t\t\"abbreviations\": {\n\t\t\t\"!svg\": \"!!!+svgdoc+svg\",\n\t\t\t\"svg\": \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\",\n\t\t\t\"a\": \"<a xlink:href=\\\"\\\">\",\n\t\t\t\"ag\": \"altGliph\",\n\t\t\t\"agd\": \"altGliphDef\",\n\t\t\t\"agi\": \"altGliphItem\",\n\t\t\t\"anim|animate\": \"<animate attributeType=\\\"\\\" attributeName=\\\"\\\" from=\\\"\\\" to=\\\"\\\" dur=\\\"\\\" repeatCount=\\\"indefinite\\\">\",\n\t\t\t\"ac\": \"<animateColor>\",\n\t\t\t\"am\": \"<animateMotion>\",\n\t\t\t\"at\": \"<animateTransform>\",\n\t\t\t\"c\": \"circle\",\n\t\t\t\"cp\": \"colorPath\",\n\t\t\t\"c-p\": \"color-profile\",\n\t\t\t\"cur\": \"cursor\",\n\t\t\t\"df\": \"defs\",\n\t\t\t\"e|ellipse\": \"<ellipse  cx=\\\"\\\" cy=\\\"\\\" rx=\\\"\\\" ry=\\\"\\\"/>\",\n\t\t\t\"ff\": \"<font-face>\",\n\t\t\t\"fff\": \"<font-face-format>\",\n\t\t\t\"ffn\": \"<font-face-name>\",\n\t\t\t\"ffs\": \"<font-face-src>\",\n\t\t\t\"ffu\": \"<font-face-uri>\",\n\t\t\t\"fo\": \"<foreignObject>\",\n\t\t\t\"g\": \"<g>\",\n\t\t\t\"gl\": \"<glyph>\",\n\t\t\t\"glr\": \"<glyphRef>\",\n\t\t\t\"hk\": \"<hkern>\",\n\t\t\t\"i|image\": \"<image xlink:href=\\\"\\\" x=\\\"\\\" y=\\\"\\\" width=\\\"\\\" height=\\\"\\\"/>\",\n\t\t\t\"l\": \"<line>\",\n\t\t\t\"lg\": \"<linearGradient>\",\n\t\t\t\"marker\": \"<marker>\",\n\t\t\t\"mask\": \"<mask>\",\n\t\t\t\"md\": \"<metadata>\",\n\t\t\t\"mg\": \"<missing-glyph>\",\n\t\t\t\"mp\": \"<mpath>\",\n\t\t\t\"path\": \"<path d=\\\"\\\">\",\n\t\t\t\"patt\": \"<pattern>\",\n\t\t\t\"pg\": \"<polygon points=\\\"\\\">\",\n\t\t\t\"pl\": \"<polyline points=\\\"\\\">\",\n\t\t\t\"rg\": \"<radialGradient>\",\n\t\t\t\"r\": \"<rect x=\\\"\\\" y=\\\"\\\" width=\\\"\\\" height=\\\"\\\"/>\",\n\t\t\t\"scr\": \"<script>\",\n\t\t\t\"sb\": \"<symbol>\",\n\t\t\t\"txt\": \"<text>\",\n\t\t\t\"tp\": \"<textPath>\",\n\t\t\t\"ts\": \"<tspan>\",\n\t\t\t\"u|use\": \"<use xlink:href=\\\"\\\"/>\",\n\t\t\t\"v\": \"<view>\",\n\t\t\t\"vk\": \"<vkern>\"\n\t\t}\n\t},\n\t\n\t\"xsl\": {\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\",\n\t\t\"filters\": \"html, xsl\",\n\t\t\"abbreviations\": {\n\t\t\t\"tm|tmatch\": \"<xsl:template match=\\\"\\\" mode=\\\"\\\">\",\n\t\t\t\"tn|tname\": \"<xsl:template name=\\\"\\\">\",\n\t\t\t\"call\": \"<xsl:call-template name=\\\"\\\"/>\",\n\t\t\t\"ap\": \"<xsl:apply-templates select=\\\"\\\" mode=\\\"\\\"/>\",\n\t\t\t\"api\": \"<xsl:apply-imports/>\",\n\t\t\t\"imp\": \"<xsl:import href=\\\"\\\"/>\",\n\t\t\t\"inc\": \"<xsl:include href=\\\"\\\"/>\",\n\n\t\t\t\"ch\": \"<xsl:choose>\",\n\t\t\t\"wh|xsl:when\": \"<xsl:when test=\\\"\\\">\",\n\t\t\t\"ot\": \"<xsl:otherwise>\",\n\t\t\t\"if\": \"<xsl:if test=\\\"\\\">\",\n\n\t\t\t\"par\": \"<xsl:param name=\\\"\\\">\",\n\t\t\t\"pare\": \"<xsl:param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"var\": \"<xsl:variable name=\\\"\\\">\",\n\t\t\t\"vare\": \"<xsl:variable name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"wp\": \"<xsl:with-param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"key\": \"<xsl:key name=\\\"\\\" match=\\\"\\\" use=\\\"\\\"/>\",\n\n\t\t\t\"elem\": \"<xsl:element name=\\\"\\\">\",\n\t\t\t\"attr\": \"<xsl:attribute name=\\\"\\\">\",\n\t\t\t\"attrs\": \"<xsl:attribute-set name=\\\"\\\">\",\n\n\t\t\t\"cp\": \"<xsl:copy select=\\\"\\\"/>\",\n\t\t\t\"co\": \"<xsl:copy-of select=\\\"\\\"/>\",\n\t\t\t\"val\": \"<xsl:value-of select=\\\"\\\"/>\",\n\t\t\t\"for|each\": \"<xsl:for-each select=\\\"\\\">\",\n\t\t\t\"tex\": \"<xsl:text></xsl:text>\",\n\n\t\t\t\"com\": \"<xsl:comment>\",\n\t\t\t\"msg\": \"<xsl:message terminate=\\\"no\\\">\",\n\t\t\t\"fall\": \"<xsl:fallback>\",\n\t\t\t\"num\": \"<xsl:number value=\\\"\\\"/>\",\n\t\t\t\"nam\": \"<namespace-alias stylesheet-prefix=\\\"\\\" result-prefix=\\\"\\\"/>\",\n\t\t\t\"pres\": \"<xsl:preserve-space elements=\\\"\\\"/>\",\n\t\t\t\"strip\": \"<xsl:strip-space elements=\\\"\\\"/>\",\n\t\t\t\"proc\": \"<xsl:processing-instruction name=\\\"\\\">\",\n\t\t\t\"sort\": \"<xsl:sort select=\\\"\\\" order=\\\"\\\"/>\",\n\n\t\t\t\"choose+\": \"xsl:choose>xsl:when+xsl:otherwise\",\n\t\t\t\"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\"\n\t\t}, \n\t\t\"snippets\": {\n\t\t\t\"!!!\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n\t\t}\n\t},\n\t\n\t\"haml\": {\n\t\t\"filters\": \"haml\",\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\"\n\t},\n\n\t\"jade\": {\n\t\t\"filters\": \"jade\",\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\"\n\t},\n\n\t\"jsx\": {\n\t\t\"filters\": \"jsx, html\",\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\"\n\t},\n\n\t\"slim\": {\n\t\t\"filters\": \"slim\",\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\"\n\t},\n\t\n\t\"scss\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"sass\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"less\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"stylus\": {\n\t\t\"extends\": \"css\"\n\t},\n\n\t\"styl\": {\n\t\t\"extends\": \"stylus\"\n\t}\n}\n\n},{}],\"utils\\\\abbreviation.js\":[function(require,module,exports){\n/**\n * Utility functions to work with <code>AbbreviationNode</code> as HTML element\n * @param {Function} require\n * @param {Underscore} _\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar elements = require('../assets/elements');\n\tvar tabStops = require('../assets/tabStops');\n\tvar utils = require('../utils/common');\n\tvar tagName = require('../resolver/tagName');\n\n\treturn {\n\t\t/**\n\t\t * Test if passed node is unary (no closing tag)\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisUnary: function(node) {\n\t\t\tif (node.children.length || node._text || this.isSnippet(node)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tvar r = node.data('resource');\n\t\t\treturn r && r.is_empty;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is inline-level (like &lt;strong&gt;, &lt;img&gt;)\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisInline: function(node) {\n\t\t\treturn node.isTextNode() \n\t\t\t\t|| !node.name() \n\t\t\t\t|| tagName.isInlineLevel(node.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is block-level\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisBlock: function(node) {\n\t\t\treturn this.isSnippet(node) || !this.isInline(node);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if given node is a snippet\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisSnippet: function(node) {\n\t\t\treturn elements.is(node.data('resource'), 'snippet');\n\t\t},\n\t\t\n\t\t/**\n\t\t * This function tests if passed node content contains HTML tags. \n\t\t * This function is mostly used for output formatting\n\t\t * @param {AbbreviationNode} node\n\t\t * @returns {Boolean}\n\t\t */\n\t\thasTagsInContent: function(node) {\n\t\t\treturn utils.matchesTag(node.content);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if current element contains block-level children\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasBlockChildren: function(node) {\n\t\t\treturn (this.hasTagsInContent(node) && this.isBlock(node)) \n\t\t\t\t|| node.children.some(function(child) {\n\t\t\t\t\treturn this.isBlock(child);\n\t\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Utility function that inserts content instead of <code>${child}</code>\n\t\t * variables on <code>text</code>\n\t\t * @param {String} text Text where child content should be inserted\n\t\t * @param {String} childContent Content to insert\n\t\t * @param {Object} options\n\t\t * @returns {String\n\t\t */\n\t\tinsertChildContent: function(text, childContent, options) {\n\t\t\toptions = utils.extend({\n\t\t\t\tkeepVariable: true,\n\t\t\t\tappendIfNoChild: true\n\t\t\t}, options || {});\n\t\t\t\n\t\t\tvar childVariableReplaced = false;\n\t\t\ttext = tabStops.replaceVariables(text, function(variable, name, data) {\n\t\t\t\tvar output = variable;\n\t\t\t\tif (name == 'child') {\n\t\t\t\t\t// add correct indentation\n\t\t\t\t\toutput = utils.padString(childContent, utils.getLinePaddingFromPosition(text, data.start));\n\t\t\t\t\tchildVariableReplaced = true;\n\t\t\t\t\tif (options.keepVariable)\n\t\t\t\t\t\toutput += variable;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn output;\n\t\t\t});\n\t\t\t\n\t\t\tif (!childVariableReplaced && options.appendIfNoChild) {\n\t\t\t\ttext += childContent;\n\t\t\t}\n\t\t\t\n\t\t\treturn text;\n\t\t}\n\t};\n});\n},{\"../assets/elements\":\"assets\\\\elements.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../resolver/tagName\":\"resolver\\\\tagName.js\",\"../utils/common\":\"utils\\\\common.js\"}],\"utils\\\\action.js\":[function(require,module,exports){\n/**\n * Utility methods for Emmet actions\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('./common');\n\tvar cssSections = require('./cssSections');\n\tvar abbreviationParser = require('../parser/abbreviation');\n\tvar htmlMatcher = require('../assets/htmlMatcher');\n\tvar xmlEditTree = require('../editTree/xml');\n\tvar range = require('../assets/range');\n\tvar resources = require('../assets/resources');\n\n\treturn {\n\t\tmimeTypes: {\n\t\t\t'gif' : 'image/gif',\n\t\t\t'png' : 'image/png',\n\t\t\t'jpg' : 'image/jpeg',\n\t\t\t'jpeg': 'image/jpeg',\n\t\t\t'svg' : 'image/svg+xml',\n\t\t\t'html': 'text/html',\n\t\t\t'htm' : 'text/html'\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts abbreviations from text stream, starting from the end\n\t\t * @param {String} str\n\t\t * @return {String} Abbreviation or empty string\n\t\t * @memberOf emmet.actionUtils\n\t\t */\n\t\textractAbbreviation: function(str) {\n\t\t\tvar curOffset = str.length;\n\t\t\tvar startIndex = -1;\n\t\t\tvar groupCount = 0;\n\t\t\tvar braceCount = 0;\n\t\t\tvar textCount = 0;\n\t\t\t\n\t\t\twhile (true) {\n\t\t\t\tcurOffset--;\n\t\t\t\tif (curOffset < 0) {\n\t\t\t\t\t// moved to the beginning of the line\n\t\t\t\t\tstartIndex = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar ch = str.charAt(curOffset);\n\t\t\t\t\n\t\t\t\tif (ch == ']') {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == '[') {\n\t\t\t\t\tif (!braceCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbraceCount--;\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\ttextCount++;\n\t\t\t\t} else if (ch == '{') {\n\t\t\t\t\tif (!textCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttextCount--;\n\t\t\t\t} else if (ch == ')') {\n\t\t\t\t\tgroupCount++;\n\t\t\t\t} else if (ch == '(') {\n\t\t\t\t\tif (!groupCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgroupCount--;\n\t\t\t\t} else {\n\t\t\t\t\tif (braceCount || textCount) \n\t\t\t\t\t\t// respect all characters inside attribute sets or text nodes\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (!abbreviationParser.isAllowedChar(ch) || (ch == '>' && utils.endsWithTag(str.substring(0, curOffset + 1)))) {\n\t\t\t\t\t\t// found stop symbol\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (startIndex != -1 && !textCount && !braceCount && !groupCount) \n\t\t\t\t// found something, remove some invalid symbols from the \n\t\t\t\t// beginning and return abbreviation\n\t\t\t\treturn str.substring(startIndex).replace(/^[\\*\\+\\>\\^]+/, '');\n\t\t\telse\n\t\t\t\treturn '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Gets image size from image byte stream.\n\t\t * @author http://romeda.org/rePublish/\n\t\t * @param {String} stream Image byte stream (use <code>IEmmetFile.read()</code>)\n\t\t * @return {Object} Object with <code>width</code> and <code>height</code> properties\n\t\t */\n\t\tgetImageSize: function(stream) {\n\t\t\tvar pngMagicNum = \"\\211PNG\\r\\n\\032\\n\",\n\t\t\t\tjpgMagicNum = \"\\377\\330\",\n\t\t\t\tgifMagicNum = \"GIF8\",\n\t\t\t\tpos = 0,\n\t\t\t\tnextByte = function() {\n\t\t\t\t\treturn stream.charCodeAt(pos++);\n\t\t\t\t};\n\t\t\n\t\t\tif (stream.substr(0, 8) === pngMagicNum) {\n\t\t\t\t// PNG. Easy peasy.\n\t\t\t\tpos = stream.indexOf('IHDR') + 4;\n\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\twidth:  (nextByte() << 24) | (nextByte() << 16) | (nextByte() <<  8) | nextByte(),\n\t\t\t\t\theight: (nextByte() << 24) | (nextByte() << 16) | (nextByte() <<  8) | nextByte()\n\t\t\t\t};\n\t\t\t\n\t\t\t} else if (stream.substr(0, 4) === gifMagicNum) {\n\t\t\t\tpos = 6;\n\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\twidth:  nextByte() | (nextByte() << 8),\n\t\t\t\t\theight: nextByte() | (nextByte() << 8)\n\t\t\t\t};\n\t\t\t\n\t\t\t} else if (stream.substr(0, 2) === jpgMagicNum) {\n\t\t\t\tpos = 2;\n\t\t\t\n\t\t\t\tvar l = stream.length;\n\t\t\t\twhile (pos < l) {\n\t\t\t\t\tif (nextByte() != 0xFF) return;\n\t\t\t\t\n\t\t\t\t\tvar marker = nextByte();\n\t\t\t\t\tif (marker == 0xDA) break;\n\t\t\t\t\n\t\t\t\t\tvar size = (nextByte() << 8) | nextByte();\n\t\t\t\t\n\t\t\t\t\tif (marker >= 0xC0 && marker <= 0xCF && !(marker & 0x4) && !(marker & 0x8)) {\n\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\theight: (nextByte() << 8) | nextByte(),\n\t\t\t\t\t\t\twidth: (nextByte() << 8) | nextByte()\n\t\t\t\t\t\t};\n\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos += size - 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Captures context XHTML element from editor under current caret position.\n\t\t * This node can be used as a helper for abbreviation extraction\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Object}\n\t\t */\n\t\tcaptureContext: function(editor, pos) {\n\t\t\tvar allowedSyntaxes = {'html': 1, 'xml': 1, 'xsl': 1, 'jsx': 1};\n\t\t\tvar syntax = editor.getSyntax();\n\t\t\tif (syntax in allowedSyntaxes) {\n\t\t\t\tvar content = editor.getContent();\n\t\t\t\tif (typeof pos === 'undefined') {\n\t\t\t\t\tpos = editor.getCaretPos();\n\t\t\t\t}\n\n\t\t\t\tvar tag = htmlMatcher.find(content, pos);\n\t\t\t\tif (tag && tag.type == 'tag') {\n\t\t\t\t\tvar startTag = tag.open;\n\t\t\t\t\tvar contextNode = {\n\t\t\t\t\t\tname: startTag.name,\n\t\t\t\t\t\tattributes: [],\n\t\t\t\t\t\tmatch: tag\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\t// parse attributes\n\t\t\t\t\tvar tagTree = xmlEditTree.parse(startTag.range.substring(content));\n\t\t\t\t\tif (tagTree) {\n\t\t\t\t\t\tcontextNode.attributes = tagTree.getAll().map(function(item) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tname: item.name(),\n\t\t\t\t\t\t\t\tvalue: item.value()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn contextNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Find expression bounds in current editor at caret position. \n\t\t * On each character a <code>fn</code> function will be called and must \n\t\t * return <code>true</code> if current character meets requirements, \n\t\t * <code>false</code> otherwise\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {Function} fn Function to test each character of expression\n\t\t * @return {Range}\n\t\t */\n\t\tfindExpressionBounds: function(editor, fn) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar il = content.length;\n\t\t\tvar exprStart = editor.getCaretPos() - 1;\n\t\t\tvar exprEnd = exprStart + 1;\n\t\t\t\t\n\t\t\t// start by searching left\n\t\t\twhile (exprStart >= 0 && fn(content.charAt(exprStart), exprStart, content)) exprStart--;\n\t\t\t\n\t\t\t// then search right\n\t\t\twhile (exprEnd < il && fn(content.charAt(exprEnd), exprEnd, content)) exprEnd++;\n\t\t\t\n\t\t\tif (exprEnd > exprStart) {\n\t\t\t\treturn range([++exprStart, exprEnd]);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {Object} data\n\t\t * @returns {Boolean}\n\t\t */\n\t\tcompoundUpdate: function(editor, data) {\n\t\t\tif (data) {\n\t\t\t\tvar sel = editor.getSelectionRange();\n\t\t\t\teditor.replaceContent(data.data, data.start, data.end, true);\n\t\t\t\teditor.createSelection(data.caret, data.caret + sel.end - sel.start);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Common syntax detection method for editors that doesnt provide any\n\t\t * info about current syntax scope. \n\t\t * @param {IEmmetEditor} editor Current editor\n\t\t * @param {String} hint Any syntax hint that editor can provide \n\t\t * for syntax detection. Default is 'html'\n\t\t * @returns {String} \n\t\t */\n\t\tdetectSyntax: function(editor, hint) {\n\t\t\tvar syntax = hint || 'html';\n\t\t\t\n\t\t\tif (!resources.hasSyntax(syntax)) {\n\t\t\t\tsyntax = 'html';\n\t\t\t}\n\t\t\t\n\t\t\tif (syntax == 'html' && (this.isStyle(editor) || this.isInlineCSS(editor))) {\n\t\t\t\tsyntax = 'css';\n\t\t\t}\n\n\t\t\tif (syntax == 'styl') {\n\t\t\t\tsyntax = 'stylus';\n\t\t\t}\n\t\t\t\n\t\t\treturn syntax;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Common method for detecting output profile\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {String}\n\t\t */\n\t\tdetectProfile: function(editor) {\n\t\t\tvar syntax = editor.getSyntax();\n\t\t\t\n\t\t\t// get profile from syntax definition\n\t\t\tvar profile = resources.findItem(syntax, 'profile');\n\t\t\tif (profile) {\n\t\t\t\treturn profile;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(syntax) {\n\t\t\t\tcase 'xml':\n\t\t\t\tcase 'xsl':\n\t\t\t\t\treturn 'xml';\n\t\t\t\tcase 'css':\n\t\t\t\t\tif (this.isInlineCSS(editor)) {\n\t\t\t\t\t\treturn 'line';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\tprofile = resources.getVariable('profile');\n\t\t\t\t\tif (!profile) { // no forced profile, guess from content\n\t\t\t\t\t\t// html or xhtml?\n\t\t\t\t\t\tprofile = this.isXHTML(editor) ? 'xhtml': 'html';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn profile;\n\t\t\t}\n\n\t\t\treturn 'xhtml';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Tries to detect if current document is XHTML one.\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisXHTML: function(editor) {\n\t\t\treturn editor.getContent().search(/<!DOCTYPE[^>]+XHTML/i) != -1;\n\t\t},\n\n\t\t/**\n\t\t * Check if current caret position is inside &lt;style&gt; tag\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Range} Inner range of &lt;style&gt; tag\n\t\t */\n\t\tisStyle: function(editor) {\n\t\t\treturn !!cssSections.styleTagRange(editor.getContent(), editor.getCaretPos());\n\t\t},\n\n\t\t/**\n\t\t * Check if given CSS dialect is supported by CSS actions\n\t\t * @param  {String}  syntax\n\t\t * @return {Boolean}\n\t\t */\n\t\tisSupportedCSS: function(syntax) {\n\t\t\treturn syntax == 'css' || syntax == 'less' || syntax == 'scss';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current caret position is inside \"style\" attribute of HTML\n\t\t * element\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Range} Inner range of style attribute\n\t\t */\n\t\tisInlineCSS: function(editor) {\n\t\t\treturn !!cssSections.styleAttrRange(editor.getContent(), editor.getCaretPos());\n\t\t}\n\t};\n});\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../editTree/xml\":\"editTree\\\\xml.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"./common\":\"utils\\\\common.js\",\"./cssSections\":\"utils\\\\cssSections.js\"}],\"utils\\\\base64.js\":[function(require,module,exports){\n/**\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\t\n\treturn {\n\t\t/**\n\t\t * Encodes data using base64 algorithm\n\t\t * @author Tyler Akins (http://rumkin.com)\n\t\t * @param {String} input\n\t\t * @returns {String}\n\t\t */\n\t\tencode : function(input) {\n\t\t\tvar output = [];\n\t\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4, cdp1, cdp2, cdp3;\n\t\t\tvar i = 0, il = input.length, b64 = chars;\n\n\t\t\twhile (i < il) {\n\n\t\t\t\tcdp1 = input.charCodeAt(i++);\n\t\t\t\tcdp2 = input.charCodeAt(i++);\n\t\t\t\tcdp3 = input.charCodeAt(i++);\n\n\t\t\t\tchr1 = cdp1 & 0xff;\n\t\t\t\tchr2 = cdp2 & 0xff;\n\t\t\t\tchr3 = cdp3 & 0xff;\n\n\t\t\t\tenc1 = chr1 >> 2;\n\t\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\t\t\tenc4 = chr3 & 63;\n\n\t\t\t\tif (isNaN(cdp2)) {\n\t\t\t\t\tenc3 = enc4 = 64;\n\t\t\t\t} else if (isNaN(cdp3)) {\n\t\t\t\t\tenc4 = 64;\n\t\t\t\t}\n\n\t\t\t\toutput.push(b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4));\n\t\t\t}\n\n\t\t\treturn output.join('');\n\t\t},\n\n\t\t/**\n\t\t * Decodes string using MIME base64 algorithm\n\t\t * \n\t\t * @author Tyler Akins (http://rumkin.com)\n\t\t * @param {String} data\n\t\t * @return {String}\n\t\t */\n\t\tdecode : function(data) {\n\t\t\tvar o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, tmpArr = [];\n\t\t\tvar b64 = chars, il = data.length;\n\n\t\t\tif (!data) {\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tdata += '';\n\n\t\t\tdo { // unpack four hexets into three octets using index points in b64\n\t\t\t\th1 = b64.indexOf(data.charAt(i++));\n\t\t\t\th2 = b64.indexOf(data.charAt(i++));\n\t\t\t\th3 = b64.indexOf(data.charAt(i++));\n\t\t\t\th4 = b64.indexOf(data.charAt(i++));\n\n\t\t\t\tbits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n\t\t\t\to1 = bits >> 16 & 0xff;\n\t\t\t\to2 = bits >> 8 & 0xff;\n\t\t\t\to3 = bits & 0xff;\n\n\t\t\t\tif (h3 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1);\n\t\t\t\t} else if (h4 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2);\n\t\t\t\t} else {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2, o3);\n\t\t\t\t}\n\t\t\t} while (i < il);\n\n\t\t\treturn tmpArr.join('');\n\t\t}\n\t};\n});\n},{}],\"utils\\\\comments.js\":[function(require,module,exports){\n/**\n * Utility module for working with comments in source code\n * (mostly stripping it from source)\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('./common');\n\tvar range = require('../assets/range');\n\tvar stringStream = require('../assets/stringStream');\n\tvar reHasComment = /\\/\\*|\\/\\//;\n\n\treturn {\n\t\t/**\n\t\t * Replaces all comments in given CSS source with spaces,\n\t\t * which allows more reliable (and faster) token search\n\t\t * in CSS content\n\t\t * @param  {String} content CSS content\n\t\t * @return {String}\n\t\t */\n\t\tstrip: function(content) {\n\t\t\tif (!reHasComment.test(content)) {\n\t\t\t\treturn content;\n\t\t\t}\n\n\t\t\tvar stream = stringStream(content);\n\t\t\tvar replaceRanges = [];\n\t\t\tvar ch, ch2;\n\n\t\t\twhile ((ch = stream.next())) {\n\t\t\t\tif (ch === '/') {\n\t\t\t\t\tch2 = stream.peek();\n\t\t\t\t\tif (ch2 === '*') { // multiline CSS comment\n\t\t\t\t\t\tstream.start = stream.pos - 1;\n\n\t\t\t\t\t\tif (stream.skipTo('*/')) {\n\t\t\t\t\t\t\tstream.pos += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// unclosed comment\n\t\t\t\t\t\t\tstream.skipToEnd();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treplaceRanges.push([stream.start, stream.pos]);\n\t\t\t\t\t} else if (ch2 === '/') {\n\t\t\t\t\t\t// preprocessors single line comments\n\t\t\t\t\t\tstream.start = stream.pos - 1;\n\t\t\t\t\t\twhile ((ch2 = stream.next())) {\n\t\t\t\t\t\t\tif (ch2 === '\\n' || ch2 == '\\r') {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treplaceRanges.push([stream.start, stream.pos]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstream.skipQuoted();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn utils.replaceWith(content, replaceRanges, ' ');\n\t\t}\n\t};\n});\n},{\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"./common\":\"utils\\\\common.js\"}],\"utils\\\\common.js\":[function(require,module,exports){\n/**\n * Common utility helper for Emmet\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar range = require('../assets/range');\n\n\t/** \n\t * Special token used as a placeholder for caret positions inside \n\t * generated output \n\t */\n\tvar caretPlaceholder = '${0}';\n\t\n\treturn {\n\t\treTag: /<\\/?[\\w:\\-]+(?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*\\s*(\\/?)>$/,\n\n\t\tdefaultSyntax: function() {\n\t\t\treturn 'html';\n\t\t},\n\n\t\tdefaultProfile: function() {\n\t\t\treturn 'plain';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed string ends with XHTML tag. This method is used for testing\n\t\t * '>' character: it belongs to tag or it's a part of abbreviation? \n\t\t * @param {String} str\n\t\t * @return {Boolean}\n\t\t */\n\t\tendsWithTag: function(str) {\n\t\t\treturn this.reTag.test(str);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed symbol is a number\n\t\t * @param {String} ch\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisNumeric: function(ch) {\n\t\t\tif (typeof(ch) == 'string')\n\t\t\t\tch = ch.charCodeAt(0);\n\t\t\t\t\n\t\t\treturn (ch && ch > 47 && ch < 58);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Trim whitespace from string\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: (function() {\n\t\t\tif (String.prototype.trim) {\n\t\t\t\treturn function(text) {\n\t\t\t\t\treturn text ? text.trim() : '';\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn function(text) {\n\t\t\t\treturn (text || \"\").replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t}\n\t\t})(),\n\t\t\n\t\t/**\n\t\t * Split text into lines. Set <code>remove_empty</code> to true to filter\n\t\t * empty lines\n\t\t * @param {String} text Text to split\n\t\t * @param {Boolean} removeEmpty Remove empty lines from result\n\t\t * @return {Array}\n\t\t */\n\t\tsplitByLines: function(text, removeEmpty) {\n\t\t\t// IE fails to split string by regexp, \n\t\t\t// need to normalize newlines first\n\t\t\t// Also, Mozilla's Rhiho JS engine has a weird newline bug\n\t\t\tvar nl = '\\n';\n\t\t\tvar lines = (text || '')\n\t\t\t\t.replace(/\\r\\n/g, '\\n')\n\t\t\t\t.replace(/\\n\\r/g, '\\n')\n\t\t\t\t.replace(/\\r/g, '\\n')\n\t\t\t\t.replace(/\\n/g, nl)\n\t\t\t\t.split(nl);\n\t\t\t\n\t\t\tif (removeEmpty) {\n\t\t\t\tlines = lines.filter(function(line) {\n\t\t\t\t\treturn line.length && !!this.trim(line);\n\t\t\t\t}, this);\n\t\t\t}\n\t\t\t\n\t\t\treturn lines;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Repeats string <code>howMany</code> times\n\t\t * @param {String} str\n\t\t * @param {Number} how_many\n\t\t * @return {String}\n\t\t */\n\t\trepeatString: function(str, howMany) {\n\t\t\tvar out = '';\n\t\t\twhile (howMany--) {\n\t\t\t\tout += str;\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of paddings that should be used to align passed string\n\t\t * @param {Array} strings\n\t\t * @returns {Array}\n\t\t */\n\t\tgetStringsPads: function(strings) {\n\t\t\tvar lengths = strings.map(function(s) {\n\t\t\t\treturn typeof s === 'string' ? s.length : +s;\n\t\t\t});\n\t\t\t\n\t\t\tvar max = lengths.reduce(function(prev, cur) {\n\t\t\t\treturn typeof prev === 'undefined' ? cur : Math.max(prev, cur);\n\t\t\t});\n\t\t\treturn lengths.map(function(l) {\n\t\t\t\tvar pad = max - l;\n\t\t\t\treturn pad ? this.repeatString(' ', pad) : '';\n\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indents text with padding\n\t\t * @param {String} text Text to indent\n\t\t * @param {String} pad Padding size (number) or padding itself (string)\n\t\t * @return {String}\n\t\t */\n\t\tpadString: function(text, pad) {\n\t\t\tvar result = [];\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tvar nl = '\\n';\n\t\t\t\t\n\t\t\tresult.push(lines[0]);\n\t\t\tfor (var j = 1; j < lines.length; j++) \n\t\t\t\tresult.push(nl + pad + lines[j]);\n\t\t\t\t\n\t\t\treturn result.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Pad string with zeroes\n\t\t * @param {String} str String to pad\n\t\t * @param {Number} pad Desired string length\n\t\t * @return {String}\n\t\t */\n\t\tzeroPadString: function(str, pad) {\n\t\t\tvar padding = '';\n\t\t\tvar il = str.length;\n\t\t\t\t\n\t\t\twhile (pad > il++) padding += '0';\n\t\t\treturn padding + str; \n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes padding at the beginning of each text's line\n\t\t * @param {String} text\n\t\t * @param {String} pad\n\t\t */\n\t\tunindentString: function(text, pad) {\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tvar pl = pad.length;\n\t\t\tfor (var i = 0, il = lines.length, line; i < il; i++) {\n\t\t\t\tline = lines[i];\n\t\t\t\tif (line.substr(0, pl) === pad) {\n\t\t\t\t\tlines[i] = line.substr(pl);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn lines.join('\\n');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces unescaped symbols in <code>str</code>. For example, the '$' symbol\n\t\t * will be replaced in 'item$count', but not in 'item\\$count'.\n\t\t * @param {String} str Original string\n\t\t * @param {String} symbol Symbol to replace\n\t\t * @param {String} replace Symbol replacement. Might be a function that \n\t\t * returns new value\n\t\t * @return {String}\n\t\t */\n\t\treplaceUnescapedSymbol: function(str, symbol, replace) {\n\t\t\tvar i = 0;\n\t\t\tvar il = str.length;\n\t\t\tvar sl = symbol.length;\n\t\t\tvar matchCount = 0;\n\t\t\t\t\n\t\t\twhile (i < il) {\n\t\t\t\tif (str.charAt(i) == '\\\\') {\n\t\t\t\t\t// escaped symbol, skip next character\n\t\t\t\t\ti += sl + 1;\n\t\t\t\t} else if (str.substr(i, sl) == symbol) {\n\t\t\t\t\t// have match\n\t\t\t\t\tvar curSl = sl;\n\t\t\t\t\tmatchCount++;\n\t\t\t\t\tvar newValue = replace;\n\t\t\t\t\tif (typeof replace === 'function') {\n\t\t\t\t\t\tvar replaceData = replace(str, symbol, i, matchCount);\n\t\t\t\t\t\tif (replaceData) {\n\t\t\t\t\t\t\tcurSl = replaceData[0].length;\n\t\t\t\t\t\t\tnewValue = replaceData[1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewValue = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (newValue === false) { // skip replacement\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstr = str.substring(0, i) + newValue + str.substring(i + curSl);\n\t\t\t\t\t// adjust indexes\n\t\t\t\t\til = str.length;\n\t\t\t\t\ti += newValue.length;\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn str;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces '$' character in string assuming it might be escaped with '\\'\n\t\t * @param {String} str String where character should be replaced\n\t\t * @param {String} value New value\n\t\t * @return {String}\n\t\t */\n\t\treplaceCounter: function(str, value, total) {\n\t\t\tvar symbol = '$';\n\t\t\t// in case we received strings from Java, convert the to native strings\n\t\t\tstr = String(str);\n\t\t\tvalue = String(value);\n\t\t\t\n\t\t\tif (/^\\-?\\d+$/.test(value)) {\n\t\t\t\tvalue = +value;\n\t\t\t}\n\t\t\t\n\t\t\tvar that = this;\n\t\t\t\n\t\t\treturn this.replaceUnescapedSymbol(str, symbol, function(str, symbol, pos, matchNum){\n\t\t\t\tif (str.charAt(pos + 1) == '{' || that.isNumeric(str.charAt(pos + 1)) ) {\n\t\t\t\t\t// it's a variable, skip it\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// replace sequense of $ symbols with padded number  \n\t\t\t\tvar j = pos + 1;\n\t\t\t\twhile(str.charAt(j) == '$' && str.charAt(j + 1) != '{') j++;\n\t\t\t\tvar pad = j - pos;\n\t\t\t\t\n\t\t\t\t// get counter base\n\t\t\t\tvar base = 0, decrement = false, m;\n\t\t\t\tif ((m = str.substr(j).match(/^@(\\-?)(\\d*)/))) {\n\t\t\t\t\tj += m[0].length;\n\t\t\t\t\t\n\t\t\t\t\tif (m[1]) {\n\t\t\t\t\t\tdecrement = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbase = parseInt(m[2] || 1, 10) - 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (decrement && total && typeof value === 'number') {\n\t\t\t\t\tvalue = total - value + 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalue += base;\n\t\t\t\t\n\t\t\t\treturn [str.substring(pos, j), that.zeroPadString(value + '', pad)];\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if string matches against <code>reTag</code> regexp. This \n\t\t * function may be used to test if provided string contains HTML tags\n\t\t * @param {String} str\n\t\t * @returns {Boolean}\n\t\t */\n\t\tmatchesTag: function(str) {\n\t\t\treturn this.reTag.test(str || '');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Escapes special characters used in Emmet, like '$', '|', etc.\n\t\t * Use this method before passing to actions like \"Wrap with Abbreviation\"\n\t\t * to make sure that existing special characters won't be altered\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tescapeText: function(text) {\n\t\t\treturn text.replace(/([\\$\\\\])/g, '\\\\$1');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Unescapes special characters used in Emmet, like '$', '|', etc.\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tunescapeText: function(text) {\n\t\t\treturn text.replace(/\\\\(.)/g, '$1');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns caret placeholder\n\t\t * @returns {String}\n\t\t */\n\t\tgetCaretPlaceholder: function() {\n\t\t\treturn typeof caretPlaceholder === 'function'\n\t\t\t\t? caretPlaceholder.apply(this, arguments)\n\t\t\t\t: caretPlaceholder;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets new representation for carets in generated output\n\t\t * @param {String} value New caret placeholder. Might be a \n\t\t * <code>Function</code>\n\t\t */\n\t\tsetCaretPlaceholder: function(value) {\n\t\t\tcaretPlaceholder = value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns line padding\n\t\t * @param {String} line\n\t\t * @return {String}\n\t\t */\n\t\tgetLinePadding: function(line) {\n\t\t\treturn (line.match(/^(\\s+)/) || [''])[0];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that returns padding of line of <code>pos</code>\n\t\t * position in <code>content</code>\n\t\t * @param {String} content\n\t\t * @param {Number} pos\n\t\t * @returns {String}\n\t\t */\n\t\tgetLinePaddingFromPosition: function(content, pos) {\n\t\t\tvar lineRange = this.findNewlineBounds(content, pos);\n\t\t\treturn this.getLinePadding(lineRange.substring(content));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Escape special regexp chars in string, making it usable for creating dynamic\n\t\t * regular expressions\n\t\t * @param {String} str\n\t\t * @return {String}\n\t\t */\n\t\tescapeForRegexp: function(str) {\n\t\t\tvar specials = new RegExp(\"[.*+?|()\\\\[\\\\]{}\\\\\\\\]\", \"g\"); // .*+?|()[]{}\\\n\t\t\treturn str.replace(specials, \"\\\\$&\");\n\t\t},\n\t\t\n\t\t/**\n\t\t * Make decimal number look good: convert it to fixed precision end remove\n\t\t * traling zeroes \n\t\t * @param {Number} num\n\t\t * @param {Number} fracion Fraction numbers (default is 2)\n\t\t * @return {String}\n\t\t */\n\t\tprettifyNumber: function(num, fraction) {\n\t\t\treturn num.toFixed(typeof fraction == 'undefined' ? 2 : fraction).replace(/\\.?0+$/, '');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replace substring of <code>str</code> with <code>value</code>\n\t\t * @param {String} str String where to replace substring\n\t\t * @param {String} value New substring value\n\t\t * @param {Number} start Start index of substring to replace. May also\n\t\t * be a <code>Range</code> object: in this case, the <code>end</code>\n\t\t * argument is not required\n\t\t * @param {Number} end End index of substring to replace. If ommited, \n\t\t * <code>start</code> argument is used\n\t\t */\n\t\treplaceSubstring: function(str, value, start, end) {\n\t\t\tif (typeof start === 'object' && 'end' in start) {\n\t\t\t\tend = start.end;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\t\t\t\n\t\t\tif (typeof end === 'string') {\n\t\t\t\tend = start + end.length;\n\t\t\t}\n\t\t\t\n\t\t\tif (typeof end === 'undefined') {\n\t\t\t\tend = start;\n\t\t\t}\n\t\t\t\n\t\t\tif (start < 0 || start > str.length)\n\t\t\t\treturn str;\n\t\t\t\n\t\t\treturn str.substring(0, start) + value + str.substring(end);\n\t\t},\n\n\t\t/**\n\t\t * Fills substrings in `content`, defined by given ranges,\n\t\t * wich `ch` character\n\t\t * @param  {String} content\n\t\t * @param  {Array} ranges\n\t\t * @return {String}\n\t\t */\n\t\treplaceWith: function(content, ranges, ch, noRepeat) {\n\t\t\tif (ranges.length) {\n\t\t\t\tvar offset = 0, fragments = [];\n\t\t\t\tranges.forEach(function(r) {\n\t\t\t\t\tvar repl = noRepeat ? ch : this.repeatString(ch, r[1] - r[0]);\n\t\t\t\t\tfragments.push(content.substring(offset, r[0]), repl);\n\t\t\t\t\toffset = r[1];\n\t\t\t\t}, this);\n\n\t\t\t\tcontent = fragments.join('') + content.substring(offset);\n\t\t\t}\n\n\t\t\treturn content;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Narrows down text range, adjusting selection to non-space characters\n\t\t * @param {String} text\n\t\t * @param {Number} start Starting range in <code>text</code> where \n\t\t * slection should be adjusted. Can also be any object that is accepted\n\t\t * by <code>Range</code> class\n\t\t * @return {Range}\n\t\t */\n\t\tnarrowToNonSpace: function(text, start, end) {\n\t\t\tvar rng = range.create(start, end);\n\t\t\t\n\t\t\tvar reSpace = /[\\s\\n\\r\\u00a0]/;\n\t\t\t// narrow down selection until first non-space character\n\t\t\twhile (rng.start < rng.end) {\n\t\t\t\tif (!reSpace.test(text.charAt(rng.start)))\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\trng.start++;\n\t\t\t}\n\t\t\t\n\t\t\twhile (rng.end > rng.start) {\n\t\t\t\trng.end--;\n\t\t\t\tif (!reSpace.test(text.charAt(rng.end))) {\n\t\t\t\t\trng.end++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn rng;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Find start and end index of text line for <code>from</code> index\n\t\t * @param {String} text \n\t\t * @param {Number} from\n\t\t */\n\t\tfindNewlineBounds: function(text, from) {\n\t\t\tvar len = text.length,\n\t\t\t\tstart = 0,\n\t\t\t\tend = len - 1, \n\t\t\t\tch;\n\n\t\t\t\n\t\t\t// search left\n\t\t\tfor (var i = from - 1; i > 0; i--) {\n\t\t\t\tch = text.charAt(i);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// search right\n\t\t\tfor (var j = from; j < len; j++) {\n\t\t\t\tch = text.charAt(j);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tend = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn range.create(start, end - start);\n\t\t},\n\n\t\t/**\n\t\t * Deep merge of two or more objects. Taken from jQuery.extend()\n\t\t */\n\t\tdeepMerge: function() {\n\t\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\t\ttarget = arguments[0] || {},\n\t\t\t\ti = 1,\n\t\t\t\tlength = arguments.length;\n\n\n\t\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\t\tif (typeof target !== 'object' && typeof target !== 'function') {\n\t\t\t\ttarget = {};\n\t\t\t}\n\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t// Only deal with non-null/undefined values\n\t\t\t\tif ( (options = arguments[ i ]) !== null ) {\n\t\t\t\t\t// Extend the base object\n\t\t\t\t\tfor ( name in options ) {\n\t\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif ( copy && ( typeof copy === 'object' || (copyIsArray = Array.isArray(copy)) ) ) {\n\t\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && Array.isArray(src) ? src : [];\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && typeof src === 'object' ? src : {};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[ name ] = this.deepMerge(clone, copy );\n\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return the modified object\n\t\t\treturn target;\n\t\t},\n\n\t\t/**\n\t\t * Dead simple string-to-JSON parser\n\t\t * @param {String} str\n\t\t * @returns {Object}\n\t\t */\n\t\tparseJSON: function(str) {\n\t\t\tif (typeof str == 'object') {\n\t\t\t\treturn str;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(str);\n\t\t\t} catch(e) {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t},\n\n\n\t\t/**************************\n\t\t * Utility belt\n\t\t **************************/\n\t\tunique: function(arr, comparator) {\n\t\t\tvar lookup = [];\n\t\t\treturn arr.filter(function(item) {\n\t\t\t\tvar val = comparator ? comparator(item) : item;\n\t\t\t\tif (lookup.indexOf(val) < 0) {\n\t\t\t\t\tlookup.push(val);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Return a copy of the object, filtered to only have values for \n\t\t * the whitelisted keys. \n\t\t * @param  {Object} obj\n\t\t * @return {Object}\n\t\t */\n\t\tpick: function(obj) {\n\t\t\tvar result = {};\n\t\t\tvar keys = this.toArray(arguments, 1);\n\t\t\tObject.keys(obj).forEach(function(key) {\n\t\t\t\tif (~keys.indexOf(key)) {\n\t\t\t\t\tresult[key] = obj[key];\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn result;\n\t\t},\n\n\t\tfind: function(arr, comparator, ctx) {\n\t\t\tvar result;\n\t\t\tif (ctx) {\n\t\t\t\tcomparator = comparator.bind(ctx);\n\t\t\t}\n\n\t\t\tif (Array.isArray(arr)) {\n\t\t\t\tarr.some(function(item, i) {\n\t\t\t\t\tif (comparator(item, i)) {\n\t\t\t\t\t\treturn result = item;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tObject.keys(arr).some(function(key, i) {\n\t\t\t\t\tif (comparator(arr[key], i)) {\n\t\t\t\t\t\treturn result = arr[key];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\ttoArray: function(obj, sliceIx) {\n\t\t\tif (Array.isArray(obj) && !sliceIx) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\treturn Array.prototype.slice.call(obj, sliceIx || 0);\n\t\t},\n\n\t\textend: function(obj) {\n\t\t\tfor (var i = 1, il = arguments.length, a; i < il; i++) {\n\t\t\t\ta = arguments[i];\n\t\t\t\tif (a) {\n\t\t\t\t\tObject.keys(a).forEach(function(key) {\n\t\t\t\t\t\tobj[key] = a[key];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\n\t\tdefaults: function(obj) {\n\t\t\tfor (var i = 1, il = arguments.length, a; i < il; i++) {\n\t\t\t\ta = arguments[i];\n\t\t\t\tif (a) {\n\t\t\t\t\tObject.keys(a).forEach(function(key) {\n\t\t\t\t\t\tif (!(key in obj)) {\n\t\t\t\t\t\t\tobj[key] = a[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\n\t\tflatten: function(arr, out) {\n\t\t\tout = out || [];\n\t\t\tvar self = this;\n\t\t\tself.toArray(arr).forEach(function(item) {\n\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\tself.flatten(item, out);\n\t\t\t\t} else {\n\t\t\t\t\tout.push(item);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn out;\n\t\t},\n\n\t\tclone: function(obj) {\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\treturn obj.slice(0);\n\t\t\t}\n\n\t\t\treturn this.extend({}, obj);\n\t\t},\n\n\t\twithout: function(arr) {\n\t\t\tthis.toArray(arguments, 1).forEach(function(item) {\n\t\t\t\tvar ix;\n\t\t\t\twhile (~(ix = arr.indexOf(item))) {\n\t\t\t\t\tarr.splice(ix, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn arr;\n\t\t},\n\n\t\tlast: function(arr) {\n\t\t\treturn arr[arr.length - 1];\n\t\t}\n\t};\n});\n\n},{\"../assets/range\":\"assets\\\\range.js\"}],\"utils\\\\cssSections.js\":[function(require,module,exports){\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('./common');\n\tvar commentsUtils = require('./comments');\n\tvar range = require('../assets/range');\n\tvar stringStream = require('../assets/stringStream');\n\tvar cssParser = require('../parser/css');\n\tvar htmlMatcher = require('../assets/htmlMatcher');\n\tvar xmlEditTree = require('../editTree/xml');\n\n\tvar idCounter = 1;\n\tvar maxId = 1000000;\n\n\tvar reSpaceTrim = /^(\\s*).+?(\\s*)$/;\n\tvar reSpace = /\\s/g;\n\tvar reComma = /,/;\n\n\tfunction isQuote(ch) {\n\t\treturn ch == '\"' || ch == \"'\";\n\t}\n\n\tfunction getId() {\n\t\tidCounter = (idCounter + 1) % maxId;\n\t\treturn 's' + idCounter;\n\t}\n\n\t/**\n\t * @param {Range} range Full selector range with additional\n\t * properties for matching name and content (@see findAllRules())\n\t * @param {String} source CSS source\n\t */\n\tfunction CSSSection(rng, source) {\n\t\tthis.id = getId();\n\t\t/** @type {CSSSection} */\n\t\tthis.parent = null;\n\t\t/** @type {CSSSection} */\n\t\tthis.nextSibling = null;\n\t\t/** @type {CSSSection} */\n\t\tthis.previousSibling = null;\n\t\tthis._source = source;\n\t\tthis._name = null;\n\t\tthis._content = null;\n\n\t\t/**\n\t\t * Custom data for current nodes, used by other modules for\n\t\t * caching etc.\n\t\t * @type {Object}\n\t\t */\n\t\tthis._data = {};\n\n\t\tif (!rng && source) {\n\t\t\trng = range(0, source);\n\t\t}\n\n\t\tthis.range = rng;\n\t\tthis.children = [];\n\t}\n\n\tCSSSection.prototype = {\n\t\taddChild: function(section) {\n\t\t\tif (!(section instanceof CSSSection)) {\n\t\t\t\tsection = new CSSSection(section);\n\t\t\t}\n\n\t\t\tvar lastChild = utils.last(this.children);\n\t\t\tif (lastChild) {\n\t\t\t\tlastChild.nextSibling = section;\n\t\t\t\tsection.previousSibling = lastChild;\n\t\t\t}\n\t\t\tsection.parent = this;\n\n\t\t\tthis.children.push(section);\n\t\t\treturn section;\n\t\t},\n\n\t\t/**\n\t\t * Returns root node\n\t\t * @return {CSSSection}\n\t\t */\n\t\troot: function() {\n\t\t\tvar root = this;\n\t\t\tdo {\n\t\t\t\tif (!root.parent) {\n\t\t\t\t\treturn root;\n\t\t\t\t}\n\t\t\t} while(root = root.parent);\n\n\t\t\treturn root;\n\t\t},\n\n\t\t/**\n\t\t * Returns currect CSS source\n\t\t * @return {String}\n\t\t */\n\t\tsource: function() {\n\t\t\treturn this._source || this.root()._source;\n\t\t},\n\n\t\t/**\n\t\t * Returns section name\n\t\t * @return {String}\n\t\t */\n\t\tname: function() {\n\t\t\tif (this._name === null) {\n\t\t\t\tvar range = this.nameRange();\n\t\t\t\tif (range) {\n\t\t\t\t\tthis._name = range.substring(this.source());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this._name;\n\t\t},\n\n\t\t/**\n\t\t * Returns section name range\n\t\t * @return {[type]} [description]\n\t\t */\n\t\tnameRange: function() {\n\t\t\tif (this.range && '_selectorEnd' in this.range) {\n\t\t\t\treturn range.create2(this.range.start, this.range._selectorEnd);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Returns deepest child of current section (or section itself) \n\t\t * which includes given position.\n\t\t * @param  {Number} pos\n\t\t * @return {CSSSection}\n\t\t */\n\t\tmatchDeep: function(pos) {\n\t\t\tif (!this.range.inside(pos)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfor (var i = 0, il = this.children.length, m; i < il; i++) {\n\t\t\t\tm = this.children[i].matchDeep(pos);\n\t\t\t\tif (m) {\n\t\t\t\t\treturn m;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn this.parent ? this : null;\n\t\t},\n\n\t\t/**\n\t\t * Returns current and all nested sections ranges\n\t\t * @return {Array}\n\t\t */\n\t\tallRanges: function() {\n\t\t\tvar out = [];\n\t\t\tif (this.parent) {\n\t\t\t\t// add current range if it is not root node\n\t\t\t\tout.push(this.range);\n\t\t\t}\n\n\t\t\tthis.children.forEach(function(child) {\n\t\t\t\tout = out.concat(child.allRanges());\n\t\t\t});\n\n\t\t\treturn out;\n\t\t},\n\n\t\tdata: function(key, value) {\n\t\t\tif (typeof value !== 'undefined') {\n\t\t\t\tthis._data[key] = value;\n\t\t\t}\n\n\t\t\treturn this._data[key];\n\t\t},\n\n\t\tstringify: function(indent) {\n\t\t\tindent = indent || '';\n\t\t\tvar out = '';\n\t\t\tthis.children.forEach(function(item) {\n\t\t\t\tout += indent + item.name().replace(/\\n/g, '\\\\n') + '\\n';\n\t\t\t\tout += item.stringify(indent + '--');\n\t\t\t});\n\n\t\t\treturn out;\n\t\t},\n\n\t\t/**\n\t\t * Returns current sections actual content,\n\t\t * e.g. content without nested sections\n\t\t * @return {String} \n\t\t */\n\t\tcontent: function() {\n\t\t\tif (this._content !== null) {\n\t\t\t\treturn this._content;\n\t\t\t}\n\n\t\t\tif (!this.range || !('_contentStart' in this.range)) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tvar r = range.create2(this.range._contentStart + 1, this.range.end - 1);\n\t\t\tvar source = this.source();\n\t\t\tvar start = r.start;\n\t\t\tvar out = '';\n\n\t\t\tthis.children.forEach(function(child) {\n\t\t\t\tout += source.substring(start, child.range.start);\n\t\t\t\tstart = child.range.end;\n\t\t\t});\n\n\t\t\tout += source.substring(start, r.end);\n\t\t\treturn this._content = utils.trim(out);\n\t\t}\n\t};\n\n\treturn {\n\t\t/**\n\t\t * Finds all CSS rules ranges in given CSS source\n\t\t * @param  {String} content CSS source\n\t\t * @return {Array} Array of ranges\n\t\t */\n\t\tfindAllRules: function(content) {\n\t\t\tcontent = this.sanitize(content);\n\t\t\tvar stream = stringStream(content);\n\t\t\tvar ranges = [], matchedRanges;\n\t\t\tvar self = this;\n\n\t\t\tvar saveRule = function(r) {\n\t\t\t\tvar selRange = self.extractSelector(content, r.start);\n\t\t\t\tvar rule = range.create2(selRange.start, r.end);\n\t\t\t\trule._selectorEnd = selRange.end;\n\t\t\t\trule._contentStart = r.start;\n\t\t\t\tranges.push(rule);\n\t\t\t};\n\n\t\t\tvar ch;\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (isQuote(ch)) {\n\t\t\t\t\tif (!stream.skipString(ch)) {\n\t\t\t\t\t\tbreak; // unterminated string\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tmatchedRanges = this.matchBracesRanges(content, stream.pos - 1);\n\t\t\t\t\tmatchedRanges.forEach(saveRule);\n\n\t\t\t\t\tif (matchedRanges.length) {\n\t\t\t\t\t\tstream.pos = utils.last(matchedRanges).end;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn ranges.sort(function(a, b) {\n\t\t\t\treturn a.start - b.start;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Matches curly braces content right after given position\n\t\t * @param  {String} content CSS content. Must not contain comments!\n\t\t * @param  {Number} pos     Search start position\n\t\t * @return {Range}\n\t\t */\n\t\tmatchBracesRanges: function(content, pos, sanitize) {\n\t\t\tif (sanitize) {\n\t\t\t\tcontent = this.sanitize(content);\n\t\t\t}\n\n\t\t\tvar stream = stringStream(content);\n\t\t\tstream.start = stream.pos = pos;\n\t\t\tvar stack = [], ranges = [];\n\t\t\tvar ch;\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tstack.push(stream.pos - 1);\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\tif (!stack.length) {\n\t\t\t\t\t\tthrow 'Invalid source structure (check for curly braces)';\n\t\t\t\t\t}\n\t\t\t\t\tranges.push(range.create2(stack.pop(), stream.pos));\n\t\t\t\t\tif (!stack.length) {\n\t\t\t\t\t\treturn ranges;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstream.skipQuoted();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ranges;\n\t\t},\n\n\t\t/**\n\t\t * Extracts CSS selector from CSS document from\n\t\t * given position. The selector is located by moving backward\n\t\t * from given position which means that passed position\n\t\t * must point to the end of selector \n\t\t * @param  {String}  content CSS source\n\t\t * @param  {Number}  pos     Search position\n\t\t * @param  {Boolean} sanitize Sanitize CSS source before processing.\n\t\t * Off by default and assumes that CSS must be comment-free already\n\t\t * (for performance)\n\t\t * @return {Range}\n\t\t */\n\t\textractSelector: function(content, pos, sanitize) {\n\t\t\tif (sanitize) {\n\t\t\t\tcontent = this.sanitize(content);\n\t\t\t}\n\n\t\t\tvar skipString = function() {\n\t\t\t\tvar quote = content.charAt(pos);\n\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\twhile (--pos >= 0) {\n\t\t\t\t\t\tif (content.charAt(pos) == quote && content.charAt(pos - 1) != '\\\\') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t};\n\n\t\t\t// find CSS selector\n\t\t\tvar ch;\n\t\t\tvar endPos = pos;\n\t\t\twhile (--pos >= 0) {\n\t\t\t\tif (skipString()) continue;\n\n\t\t\t\tch = content.charAt(pos);\n\t\t\t\tif (ch == ')') {\n\t\t\t\t\t// looks like its a preprocessor thing,\n\t\t\t\t\t// most likely a mixin arguments list, e.g.\n\t\t\t\t\t// .mixin (@arg1; @arg2) {...}\n\t\t\t\t\twhile (--pos >= 0) {\n\t\t\t\t\t\tif (skipString()) continue;\n\n\t\t\t\t\t\tif (content.charAt(pos) == '(') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (ch == '{' || ch == '}' || ch == ';') {\n\t\t\t\t\tpos++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pos < 0) {\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\t\n\t\t\tvar selector = content.substring(pos, endPos);\n\n\t\t\t// trim whitespace from matched selector\n\t\t\tvar m = selector.replace(reSpace, ' ').match(reSpaceTrim);\n\t\t\tif (m) {\n\t\t\t\tpos += m[1].length;\n\t\t\t\tendPos -= m[2].length;\n\t\t\t}\n\n\t\t\treturn range.create2(pos, endPos);\n\t\t},\n\n\t\t/**\n\t\t * Search for nearest CSS rule/section that contains\n\t\t * given position\n\t\t * @param  {String} content CSS content or matched CSS rules (array of ranges)\n\t\t * @param  {Number} pos     Search position\n\t\t * @return {Range}\n\t\t */\n\t\tmatchEnclosingRule: function(content, pos) {\n\t\t\tif (typeof content === 'string') {\n\t\t\t\tcontent = this.findAllRules(content);\n\t\t\t}\n\n\t\t\tvar rules = content.filter(function(r) {\n\t\t\t\treturn r.inside(pos);\n\t\t\t});\n\n\t\t\treturn utils.last(rules);\n\t\t},\n\n\t\t/**\n\t\t * Locates CSS rule next or before given position\n\t\t * @param  {String}  content    CSS content\n\t\t * @param  {Number}  pos        Search start position\n\t\t * @param  {Boolean} isBackward Search backward (find previous rule insteaf of next one)\n\t\t * @return {Range}\n\t\t */\n\t\tlocateRule: function(content, pos, isBackward) {\n\t\t\t// possible case: editor reported that current syntax is\n\t\t\t// CSS, but its actually a HTML document (either `style` tag or attribute)\n\t\t\tvar offset = 0;\n\t\t\tvar subrange = this.styleTagRange(content, pos);\n\t\t\tif (subrange) {\n\t\t\t\toffset = subrange.start;\n\t\t\t\tpos -= subrange.start;\n\t\t\t\tcontent = subrange.substring(content);\n\t\t\t}\n\n\t\t\tvar rules = this.findAllRules(content);\n\t\t\tvar ctxRule = this.matchEnclosingRule(rules, pos);\n\n\t\t\tif (ctxRule) {\n\t\t\t\treturn ctxRule.shift(offset);\n\t\t\t}\n\n\t\t\tfor (var i = 0, il = rules.length; i < il; i++) {\n\t\t\t\tif (rules[i].start > pos) {\n\t\t\t\t\treturn rules[isBackward && i > 0 ? i - 1 : i].shift(offset);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Sanitizes given CSS content: replaces content that may \n\t\t * interfere with parsing (comments, interpolations, etc.)\n\t\t * with spaces. Sanitized content MUST NOT be used for\n\t\t * editing or outputting, it just simplifies searching\n\t\t * @param  {String} content CSS content\n\t\t * @return {String}\n\t\t */\n\t\tsanitize: function(content) {\n\t\t\tcontent = commentsUtils.strip(content);\n\n\t\t\t// remove preprocessor string interpolations like #{var}\n\t\t\tvar stream = stringStream(content);\n\t\t\tvar replaceRanges = [];\n\t\t\tvar ch, ch2;\n\n\t\t\twhile ((ch = stream.next())) {\n\t\t\t\tif (isQuote(ch)) {\n\t\t\t\t\t// skip string\n\t\t\t\t\tstream.skipString(ch)\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ch === '#' || ch === '@') {\n\t\t\t\t\tch2 = stream.peek();\n\t\t\t\t\tif (ch2 === '{') { // string interpolation\n\t\t\t\t\t\tstream.start = stream.pos - 1;\n\n\t\t\t\t\t\tif (stream.skipTo('}')) {\n\t\t\t\t\t\t\tstream.pos += 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow 'Invalid string interpolation at ' + stream.start;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treplaceRanges.push([stream.start, stream.pos]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn utils.replaceWith(content, replaceRanges, 'a');\n\t\t},\n\n\t\t/**\n\t\t * Parses and returns all sections in given CSS\n\t\t * as tree-like structure, e.g. provides nesting\n\t\t * info\n\t\t * @param  {String} content CSS content\n\t\t * @return {CSSSection}\n\t\t */\n\t\tsectionTree: function(content) {\n\t\t\tvar root = new CSSSection(null, content);\n\t\t\tvar rules = this.findAllRules(content);\n\n\t\t\t// rules are sorted in order they appear in CSS source\n\t\t\t// so we can optimize their nesting routine\n\t\t\tvar insert = function(range, ctx) {\n\t\t\t\twhile (ctx && ctx.range) {\n\t\t\t\t\tif (ctx.range.contains(range)) {\n\t\t\t\t\t\treturn ctx.addChild(range);\n\t\t\t\t\t}\n\n\t\t\t\t\tctx = ctx.parent;\n\t\t\t\t}\n\n\t\t\t\t// if we are here then given range is a top-level section\n\t\t\t\treturn root.addChild(range);\n\t\t\t};\n\n\t\t\tvar ctx = root;\n\t\t\trules.forEach(function(r) {\n\t\t\t\tctx = insert(r, ctx);\n\t\t\t});\n\n\t\t\treturn root;\n\t\t},\n\n\t\t/**\n\t\t * Returns ranges for all nested sections, available in\n\t\t * given CSS rule\n\t\t * @param  {CSSEditContainer} rule\n\t\t * @return {Array}\n\t\t */\n\t\tnestedSectionsInRule: function(rule) {\n\t\t\tvar offset = rule.valueRange(true).start;\n\t\t\tvar nestedSections = this.findAllRules(rule.valueRange().substring(rule.source));\n\t\t\tnestedSections.forEach(function(section) {\n\t\t\t\tsection.start += offset;\n\t\t\t\tsection.end += offset;\n\t\t\t\tsection._selectorEnd += offset;\n\t\t\t\tsection._contentStart += offset;\n\t\t\t});\n\t\t\treturn nestedSections;\n\t\t},\n\n\t\tstyleTagRange: function(content, pos) {\n\t\t\tvar tag = htmlMatcher.tag(content, pos);\n\t\t\treturn tag && tag.open.name.toLowerCase() == 'style' \n\t\t\t\t&& tag.innerRange.cmp(pos, 'lte', 'gte')\n\t\t\t\t&& tag.innerRange;\n\t\t},\n\n\t\tstyleAttrRange: function(content, pos) {\n\t\t\tvar tree = xmlEditTree.parseFromPosition(content, pos, true);\n\t\t\tif (tree) {\n\t\t\t\tvar attr = tree.itemFromPosition(pos, true);\n\t\t\t\treturn attr && attr.name().toLowerCase() == 'style' \n\t\t\t\t\t&& attr.valueRange(true).cmp(pos, 'lte', 'gte')\n\t\t\t\t\t&& attr.valueRange(true);\n\t\t\t}\n\t\t},\n\n\t\tCSSSection: CSSSection\n\t};\n});\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/xml\":\"editTree\\\\xml.js\",\"../parser/css\":\"parser\\\\css.js\",\"./comments\":\"utils\\\\comments.js\",\"./common\":\"utils\\\\common.js\"}],\"utils\\\\editor.js\":[function(require,module,exports){\n/**\n * Utility module used to prepare text for pasting into back-end editor\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('./common');\n\tvar resources = require('../assets/resources');\n\n\treturn  {\n\t\t/**\n\t\t * Check if cursor is placed inside XHTML tag\n\t\t * @param {String} html Contents of the document\n\t\t * @param {Number} caretPos Current caret position inside tag\n\t\t * @return {Boolean}\n\t\t */\n\t\tisInsideTag: function(html, caretPos) {\n\t\t\tvar reTag = /^<\\/?\\w[\\w\\:\\-]*.*?>/;\n\t\t\t\n\t\t\t// search left to find opening brace\n\t\t\tvar pos = caretPos;\n\t\t\twhile (pos > -1) {\n\t\t\t\tif (html.charAt(pos) == '<') \n\t\t\t\t\tbreak;\n\t\t\t\tpos--;\n\t\t\t}\n\t\t\t\n\t\t\tif (pos != -1) {\n\t\t\t\tvar m = reTag.exec(html.substring(pos));\n\t\t\t\tif (m && caretPos > pos && caretPos < pos + m[0].length)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sanitizes incoming editor data and provides default values for\n\t\t * output-specific info\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {String} syntax\n\t\t * @param {String} profile\n\t\t */\n\t\toutputInfo: function(editor, syntax, profile) {\n\t\t\t// most of this code makes sense for Java/Rhino environment\n\t\t\t// because string that comes from Java are not actually JS string\n\t\t\t// but Java String object so the have to be explicitly converted\n\t\t\t// to native string\n\t\t\tprofile = profile || editor.getProfileName();\n\t\t\treturn  {\n\t\t\t\t/** @memberOf outputInfo */\n\t\t\t\tsyntax: String(syntax || editor.getSyntax()),\n\t\t\t\tprofile: profile || null,\n\t\t\t\tcontent: String(editor.getContent())\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Unindent content, thus preparing text for tag wrapping\n\t\t * @param {IEmmetEditor} editor Editor instance\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tunindent: function(editor, text) {\n\t\t\treturn utils.unindentString(text, this.getCurrentLinePadding(editor));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns padding of current editor's line\n\t\t * @param {IEmmetEditor} Editor instance\n\t\t * @return {String}\n\t\t */\n\t\tgetCurrentLinePadding: function(editor) {\n\t\t\treturn utils.getLinePadding(editor.getCurrentLine());\n\t\t},\n\n\t\t/**\n\t\t * Normalizes content according to given preferences, e.g.\n\t\t * replaces newlines and indentation with ones defined in\n\t\t * `options`. If options are not provided or incomplete, \n\t\t * values will be taken from current user environment\n\t\t * @param {String} text\n\t\t * @param {Object} options\n\t\t * @return {String}\n\t\t */\n\t\tnormalize: function(text, options) {\n\t\t\toptions = utils.extend({\n\t\t\t\tnewline: resources.getNewline(),\n\t\t\t\tindentation: resources.getVariable('indentation')\n\t\t\t}, options);\n\n\t\t\tvar indent = function(tabs) {\n\t\t\t\treturn utils.repeatString(options.indentation, tabs.length);\n\t\t\t};\n\n\t\t\tvar lines = utils.splitByLines(text);\n\n\t\t\t// normailze indentation if its not tabs\n\t\t\tif (options.indentation !== '\\t') {\n\t\t\t\tlines = lines.map(function(line) {\n\t\t\t\t\treturn line.replace(/^\\s+/, function(space) {\n\t\t\t\t\t\treturn space.replace(/\\t/g, indent);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// normalize newlines\n\t\t\treturn lines.join(options.newline);\n\t\t}\n\t};\n});\n\n},{\"../assets/resources\":\"assets\\\\resources.js\",\"./common\":\"utils\\\\common.js\"}],\"utils\\\\math.js\":[function(require,module,exports){\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\t/*\n\t Source: https://github.com/silentmatt/js-expression-eval\n\n\t Based on ndef.parser, by Raphael Graf(r@undefined.ch)\n\t http://www.undefined.ch/mparser/index.html\n\n\t Ported to JavaScript and modified by Matthew Crumley (email@matthewcrumley.com, http://silentmatt.com/)\n\n\t You are free to use and modify this code in anyway you find useful. Please leave this comment in the code\n\t to acknowledge its original source. If you feel like it, I enjoy hearing about projects that use my code,\n\t but don't feel like you have to let me know or ask permission.\n\t*/\n\n\tfunction object(o) {\n\t\tfunction F() {}\n\t\tF.prototype = o;\n\t\treturn new F();\n\t}\n\n\tvar TNUMBER = 0;\n\tvar TOP1 = 1;\n\tvar TOP2 = 2;\n\tvar TVAR = 3;\n\tvar TFUNCALL = 4;\n\n\tfunction Token(type_, index_, prio_, number_) {\n\t\tthis.type_ = type_;\n\t\tthis.index_ = index_ || 0;\n\t\tthis.prio_ = prio_ || 0;\n\t\tthis.number_ = (number_ !== undefined && number_ !== null) ? number_ : 0;\n\t\tthis.toString = function () {\n\t\t\tswitch (this.type_) {\n\t\t\tcase TNUMBER:\n\t\t\t\treturn this.number_;\n\t\t\tcase TOP1:\n\t\t\tcase TOP2:\n\t\t\tcase TVAR:\n\t\t\t\treturn this.index_;\n\t\t\tcase TFUNCALL:\n\t\t\t\treturn \"CALL\";\n\t\t\tdefault:\n\t\t\t\treturn \"Invalid Token\";\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction Expression(tokens, ops1, ops2, functions) {\n\t\tthis.tokens = tokens;\n\t\tthis.ops1 = ops1;\n\t\tthis.ops2 = ops2;\n\t\tthis.functions = functions;\n\t}\n\n\t// Based on http://www.json.org/json2.js\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        escapable = /[\\\\\\'\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        meta = {    // table of character substitutions\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            \"'\" : \"\\\\'\",\n            '\\\\': '\\\\\\\\'\n        };\n\n\tfunction escapeValue(v) {\n\t\tif (typeof v === \"string\") {\n\t\t\tescapable.lastIndex = 0;\n\t        return escapable.test(v) ?\n\t            \"'\" + v.replace(escapable, function (a) {\n\t                var c = meta[a];\n\t                return typeof c === 'string' ? c :\n\t                    '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t            }) + \"'\" :\n\t            \"'\" + v + \"'\";\n\t\t}\n\t\treturn v;\n\t}\n\n\tExpression.prototype = {\n\t\tsimplify: function (values) {\n\t\t\tvalues = values || {};\n\t\t\tvar nstack = [];\n\t\t\tvar newexpression = [];\n\t\t\tvar n1;\n\t\t\tvar n2;\n\t\t\tvar f;\n\t\t\tvar L = this.tokens.length;\n\t\t\tvar item;\n\t\t\tvar i = 0;\n\t\t\tfor (i = 0; i < L; i++) {\n\t\t\t\titem = this.tokens[i];\n\t\t\t\tvar type_ = item.type_;\n\t\t\t\tif (type_ === TNUMBER) {\n\t\t\t\t\tnstack.push(item);\n\t\t\t\t}\n\t\t\t\telse if (type_ === TVAR && (item.index_ in values)) {\n\t\t\t\t\titem = new Token(TNUMBER, 0, 0, values[item.index_]);\n\t\t\t\t\tnstack.push(item);\n\t\t\t\t}\n\t\t\t\telse if (type_ === TOP2 && nstack.length > 1) {\n\t\t\t\t\tn2 = nstack.pop();\n\t\t\t\t\tn1 = nstack.pop();\n\t\t\t\t\tf = this.ops2[item.index_];\n\t\t\t\t\titem = new Token(TNUMBER, 0, 0, f(n1.number_, n2.number_));\n\t\t\t\t\tnstack.push(item);\n\t\t\t\t}\n\t\t\t\telse if (type_ === TOP1 && nstack.length > 0) {\n\t\t\t\t\tn1 = nstack.pop();\n\t\t\t\t\tf = this.ops1[item.index_];\n\t\t\t\t\titem = new Token(TNUMBER, 0, 0, f(n1.number_));\n\t\t\t\t\tnstack.push(item);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twhile (nstack.length > 0) {\n\t\t\t\t\t\tnewexpression.push(nstack.shift());\n\t\t\t\t\t}\n\t\t\t\t\tnewexpression.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nstack.length > 0) {\n\t\t\t\tnewexpression.push(nstack.shift());\n\t\t\t}\n\n\t\t\treturn new Expression(newexpression, object(this.ops1), object(this.ops2), object(this.functions));\n\t\t},\n\n\t\tsubstitute: function (variable, expr) {\n\t\t\tif (!(expr instanceof Expression)) {\n\t\t\t\texpr = new Parser().parse(String(expr));\n\t\t\t}\n\t\t\tvar newexpression = [];\n\t\t\tvar L = this.tokens.length;\n\t\t\tvar item;\n\t\t\tvar i = 0;\n\t\t\tfor (i = 0; i < L; i++) {\n\t\t\t\titem = this.tokens[i];\n\t\t\t\tvar type_ = item.type_;\n\t\t\t\tif (type_ === TVAR && item.index_ === variable) {\n\t\t\t\t\tfor (var j = 0; j < expr.tokens.length; j++) {\n\t\t\t\t\t\tvar expritem = expr.tokens[j];\n\t\t\t\t\t\tvar replitem = new Token(expritem.type_, expritem.index_, expritem.prio_, expritem.number_);\n\t\t\t\t\t\tnewexpression.push(replitem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewexpression.push(item);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ret = new Expression(newexpression, object(this.ops1), object(this.ops2), object(this.functions));\n\t\t\treturn ret;\n\t\t},\n\n\t\tevaluate: function (values) {\n\t\t\tvalues = values || {};\n\t\t\tvar nstack = [];\n\t\t\tvar n1;\n\t\t\tvar n2;\n\t\t\tvar f;\n\t\t\tvar L = this.tokens.length;\n\t\t\tvar item;\n\t\t\tvar i = 0;\n\t\t\tfor (i = 0; i < L; i++) {\n\t\t\t\titem = this.tokens[i];\n\t\t\t\tvar type_ = item.type_;\n\t\t\t\tif (type_ === TNUMBER) {\n\t\t\t\t\tnstack.push(item.number_);\n\t\t\t\t}\n\t\t\t\telse if (type_ === TOP2) {\n\t\t\t\t\tn2 = nstack.pop();\n\t\t\t\t\tn1 = nstack.pop();\n\t\t\t\t\tf = this.ops2[item.index_];\n\t\t\t\t\tnstack.push(f(n1, n2));\n\t\t\t\t}\n\t\t\t\telse if (type_ === TVAR) {\n\t\t\t\t\tif (item.index_ in values) {\n\t\t\t\t\t\tnstack.push(values[item.index_]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (item.index_ in this.functions) {\n\t\t\t\t\t\tnstack.push(this.functions[item.index_]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new Error(\"undefined variable: \" + item.index_);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (type_ === TOP1) {\n\t\t\t\t\tn1 = nstack.pop();\n\t\t\t\t\tf = this.ops1[item.index_];\n\t\t\t\t\tnstack.push(f(n1));\n\t\t\t\t}\n\t\t\t\telse if (type_ === TFUNCALL) {\n\t\t\t\t\tn1 = nstack.pop();\n\t\t\t\t\tf = nstack.pop();\n\t\t\t\t\tif (f.apply && f.call) {\n\t\t\t\t\t\tif (Object.prototype.toString.call(n1) == \"[object Array]\") {\n\t\t\t\t\t\t\tnstack.push(f.apply(undefined, n1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnstack.push(f.call(undefined, n1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new Error(f + \" is not a function\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(\"invalid Expression\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nstack.length > 1) {\n\t\t\t\tthrow new Error(\"invalid Expression (parity)\");\n\t\t\t}\n\t\t\treturn nstack[0];\n\t\t},\n\n\t\ttoString: function (toJS) {\n\t\t\tvar nstack = [];\n\t\t\tvar n1;\n\t\t\tvar n2;\n\t\t\tvar f;\n\t\t\tvar L = this.tokens.length;\n\t\t\tvar item;\n\t\t\tvar i = 0;\n\t\t\tfor (i = 0; i < L; i++) {\n\t\t\t\titem = this.tokens[i];\n\t\t\t\tvar type_ = item.type_;\n\t\t\t\tif (type_ === TNUMBER) {\n\t\t\t\t\tnstack.push(escapeValue(item.number_));\n\t\t\t\t}\n\t\t\t\telse if (type_ === TOP2) {\n\t\t\t\t\tn2 = nstack.pop();\n\t\t\t\t\tn1 = nstack.pop();\n\t\t\t\t\tf = item.index_;\n\t\t\t\t\tif (toJS && f == \"^\") {\n\t\t\t\t\t\tnstack.push(\"Math.pow(\" + n1 + \",\" + n2 + \")\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnstack.push(\"(\" + n1 + f + n2 + \")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (type_ === TVAR) {\n\t\t\t\t\tnstack.push(item.index_);\n\t\t\t\t}\n\t\t\t\telse if (type_ === TOP1) {\n\t\t\t\t\tn1 = nstack.pop();\n\t\t\t\t\tf = item.index_;\n\t\t\t\t\tif (f === \"-\") {\n\t\t\t\t\t\tnstack.push(\"(\" + f + n1 + \")\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnstack.push(f + \"(\" + n1 + \")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (type_ === TFUNCALL) {\n\t\t\t\t\tn1 = nstack.pop();\n\t\t\t\t\tf = nstack.pop();\n\t\t\t\t\tnstack.push(f + \"(\" + n1 + \")\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(\"invalid Expression\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nstack.length > 1) {\n\t\t\t\tthrow new Error(\"invalid Expression (parity)\");\n\t\t\t}\n\t\t\treturn nstack[0];\n\t\t},\n\n\t\tvariables: function () {\n\t\t\tvar L = this.tokens.length;\n\t\t\tvar vars = [];\n\t\t\tfor (var i = 0; i < L; i++) {\n\t\t\t\tvar item = this.tokens[i];\n\t\t\t\tif (item.type_ === TVAR && (vars.indexOf(item.index_) == -1)) {\n\t\t\t\t\tvars.push(item.index_);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn vars;\n\t\t},\n\n\t\ttoJSFunction: function (param, variables) {\n\t\t\tvar f = new Function(param, \"with(Parser.values) { return \" + this.simplify(variables).toString(true) + \"; }\");\n\t\t\treturn f;\n\t\t}\n\t};\n\n\tfunction add(a, b) {\n\t\treturn Number(a) + Number(b);\n\t}\n\tfunction sub(a, b) {\n\t\treturn a - b; \n\t}\n\tfunction mul(a, b) {\n\t\treturn a * b;\n\t}\n\tfunction div(a, b) {\n\t\treturn a / b;\n\t}\n\tfunction mod(a, b) {\n\t\treturn a % b;\n\t}\n\tfunction concat(a, b) {\n\t\treturn \"\" + a + b;\n\t}\n\n\tfunction neg(a) {\n\t\treturn -a;\n\t}\n\n\tfunction random(a) {\n\t\treturn Math.random() * (a || 1);\n\t}\n\tfunction fac(a) { //a!\n\t\ta = Math.floor(a);\n\t\tvar b = a;\n\t\twhile (a > 1) {\n\t\t\tb = b * (--a);\n\t\t}\n\t\treturn b;\n\t}\n\n\t// TODO: use hypot that doesn't overflow\n\tfunction pyt(a, b) {\n\t\treturn Math.sqrt(a * a + b * b);\n\t}\n\n\tfunction append(a, b) {\n\t\tif (Object.prototype.toString.call(a) != \"[object Array]\") {\n\t\t\treturn [a, b];\n\t\t}\n\t\ta = a.slice();\n\t\ta.push(b);\n\t\treturn a;\n\t}\n\n\tfunction Parser() {\n\t\tthis.success = false;\n\t\tthis.errormsg = \"\";\n\t\tthis.expression = \"\";\n\n\t\tthis.pos = 0;\n\n\t\tthis.tokennumber = 0;\n\t\tthis.tokenprio = 0;\n\t\tthis.tokenindex = 0;\n\t\tthis.tmpprio = 0;\n\n\t\tthis.ops1 = {\n\t\t\t\"sin\": Math.sin,\n\t\t\t\"cos\": Math.cos,\n\t\t\t\"tan\": Math.tan,\n\t\t\t\"asin\": Math.asin,\n\t\t\t\"acos\": Math.acos,\n\t\t\t\"atan\": Math.atan,\n\t\t\t\"sqrt\": Math.sqrt,\n\t\t\t\"log\": Math.log,\n\t\t\t\"abs\": Math.abs,\n\t\t\t\"ceil\": Math.ceil,\n\t\t\t\"floor\": Math.floor,\n\t\t\t\"round\": Math.round,\n\t\t\t\"-\": neg,\n\t\t\t\"exp\": Math.exp\n\t\t};\n\n\t\tthis.ops2 = {\n\t\t\t\"+\": add,\n\t\t\t\"-\": sub,\n\t\t\t\"*\": mul,\n\t\t\t\"/\": div,\n\t\t\t\"%\": mod,\n\t\t\t\"^\": Math.pow,\n\t\t\t\",\": append,\n\t\t\t\"||\": concat\n\t\t};\n\n\t\tthis.functions = {\n\t\t\t\"random\": random,\n\t\t\t\"fac\": fac,\n\t\t\t\"min\": Math.min,\n\t\t\t\"max\": Math.max,\n\t\t\t\"pyt\": pyt,\n\t\t\t\"pow\": Math.pow,\n\t\t\t\"atan2\": Math.atan2\n\t\t};\n\n\t\tthis.consts = {\n\t\t\t\"E\": Math.E,\n\t\t\t\"PI\": Math.PI\n\t\t};\n\t}\n\n\tParser.parse = function (expr) {\n\t\treturn new Parser().parse(expr);\n\t};\n\n\tParser.evaluate = function (expr, variables) {\n\t\treturn Parser.parse(expr).evaluate(variables);\n\t};\n\n\tParser.Expression = Expression;\n\n\tParser.values = {\n\t\tsin: Math.sin,\n\t\tcos: Math.cos,\n\t\ttan: Math.tan,\n\t\tasin: Math.asin,\n\t\tacos: Math.acos,\n\t\tatan: Math.atan,\n\t\tsqrt: Math.sqrt,\n\t\tlog: Math.log,\n\t\tabs: Math.abs,\n\t\tceil: Math.ceil,\n\t\tfloor: Math.floor,\n\t\tround: Math.round,\n\t\trandom: random,\n\t\tfac: fac,\n\t\texp: Math.exp,\n\t\tmin: Math.min,\n\t\tmax: Math.max,\n\t\tpyt: pyt,\n\t\tpow: Math.pow,\n\t\tatan2: Math.atan2,\n\t\tE: Math.E,\n\t\tPI: Math.PI\n\t};\n\n\tvar PRIMARY      = 1 << 0;\n\tvar OPERATOR     = 1 << 1;\n\tvar FUNCTION     = 1 << 2;\n\tvar LPAREN       = 1 << 3;\n\tvar RPAREN       = 1 << 4;\n\tvar COMMA        = 1 << 5;\n\tvar SIGN         = 1 << 6;\n\tvar CALL         = 1 << 7;\n\tvar NULLARY_CALL = 1 << 8;\n\n\tParser.prototype = {\n\t\tparse: function (expr) {\n\t\t\tthis.errormsg = \"\";\n\t\t\tthis.success = true;\n\t\t\tvar operstack = [];\n\t\t\tvar tokenstack = [];\n\t\t\tthis.tmpprio = 0;\n\t\t\tvar expected = (PRIMARY | LPAREN | FUNCTION | SIGN);\n\t\t\tvar noperators = 0;\n\t\t\tthis.expression = expr;\n\t\t\tthis.pos = 0;\n\n\t\t\twhile (this.pos < this.expression.length) {\n\t\t\t\tif (this.isOperator()) {\n\t\t\t\t\tif (this.isSign() && (expected & SIGN)) {\n\t\t\t\t\t\tif (this.isNegativeSign()) {\n\t\t\t\t\t\t\tthis.tokenprio = 2;\n\t\t\t\t\t\t\tthis.tokenindex = \"-\";\n\t\t\t\t\t\t\tnoperators++;\n\t\t\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN);\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.isComment()) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ((expected & OPERATOR) === 0) {\n\t\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected operator\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnoperators += 2;\n\t\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP2);\n\t\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (this.isNumber()) {\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected number\");\n\t\t\t\t\t}\n\t\t\t\t\tvar token = new Token(TNUMBER, 0, 0, this.tokennumber);\n\t\t\t\t\ttokenstack.push(token);\n\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA);\n\t\t\t\t}\n\t\t\t\telse if (this.isString()) {\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected string\");\n\t\t\t\t\t}\n\t\t\t\t\tvar token = new Token(TNUMBER, 0, 0, this.tokennumber);\n\t\t\t\t\ttokenstack.push(token);\n\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA);\n\t\t\t\t}\n\t\t\t\telse if (this.isLeftParenth()) {\n\t\t\t\t\tif ((expected & LPAREN) === 0) {\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected \\\"(\\\"\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (expected & CALL) {\n\t\t\t\t\t\tnoperators += 2;\n\t\t\t\t\t\tthis.tokenprio = -2;\n\t\t\t\t\t\tthis.tokenindex = -1;\n\t\t\t\t\t\tthis.addfunc(tokenstack, operstack, TFUNCALL);\n\t\t\t\t\t}\n\n\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN | NULLARY_CALL);\n\t\t\t\t}\n\t\t\t\telse if (this.isRightParenth()) {\n\t\t\t\t    if (expected & NULLARY_CALL) {\n\t\t\t\t\t\tvar token = new Token(TNUMBER, 0, 0, []);\n\t\t\t\t\t\ttokenstack.push(token);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((expected & RPAREN) === 0) {\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected \\\")\\\"\");\n\t\t\t\t\t}\n\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA | LPAREN | CALL);\n\t\t\t\t}\n\t\t\t\telse if (this.isComma()) {\n\t\t\t\t\tif ((expected & COMMA) === 0) {\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected \\\",\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP2);\n\t\t\t\t\tnoperators += 2;\n\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN);\n\t\t\t\t}\n\t\t\t\telse if (this.isConst()) {\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected constant\");\n\t\t\t\t\t}\n\t\t\t\t\tvar consttoken = new Token(TNUMBER, 0, 0, this.tokennumber);\n\t\t\t\t\ttokenstack.push(consttoken);\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA);\n\t\t\t\t}\n\t\t\t\telse if (this.isOp2()) {\n\t\t\t\t\tif ((expected & FUNCTION) === 0) {\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected function\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP2);\n\t\t\t\t\tnoperators += 2;\n\t\t\t\t\texpected = (LPAREN);\n\t\t\t\t}\n\t\t\t\telse if (this.isOp1()) {\n\t\t\t\t\tif ((expected & FUNCTION) === 0) {\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected function\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP1);\n\t\t\t\t\tnoperators++;\n\t\t\t\t\texpected = (LPAREN);\n\t\t\t\t}\n\t\t\t\telse if (this.isVar()) {\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected variable\");\n\t\t\t\t\t}\n\t\t\t\t\tvar vartoken = new Token(TVAR, this.tokenindex, 0, 0);\n\t\t\t\t\ttokenstack.push(vartoken);\n\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA | LPAREN | CALL);\n\t\t\t\t}\n\t\t\t\telse if (this.isWhite()) {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.errormsg === \"\") {\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unknown character\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.error_parsing(this.pos, this.errormsg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.tmpprio < 0 || this.tmpprio >= 10) {\n\t\t\t\tthis.error_parsing(this.pos, \"unmatched \\\"()\\\"\");\n\t\t\t}\n\t\t\twhile (operstack.length > 0) {\n\t\t\t\tvar tmp = operstack.pop();\n\t\t\t\ttokenstack.push(tmp);\n\t\t\t}\n\t\t\tif (noperators + 1 !== tokenstack.length) {\n\t\t\t\t//print(noperators + 1);\n\t\t\t\t//print(tokenstack);\n\t\t\t\tthis.error_parsing(this.pos, \"parity\");\n\t\t\t}\n\n\t\t\treturn new Expression(tokenstack, object(this.ops1), object(this.ops2), object(this.functions));\n\t\t},\n\n\t\tevaluate: function (expr, variables) {\n\t\t\treturn this.parse(expr).evaluate(variables);\n\t\t},\n\n\t\terror_parsing: function (column, msg) {\n\t\t\tthis.success = false;\n\t\t\tthis.errormsg = \"parse error [column \" + (column) + \"]: \" + msg;\n\t\t\tthrow new Error(this.errormsg);\n\t\t},\n\n//\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n\n\t\taddfunc: function (tokenstack, operstack, type_) {\n\t\t\tvar operator = new Token(type_, this.tokenindex, this.tokenprio + this.tmpprio, 0);\n\t\t\twhile (operstack.length > 0) {\n\t\t\t\tif (operator.prio_ <= operstack[operstack.length - 1].prio_) {\n\t\t\t\t\ttokenstack.push(operstack.pop());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperstack.push(operator);\n\t\t},\n\n\t\tisNumber: function () {\n\t\t\tvar r = false;\n\t\t\tvar str = \"\";\n\t\t\twhile (this.pos < this.expression.length) {\n\t\t\t\tvar code = this.expression.charCodeAt(this.pos);\n\t\t\t\tif ((code >= 48 && code <= 57) || code === 46) {\n\t\t\t\t\tstr += this.expression.charAt(this.pos);\n\t\t\t\t\tthis.pos++;\n\t\t\t\t\tthis.tokennumber = parseFloat(str);\n\t\t\t\t\tr = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn r;\n\t\t},\n\n\t\t// Ported from the yajjl JSON parser at http://code.google.com/p/yajjl/\n\t\tunescape: function(v, pos) {\n\t\t\tvar buffer = [];\n\t\t\tvar escaping = false;\n\n\t\t\tfor (var i = 0; i < v.length; i++) {\n\t\t\t\tvar c = v.charAt(i);\n\t\n\t\t\t\tif (escaping) {\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\tcase \"'\":\n\t\t\t\t\t\tbuffer.push(\"'\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tbuffer.push('\\\\');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tbuffer.push('/');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tbuffer.push('\\b');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\tbuffer.push('\\f');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tbuffer.push('\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tbuffer.push('\\r');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tbuffer.push('\\t');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\t// interpret the following 4 characters as the hex of the unicode code point\n\t\t\t\t\t\tvar codePoint = parseInt(v.substring(i + 1, i + 5), 16);\n\t\t\t\t\t\tbuffer.push(String.fromCharCode(codePoint));\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow this.error_parsing(pos + i, \"Illegal escape sequence: '\\\\\" + c + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tescaping = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (c == '\\\\') {\n\t\t\t\t\t\tescaping = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuffer.push(c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn buffer.join('');\n\t\t},\n\n\t\tisString: function () {\n\t\t\tvar r = false;\n\t\t\tvar str = \"\";\n\t\t\tvar startpos = this.pos;\n\t\t\tif (this.pos < this.expression.length && this.expression.charAt(this.pos) == \"'\") {\n\t\t\t\tthis.pos++;\n\t\t\t\twhile (this.pos < this.expression.length) {\n\t\t\t\t\tvar code = this.expression.charAt(this.pos);\n\t\t\t\t\tif (code != \"'\" || str.slice(-1) == \"\\\\\") {\n\t\t\t\t\t\tstr += this.expression.charAt(this.pos);\n\t\t\t\t\t\tthis.pos++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.pos++;\n\t\t\t\t\t\tthis.tokennumber = this.unescape(str, startpos);\n\t\t\t\t\t\tr = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn r;\n\t\t},\n\n\t\tisConst: function () {\n\t\t\tvar str;\n\t\t\tfor (var i in this.consts) {\n\t\t\t\tif (true) {\n\t\t\t\t\tvar L = i.length;\n\t\t\t\t\tstr = this.expression.substr(this.pos, L);\n\t\t\t\t\tif (i === str) {\n\t\t\t\t\t\tthis.tokennumber = this.consts[i];\n\t\t\t\t\t\tthis.pos += L;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tisOperator: function () {\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\n\t\t\tif (code === 43) { // +\n\t\t\t\tthis.tokenprio = 0;\n\t\t\t\tthis.tokenindex = \"+\";\n\t\t\t}\n\t\t\telse if (code === 45) { // -\n\t\t\t\tthis.tokenprio = 0;\n\t\t\t\tthis.tokenindex = \"-\";\n\t\t\t}\n\t\t\telse if (code === 124) { // |\n\t\t\t\tif (this.expression.charCodeAt(this.pos + 1) === 124) {\n\t\t\t\t\tthis.pos++;\n\t\t\t\t\tthis.tokenprio = 0;\n\t\t\t\t\tthis.tokenindex = \"||\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (code === 42) { // *\n\t\t\t\tthis.tokenprio = 1;\n\t\t\t\tthis.tokenindex = \"*\";\n\t\t\t}\n\t\t\telse if (code === 47) { // /\n\t\t\t\tthis.tokenprio = 2;\n\t\t\t\tthis.tokenindex = \"/\";\n\t\t\t}\n\t\t\telse if (code === 37) { // %\n\t\t\t\tthis.tokenprio = 2;\n\t\t\t\tthis.tokenindex = \"%\";\n\t\t\t}\n\t\t\telse if (code === 94) { // ^\n\t\t\t\tthis.tokenprio = 3;\n\t\t\t\tthis.tokenindex = \"^\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.pos++;\n\t\t\treturn true;\n\t\t},\n\n\t\tisSign: function () {\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\n\t\t\tif (code === 45 || code === 43) { // -\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tisPositiveSign: function () {\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\n\t\t\tif (code === 43) { // -\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tisNegativeSign: function () {\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\n\t\t\tif (code === 45) { // -\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tisLeftParenth: function () {\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\n\t\t\tif (code === 40) { // (\n\t\t\t\tthis.pos++;\n\t\t\t\tthis.tmpprio += 10;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tisRightParenth: function () {\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\n\t\t\tif (code === 41) { // )\n\t\t\t\tthis.pos++;\n\t\t\t\tthis.tmpprio -= 10;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tisComma: function () {\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\n\t\t\tif (code === 44) { // ,\n\t\t\t\tthis.pos++;\n\t\t\t\tthis.tokenprio = -1;\n\t\t\t\tthis.tokenindex = \",\";\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tisWhite: function () {\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\n\t\t\tif (code === 32 || code === 9 || code === 10 || code === 13) {\n\t\t\t\tthis.pos++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tisOp1: function () {\n\t\t\tvar str = \"\";\n\t\t\tfor (var i = this.pos; i < this.expression.length; i++) {\n\t\t\t\tvar c = this.expression.charAt(i);\n\t\t\t\tif (c.toUpperCase() === c.toLowerCase()) {\n\t\t\t\t\tif (i === this.pos || (c != '_' && (c < '0' || c > '9'))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr += c;\n\t\t\t}\n\t\t\tif (str.length > 0 && (str in this.ops1)) {\n\t\t\t\tthis.tokenindex = str;\n\t\t\t\tthis.tokenprio = 5;\n\t\t\t\tthis.pos += str.length;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tisOp2: function () {\n\t\t\tvar str = \"\";\n\t\t\tfor (var i = this.pos; i < this.expression.length; i++) {\n\t\t\t\tvar c = this.expression.charAt(i);\n\t\t\t\tif (c.toUpperCase() === c.toLowerCase()) {\n\t\t\t\t\tif (i === this.pos || (c != '_' && (c < '0' || c > '9'))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr += c;\n\t\t\t}\n\t\t\tif (str.length > 0 && (str in this.ops2)) {\n\t\t\t\tthis.tokenindex = str;\n\t\t\t\tthis.tokenprio = 5;\n\t\t\t\tthis.pos += str.length;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tisVar: function () {\n\t\t\tvar str = \"\";\n\t\t\tfor (var i = this.pos; i < this.expression.length; i++) {\n\t\t\t\tvar c = this.expression.charAt(i);\n\t\t\t\tif (c.toUpperCase() === c.toLowerCase()) {\n\t\t\t\t\tif (i === this.pos || (c != '_' && (c < '0' || c > '9'))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr += c;\n\t\t\t}\n\t\t\tif (str.length > 0) {\n\t\t\t\tthis.tokenindex = str;\n\t\t\t\tthis.tokenprio = 4;\n\t\t\t\tthis.pos += str.length;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tisComment: function () {\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\n\t\t\tif (code === 47 && this.expression.charCodeAt(this.pos) === 42) {\n\t\t\t\tthis.pos = this.expression.indexOf(\"*/\", this.pos) + 2;\n\t\t\t\tif (this.pos === 1) {\n\t\t\t\t\tthis.pos = this.expression.length;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t};\n\n\treturn Parser;\n});\n},{}],\"utils\\\\template.js\":[function(require,module,exports){\n/**\n * A very simple, ERB-style templating. Basically, just as string substitution.\n * The reason to not use default Lo-dashes `_.template()` implementation\n * is because it fails to run in CSP-enabled environments (Chrome extension, Atom)\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar stringStream = require('../assets/stringStream');\n\tvar utils = require('./common');\n\n\tfunction parseArgs(str) {\n\t\tvar args = [];\n\t\tvar stream = stringStream(str);\n\n\t\twhile (!stream.eol()) {\n\t\t\tif (stream.peek() == ',') {\n\t\t\t\targs.push(utils.trim(stream.current()));\n\t\t\t\tstream.next();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t\tstream.next();\n\t\t}\n\n\t\targs.push(utils.trim(stream.current()));\n\t\treturn args.filter(function(a) {\n\t\t\treturn !!a;\n\t\t});\n\t}\n\n\tfunction parseFunctionCall(str) {\n\t\tvar fnName = null, args;\n\t\tvar stream = stringStream(str);\n\t\twhile (!stream.eol()) {\n\t\t\tif (stream.peek() == '(') {\n\t\t\t\tfnName = stream.current();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tstream.skipToPair('(', ')', true);\n\t\t\t\targs = stream.current();\n\t\t\t\targs = parseArgs(args.substring(1, args.length - 1));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstream.next();\n\t\t}\n\n\t\treturn fnName && {\n\t\t\tname: fnName,\n\t\t\targs: args\n\t\t};\n\t}\n\n\tfunction evalArg(arg, context) {\n\t\tif (/^['\"]/.test(arg)) {\n\t\t\t// plain string\n\t\t\treturn arg.replace(/^(['\"])(.+?)\\1$/, '$2');\n\t\t}\n\n\t\tif (!isNaN(+arg)) {\n\t\t\t// a number\n\t\t\treturn +arg;\n\t\t}\n\n\t\t// otherwise, treat argument as a property name\n\t\tif (arg) {\n\t\t\tvar parts = arg.split('.');\n\t\t\tvar prop = context;\n\t\t\twhile (parts.length) {\n\t\t\t\tprop = prop[parts.shift()];\n\t\t\t}\n\n\t\t\treturn prop;\n\t\t}\n\t}\n\n\tfunction process(template, context) {\n\t\treturn template.replace(/<%[=\\-](.+?)%>/g, function(str, match) {\n\t\t\tmatch = utils.trim(match);\n\t\t\tvar fn = parseFunctionCall(match);\n\t\t\tif (fn) {\n\t\t\t\tvar fnArgs = fn.args.map(function(arg) {\n\t\t\t\t\treturn evalArg(arg, context);\n\t\t\t\t});\n\t\t\t\treturn context[fn.name].apply(context, fnArgs);\n\t\t\t}\n\n\t\t\treturn evalArg(match, context);\n\t\t});\n\t}\n\n\treturn function(template, context) {\n\t\treturn context ? process(template, context) : function(context) {\n\t\t\treturn process(template, context);\n\t\t};\n\t};\n});\n},{\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"./common\":\"utils\\\\common.js\"}],\"vendor\\\\klass.js\":[function(require,module,exports){\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\tvar utils = require('../utils/common');\n\n\t/**\n\t * Shared empty constructor function to aid in prototype-chain creation.\n\t */\n\tvar ctor = function(){};\n\n\t/**\n\t * Helper function to correctly set up the prototype chain, for subclasses.\n\t * Similar to `goog.inherits`, but uses a hash of prototype properties and\n\t * class properties to be extended.\n\t * Took it from Backbone.\n\t * @param {Object} parent\n\t * @param {Object} protoProps\n\t * @param {Object} staticProps\n\t * @returns {Object}\n\t */\n\tfunction inherits(parent, protoProps, staticProps) {\n\t\tvar child;\n\n\t\t// The constructor function for the new subclass is either defined by\n\t\t// you (the \"constructor\" property in your `extend` definition), or\n\t\t// defaulted by us to simply call the parent's constructor.\n\t\tif (protoProps && protoProps.hasOwnProperty('constructor')) {\n\t\t\tchild = protoProps.constructor;\n\t\t} else {\n\t\t\tchild = function() {\n\t\t\t\tparent.apply(this, arguments);\n\t\t\t};\n\t\t}\n\n\t\t// Inherit class (static) properties from parent.\n\t\tutils.extend(child, parent);\n\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tctor.prototype = parent.prototype;\n\t\tchild.prototype = new ctor();\n\n\t\t// Add prototype properties (instance properties) to the subclass,\n\t\t// if supplied.\n\t\tif (protoProps)\n\t\t\tutils.extend(child.prototype, protoProps);\n\n\t\t// Add static properties to the constructor function, if supplied.\n\t\tif (staticProps)\n\t\t\tutils.extend(child, staticProps);\n\n\t\t// Correctly set child's `prototype.constructor`.\n\t\tchild.prototype.constructor = child;\n\n\t\t// Set a convenience property in case the parent's prototype is needed\n\t\t// later.\n\t\tchild.__super__ = parent.prototype;\n\n\t\treturn child;\n\t}\n\n\treturn {\n\t\t/**\n\t\t * The self-propagating extend function for classes.\n\t\t * Took it from Backbone \n\t\t * @param {Object} protoProps\n\t\t * @param {Object} classProps\n\t\t * @returns {Object}\n\t\t */\n\t\textend: function(protoProps, classProps) {\n\t\t\tvar child = inherits(this, protoProps, classProps);\n\t\t\tchild.extend = this.extend;\n\t\t\t// a hack required to WSH inherit `toString` method\n\t\t\tif (protoProps.hasOwnProperty('toString'))\n\t\t\t\tchild.prototype.toString = protoProps.toString;\n\t\t\treturn child;\n\t\t}\n\t};\n});\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"vendor\\\\stringScore.js\":[function(require,module,exports){\n/*!\n * string_score.js: String Scoring Algorithm 0.1.10 \n *\n * http://joshaven.com/string_score\n * https://github.com/joshaven/string_score\n *\n * Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>\n * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score\n * MIT license: http://www.opensource.org/licenses/mit-license.php\n *\n * Date: Tue Mar 1 2011\n*/\n\n/**\n * Scores a string against another string.\n *  'Hello World'.score('he');     //=> 0.5931818181818181\n *  'Hello World'.score('Hello');  //=> 0.7318181818181818\n */\nif (typeof module === 'object' && typeof define !== 'function') {\n\tvar define = function (factory) {\n\t\tmodule.exports = factory(require, exports, module);\n\t};\n}\n\ndefine(function(require, exports, module) {\n\treturn {\n\t\tscore: function(string, abbreviation, fuzziness) {\n\t\t\t// If the string is equal to the abbreviation, perfect match.\n\t\t\t  if (string == abbreviation) {return 1;}\n\t\t\t  //if it's not a perfect match and is empty return 0\n\t\t\t  if(abbreviation == \"\") {return 0;}\n\n\t\t\t  var total_character_score = 0,\n\t\t\t      abbreviation_length = abbreviation.length,\n\t\t\t      string_length = string.length,\n\t\t\t      start_of_string_bonus,\n\t\t\t      abbreviation_score,\n\t\t\t      fuzzies=1,\n\t\t\t      final_score;\n\t\t\t  \n\t\t\t  // Walk through abbreviation and add up scores.\n\t\t\t  for (var i = 0,\n\t\t\t         character_score/* = 0*/,\n\t\t\t         index_in_string/* = 0*/,\n\t\t\t         c/* = ''*/,\n\t\t\t         index_c_lowercase/* = 0*/,\n\t\t\t         index_c_uppercase/* = 0*/,\n\t\t\t         min_index/* = 0*/;\n\t\t\t     i < abbreviation_length;\n\t\t\t     ++i) {\n\t\t\t    \n\t\t\t    // Find the first case-insensitive match of a character.\n\t\t\t    c = abbreviation.charAt(i);\n\t\t\t    \n\t\t\t    index_c_lowercase = string.indexOf(c.toLowerCase());\n\t\t\t    index_c_uppercase = string.indexOf(c.toUpperCase());\n\t\t\t    min_index = Math.min(index_c_lowercase, index_c_uppercase);\n\t\t\t    index_in_string = (min_index > -1) ? min_index : Math.max(index_c_lowercase, index_c_uppercase);\n\t\t\t    \n\t\t\t    if (index_in_string === -1) { \n\t\t\t      if (fuzziness) {\n\t\t\t        fuzzies += 1-fuzziness;\n\t\t\t        continue;\n\t\t\t      } else {\n\t\t\t        return 0;\n\t\t\t      }\n\t\t\t    } else {\n\t\t\t      character_score = 0.1;\n\t\t\t    }\n\t\t\t    \n\t\t\t    // Set base score for matching 'c'.\n\t\t\t    \n\t\t\t    // Same case bonus.\n\t\t\t    if (string[index_in_string] === c) { \n\t\t\t      character_score += 0.1; \n\t\t\t    }\n\t\t\t    \n\t\t\t    // Consecutive letter & start-of-string Bonus\n\t\t\t    if (index_in_string === 0) {\n\t\t\t      // Increase the score when matching first character of the remainder of the string\n\t\t\t      character_score += 0.6;\n\t\t\t      if (i === 0) {\n\t\t\t        // If match is the first character of the string\n\t\t\t        // & the first character of abbreviation, add a\n\t\t\t        // start-of-string match bonus.\n\t\t\t        start_of_string_bonus = 1; //true;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    else {\n\t\t\t  // Acronym Bonus\n\t\t\t  // Weighing Logic: Typing the first character of an acronym is as if you\n\t\t\t  // preceded it with two perfect character matches.\n\t\t\t  if (string.charAt(index_in_string - 1) === ' ') {\n\t\t\t    character_score += 0.8; // * Math.min(index_in_string, 5); // Cap bonus at 0.4 * 5\n\t\t\t  }\n\t\t\t    }\n\t\t\t    \n\t\t\t    // Left trim the already matched part of the string\n\t\t\t    // (forces sequential matching).\n\t\t\t    string = string.substring(index_in_string + 1, string_length);\n\t\t\t    \n\t\t\t    total_character_score += character_score;\n\t\t\t  } // end of for loop\n\t\t\t  \n\t\t\t  // Uncomment to weigh smaller words higher.\n\t\t\t  // return total_character_score / string_length;\n\t\t\t  \n\t\t\t  abbreviation_score = total_character_score / abbreviation_length;\n\t\t\t  //percentage_of_matched_string = abbreviation_length / string_length;\n\t\t\t  //word_score = abbreviation_score * percentage_of_matched_string;\n\t\t\t  \n\t\t\t  // Reduce penalty for longer strings.\n\t\t\t  //final_score = (word_score + abbreviation_score) / 2;\n\t\t\t  final_score = ((abbreviation_score * (abbreviation_length / string_length)) + abbreviation_score) / 2;\n\t\t\t  \n\t\t\t  final_score = final_score / fuzzies;\n\t\t\t  \n\t\t\t  if (start_of_string_bonus && (final_score + 0.15 < 1)) {\n\t\t\t    final_score += 0.15;\n\t\t\t  }\n\t\t\t  \n\t\t\t  return final_score;\n\t\t}\n\t};\n});\n},{}]},{},[\"./lib/emmet.js\",\"./bundles/snippets.js\"])(\"./lib/emmet.js\")\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer, __webpack_require__(/*! ./../@vue/cli-service/node_modules/webpack/buildin/global.js */ \"./node_modules/@vue/cli-service/node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW1tZXQvZW1tZXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW1tZXQvZW1tZXQuanM/YzA2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSl7dmFyIHZhbD1lKCk7IGlmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPXZhbDtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFwiZW1tZXRcIixbXSx2YWwpO3t2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuZW1tZXQ9dmFsfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gb3V0ZXIgKG1vZHVsZXMsIGNhY2hlLCBlbnRyeSkge1xuICAgIC8vIFNhdmUgdGhlIHJlcXVpcmUgZnJvbSBwcmV2aW91cyBidW5kbGUgdG8gdGhpcyBjbG9zdXJlIGlmIGFueVxuICAgIHZhciBwcmV2aW91c1JlcXVpcmUgPSB0eXBlb2YgcmVxdWlyZSA9PSBcImZ1bmN0aW9uXCIgJiYgcmVxdWlyZTtcblxuICAgIGZ1bmN0aW9uIG5ld1JlcXVpcmUobmFtZSwganVtcGVkKXtcbiAgICAgICAgaWYoIWNhY2hlW25hbWVdKSB7XG4gICAgICAgICAgICBpZighbW9kdWxlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNhbm5vdCBmaW5kIHRoZSB0aGUgbW9kdWxlIHdpdGhpbiBvdXIgaW50ZXJuYWwgbWFwIG9yXG4gICAgICAgICAgICAgICAgLy8gY2FjaGUganVtcCB0byB0aGUgY3VycmVudCBnbG9iYWwgcmVxdWlyZSBpZS4gdGhlIGxhc3QgYnVuZGxlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB3YXMgYWRkZWQgdG8gdGhlIHBhZ2UuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRSZXF1aXJlID0gdHlwZW9mIHJlcXVpcmUgPT0gXCJmdW5jdGlvblwiICYmIHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgaWYgKCFqdW1wZWQgJiYgY3VycmVudFJlcXVpcmUpIHJldHVybiBjdXJyZW50UmVxdWlyZShuYW1lLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBvdGhlciBidW5kbGVzIG9uIHRoaXMgcGFnZSB0aGUgcmVxdWlyZSBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIG9uZSBpcyBzYXZlZCB0byAncHJldmlvdXNSZXF1aXJlJy4gUmVwZWF0IHRoaXMgYXNcbiAgICAgICAgICAgICAgICAvLyBtYW55IHRpbWVzIGFzIHRoZXJlIGFyZSBidW5kbGVzIHVudGlsIHRoZSBtb2R1bGUgaXMgZm91bmQgb3JcbiAgICAgICAgICAgICAgICAvLyB3ZSBleGhhdXN0IHRoZSByZXF1aXJlIGNoYWluLlxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1JlcXVpcmUpIHJldHVybiBwcmV2aW91c1JlcXVpcmUobmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgbW9kdWxlIFxcJycgKyBuYW1lICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtID0gY2FjaGVbbmFtZV0gPSB7ZXhwb3J0czp7fX07XG4gICAgICAgICAgICBtb2R1bGVzW25hbWVdWzBdLmNhbGwobS5leHBvcnRzLCBmdW5jdGlvbih4KXtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBtb2R1bGVzW25hbWVdWzFdW3hdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdSZXF1aXJlKGlkID8gaWQgOiB4KTtcbiAgICAgICAgICAgIH0sbSxtLmV4cG9ydHMsb3V0ZXIsbW9kdWxlcyxjYWNoZSxlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlW25hbWVdLmV4cG9ydHM7XG4gICAgfVxuICAgIGZvcih2YXIgaT0wO2k8ZW50cnkubGVuZ3RoO2krKykgbmV3UmVxdWlyZShlbnRyeVtpXSk7XG5cbiAgICAvLyBPdmVycmlkZSB0aGUgY3VycmVudCByZXF1aXJlIHdpdGggdGhpcyBuZXcgb25lXG4gICAgcmV0dXJuIG5ld1JlcXVpcmU7XG59KVxuKHtcIi4vYnVuZGxlcy9zbmlwcGV0cy5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQnVuZGxlciwgdXNlZCBpbiBidWlsZGVyIHNjcmlwdCB0byBzdGF0aWNhbGx5XG4gKiBpbmNsdWRlIHNuaXBwZXRzLmpzb24gaW50byBidW5kbGVcbiAqL1xudmFyIHJlcyA9IHJlcXVpcmUoJy4uL2xpYi9hc3NldHMvcmVzb3VyY2VzJyk7XG52YXIgc25pcHBldHMgPSByZXF1aXJlKCcuLi9saWIvc25pcHBldHMuanNvbicpO1xucmVzLnNldFZvY2FidWxhcnkoc25pcHBldHMsICdzeXN0ZW0nKTtcblxufSx7XCIuLi9saWIvYXNzZXRzL3Jlc291cmNlc1wiOlwiYXNzZXRzXFxcXHJlc291cmNlcy5qc1wiLFwiLi4vbGliL3NuaXBwZXRzLmpzb25cIjpcInNuaXBwZXRzLmpzb25cIn1dLFwiLi9saWIvZW1tZXQuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgZ2xvYmFsID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcztcblxuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgYWN0aW9ucyA9IHJlcXVpcmUoJy4vYWN0aW9uL21haW4nKTtcblx0dmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyL2FiYnJldmlhdGlvbicpO1xuXHR2YXIgZmlsZSA9IHJlcXVpcmUoJy4vcGx1Z2luL2ZpbGUnKTtcblxuXHR2YXIgcHJlZmVyZW5jZXMgPSByZXF1aXJlKCcuL2Fzc2V0cy9wcmVmZXJlbmNlcycpO1xuXHR2YXIgcmVzb3VyY2VzID0gcmVxdWlyZSgnLi9hc3NldHMvcmVzb3VyY2VzJyk7XG5cdHZhciBwcm9maWxlID0gcmVxdWlyZSgnLi9hc3NldHMvcHJvZmlsZScpO1xuXHR2YXIgY2l1ID0gcmVxdWlyZSgnLi9hc3NldHMvY2FuaXVzZScpO1xuXHR2YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi9hc3NldHMvbG9nZ2VyJyk7XG5cblx0dmFyIHNsaWNlRm4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgZmlsZSBuYW1lIHBhcnQgZnJvbSBwYXRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdG8gZmlsZVxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRGaWxlTmFtZShwYXRoKSB7XG5cdFx0dmFyIHJlID0gLyhbXFx3XFwuXFwtXSspJC9pO1xuXHRcdHZhciBtID0gcmUuZXhlYyhwYXRoKTtcblx0XHRyZXR1cm4gbSA/IG1bMV0gOiAnJztcblx0fVxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemVzIHByb2ZpbGUgZGVmaW5pdGlvbjogY29udmVydHMgc29tZVxuXHQgKiBwcm9wZXJ0aWVzIHRvIHZhbGlkIGRhdGEgdHlwZXNcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb2ZpbGVcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKi9cblx0ZnVuY3Rpb24gbm9ybWFsaXplUHJvZmlsZShwcm9maWxlKSB7XG5cdFx0aWYgKHR5cGVvZiBwcm9maWxlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aWYgKCdpbmRlbnQnIGluIHByb2ZpbGUpIHtcblx0XHRcdFx0cHJvZmlsZS5pbmRlbnQgPSAhIXByb2ZpbGUuaW5kZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoJ3NlbGZfY2xvc2luZ190YWcnIGluIHByb2ZpbGUpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBwcm9maWxlLnNlbGZfY2xvc2luZ190YWcgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0cHJvZmlsZS5zZWxmX2Nsb3NpbmdfdGFnID0gISFwcm9maWxlLnNlbGZfY2xvc2luZ190YWc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvZmlsZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGVzc2VudGlhbCBmdW5jdGlvbiB0aGF0IGV4cGFuZHMgRW1tZXQgYWJicmV2aWF0aW9uXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFiYnIgQWJicmV2aWF0aW9uIHRvIHBhcnNlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN5bnRheCBBYmJyZXZpYXRpb24ncyBjb250ZXh0IHN5bnRheFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm9maWxlIE91dHB1dCBwcm9maWxlIChvciBpdHMgbmFtZSlcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dE5vZGUgQ29udGV4dHVhbCBub2RlIHdoZXJlIGFiYnJldmlhdGlvbiBpc1xuXHRcdCAqIHdyaXR0ZW5cblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0ZXhwYW5kQWJicmV2aWF0aW9uOiBmdW5jdGlvbihhYmJyLCBzeW50YXgsIHByb2ZpbGUsIGNvbnRleHROb2RlKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VyLmV4cGFuZChhYmJyLCB7XG5cdFx0XHRcdHN5bnRheDogc3ludGF4LFxuXHRcdFx0XHRwcm9maWxlOiBwcm9maWxlLFxuXHRcdFx0XHRjb250ZXh0Tm9kZTogY29udGV4dE5vZGVcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSdW5zIGdpdmVuIGFjdGlvblxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBBY3Rpb24gbmFtZVxuXHRcdCAqIEBwYXJhbSAge0lFbW1ldEVkaXRvcn0gZWRpdG9yIEVkaXRvciBpbnN0YW5jZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhY3Rpb24gd2FzIHBlcmZvcm1lZCBzdWNjZXNzZnVsbHlcblx0XHQgKi9cblx0XHRydW46IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiBhY3Rpb25zLnJ1bi5hcHBseShhY3Rpb25zLCBzbGljZUZuLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIExvYWRzIEVtbWV0IGV4dGVuc2lvbnMuIEV4dGVuc2lvbnMgYXJlIHNpbXBsZSAuanMgZmlsZXMgdGhhdFxuXHRcdCAqIHVzZXMgRW1tZXQgbW9kdWxlcyBhbmQgcmVzb3VyY2VzIHRvIGNyZWF0ZSBuZXcgYWN0aW9ucywgbW9kaWZ5XG5cdFx0ICogZXhpc3Rpbmcgb25lcyBldGMuXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gZmlsZUxpc3QgTGlzdCBvZiBhYnNvbHV0ZSBwYXRocyB0byBmaWxlcyBpbiBleHRlbnNpb25zXG5cdFx0ICogZm9sZGVyLiBCYWNrLWVuZCBhcHAgc2hvdWxkIG5vdCBmaWx0ZXIgdGhpcyBsaXN0IChlLmcuIGJ5IGV4dGVuc2lvbilcblx0XHQgKiBidXQgcmV0dXJuIGl0IFwiYXMtaXNcIiBzbyBib290c3RyYXAgY2FuIGRlY2lkZSBob3cgdG8gbG9hZCBjb250ZW50c1xuXHRcdCAqIG9mIGVhY2ggZmlsZS5cblx0XHQgKiBUaGlzIG1ldGhvZCByZXF1aXJlcyBhIDxjb2RlPmZpbGU8L2NvZGU+IG1vZHVsZSBvZiA8Y29kZT5JRW1tZXRGaWxlPC9jb2RlPlxuXHRcdCAqIGludGVyZmFjZSB0byBiZSBpbXBsZW1lbnRlZC5cblx0XHQgKiBAbWVtYmVyT2YgYm9vdHN0cmFwXG5cdFx0ICovXG5cdFx0bG9hZEV4dGVuc2lvbnM6IGZ1bmN0aW9uKGZpbGVMaXN0KSB7XG5cdFx0XHR2YXIgcGF5bG9hZCA9IHt9O1xuXHRcdFx0dmFyIHVzZXJTbmlwcGV0cyA9IG51bGw7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHRcdC8vIG1ha2Ugc3VyZSBmaWxlIGxpc3QgY29udGlhbnMgb25seSB2YWxpZCBleHRlbnNpb24gZmlsZXNcblx0XHRcdGZpbGVMaXN0ID0gZmlsZUxpc3QuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcblx0XHRcdFx0dmFyIGV4dCA9IGZpbGUuZ2V0RXh0KGYpO1xuXHRcdFx0XHRyZXR1cm4gZXh0ID09PSAnanNvbicgfHwgZXh0ID09PSAnanMnO1xuXHRcdFx0fSk7XG5cblx0XHRcdHZhciByZWFkZXIgPSAoZmlsZS5yZWFkVGV4dCB8fCBmaWxlLnJlYWQpLmJpbmQoZmlsZSk7XG5cdFx0XHR2YXIgbmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoZmlsZUxpc3QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGYgPSBmaWxlTGlzdC5zaGlmdCgpO1xuXHRcdFx0XHRcdHJlYWRlcihmLCBmdW5jdGlvbihlcnIsIGNvbnRlbnQpIHtcblx0XHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0bG9nZ2VyLmxvZygnVW5hYmxlIHRvIHJlYWQgXCInICsgZiArICdcIiBmaWxlOiAnKyBlcnIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV4dCgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKGZpbGUuZ2V0RXh0KGYpKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2pzJzpcblx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXZhbChjb250ZW50KTtcblx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsb2dnZXIubG9nKCdVbmFibGUgdG8gZXZhbCBcIicgKyBmICsgJ1wiIGZpbGU6ICcrIGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAnanNvbic6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGZpbGVOYW1lID0gZ2V0RmlsZU5hbWUoZikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC5qc29uJC8sICcnKTtcblx0XHRcdFx0XHRcdFx0XHRjb250ZW50ID0gdXRpbHMucGFyc2VKU09OKGNvbnRlbnQpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICgvXnNuaXBwZXRzLy50ZXN0KGZpbGVOYW1lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGZpbGVOYW1lID09PSAnc25pcHBldHMnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGRhdGEgaW4gc25pcHBldHMuanNvbiBpcyBtb3JlIGltcG9ydGFudCB0byB1c2VyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHVzZXJTbmlwcGV0cyA9IGNvbnRlbnQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXlsb2FkLnNuaXBwZXRzID0gdXRpbHMuZGVlcE1lcmdlKHBheWxvYWQuc25pcHBldHMgfHwge30sIGNvbnRlbnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXlsb2FkW2ZpbGVOYW1lXSA9IGNvbnRlbnQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG5leHQoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBjb21wbGV0ZVxuXHRcdFx0XHRcdGlmICh1c2VyU25pcHBldHMpIHtcblx0XHRcdFx0XHRcdHBheWxvYWQuc25pcHBldHMgPSB1dGlscy5kZWVwTWVyZ2UocGF5bG9hZC5zbmlwcGV0cyB8fCB7fSwgdXNlclNuaXBwZXRzKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGF0LmxvYWRVc2VyRGF0YShwYXlsb2FkKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bmV4dCgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBMb2FkcyBwcmVmZXJlbmNlcyBmcm9tIEpTT04gb2JqZWN0IChvciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgSlNPTilcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHRcdCAqIEByZXR1cm5zXG5cdFx0ICovXG5cdFx0bG9hZFByZWZlcmVuY2VzOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRwcmVmZXJlbmNlcy5sb2FkKHV0aWxzLnBhcnNlSlNPTihkYXRhKSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIExvYWRzIHVzZXIgc25pcHBldHMgYW5kIGFiYnJldmlhdGlvbnMuIEl0IGRvZXNu4oCZdCByZXBsYWNlIGN1cnJlbnRcblx0XHQgKiB1c2VyIHJlc291cmNlIHZvY2FidWxhcnkgYnV0IG1lcmdlcyBpdCB3aXRoIHBhc3NlZCBvbmUuIElmIHlvdSBuZWVkXG5cdFx0ICogdG8gPGk+cmVwbGFjZXM8L2k+IHVzZXIgc25pcHBldHMgeW91IHNob3VsZCBjYWxsXG5cdFx0ICogPGNvZGU+cmVzZXRTbmlwcGV0cygpPC9jb2RlPiBtZXRob2QgZmlyc3Rcblx0XHQgKi9cblx0XHRsb2FkU25pcHBldHM6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdGRhdGEgPSB1dGlscy5wYXJzZUpTT04oZGF0YSk7XG5cblx0XHRcdHZhciB1c2VyRGF0YSA9IHJlc291cmNlcy5nZXRWb2NhYnVsYXJ5KCd1c2VyJykgfHwge307XG5cdFx0XHRyZXNvdXJjZXMuc2V0Vm9jYWJ1bGFyeSh1dGlscy5kZWVwTWVyZ2UodXNlckRhdGEsIGRhdGEpLCAndXNlcicpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBsb2FkcyBkZWZhdWx0IHNuaXBwZXRzLCBkZWZpbmVkIGluIHByb2plY3TigJlzXG5cdFx0ICogPGk+c25pcHBldHMuanNvbjwvaT5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHRcdCAqL1xuXHRcdGxvYWRTeXN0ZW1TbmlwcGV0czogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0cmVzb3VyY2VzLnNldFZvY2FidWxhcnkodXRpbHMucGFyc2VKU09OKGRhdGEpLCAnc3lzdGVtJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGxvYWRzIENhbiBJIFVzZSBkYXRhYmFzZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdFx0ICovXG5cdFx0bG9hZENJVTogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0Y2l1LmxvYWQodXRpbHMucGFyc2VKU09OKGRhdGEpKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhbGwgdXNlci1kZWZpbmVkIHNuaXBwZXRzXG5cdFx0ICovXG5cdFx0cmVzZXRTbmlwcGV0czogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNvdXJjZXMuc2V0Vm9jYWJ1bGFyeSh7fSwgJ3VzZXInKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbG9hZHMgYWxsIHVzZXIgZGF0YSAoc25pcHBldHMgYW5kIHByZWZlcmVuY2VzKVxuXHRcdCAqIGRlZmluZWQgYXMgYSBzaW5nbGUgSlNPTiBvYmplY3QuIFRoaXMgaXMgdXNlZnVsIGZvciBsb2FkaW5nIGRhdGFcblx0XHQgKiBzdG9yZWQgaW4gYSBjb21tb24gc3RvcmFnZSwgZm9yIGV4YW1wbGUgPGNvZGU+TlNVc2VyRGVmYXVsdHM8L2NvZGU+XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0XHQgKi9cblx0XHRsb2FkVXNlckRhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdGRhdGEgPSB1dGlscy5wYXJzZUpTT04oZGF0YSk7XG5cdFx0XHRpZiAoZGF0YS5zbmlwcGV0cykge1xuXHRcdFx0XHR0aGlzLmxvYWRTbmlwcGV0cyhkYXRhLnNuaXBwZXRzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGEucHJlZmVyZW5jZXMpIHtcblx0XHRcdFx0dGhpcy5sb2FkUHJlZmVyZW5jZXMoZGF0YS5wcmVmZXJlbmNlcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhLnByb2ZpbGVzKSB7XG5cdFx0XHRcdHRoaXMubG9hZFByb2ZpbGVzKGRhdGEucHJvZmlsZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YS5jYW5pdXNlKSB7XG5cdFx0XHRcdHRoaXMubG9hZENJVShkYXRhLmNhbml1c2UpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcHJvZmlsZXMgPSBkYXRhLnN5bnRheFByb2ZpbGVzIHx8IGRhdGEuc3ludGF4cHJvZmlsZXM7XG5cdFx0XHRpZiAocHJvZmlsZXMpIHtcblx0XHRcdFx0dGhpcy5sb2FkU3ludGF4UHJvZmlsZXMocHJvZmlsZXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXNldHMgYWxsIHVzZXItZGVmaW5lZCBkYXRhOiBwcmVmZXJlbmNlcywgc25pcHBldHMgZXRjLlxuXHRcdCAqIEByZXR1cm5zXG5cdFx0ICovXG5cdFx0cmVzZXRVc2VyRGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlc2V0U25pcHBldHMoKTtcblx0XHRcdHByZWZlcmVuY2VzLnJlc2V0KCk7XG5cdFx0XHRwcm9maWxlLnJlc2V0KCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIExvYWQgc3ludGF4LXNwZWNpZmljIG91dHB1dCBwcm9maWxlcy4gVGhlc2UgYXJlIGVzc2VudGlhbGx5XG5cdFx0ICogYW4gZXh0ZW5zaW9uIHRvIHN5bnRheCBzbmlwcGV0c1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9maWxlcyBEaWN0aW9uYXJ5IG9mIHByb2ZpbGVzXG5cdFx0ICovXG5cdFx0bG9hZFN5bnRheFByb2ZpbGVzOiBmdW5jdGlvbihwcm9maWxlcykge1xuXHRcdFx0cHJvZmlsZXMgPSB1dGlscy5wYXJzZUpTT04ocHJvZmlsZXMpO1xuXHRcdFx0dmFyIHNuaXBwZXRzID0ge307XG5cdFx0XHRPYmplY3Qua2V5cyhwcm9maWxlcykuZm9yRWFjaChmdW5jdGlvbihzeW50YXgpIHtcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSBwcm9maWxlc1tzeW50YXhdO1xuXHRcdFx0XHRpZiAoIShzeW50YXggaW4gc25pcHBldHMpKSB7XG5cdFx0XHRcdFx0c25pcHBldHNbc3ludGF4XSA9IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNuaXBwZXRzW3N5bnRheF0ucHJvZmlsZSA9IG5vcm1hbGl6ZVByb2ZpbGUob3B0aW9ucyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5sb2FkU25pcHBldHMoc25pcHBldHMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBMb2FkIG5hbWVkIHByb2ZpbGVzXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHByb2ZpbGVzXG5cdFx0ICovXG5cdFx0bG9hZFByb2ZpbGVzOiBmdW5jdGlvbihwcm9maWxlcykge1xuXHRcdFx0cHJvZmlsZXMgPSB1dGlscy5wYXJzZUpTT04ocHJvZmlsZXMpO1xuXHRcdFx0T2JqZWN0LmtleXMocHJvZmlsZXMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRwcm9maWxlLmNyZWF0ZShuYW1lLCBub3JtYWxpemVQcm9maWxlKHByb2ZpbGVzW25hbWVdKSk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Ly8gZXhwb3NlIHNvbWUgdXNlZnVsIGRhdGEgZm9yIHBsdWdpbiBhdXRob3JzXG5cdFx0YWN0aW9uczogYWN0aW9ucyxcblx0XHRwYXJzZXI6IHBhcnNlcixcblx0XHRmaWxlOiBmaWxlLFxuXHRcdHByZWZlcmVuY2VzOiBwcmVmZXJlbmNlcyxcblx0XHRyZXNvdXJjZXM6IHJlc291cmNlcyxcblx0XHRwcm9maWxlOiBwcm9maWxlLFxuXHRcdHRhYlN0b3BzOiByZXF1aXJlKCcuL2Fzc2V0cy90YWJTdG9wcycpLFxuXHRcdGh0bWxNYXRjaGVyOiByZXF1aXJlKCcuL2Fzc2V0cy9odG1sTWF0Y2hlcicpLFxuXHRcdHV0aWxzOiB7XG5cdFx0XHRjb21tb246IHV0aWxzLFxuXHRcdFx0YWN0aW9uOiByZXF1aXJlKCcuL3V0aWxzL2FjdGlvbicpLFxuXHRcdFx0ZWRpdG9yOiByZXF1aXJlKCcuL3V0aWxzL2VkaXRvcicpXG5cdFx0fVxuXHR9O1xufSk7XG5cbn0se1wiLi9hY3Rpb24vbWFpblwiOlwiYWN0aW9uXFxcXG1haW4uanNcIixcIi4vYXNzZXRzL2Nhbml1c2VcIjpcImFzc2V0c1xcXFxjYW5pdXNlLmpzXCIsXCIuL2Fzc2V0cy9odG1sTWF0Y2hlclwiOlwiYXNzZXRzXFxcXGh0bWxNYXRjaGVyLmpzXCIsXCIuL2Fzc2V0cy9sb2dnZXJcIjpcImFzc2V0c1xcXFxsb2dnZXIuanNcIixcIi4vYXNzZXRzL3ByZWZlcmVuY2VzXCI6XCJhc3NldHNcXFxccHJlZmVyZW5jZXMuanNcIixcIi4vYXNzZXRzL3Byb2ZpbGVcIjpcImFzc2V0c1xcXFxwcm9maWxlLmpzXCIsXCIuL2Fzc2V0cy9yZXNvdXJjZXNcIjpcImFzc2V0c1xcXFxyZXNvdXJjZXMuanNcIixcIi4vYXNzZXRzL3RhYlN0b3BzXCI6XCJhc3NldHNcXFxcdGFiU3RvcHMuanNcIixcIi4vcGFyc2VyL2FiYnJldmlhdGlvblwiOlwicGFyc2VyXFxcXGFiYnJldmlhdGlvbi5qc1wiLFwiLi9wbHVnaW4vZmlsZVwiOlwicGx1Z2luXFxcXGZpbGUuanNcIixcIi4vdXRpbHMvYWN0aW9uXCI6XCJ1dGlsc1xcXFxhY3Rpb24uanNcIixcIi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4vdXRpbHMvZWRpdG9yXCI6XCJ1dGlsc1xcXFxlZGl0b3IuanNcIn1dLFwiYWN0aW9uXFxcXGJhbGFuY2UuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEhUTUwgcGFpciBtYXRjaGluZyAoYmFsYW5jaW5nKSBhY3Rpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIGh0bWxNYXRjaGVyID0gcmVxdWlyZSgnLi4vYXNzZXRzL2h0bWxNYXRjaGVyJyk7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgZWRpdG9yVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9lZGl0b3InKTtcblx0dmFyIGFjdGlvblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvYWN0aW9uJyk7XG5cdHZhciByYW5nZSA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9yYW5nZScpO1xuXHR2YXIgY3NzRWRpdFRyZWUgPSByZXF1aXJlKCcuLi9lZGl0VHJlZS9jc3MnKTtcblx0dmFyIGNzc1NlY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbHMvY3NzU2VjdGlvbnMnKTtcblx0dmFyIGxhc3RNYXRjaCA9IG51bGw7XG5cblx0ZnVuY3Rpb24gbGFzdChhcnIpIHtcblx0XHRyZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGJhbGFuY2VIVE1MKGVkaXRvciwgZGlyZWN0aW9uKSB7XG5cdFx0dmFyIGluZm8gPSBlZGl0b3JVdGlscy5vdXRwdXRJbmZvKGVkaXRvcik7XG5cdFx0dmFyIGNvbnRlbnQgPSBpbmZvLmNvbnRlbnQ7XG5cdFx0dmFyIHNlbCA9IHJhbmdlKGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcblx0XHRcblx0XHQvLyB2YWxpZGF0ZSBwcmV2aW91cyBtYXRjaFxuXHRcdGlmIChsYXN0TWF0Y2ggJiYgIWxhc3RNYXRjaC5yYW5nZS5lcXVhbChzZWwpKSB7XG5cdFx0XHRsYXN0TWF0Y2ggPSBudWxsO1xuXHRcdH1cblx0XHRcblx0XHRpZiAobGFzdE1hdGNoICYmIHNlbC5sZW5ndGgoKSkge1xuXHRcdFx0aWYgKGRpcmVjdGlvbiA9PSAnaW4nKSB7XG5cdFx0XHRcdC8vIHVzZXIgaGFzIHByZXZpb3VzbHkgc2VsZWN0ZWQgdGFnIGFuZCB3YW50cyB0byBtb3ZlIGlud2FyZFxuXHRcdFx0XHRpZiAobGFzdE1hdGNoLnR5cGUgPT0gJ3RhZycgJiYgIWxhc3RNYXRjaC5jbG9zZSkge1xuXHRcdFx0XHRcdC8vIHVuYXJ5IHRhZyB3YXMgc2VsZWN0ZWQsIGNhbid0IG1vdmUgaW53YXJkXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChsYXN0TWF0Y2gucmFuZ2UuZXF1YWwobGFzdE1hdGNoLm91dGVyUmFuZ2UpKSB7XG5cdFx0XHRcdFx0XHRsYXN0TWF0Y2gucmFuZ2UgPSBsYXN0TWF0Y2guaW5uZXJSYW5nZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIG5hcnJvd2VkID0gdXRpbHMubmFycm93VG9Ob25TcGFjZShjb250ZW50LCBsYXN0TWF0Y2guaW5uZXJSYW5nZSk7XG5cdFx0XHRcdFx0XHRsYXN0TWF0Y2ggPSBodG1sTWF0Y2hlci5maW5kKGNvbnRlbnQsIG5hcnJvd2VkLnN0YXJ0ICsgMSk7XG5cdFx0XHRcdFx0XHRpZiAobGFzdE1hdGNoICYmIGxhc3RNYXRjaC5yYW5nZS5lcXVhbChzZWwpICYmIGxhc3RNYXRjaC5vdXRlclJhbmdlLmVxdWFsKHNlbCkpIHtcblx0XHRcdFx0XHRcdFx0bGFzdE1hdGNoLnJhbmdlID0gbGFzdE1hdGNoLmlubmVyUmFuZ2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0IWxhc3RNYXRjaC5pbm5lclJhbmdlLmVxdWFsKGxhc3RNYXRjaC5vdXRlclJhbmdlKSBcblx0XHRcdFx0XHQmJiBsYXN0TWF0Y2gucmFuZ2UuZXF1YWwobGFzdE1hdGNoLmlubmVyUmFuZ2UpIFxuXHRcdFx0XHRcdCYmIHNlbC5lcXVhbChsYXN0TWF0Y2gucmFuZ2UpKSB7XG5cdFx0XHRcdFx0bGFzdE1hdGNoLnJhbmdlID0gbGFzdE1hdGNoLm91dGVyUmFuZ2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGFzdE1hdGNoID0gaHRtbE1hdGNoZXIuZmluZChjb250ZW50LCBzZWwuc3RhcnQpO1xuXHRcdFx0XHRcdGlmIChsYXN0TWF0Y2ggJiYgbGFzdE1hdGNoLnJhbmdlLmVxdWFsKHNlbCkgJiYgbGFzdE1hdGNoLmlubmVyUmFuZ2UuZXF1YWwoc2VsKSkge1xuXHRcdFx0XHRcdFx0bGFzdE1hdGNoLnJhbmdlID0gbGFzdE1hdGNoLm91dGVyUmFuZ2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxhc3RNYXRjaCA9IGh0bWxNYXRjaGVyLmZpbmQoY29udGVudCwgc2VsLnN0YXJ0KTtcblx0XHR9XG5cblx0XHRpZiAobGFzdE1hdGNoKSB7XG5cdFx0XHRpZiAobGFzdE1hdGNoLmlubmVyUmFuZ2UuZXF1YWwoc2VsKSkge1xuXHRcdFx0XHRsYXN0TWF0Y2gucmFuZ2UgPSBsYXN0TWF0Y2gub3V0ZXJSYW5nZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFsYXN0TWF0Y2gucmFuZ2UuZXF1YWwoc2VsKSkge1xuXHRcdFx0XHRlZGl0b3IuY3JlYXRlU2VsZWN0aW9uKGxhc3RNYXRjaC5yYW5nZS5zdGFydCwgbGFzdE1hdGNoLnJhbmdlLmVuZCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRsYXN0TWF0Y2ggPSBudWxsO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJhbmdlc0ZvckNTU1J1bGUocnVsZSwgcG9zKSB7XG5cdFx0Ly8gZmluZCBhbGwgcG9zc2libGUgcmFuZ2VzXG5cdFx0dmFyIHJhbmdlcyA9IFtydWxlLnJhbmdlKHRydWUpXTtcblxuXHRcdC8vIGJyYWNlcyBjb250ZW50XG5cdFx0cmFuZ2VzLnB1c2gocnVsZS52YWx1ZVJhbmdlKHRydWUpKTtcblxuXHRcdC8vIGZpbmQgbmVzdGVkIHNlY3Rpb25zXG5cdFx0dmFyIG5lc3RlZFNlY3Rpb25zID0gY3NzU2VjdGlvbnMubmVzdGVkU2VjdGlvbnNJblJ1bGUocnVsZSk7XG5cblx0XHQvLyByZWFsIGNvbnRlbnQsIGUuZy4gZnJvbSBmaXJzdCBwcm9wZXJ0eSBuYW1lIHRvXG5cdFx0Ly8gbGFzdCBwcm9wZXJ0eSB2YWx1ZVxuXHRcdHZhciBpdGVtcyA9IHJ1bGUubGlzdCgpO1xuXHRcdGlmIChpdGVtcy5sZW5ndGggfHwgbmVzdGVkU2VjdGlvbnMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIGVuZCA9IC0xO1xuXHRcdFx0aWYgKGl0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRzdGFydCA9IGl0ZW1zWzBdLm5hbWVQb3NpdGlvbih0cnVlKTtcblx0XHRcdFx0ZW5kID0gbGFzdChpdGVtcykucmFuZ2UodHJ1ZSkuZW5kO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmVzdGVkU2VjdGlvbnMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmIChuZXN0ZWRTZWN0aW9uc1swXS5zdGFydCA8IHN0YXJ0KSB7XG5cdFx0XHRcdFx0c3RhcnQgPSBuZXN0ZWRTZWN0aW9uc1swXS5zdGFydDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChsYXN0KG5lc3RlZFNlY3Rpb25zKS5lbmQgPiBlbmQpIHtcblx0XHRcdFx0XHRlbmQgPSBsYXN0KG5lc3RlZFNlY3Rpb25zKS5lbmQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmFuZ2VzLnB1c2gocmFuZ2UuY3JlYXRlMihzdGFydCwgZW5kKSk7XG5cdFx0fVxuXG5cdFx0cmFuZ2VzID0gcmFuZ2VzLmNvbmNhdChuZXN0ZWRTZWN0aW9ucyk7XG5cblx0XHR2YXIgcHJvcCA9IGNzc0VkaXRUcmVlLnByb3BlcnR5RnJvbVBvc2l0aW9uKHJ1bGUsIHBvcykgfHwgaXRlbXNbMF07XG5cdFx0aWYgKHByb3ApIHtcblx0XHRcdHJhbmdlcy5wdXNoKHByb3AucmFuZ2UodHJ1ZSkpO1xuXHRcdFx0dmFyIHZhbHVlUmFuZ2UgPSBwcm9wLnZhbHVlUmFuZ2UodHJ1ZSk7XG5cdFx0XHRpZiAoIXByb3AuZW5kKCkpIHtcblx0XHRcdFx0dmFsdWVSYW5nZS5fdW50ZXJtaW5hdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJhbmdlcy5wdXNoKHZhbHVlUmFuZ2UpO1xuXHRcdH1cblxuXHRcdHJldHVybiByYW5nZXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbGwgcG9zc2libGUgc2VsZWN0aW9uIHJhbmdlcyBmb3IgZ2l2ZW4gY2FyZXQgcG9zaXRpb25cblx0ICogQHBhcmFtICB7U3RyaW5nfSBjb250ZW50IENTUyBjb250ZW50XG5cdCAqIEBwYXJhbSAge051bWJlcn0gcG9zICAgICBDYXJldCBwb3NpdGlvbih3aGVyZSB0byBzdGFydCBzZWFyY2hpbmcpXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0Q1NTUmFuZ2VzKGNvbnRlbnQsIHBvcykge1xuXHRcdHZhciBydWxlO1xuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhciBydWxlUmFuZ2UgPSBjc3NTZWN0aW9ucy5tYXRjaEVuY2xvc2luZ1J1bGUoY29udGVudCwgcG9zKTtcblx0XHRcdGlmIChydWxlUmFuZ2UpIHtcblx0XHRcdFx0cnVsZSA9IGNzc0VkaXRUcmVlLnBhcnNlKHJ1bGVSYW5nZS5zdWJzdHJpbmcoY29udGVudCksIHtcblx0XHRcdFx0XHRvZmZzZXQ6IHJ1bGVSYW5nZS5zdGFydFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGFzc2VkIHBhcnNlZCBDU1MgcnVsZVxuXHRcdFx0cnVsZSA9IGNvbnRlbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCFydWxlKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBmaW5kIGFsbCBwb3NzaWJsZSByYW5nZXNcblx0XHR2YXIgcmFuZ2VzID0gcmFuZ2VzRm9yQ1NTUnVsZShydWxlLCBwb3MpO1xuXG5cdFx0Ly8gcmVtb3ZlIGVtcHR5IHJhbmdlc1xuXHRcdHJhbmdlcyA9IHJhbmdlcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuICEhaXRlbS5sZW5ndGg7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdXRpbHMudW5pcXVlKHJhbmdlcywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuIGl0ZW0udmFsdWVPZigpO1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gYmFsYW5jZUNTUyhlZGl0b3IsIGRpcmVjdGlvbikge1xuXHRcdHZhciBpbmZvID0gZWRpdG9yVXRpbHMub3V0cHV0SW5mbyhlZGl0b3IpO1xuXHRcdHZhciBjb250ZW50ID0gaW5mby5jb250ZW50O1xuXHRcdHZhciBzZWwgPSByYW5nZShlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XG5cblx0XHR2YXIgcmFuZ2VzID0gZ2V0Q1NTUmFuZ2VzKGluZm8uY29udGVudCwgc2VsLnN0YXJ0KTtcblx0XHRpZiAoIXJhbmdlcyAmJiBzZWwubGVuZ3RoKCkpIHtcblx0XHRcdC8vIHBvc3NpYmxlIHJlYXNvbjogdXNlciBoYXMgYWxyZWFkeSBzZWxlY3RlZFxuXHRcdFx0Ly8gQ1NTIHJ1bGUgZnJvbSBsYXN0IG1hdGNoXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgcnVsZSA9IGNzc0VkaXRUcmVlLnBhcnNlKHNlbC5zdWJzdHJpbmcoaW5mby5jb250ZW50KSwge1xuXHRcdFx0XHRcdG9mZnNldDogc2VsLnN0YXJ0XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyYW5nZXMgPSBnZXRDU1NSYW5nZXMocnVsZSwgc2VsLnN0YXJ0KTtcblx0XHRcdH0gY2F0Y2goZSkge31cblx0XHR9XG5cblx0XHRpZiAoIXJhbmdlcykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJhbmdlcyA9IHJhbmdlLnNvcnQocmFuZ2VzLCB0cnVlKTtcblxuXHRcdC8vIGVkZ2UgY2FzZTogZmluZCBtYXRjaCB0aGF0IGVxdWFscyBjdXJyZW50IHNlbGVjdGlvbixcblx0XHQvLyBpbiBjYXNlIGlmIHVzZXIgbW92ZXMgaW53YXJkIGFmdGVyIHNlbGVjdGluZyBmdWxsIENTUyBydWxlXG5cdFx0dmFyIGJlc3RNYXRjaCA9IHV0aWxzLmZpbmQocmFuZ2VzLCBmdW5jdGlvbihyKSB7XG5cdFx0XHRyZXR1cm4gci5lcXVhbChzZWwpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKCFiZXN0TWF0Y2gpIHtcblx0XHRcdGJlc3RNYXRjaCA9IHV0aWxzLmZpbmQocmFuZ2VzLCBmdW5jdGlvbihyKSB7XG5cdFx0XHRcdC8vIENoZWNrIGZvciBlZGdlIGNhc2U6IGNhcmV0IHJpZ2h0IGFmdGVyIENTUyB2YWx1ZVxuXHRcdFx0XHQvLyBidXQgaXQgZG9lc27igJh0IGNvbnRhaW5zIHRlcm1pbmF0aW5nIHNlbWljb2xvbi5cblx0XHRcdFx0Ly8gSW4gdGhpcyBjYXNlIHdlIGhhdmUgdG8gY2hlY2sgZnVsbCB2YWx1ZSByYW5nZVxuXHRcdFx0XHRyZXR1cm4gci5fdW50ZXJtaW5hdGVkID8gci5pbmNsdWRlKHNlbC5zdGFydCkgOiByLmluc2lkZShzZWwuc3RhcnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFiZXN0TWF0Y2gpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBpZiBiZXN0IG1hdGNoIGVxdWFscyB0byBjdXJyZW50IHNlbGVjdGlvbiwgbW92ZSBpbmRleFxuXHRcdC8vIG9uZSBwb3NpdGlvbiB1cCBvciBkb3duLCBkZXBlbmRpbmcgb24gZGlyZWN0aW9uXG5cdFx0dmFyIGJlc3RNYXRjaEl4ID0gcmFuZ2VzLmluZGV4T2YoYmVzdE1hdGNoKTtcblx0XHRpZiAoYmVzdE1hdGNoLmVxdWFsKHNlbCkpIHtcblx0XHRcdGJlc3RNYXRjaEl4ICs9IGRpcmVjdGlvbiA9PSAnb3V0JyA/IDEgOiAtMTtcblx0XHR9XG5cblx0XHRpZiAoYmVzdE1hdGNoSXggPCAwIHx8IGJlc3RNYXRjaEl4ID49IHJhbmdlcy5sZW5ndGgpIHtcblx0XHRcdGlmIChiZXN0TWF0Y2hJeCA+PSByYW5nZXMubGVuZ3RoICYmIGRpcmVjdGlvbiA9PSAnb3V0Jykge1xuXHRcdFx0XHRwb3MgPSBiZXN0TWF0Y2guc3RhcnQgLSAxO1xuXG5cdFx0XHRcdHZhciBvdXRlclJhbmdlcyA9IGdldENTU1Jhbmdlcyhjb250ZW50LCBwb3MpO1xuXHRcdFx0XHRpZiAob3V0ZXJSYW5nZXMpIHtcblx0XHRcdFx0XHRiZXN0TWF0Y2ggPSBsYXN0KG91dGVyUmFuZ2VzLmZpbHRlcihmdW5jdGlvbihyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gci5pbnNpZGUocG9zKTtcblx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYmVzdE1hdGNoSXggPCAwICYmIGRpcmVjdGlvbiA9PSAnaW4nKSB7XG5cdFx0XHRcdGJlc3RNYXRjaCA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRiZXN0TWF0Y2ggPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRiZXN0TWF0Y2ggPSByYW5nZXNbYmVzdE1hdGNoSXhdO1x0XG5cdFx0fVxuXG5cdFx0aWYgKGJlc3RNYXRjaCkge1xuXHRcdFx0ZWRpdG9yLmNyZWF0ZVNlbGVjdGlvbihiZXN0TWF0Y2guc3RhcnQsIGJlc3RNYXRjaC5lbmQpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBGaW5kIGFuZCBzZWxlY3QgSFRNTCB0YWcgcGFpclxuXHRcdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3IgRWRpdG9yIGluc3RhbmNlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiBEaXJlY3Rpb24gb2YgcGFpciBtYXRjaGluZzogJ2luJyBvciAnb3V0Jy4gXG5cdFx0ICogRGVmYXVsdCBpcyAnb3V0J1xuXHRcdCAqL1xuXHRcdGJhbGFuY2U6IGZ1bmN0aW9uKGVkaXRvciwgZGlyZWN0aW9uKSB7XG5cdFx0XHRkaXJlY3Rpb24gPSBTdHJpbmcoKGRpcmVjdGlvbiB8fCAnb3V0JykudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHR2YXIgaW5mbyA9IGVkaXRvclV0aWxzLm91dHB1dEluZm8oZWRpdG9yKTtcblx0XHRcdGlmIChhY3Rpb25VdGlscy5pc1N1cHBvcnRlZENTUyhpbmZvLnN5bnRheCkpIHtcblx0XHRcdFx0cmV0dXJuIGJhbGFuY2VDU1MoZWRpdG9yLCBkaXJlY3Rpb24pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gYmFsYW5jZUhUTUwoZWRpdG9yLCBkaXJlY3Rpb24pO1xuXHRcdH0sXG5cblx0XHRiYWxhbmNlSW53YXJkQWN0aW9uOiBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRcdHJldHVybiB0aGlzLmJhbGFuY2UoZWRpdG9yLCAnaW4nKTtcblx0XHR9LFxuXG5cdFx0YmFsYW5jZU91dHdhcmRBY3Rpb246IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYmFsYW5jZShlZGl0b3IsICdvdXQnKTtcdFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBNb3ZlcyBjYXJldCB0byBtYXRjaGluZyBvcGVuaW5nIG9yIGNsb3NpbmcgdGFnXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHRcdCAqL1xuXHRcdGdvVG9NYXRjaGluZ1BhaXJBY3Rpb246IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBTdHJpbmcoZWRpdG9yLmdldENvbnRlbnQoKSk7XG5cdFx0XHR2YXIgY2FyZXRQb3MgPSBlZGl0b3IuZ2V0Q2FyZXRQb3MoKTtcblx0XHRcdFxuXHRcdFx0aWYgKGNvbnRlbnQuY2hhckF0KGNhcmV0UG9zKSA9PSAnPCcpIFxuXHRcdFx0XHQvLyBsb29rcyBsaWtlIGNhcmV0IGlzIG91dHNpZGUgb2YgdGFnIHBhaXIgIFxuXHRcdFx0XHRjYXJldFBvcysrO1xuXHRcdFx0XHRcblx0XHRcdHZhciB0YWcgPSBodG1sTWF0Y2hlci50YWcoY29udGVudCwgY2FyZXRQb3MpO1xuXHRcdFx0aWYgKHRhZyAmJiB0YWcuY2xvc2UpIHsgLy8gZXhjbHVkZSB1bmFyeSB0YWdzXG5cdFx0XHRcdGlmICh0YWcub3Blbi5yYW5nZS5pbnNpZGUoY2FyZXRQb3MpKSB7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldENhcmV0UG9zKHRhZy5jbG9zZS5yYW5nZS5zdGFydCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldENhcmV0UG9zKHRhZy5vcGVuLnJhbmdlLnN0YXJ0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vYXNzZXRzL2h0bWxNYXRjaGVyXCI6XCJhc3NldHNcXFxcaHRtbE1hdGNoZXIuanNcIixcIi4uL2Fzc2V0cy9yYW5nZVwiOlwiYXNzZXRzXFxcXHJhbmdlLmpzXCIsXCIuLi9lZGl0VHJlZS9jc3NcIjpcImVkaXRUcmVlXFxcXGNzcy5qc1wiLFwiLi4vdXRpbHMvYWN0aW9uXCI6XCJ1dGlsc1xcXFxhY3Rpb24uanNcIixcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCIsXCIuLi91dGlscy9jc3NTZWN0aW9uc1wiOlwidXRpbHNcXFxcY3NzU2VjdGlvbnMuanNcIixcIi4uL3V0aWxzL2VkaXRvclwiOlwidXRpbHNcXFxcZWRpdG9yLmpzXCJ9XSxcImFjdGlvblxcXFxiYXNlNjQuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEVuY29kZXMvZGVjb2RlcyBpbWFnZSB1bmRlciBjdXJzb3IgdG8vZnJvbSBiYXNlNjRcbiAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3JcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIGZpbGUgPSByZXF1aXJlKCcuLi9wbHVnaW4vZmlsZScpO1xuXHR2YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi4vdXRpbHMvYmFzZTY0Jyk7XG5cdHZhciBhY3Rpb25VdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2FjdGlvbicpO1xuXHR2YXIgZWRpdG9yVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9lZGl0b3InKTtcblxuXHQvKipcblx0ICogVGVzdCBpZiA8Y29kZT50ZXh0PC9jb2RlPiBzdGFydHMgd2l0aCA8Y29kZT50b2tlbjwvY29kZT4gYXQgPGNvZGU+cG9zPC9jb2RlPlxuXHQgKiBwb3NpdGlvbi4gSWYgPGNvZGU+cG9zPC9jb2RlPiBpcyBvbWl0dGVkLCBzZWFyY2ggZnJvbSBiZWdpbm5pbmcgb2YgdGV4dCBcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIFRva2VuIHRvIHRlc3Rcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgV2hlcmUgdG8gc2VhcmNoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgUG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgc2VhcmNoXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBzaW5jZSAwLjY1XG5cdCAqL1xuXHRmdW5jdGlvbiBzdGFydHNXaXRoKHRva2VuLCB0ZXh0LCBwb3MpIHtcblx0XHRwb3MgPSBwb3MgfHwgMDtcblx0XHRyZXR1cm4gdGV4dC5jaGFyQXQocG9zKSA9PSB0b2tlbi5jaGFyQXQoMCkgJiYgdGV4dC5zdWJzdHIocG9zLCB0b2tlbi5sZW5ndGgpID09IHRva2VuO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgaW1hZ2UgdG8gYmFzZTY0XG5cdCAqIFxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbWdQYXRoIFBhdGggdG8gaW1hZ2Vcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvcyBDYXJldCBwb3NpdGlvbiB3aGVyZSBpbWFnZSBpcyBsb2NhdGVkIGluIHRoZSBlZGl0b3Jcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZVRvQmFzZTY0KGVkaXRvciwgaW1nUGF0aCwgcG9zKSB7XG5cdFx0dmFyIGVkaXRvckZpbGUgPSBlZGl0b3IuZ2V0RmlsZVBhdGgoKTtcblx0XHR2YXIgZGVmYXVsdE1pbWVUeXBlID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG5cblx0XHRpZiAoZWRpdG9yRmlsZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgXCJZb3Ugc2hvdWxkIHNhdmUgeW91ciBmaWxlIGJlZm9yZSB1c2luZyB0aGlzIGFjdGlvblwiO1xuXHRcdH1cblxuXHRcdC8vIGxvY2F0ZSByZWFsIGltYWdlIHBhdGhcblx0XHRmaWxlLmxvY2F0ZUZpbGUoZWRpdG9yRmlsZSwgaW1nUGF0aCwgZnVuY3Rpb24ocmVhbEltZ1BhdGgpIHtcblx0XHRcdGlmIChyZWFsSW1nUGF0aCA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aHJvdyBcIkNhbid0IGZpbmQgXCIgKyBpbWdQYXRoICsgJyBmaWxlJztcblx0XHRcdH1cblxuXHRcdFx0ZmlsZS5yZWFkKHJlYWxJbWdQYXRoLCBmdW5jdGlvbihlcnIsIGNvbnRlbnQpIHtcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdHRocm93ICdVbmFibGUgdG8gcmVhZCAnICsgcmVhbEltZ1BhdGggKyAnOiAnICsgZXJyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGI2NCA9IGJhc2U2NC5lbmNvZGUoU3RyaW5nKGNvbnRlbnQpKTtcblx0XHRcdFx0aWYgKCFiNjQpIHtcblx0XHRcdFx0XHR0aHJvdyBcIkNhbid0IGVuY29kZSBmaWxlIGNvbnRlbnQgdG8gYmFzZTY0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiNjQgPSAnZGF0YTonICsgKGFjdGlvblV0aWxzLm1pbWVUeXBlc1tTdHJpbmcoZmlsZS5nZXRFeHQocmVhbEltZ1BhdGgpKV0gfHwgZGVmYXVsdE1pbWVUeXBlKSArXG5cdFx0XHRcdFx0JztiYXNlNjQsJyArIGI2NDtcblxuXHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQoJyQwJyArIGI2NCwgcG9zLCBwb3MgKyBpbWdQYXRoLmxlbmd0aCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29kZXMgYmFzZTY0IHN0cmluZyBiYWNrIHRvIGZpbGUuXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IGZpbGVQYXRoIHRvIG5ldyBpbWFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBCYXNlNjQtZW5jb2RlZCBmaWxlIGNvbnRlbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvcyBDYXJldCBwb3NpdGlvbiB3aGVyZSBpbWFnZSBpcyBsb2NhdGVkIGluIHRoZSBlZGl0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZUZyb21CYXNlNjQoZWRpdG9yLCBmaWxlUGF0aCwgZGF0YSwgcG9zKSB7XG5cdFx0Ly8gYXNrIHVzZXIgdG8gZW50ZXIgcGF0aCB0byBmaWxlXG5cdFx0ZmlsZVBhdGggPSBmaWxlUGF0aCB8fCBTdHJpbmcoZWRpdG9yLnByb21wdCgnRW50ZXIgcGF0aCB0byBmaWxlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSknKSk7XG5cdFx0aWYgKCFmaWxlUGF0aCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBlZGl0b3JGaWxlID0gZWRpdG9yLmdldEZpbGVQYXRoKCk7XG5cdFx0ZmlsZS5jcmVhdGVQYXRoKGVkaXRvckZpbGUsIGZpbGVQYXRoLCBmdW5jdGlvbihlcnIsIGFic1BhdGgpIHtcblx0XHRcdGlmIChlcnIgfHwgIWFic1BhdGgpIHtcblx0XHRcdFx0dGhyb3cgXCJDYW4ndCBzYXZlIGZpbGVcIjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvbnRlbnQgPSBkYXRhLnJlcGxhY2UoL15kYXRhXFw6Lis/Oy4rPywvLCAnJyk7XG5cdFx0XHRmaWxlLnNhdmUoYWJzUGF0aCwgYmFzZTY0LmRlY29kZShjb250ZW50KSwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHR0aHJvdyAnVW5hYmxlIHRvIHNhdmUgJyArIGFic1BhdGggKyAnOiAnICsgZXJyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KCckMCcgKyBmaWxlUGF0aCwgcG9zLCBwb3MgKyBkYXRhLmxlbmd0aCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBBY3Rpb24gdG8gZW5jb2RlIG9yIGRlY29kZSBmaWxlIHRvIGRhdGE6dXJsXG5cdFx0ICogQHBhcmFtICB7SUVtbWV0RWRpdG9yfSBlZGl0b3IgIEVkaXRvciBpbnN0YW5jZVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gc3ludGF4ICBDdXJyZW50IGRvY3VtZW50IHN5bnRheFxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gcHJvZmlsZSBPdXRwdXQgcHJvZmlsZSBuYW1lXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRlbmNvZGVEZWNvZGVEYXRhVXJsQWN0aW9uOiBmdW5jdGlvbihlZGl0b3IsIGZpbGVwYXRoKSB7XG5cdFx0XHR2YXIgZGF0YSA9IFN0cmluZyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpO1xuXHRcdFx0dmFyIGNhcmV0UG9zID0gZWRpdG9yLmdldENhcmV0UG9zKCk7XG5cdFx0XHR2YXIgaW5mbyA9IGVkaXRvclV0aWxzLm91dHB1dEluZm8oZWRpdG9yKTtcblxuXHRcdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRcdC8vIG5vIHNlbGVjdGlvbiwgdHJ5IHRvIGZpbmQgaW1hZ2UgYm91bmRzIGZyb20gY3VycmVudCBjYXJldCBwb3NpdGlvblxuXHRcdFx0XHR2YXIgdGV4dCA9IGluZm8uY29udGVudCwgbTtcblx0XHRcdFx0d2hpbGUgKGNhcmV0UG9zLS0gPj0gMCkge1xuXHRcdFx0XHRcdGlmIChzdGFydHNXaXRoKCdzcmM9JywgdGV4dCwgY2FyZXRQb3MpKSB7IC8vIGZvdW5kIDxpbWcgc3JjPVwiXCI+XG5cdFx0XHRcdFx0XHRpZiAoKG0gPSB0ZXh0LnN1YnN0cihjYXJldFBvcykubWF0Y2goL14oc3JjPShbXCInXSk/KShbXidcIjw+XFxzXSspXFwxPy8pKSkge1xuXHRcdFx0XHRcdFx0XHRkYXRhID0gbVszXTtcblx0XHRcdFx0XHRcdFx0Y2FyZXRQb3MgKz0gbVsxXS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0YXJ0c1dpdGgoJ3VybCgnLCB0ZXh0LCBjYXJldFBvcykpIHsgLy8gZm91bmQgQ1NTIHVybCgpIHBhdHRlcm5cblx0XHRcdFx0XHRcdGlmICgobSA9IHRleHQuc3Vic3RyKGNhcmV0UG9zKS5tYXRjaCgvXih1cmxcXCgoWydcIl0pPykoW14nXCJcXClcXHNdKylcXDE/LykpKSB7XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBtWzNdO1xuXHRcdFx0XHRcdFx0XHRjYXJldFBvcyArPSBtWzFdLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRpZiAoc3RhcnRzV2l0aCgnZGF0YTonLCBkYXRhKSkge1xuXHRcdFx0XHRcdHJldHVybiBkZWNvZGVGcm9tQmFzZTY0KGVkaXRvciwgZmlsZXBhdGgsIGRhdGEsIGNhcmV0UG9zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5jb2RlVG9CYXNlNjQoZWRpdG9yLCBkYXRhLCBjYXJldFBvcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcbn0pO1xuXG59LHtcIi4uL3BsdWdpbi9maWxlXCI6XCJwbHVnaW5cXFxcZmlsZS5qc1wiLFwiLi4vdXRpbHMvYWN0aW9uXCI6XCJ1dGlsc1xcXFxhY3Rpb24uanNcIixcIi4uL3V0aWxzL2Jhc2U2NFwiOlwidXRpbHNcXFxcYmFzZTY0LmpzXCIsXCIuLi91dGlscy9lZGl0b3JcIjpcInV0aWxzXFxcXGVkaXRvci5qc1wifV0sXCJhY3Rpb25cXFxcZWRpdFBvaW50cy5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogTW92ZSBiZXR3ZWVuIG5leHQvcHJldiBlZGl0IHBvaW50cy4gJ0VkaXQgcG9pbnRzJyBhcmUgcGxhY2VzIGJldHdlZW4gdGFncyBcbiAqIGFuZCBxdW90ZXMgb2YgZW1wdHkgYXR0cmlidXRlcyBpbiBodG1sXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdC8qKlxuXHQgKiBTZWFyY2ggZm9yIG5ldyBjYXJldCBpbnNlcnRpb24gcG9pbnRcblx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvciBFZGl0b3IgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluYyBTZWFyY2ggaW5jcmVtZW50OiAtMSDigJQgc2VhcmNoIGxlZnQsIDEg4oCUIHNlYXJjaCByaWdodFxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IEluaXRpYWwgb2Zmc2V0IHJlbGF0aXZlIHRvIGN1cnJlbnQgY2FyZXQgcG9zaXRpb25cblx0ICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIC0xIGlmIGluc2VydGlvbiBwb2ludCB3YXNuJ3QgZm91bmRcblx0ICovXG5cdGZ1bmN0aW9uIGZpbmROZXdFZGl0UG9pbnQoZWRpdG9yLCBpbmMsIG9mZnNldCkge1xuXHRcdGluYyA9IGluYyB8fCAxO1xuXHRcdG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXHRcdFxuXHRcdHZhciBjdXJQb2ludCA9IGVkaXRvci5nZXRDYXJldFBvcygpICsgb2Zmc2V0O1xuXHRcdHZhciBjb250ZW50ID0gU3RyaW5nKGVkaXRvci5nZXRDb250ZW50KCkpO1xuXHRcdHZhciBtYXhMZW4gPSBjb250ZW50Lmxlbmd0aDtcblx0XHR2YXIgbmV4dFBvaW50ID0gLTE7XG5cdFx0dmFyIHJlRW1wdHlMaW5lID0gL15cXHMrJC87XG5cdFx0XG5cdFx0ZnVuY3Rpb24gZ2V0TGluZShpeCkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gaXg7XG5cdFx0XHR3aGlsZSAoc3RhcnQgPj0gMCkge1xuXHRcdFx0XHR2YXIgYyA9IGNvbnRlbnQuY2hhckF0KHN0YXJ0KTtcblx0XHRcdFx0aWYgKGMgPT0gJ1xcbicgfHwgYyA9PSAnXFxyJylcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0c3RhcnQtLTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0LCBpeCk7XG5cdFx0fVxuXHRcdFx0XG5cdFx0d2hpbGUgKGN1clBvaW50IDw9IG1heExlbiAmJiBjdXJQb2ludCA+PSAwKSB7XG5cdFx0XHRjdXJQb2ludCArPSBpbmM7XG5cdFx0XHR2YXIgY3VyQ2hhciA9IGNvbnRlbnQuY2hhckF0KGN1clBvaW50KTtcblx0XHRcdHZhciBuZXh0Q2hhciA9IGNvbnRlbnQuY2hhckF0KGN1clBvaW50ICsgMSk7XG5cdFx0XHR2YXIgcHJldkNoYXIgPSBjb250ZW50LmNoYXJBdChjdXJQb2ludCAtIDEpO1xuXHRcdFx0XHRcblx0XHRcdHN3aXRjaCAoY3VyQ2hhcikge1xuXHRcdFx0XHRjYXNlICdcIic6XG5cdFx0XHRcdGNhc2UgJ1xcJyc6XG5cdFx0XHRcdFx0aWYgKG5leHRDaGFyID09IGN1ckNoYXIgJiYgcHJldkNoYXIgPT0gJz0nKSB7XG5cdFx0XHRcdFx0XHQvLyBlbXB0eSBhdHRyaWJ1dGVcblx0XHRcdFx0XHRcdG5leHRQb2ludCA9IGN1clBvaW50ICsgMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJz4nOlxuXHRcdFx0XHRcdGlmIChuZXh0Q2hhciA9PSAnPCcpIHtcblx0XHRcdFx0XHRcdC8vIGJldHdlZW4gdGFnc1xuXHRcdFx0XHRcdFx0bmV4dFBvaW50ID0gY3VyUG9pbnQgKyAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnXFxuJzpcblx0XHRcdFx0Y2FzZSAnXFxyJzpcblx0XHRcdFx0XHQvLyBlbXB0eSBsaW5lXG5cdFx0XHRcdFx0aWYgKHJlRW1wdHlMaW5lLnRlc3QoZ2V0TGluZShjdXJQb2ludCAtIDEpKSkge1xuXHRcdFx0XHRcdFx0bmV4dFBvaW50ID0gY3VyUG9pbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAobmV4dFBvaW50ICE9IC0xKVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG5leHRQb2ludDtcblx0fVxuXHRcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBNb3ZlIHRvIHByZXZpb3VzIGVkaXQgcG9pbnRcblx0XHQgKiBAcGFyYW0gIHtJRW1tZXRFZGl0b3J9IGVkaXRvciAgRWRpdG9yIGluc3RhbmNlXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBzeW50YXggIEN1cnJlbnQgZG9jdW1lbnQgc3ludGF4XG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBwcm9maWxlIE91dHB1dCBwcm9maWxlIG5hbWVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHByZXZpb3VzRWRpdFBvaW50QWN0aW9uOiBmdW5jdGlvbihlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSkge1xuXHRcdFx0dmFyIGN1clBvcyA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdFx0dmFyIG5ld1BvaW50ID0gZmluZE5ld0VkaXRQb2ludChlZGl0b3IsIC0xKTtcblx0XHRcdFx0XG5cdFx0XHRpZiAobmV3UG9pbnQgPT0gY3VyUG9zKVxuXHRcdFx0XHQvLyB3ZSdyZSBzdGlsbCBpbiB0aGUgc2FtZSBwb2ludCwgdHJ5IHNlYXJjaGluZyBmcm9tIHRoZSBvdGhlciBwbGFjZVxuXHRcdFx0XHRuZXdQb2ludCA9IGZpbmROZXdFZGl0UG9pbnQoZWRpdG9yLCAtMSwgLTIpO1xuXHRcdFx0XG5cdFx0XHRpZiAobmV3UG9pbnQgIT0gLTEpIHtcblx0XHRcdFx0ZWRpdG9yLnNldENhcmV0UG9zKG5ld1BvaW50KTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTW92ZSB0byBuZXh0IGVkaXQgcG9pbnRcblx0XHQgKiBAcGFyYW0gIHtJRW1tZXRFZGl0b3J9IGVkaXRvciAgRWRpdG9yIGluc3RhbmNlXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBzeW50YXggIEN1cnJlbnQgZG9jdW1lbnQgc3ludGF4XG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBwcm9maWxlIE91dHB1dCBwcm9maWxlIG5hbWVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdG5leHRFZGl0UG9pbnRBY3Rpb246IGZ1bmN0aW9uKGVkaXRvciwgc3ludGF4LCBwcm9maWxlKSB7XG5cdFx0XHR2YXIgbmV3UG9pbnQgPSBmaW5kTmV3RWRpdFBvaW50KGVkaXRvciwgMSk7XG5cdFx0XHRpZiAobmV3UG9pbnQgIT0gLTEpIHtcblx0XHRcdFx0ZWRpdG9yLnNldENhcmV0UG9zKG5ld1BvaW50KTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG59KTtcbn0se31dLFwiYWN0aW9uXFxcXGV2YWx1YXRlTWF0aC5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogRXZhbHVhdGVzIHNpbXBsZSBtYXRoIGV4cHJlc3Npb24gdW5kZXIgY2FyZXRcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIGFjdGlvblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvYWN0aW9uJyk7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgbWF0aCA9IHJlcXVpcmUoJy4uL3V0aWxzL21hdGgnKTtcblx0dmFyIHJhbmdlID0gcmVxdWlyZSgnLi4vYXNzZXRzL3JhbmdlJyk7XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBFdmFsdWF0ZXMgbWF0aCBleHByZXNzaW9uIHVuZGVyIHRoZSBjYXJldFxuXHRcdCAqIEBwYXJhbSAge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRldmFsdWF0ZU1hdGhBY3Rpb246IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBlZGl0b3IuZ2V0Q29udGVudCgpO1xuXHRcdFx0dmFyIGNoYXJzID0gJy4rLSovXFxcXCc7XG5cdFx0XHRcblx0XHRcdC8qKiBAdHlwZSBSYW5nZSAqL1xuXHRcdFx0dmFyIHNlbCA9IHJhbmdlKGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcblx0XHRcdGlmICghc2VsLmxlbmd0aCgpKSB7XG5cdFx0XHRcdHNlbCA9IGFjdGlvblV0aWxzLmZpbmRFeHByZXNzaW9uQm91bmRzKGVkaXRvciwgZnVuY3Rpb24oY2gpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHMuaXNOdW1lcmljKGNoKSB8fCBjaGFycy5pbmRleE9mKGNoKSAhPSAtMTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChzZWwgJiYgc2VsLmxlbmd0aCgpKSB7XG5cdFx0XHRcdHZhciBleHByID0gc2VsLnN1YnN0cmluZyhjb250ZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHJlcGxhY2UgaW50ZWdyYWwgZGl2aXNpb246IDExXFwyID0+IE1hdGgucm91bmQoMTEvMikgXG5cdFx0XHRcdGV4cHIgPSBleHByLnJlcGxhY2UoLyhbXFxkXFwuXFwtXSspXFxcXChbXFxkXFwuXFwtXSspL2csICdyb3VuZCgkMS8kMiknKTtcblx0XHRcdFx0XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IHV0aWxzLnByZXR0aWZ5TnVtYmVyKG1hdGguZXZhbHVhdGUoZXhwcikpO1xuXHRcdFx0XHRcdGVkaXRvci5yZXBsYWNlQ29udGVudChyZXN1bHQsIHNlbC5zdGFydCwgc2VsLmVuZCk7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldENhcmV0UG9zKHNlbC5zdGFydCArIHJlc3VsdC5sZW5ndGgpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xufSk7XG5cbn0se1wiLi4vYXNzZXRzL3JhbmdlXCI6XCJhc3NldHNcXFxccmFuZ2UuanNcIixcIi4uL3V0aWxzL2FjdGlvblwiOlwidXRpbHNcXFxcYWN0aW9uLmpzXCIsXCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi4vdXRpbHMvbWF0aFwiOlwidXRpbHNcXFxcbWF0aC5qc1wifV0sXCJhY3Rpb25cXFxcZXhwYW5kQWJicmV2aWF0aW9uLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiAnRXhwYW5kIGFiYnJldmlhdGlvbicgZWRpdG9yIGFjdGlvbjogZXh0cmFjdHMgYWJicmV2aWF0aW9uIGZyb20gY3VycmVudCBjYXJldCBcbiAqIHBvc2l0aW9uIGFuZCByZXBsYWNlcyBpdCB3aXRoIGZvcm1hdHRlZCBvdXRwdXQuIFxuICogPGJyPjxicj5cbiAqIFRoaXMgYmVoYXZpb3IgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCBjdXN0b20gaGFuZGxlcnMgd2hpY2ggY2FuIHBlcmZvcm0gXG4gKiBkaWZmZXJlbnQgYWN0aW9ucyB3aGVuICdFeHBhbmQgQWJicmV2aWF0aW9uJyBhY3Rpb24gaXMgY2FsbGVkLlxuICogRm9yIGV4YW1wbGUsIGEgQ1NTIGdyYWRpZW50IGhhbmRsZXIgdGhhdCBwcm9kdWNlcyB2ZW5kb3ItcHJlZml4ZWQgZ3JhZGllbnRcbiAqIGRlZmluaXRpb25zIHJlZ2lzdGVycyBpdHMgb3duIGV4cGFuZCBhYmJyZXZpYXRpb24gaGFuZGxlci4gIFxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgaGFuZGxlckxpc3QgPSByZXF1aXJlKCcuLi9hc3NldHMvaGFuZGxlckxpc3QnKTtcblx0dmFyIHJhbmdlID0gcmVxdWlyZSgnLi4vYXNzZXRzL3JhbmdlJyk7XG5cdHZhciBwcmVmcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9wcmVmZXJlbmNlcycpO1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblx0dmFyIGVkaXRvclV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZWRpdG9yJyk7XG5cdHZhciBhY3Rpb25VdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2FjdGlvbicpO1xuXHR2YXIgY3NzR3JhZGllbnQgPSByZXF1aXJlKCcuLi9yZXNvbHZlci9jc3NHcmFkaWVudCcpO1xuXHR2YXIgcGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2VyL2FiYnJldmlhdGlvbicpO1xuXG5cdC8qKlxuXHQgKiBTZWFyY2ggZm9yIGFiYnJldmlhdGlvbiBpbiBlZGl0b3IgZnJvbSBjdXJyZW50IGNhcmV0IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3IgRWRpdG9yIGluc3RhbmNlXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGZpbmRBYmJyZXZpYXRpb24oZWRpdG9yKSB7XG5cdFx0dmFyIHIgPSByYW5nZShlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XG5cdFx0dmFyIGNvbnRlbnQgPSBTdHJpbmcoZWRpdG9yLmdldENvbnRlbnQoKSk7XG5cdFx0aWYgKHIubGVuZ3RoKCkpIHtcblx0XHRcdC8vIGFiYnJldmlhdGlvbiBpcyBzZWxlY3RlZCBieSB1c2VyXG5cdFx0XHRyZXR1cm4gci5zdWJzdHJpbmcoY29udGVudCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIHNlYXJjaCBmb3IgbmV3IGFiYnJldmlhdGlvbiBmcm9tIGN1cnJlbnQgY2FyZXQgcG9zaXRpb25cblx0XHR2YXIgY3VyTGluZSA9IGVkaXRvci5nZXRDdXJyZW50TGluZVJhbmdlKCk7XG5cdFx0cmV0dXJuIGFjdGlvblV0aWxzLmV4dHJhY3RBYmJyZXZpYXRpb24oY29udGVudC5zdWJzdHJpbmcoY3VyTGluZS5zdGFydCwgci5zdGFydCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIEhhbmRsZXJMaXN0IExpc3Qgb2YgcmVnaXN0ZXJlZCBoYW5kbGVyc1xuXHQgKi9cblx0dmFyIGhhbmRsZXJzID0gaGFuZGxlckxpc3QuY3JlYXRlKCk7XG5cblx0Ly8gWFhYIHNldHVwIGRlZmF1bHQgZXhwYW5kIGhhbmRsZXJzXG5cdFxuXHQvKipcblx0ICogRXh0cmFjdHMgYWJicmV2aWF0aW9uIGZyb20gY3VycmVudCBjYXJldCBcblx0ICogcG9zaXRpb24gYW5kIHJlcGxhY2VzIGl0IHdpdGggZm9ybWF0dGVkIG91dHB1dCBcblx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvciBFZGl0b3IgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN5bnRheCBTeW50YXggdHlwZSAoaHRtbCwgY3NzLCBldGMuKVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvZmlsZSBPdXRwdXQgcHJvZmlsZSBuYW1lIChodG1sLCB4bWwsIHhodG1sKVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIGFiYnJldmlhdGlvbiB3YXMgZXhwYW5kZWQgXG5cdCAqIHN1Y2Nlc3NmdWxseVxuXHQgKi9cblx0aGFuZGxlcnMuYWRkKGZ1bmN0aW9uKGVkaXRvciwgc3ludGF4LCBwcm9maWxlKSB7XG5cdFx0dmFyIGNhcmV0UG9zID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkuZW5kO1xuXHRcdHZhciBhYmJyID0gZmluZEFiYnJldmlhdGlvbihlZGl0b3IpO1xuXHRcdFx0XG5cdFx0aWYgKGFiYnIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gcGFyc2VyLmV4cGFuZChhYmJyLCB7XG5cdFx0XHRcdHN5bnRheDogc3ludGF4LCBcblx0XHRcdFx0cHJvZmlsZTogcHJvZmlsZSwgXG5cdFx0XHRcdGNvbnRleHROb2RlOiBhY3Rpb25VdGlscy5jYXB0dXJlQ29udGV4dChlZGl0b3IpXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGNvbnRlbnQpIHtcblx0XHRcdFx0dmFyIHJlcGxhY2VGcm9tID0gY2FyZXRQb3MgLSBhYmJyLmxlbmd0aDtcblx0XHRcdFx0dmFyIHJlcGxhY2VUbyA9IGNhcmV0UG9zO1xuXG5cdFx0XHRcdC8vIGEgc3BlY2lhbCBjYXNlIGZvciBDU1M6IGlmIGVkaXRvciBhbHJlYWR5IGNvbnRhaW5zXG5cdFx0XHRcdC8vIHNlbWljb2xvbiByaWdodCBhZnRlciBjdXJyZW50IGNhcmV0IHBvc2l0aW9uIOKAlCByZXBsYWNlIGl0IHRvb1xuXHRcdFx0XHR2YXIgY3NzU3ludGF4ZXMgPSBwcmVmcy5nZXRBcnJheSgnY3NzLnN5bnRheGVzJyk7XG5cdFx0XHRcdGlmIChjc3NTeW50YXhlcyAmJiB+Y3NzU3ludGF4ZXMuaW5kZXhPZihzeW50YXgpKSB7XG5cdFx0XHRcdFx0dmFyIGN1ckNvbnRlbnQgPSBlZGl0b3IuZ2V0Q29udGVudCgpO1xuXHRcdFx0XHRcdGlmIChjdXJDb250ZW50LmNoYXJBdChjYXJldFBvcykgPT0gJzsnICYmIGNvbnRlbnQuY2hhckF0KGNvbnRlbnQubGVuZ3RoIC0gMSkgPT0gJzsnKSB7XG5cdFx0XHRcdFx0XHRyZXBsYWNlVG8rKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQoY29udGVudCwgcmVwbGFjZUZyb20sIHJlcGxhY2VUbyk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sIHtvcmRlcjogLTF9KTtcblx0aGFuZGxlcnMuYWRkKGNzc0dyYWRpZW50LmV4cGFuZEFiYnJldmlhdGlvbkhhbmRsZXIuYmluZChjc3NHcmFkaWVudCkpO1xuXHRcdFxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBhY3R1YWwg4oCcRXhwYW5kIEFiYnJldmlhdGlvbuKAnCBhY3Rpb24gcm91dGluZVxuXHRcdCAqIEBwYXJhbSAge0lFbW1ldEVkaXRvcn0gZWRpdG9yICBFZGl0b3IgaW5zdGFuY2Vcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHN5bnRheCAgQ3VycmVudCBkb2N1bWVudCBzeW50YXhcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHByb2ZpbGUgT3V0cHV0IHByb2ZpbGUgbmFtZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0ZXhwYW5kQWJicmV2aWF0aW9uQWN0aW9uOiBmdW5jdGlvbihlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSkge1xuXHRcdFx0dmFyIGFyZ3MgPSB1dGlscy50b0FycmF5KGFyZ3VtZW50cyk7XG5cdFx0XHRcblx0XHRcdC8vIG5vcm1hbGl6ZSBpbmNvbWluZyBhcmd1bWVudHNcblx0XHRcdHZhciBpbmZvID0gZWRpdG9yVXRpbHMub3V0cHV0SW5mbyhlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSk7XG5cdFx0XHRhcmdzWzFdID0gaW5mby5zeW50YXg7XG5cdFx0XHRhcmdzWzJdID0gaW5mby5wcm9maWxlO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gaGFuZGxlcnMuZXhlYyhmYWxzZSwgYXJncyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEEgc3BlY2lhbCBjYXNlIG9mIOKAnEV4cGFuZCBBYmJyZXZpYXRpb27igJwgYWN0aW9uLCBpbnZva2VkIGJ5IFRhYiBrZXkuXG5cdFx0ICogSW4gdGhpcyBjYXNlIGlmIGFiYnJldmlhdGlvbiB3YXNu4oCZdCBleHBhbmRlZCBzdWNjZXNzZnVsbHkgb3IgdGhlcmXigJlzIGEgc2VsZWNldGlvbiwgXG5cdFx0ICogdGhlIGN1cnJlbnQgbGluZS9zZWxlY3Rpb24gd2lsbCBiZSBpbmRlbnRlZC4gXG5cdFx0ICogQHBhcmFtICB7SUVtbWV0RWRpdG9yfSBlZGl0b3IgIEVkaXRvciBpbnN0YW5jZVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gc3ludGF4ICBDdXJyZW50IGRvY3VtZW50IHN5bnRheFxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gcHJvZmlsZSBPdXRwdXQgcHJvZmlsZSBuYW1lXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRleHBhbmRBYmJyZXZpYXRpb25XaXRoVGFiQWN0aW9uOiBmdW5jdGlvbihlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSkge1xuXHRcdFx0dmFyIHNlbCA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdHZhciBpbmRlbnQgPSAnXFx0JztcblxuXHRcdFx0Ly8gaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkIGluIGVkaXRvcixcblx0XHRcdC8vIHdlIHNob3VsZCBpbmRlbnQgdGhlIHNlbGVjdGVkIGNvbnRlbnRcblx0XHRcdGlmIChzZWwpIHtcblx0XHRcdFx0dmFyIHNlbFJhbmdlID0gcmFuZ2UoZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuXHRcdFx0XHR2YXIgY29udGVudCA9IHV0aWxzLnBhZFN0cmluZyhzZWwsIGluZGVudCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQoaW5kZW50ICsgJyR7MH0nLCBlZGl0b3IuZ2V0Q2FyZXRQb3MoKSk7XG5cdFx0XHRcdHZhciByZXBsYWNlUmFuZ2UgPSByYW5nZShlZGl0b3IuZ2V0Q2FyZXRQb3MoKSwgc2VsUmFuZ2UubGVuZ3RoKCkpO1xuXHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQoY29udGVudCwgcmVwbGFjZVJhbmdlLnN0YXJ0LCByZXBsYWNlUmFuZ2UuZW5kLCB0cnVlKTtcblx0XHRcdFx0ZWRpdG9yLmNyZWF0ZVNlbGVjdGlvbihyZXBsYWNlUmFuZ2Uuc3RhcnQsIHJlcGxhY2VSYW5nZS5zdGFydCArIGNvbnRlbnQubGVuZ3RoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gbm90aGluZyBzZWxlY3RlZCwgdHJ5IHRvIGV4cGFuZFxuXHRcdFx0aWYgKCF0aGlzLmV4cGFuZEFiYnJldmlhdGlvbkFjdGlvbihlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSkpIHtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KGluZGVudCwgZWRpdG9yLmdldENhcmV0UG9zKCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XG5cdFx0X2RlZmF1bHRIYW5kbGVyOiBmdW5jdGlvbihlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSkge1xuXHRcdFx0dmFyIGNhcmV0UG9zID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkuZW5kO1xuXHRcdFx0dmFyIGFiYnIgPSB0aGlzLmZpbmRBYmJyZXZpYXRpb24oZWRpdG9yKTtcblx0XHRcdFx0XG5cdFx0XHRpZiAoYWJicikge1xuXHRcdFx0XHR2YXIgY3R4ID0gYWN0aW9uVXRpbHMuY2FwdHVyZUNvbnRleHQoZWRpdG9yKTtcblx0XHRcdFx0dmFyIGNvbnRlbnQgPSBwYXJzZXIuZXhwYW5kKGFiYnIsIHN5bnRheCwgcHJvZmlsZSwgY3R4KTtcblx0XHRcdFx0aWYgKGNvbnRlbnQpIHtcblx0XHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQoY29udGVudCwgY2FyZXRQb3MgLSBhYmJyLmxlbmd0aCwgY2FyZXRQb3MpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkcyBjdXN0b20gZXhwYW5kIGFiYnJldmlhdGlvbiBoYW5kbGVyLiBUaGUgcGFzc2VkIGZ1bmN0aW9uIHNob3VsZCBcblx0XHQgKiByZXR1cm4gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgaXQgd2FzIHBlcmZvcm1lZCBzdWNjZXNzZnVsbHksIFxuXHRcdCAqIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG5cdFx0ICogXG5cdFx0ICogQWRkZWQgaGFuZGxlcnMgd2lsbCBiZSBjYWxsZWQgd2hlbiAnRXhwYW5kIEFiYnJldmlhdGlvbicgaXMgY2FsbGVkXG5cdFx0ICogaW4gb3JkZXIgdGhleSB3ZXJlIGFkZGVkXG5cdFx0ICogQG1lbWJlck9mIGV4cGFuZEFiYnJldmlhdGlvblxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0XHQgKi9cblx0XHRhZGRIYW5kbGVyOiBmdW5jdGlvbihmbiwgb3B0aW9ucykge1xuXHRcdFx0aGFuZGxlcnMuYWRkKGZuLCBvcHRpb25zKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgcmVnaXN0ZXJlZCBoYW5kbGVyXG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRyZW1vdmVIYW5kbGVyOiBmdW5jdGlvbihmbikge1xuXHRcdFx0aGFuZGxlcnMucmVtb3ZlKGZuKTtcblx0XHR9LFxuXHRcdFxuXHRcdGZpbmRBYmJyZXZpYXRpb246IGZpbmRBYmJyZXZpYXRpb25cblx0fTtcbn0pO1xufSx7XCIuLi9hc3NldHMvaGFuZGxlckxpc3RcIjpcImFzc2V0c1xcXFxoYW5kbGVyTGlzdC5qc1wiLFwiLi4vYXNzZXRzL3ByZWZlcmVuY2VzXCI6XCJhc3NldHNcXFxccHJlZmVyZW5jZXMuanNcIixcIi4uL2Fzc2V0cy9yYW5nZVwiOlwiYXNzZXRzXFxcXHJhbmdlLmpzXCIsXCIuLi9wYXJzZXIvYWJicmV2aWF0aW9uXCI6XCJwYXJzZXJcXFxcYWJicmV2aWF0aW9uLmpzXCIsXCIuLi9yZXNvbHZlci9jc3NHcmFkaWVudFwiOlwicmVzb2x2ZXJcXFxcY3NzR3JhZGllbnQuanNcIixcIi4uL3V0aWxzL2FjdGlvblwiOlwidXRpbHNcXFxcYWN0aW9uLmpzXCIsXCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi4vdXRpbHMvZWRpdG9yXCI6XCJ1dGlsc1xcXFxlZGl0b3IuanNcIn1dLFwiYWN0aW9uXFxcXGluY3JlbWVudERlY3JlbWVudC5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSW5jcmVtZW50L2RlY3JlbWVudCBudW1iZXIgdW5kZXIgY3Vyc29yXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgYWN0aW9uVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9hY3Rpb24nKTtcblxuXHQvKipcblx0ICogUmV0dXJucyBsZW5ndGggb2YgaW50ZWdlciBwYXJ0IG9mIG51bWJlclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbnVtXG5cdCAqL1xuXHRmdW5jdGlvbiBpbnRMZW5ndGgobnVtKSB7XG5cdFx0bnVtID0gbnVtLnJlcGxhY2UoL15cXC0vLCAnJyk7XG5cdFx0aWYgKH5udW0uaW5kZXhPZignLicpKSB7XG5cdFx0XHRyZXR1cm4gbnVtLnNwbGl0KCcuJylbMF0ubGVuZ3RoO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbnVtLmxlbmd0aDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0aW5jcmVtZW50MDFBY3Rpb246IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5jcmVtZW50TnVtYmVyKGVkaXRvciwgLjEpO1xuXHRcdH0sXG5cblx0XHRpbmNyZW1lbnQxQWN0aW9uOiBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRcdHJldHVybiB0aGlzLmluY3JlbWVudE51bWJlcihlZGl0b3IsIDEpO1xuXHRcdH0sXG5cblx0XHRpbmNyZW1lbnQxMEFjdGlvbjogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbmNyZW1lbnROdW1iZXIoZWRpdG9yLCAxMCk7XG5cdFx0fSxcblxuXHRcdGRlY3JlbWVudDAxQWN0aW9uOiBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRcdHJldHVybiB0aGlzLmluY3JlbWVudE51bWJlcihlZGl0b3IsIC0uMSk7XG5cdFx0fSxcblxuXHRcdGRlY3JlbWVudDFBY3Rpb246IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5jcmVtZW50TnVtYmVyKGVkaXRvciwgLTEpO1xuXHRcdH0sXG5cblx0XHRkZWNyZW1lbnQxMEFjdGlvbjogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbmNyZW1lbnROdW1iZXIoZWRpdG9yLCAtMTApO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZWZhdWx0IG1ldGhvZCB0byBpbmNyZW1lbnQvZGVjcmVtZW50IG51bWJlciB1bmRlclxuXHRcdCAqIGNhcmV0IHdpdGggZ2l2ZW4gc3RlcFxuXHRcdCAqIEBwYXJhbSAge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdFx0ICogQHBhcmFtICB7TnVtYmVyfSBzdGVwXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpbmNyZW1lbnROdW1iZXI6IGZ1bmN0aW9uKGVkaXRvciwgc3RlcCkge1xuXHRcdFx0dmFyIGhhc1NpZ24gPSBmYWxzZTtcblx0XHRcdHZhciBoYXNEZWNpbWFsID0gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0dmFyIHIgPSBhY3Rpb25VdGlscy5maW5kRXhwcmVzc2lvbkJvdW5kcyhlZGl0b3IsIGZ1bmN0aW9uKGNoLCBwb3MsIGNvbnRlbnQpIHtcblx0XHRcdFx0aWYgKHV0aWxzLmlzTnVtZXJpYyhjaCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdGlmIChjaCA9PSAnLicpIHtcblx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhhdCBuZXh0IGNoYXJhY3RlciBpcyBudW1lcmljIHRvb1xuXHRcdFx0XHRcdGlmICghdXRpbHMuaXNOdW1lcmljKGNvbnRlbnQuY2hhckF0KHBvcyArIDEpKSlcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gaGFzRGVjaW1hbCA/IGZhbHNlIDogaGFzRGVjaW1hbCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNoID09ICctJylcblx0XHRcdFx0XHRyZXR1cm4gaGFzU2lnbiA/IGZhbHNlIDogaGFzU2lnbiA9IHRydWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdGlmIChyICYmIHIubGVuZ3RoKCkpIHtcblx0XHRcdFx0dmFyIHN0ck51bSA9IHIuc3Vic3RyaW5nKFN0cmluZyhlZGl0b3IuZ2V0Q29udGVudCgpKSk7XG5cdFx0XHRcdHZhciBudW0gPSBwYXJzZUZsb2F0KHN0ck51bSk7XG5cdFx0XHRcdGlmICghaXNOYU4obnVtKSkge1xuXHRcdFx0XHRcdG51bSA9IHV0aWxzLnByZXR0aWZ5TnVtYmVyKG51bSArIHN0ZXApO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGRvIHdlIGhhdmUgemVyby1wYWRkZWQgbnVtYmVyP1xuXHRcdFx0XHRcdGlmICgvXihcXC0/KTArWzEtOV0vLnRlc3Qoc3RyTnVtKSkge1xuXHRcdFx0XHRcdFx0dmFyIG1pbnVzID0gJyc7XG5cdFx0XHRcdFx0XHRpZiAoUmVnRXhwLiQxKSB7XG5cdFx0XHRcdFx0XHRcdG1pbnVzID0gJy0nO1xuXHRcdFx0XHRcdFx0XHRudW0gPSBudW0uc3Vic3RyaW5nKDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHZhciBwYXJ0cyA9IG51bS5zcGxpdCgnLicpO1xuXHRcdFx0XHRcdFx0cGFydHNbMF0gPSB1dGlscy56ZXJvUGFkU3RyaW5nKHBhcnRzWzBdLCBpbnRMZW5ndGgoc3RyTnVtKSk7XG5cdFx0XHRcdFx0XHRudW0gPSBtaW51cyArIHBhcnRzLmpvaW4oJy4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KG51bSwgci5zdGFydCwgci5lbmQpO1xuXHRcdFx0XHRcdGVkaXRvci5jcmVhdGVTZWxlY3Rpb24oci5zdGFydCwgci5zdGFydCArIG51bS5sZW5ndGgpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vdXRpbHMvYWN0aW9uXCI6XCJ1dGlsc1xcXFxhY3Rpb24uanNcIixcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCJ9XSxcImFjdGlvblxcXFxsaW5lQnJlYWtzLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBBY3Rpb25zIHRvIGluc2VydCBsaW5lIGJyZWFrcy4gU29tZSBzaW1wbGUgZWRpdG9ycyAobGlrZSBicm93c2VyJ3MgXG4gKiAmbHQ7dGV4dGFyZWEmZ3Q7LCBmb3IgZXhhbXBsZSkgZG8gbm90IHByb3ZpZGUgc3VjaCBzaW1wbGUgdGhpbmdzXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBwcmVmcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9wcmVmZXJlbmNlcycpO1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblx0dmFyIHJlc291cmNlcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9yZXNvdXJjZXMnKTtcblx0dmFyIGh0bWxNYXRjaGVyID0gcmVxdWlyZSgnLi4vYXNzZXRzL2h0bWxNYXRjaGVyJyk7XG5cdHZhciBlZGl0b3JVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2VkaXRvcicpO1xuXG5cdHZhciB4bWxTeW50YXhlcyA9IFsnaHRtbCcsICd4bWwnLCAneHNsJ107XG5cblx0Ly8gc2V0dXAgZGVmYXVsdCBwcmVmZXJlbmNlc1xuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5jbG9zZUJyYWNlSW5kZW50YXRpb24nLCAnXFxuJyxcblx0XHRcdCdJbmRlbnRhdGlvbiBiZWZvcmUgY2xvc2luZyBicmFjZSBvZiBDU1MgcnVsZS4gU29tZSB1c2VycyBwcmVmZXJlICcgXG5cdFx0XHQrICdpbmRlbnRlZCBjbG9zaW5nIGJyYWNlIG9mIENTUyBydWxlIGZvciBiZXR0ZXIgcmVhZGFiaWxpdHkuICdcblx0XHRcdCsgJ1RoaXMgcHJlZmVyZW5jZeKAmXMgdmFsdWUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluc2VydGVkIGJlZm9yZSAnXG5cdFx0XHQrICdjbG9zaW5nIGJyYWNlIHdoZW4gdXNlciBhZGRzIG5ld2xpbmUgaW4gbmV3bHkgY3JlYXRlZCBDU1MgcnVsZSAnXG5cdFx0XHQrICcoZS5nLiB3aGVuIOKAnEluc2VydCBmb3JtYXR0ZWQgbGluZWJyZWFr4oCdIGFjdGlvbiB3aWxsIGJlIHBlcmZvcm1lZCAnIFxuXHRcdFx0KyAnaW4gQ1NTIGZpbGUpLiBJZiB5b3XigJlyZSBzdWNoIHVzZXIsIHlvdSBtYXkgd2FudCB0byB3cml0ZSBwdXQgYSB2YWx1ZSAnIFxuXHRcdFx0KyAnbGlrZSA8Y29kZT5cXFxcblxcXFx0PC9jb2RlPiBpbiB0aGlzIHByZWZlcmVuY2UuJyk7XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBJbnNlcnRzIG5ld2xpbmUgY2hhcmFjdGVyIHdpdGggcHJvcGVyIGluZGVudGF0aW9uLiBUaGlzIGFjdGlvbiBpcyB1c2VkIGluXG5cdFx0ICogZWRpdG9ycyB0aGF0IGRvZXNuJ3QgaGF2ZSBpbmRlbnRhdGlvbiBjb250cm9sIChsaWtlIHRleHRhcmVhIGVsZW1lbnQpIHRvIFxuXHRcdCAqIHByb3ZpZGUgcHJvcGVyIGluZGVudGF0aW9uIGZvciBpbnNlcnRlZCBuZXdsaW5lc1xuXHRcdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3IgRWRpdG9yIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0aW5zZXJ0TGluZUJyZWFrQWN0aW9uOiBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRcdGlmICghdGhpcy5pbnNlcnRMaW5lQnJlYWtPbmx5QWN0aW9uKGVkaXRvcikpIHtcblx0XHRcdFx0dmFyIGN1clBhZGRpbmcgPSBlZGl0b3JVdGlscy5nZXRDdXJyZW50TGluZVBhZGRpbmcoZWRpdG9yKTtcblx0XHRcdFx0dmFyIGNvbnRlbnQgPSBTdHJpbmcoZWRpdG9yLmdldENvbnRlbnQoKSk7XG5cdFx0XHRcdHZhciBjYXJldFBvcyA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdFx0XHR2YXIgbGVuID0gY29udGVudC5sZW5ndGg7XG5cdFx0XHRcdHZhciBubCA9ICdcXG4nO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHQvLyBjaGVjayBvdXQgbmV4dCBsaW5lIHBhZGRpbmdcblx0XHRcdFx0dmFyIGxpbmVSYW5nZSA9IGVkaXRvci5nZXRDdXJyZW50TGluZVJhbmdlKCk7XG5cdFx0XHRcdHZhciBuZXh0UGFkZGluZyA9ICcnO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRmb3IgKHZhciBpID0gbGluZVJhbmdlLmVuZCwgY2g7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGNoID0gY29udGVudC5jaGFyQXQoaSk7XG5cdFx0XHRcdFx0aWYgKGNoID09ICcgJyB8fCBjaCA9PSAnXFx0Jylcblx0XHRcdFx0XHRcdG5leHRQYWRkaW5nICs9IGNoO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobmV4dFBhZGRpbmcubGVuZ3RoID4gY3VyUGFkZGluZy5sZW5ndGgpIHtcblx0XHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQobmwgKyBuZXh0UGFkZGluZywgY2FyZXRQb3MsIGNhcmV0UG9zLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQobmwsIGNhcmV0UG9zKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5zZXJ0cyBuZXdsaW5lIGNoYXJhY3RlciB3aXRoIHByb3BlciBpbmRlbnRhdGlvbiBpbiBzcGVjaWZpYyBwb3NpdGlvbnMgb25seS5cblx0XHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiBsaW5lIGJyZWFrIHdhcyBpbnNlcnRlZCBcblx0XHQgKi9cblx0XHRpbnNlcnRMaW5lQnJlYWtPbmx5QWN0aW9uOiBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRcdHZhciBpbmZvID0gZWRpdG9yVXRpbHMub3V0cHV0SW5mbyhlZGl0b3IpO1xuXHRcdFx0dmFyIGNhcmV0UG9zID0gZWRpdG9yLmdldENhcmV0UG9zKCk7XG5cdFx0XHR2YXIgbmwgPSAnXFxuJztcblx0XHRcdHZhciBwYWQgPSAnXFx0Jztcblx0XHRcdFxuXHRcdFx0aWYgKH54bWxTeW50YXhlcy5pbmRleE9mKGluZm8uc3ludGF4KSkge1xuXHRcdFx0XHQvLyBsZXQncyBzZWUgaWYgd2UncmUgYnJlYWtpbmcgbmV3bHkgY3JlYXRlZCB0YWdcblx0XHRcdFx0dmFyIHRhZyA9IGh0bWxNYXRjaGVyLnRhZyhpbmZvLmNvbnRlbnQsIGNhcmV0UG9zKTtcblx0XHRcdFx0aWYgKHRhZyAmJiAhdGFnLmlubmVyUmFuZ2UubGVuZ3RoKCkpIHtcblx0XHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQobmwgKyBwYWQgKyB1dGlscy5nZXRDYXJldFBsYWNlaG9sZGVyKCkgKyBubCwgY2FyZXRQb3MpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGluZm8uc3ludGF4ID09ICdjc3MnKSB7XG5cdFx0XHRcdC8qKiBAdHlwZSBTdHJpbmcgKi9cblx0XHRcdFx0dmFyIGNvbnRlbnQgPSBpbmZvLmNvbnRlbnQ7XG5cdFx0XHRcdGlmIChjYXJldFBvcyAmJiBjb250ZW50LmNoYXJBdChjYXJldFBvcyAtIDEpID09ICd7Jykge1xuXHRcdFx0XHRcdHZhciBhcHBlbmQgPSBwcmVmcy5nZXQoJ2Nzcy5jbG9zZUJyYWNlSW5kZW50YXRpb24nKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgaGFzQ2xvc2VCcmFjZSA9IGNvbnRlbnQuY2hhckF0KGNhcmV0UG9zKSA9PSAnfSc7XG5cdFx0XHRcdFx0aWYgKCFoYXNDbG9zZUJyYWNlKSB7XG5cdFx0XHRcdFx0XHQvLyBkbyB3ZSByZWFsbHkgbmVlZCBzcGVjaWFsIGZvcm1hdHRpbmcgaGVyZT9cblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIHRoaXMgaXMgcmVhbGx5IGEgbmV3bHkgY3JlYXRlZCBydWxlLFxuXHRcdFx0XHRcdFx0Ly8gbG9vayBhaGVhZCBmb3IgYSBjbG9zaW5nIGJyYWNlXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gY2FyZXRQb3MsIGlsID0gY29udGVudC5sZW5ndGgsIGNoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRjaCA9IGNvbnRlbnQuY2hhckF0KGkpO1xuXHRcdFx0XHRcdFx0XHRpZiAoY2ggPT0gJ3snKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gb2ssIHRoaXMgaXMgYSBuZXcgcnVsZSB3aXRob3V0IGNsb3NpbmcgYnJhY2Vcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYgKGNoID09ICd9Jykge1xuXHRcdFx0XHRcdFx0XHRcdC8vIG5vdCBhIG5ldyBydWxlLCBqdXN0IGFkZCBpbmRlbnRhdGlvblxuXHRcdFx0XHRcdFx0XHRcdGFwcGVuZCA9ICcnO1xuXHRcdFx0XHRcdFx0XHRcdGhhc0Nsb3NlQnJhY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghaGFzQ2xvc2VCcmFjZSkge1xuXHRcdFx0XHRcdFx0YXBwZW5kICs9ICd9Jztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gZGVmaW5pbmcgcnVsZSBzZXRcblx0XHRcdFx0XHR2YXIgaW5zVmFsdWUgPSBubCArIHBhZCArIHV0aWxzLmdldENhcmV0UGxhY2Vob2xkZXIoKSArIGFwcGVuZDtcblx0XHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQoaW5zVmFsdWUsIGNhcmV0UG9zKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG59KTtcblxufSx7XCIuLi9hc3NldHMvaHRtbE1hdGNoZXJcIjpcImFzc2V0c1xcXFxodG1sTWF0Y2hlci5qc1wiLFwiLi4vYXNzZXRzL3ByZWZlcmVuY2VzXCI6XCJhc3NldHNcXFxccHJlZmVyZW5jZXMuanNcIixcIi4uL2Fzc2V0cy9yZXNvdXJjZXNcIjpcImFzc2V0c1xcXFxyZXNvdXJjZXMuanNcIixcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCIsXCIuLi91dGlscy9lZGl0b3JcIjpcInV0aWxzXFxcXGVkaXRvci5qc1wifV0sXCJhY3Rpb25cXFxcbWFpbi5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogTW9kdWxlIGRlc2NyaWJlcyBhbmQgcGVyZm9ybXMgRW1tZXQgYWN0aW9ucy4gVGhlIGFjdGlvbnMgdGhlbXNlbHZlcyBhcmVcbiAqIGRlZmluZWQgaW4gPGk+YWN0aW9uczwvaT4gZm9sZGVyXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG5cdC8vIGFsbCByZWdpc3RlcmVkIGFjdGlvbnNcblx0dmFyIGFjdGlvbnMgPSB7fTtcblxuXHQvLyBsb2FkIGFsbCBkZWZhdWx0IGFjdGlvbnNcblx0dmFyIGFjdGlvbk1vZHVsZXMgPSB7XG5cdFx0YmFzZTY0OiByZXF1aXJlKCcuL2Jhc2U2NCcpLFxuXHRcdGVkaXRQb2ludHM6IHJlcXVpcmUoJy4vZWRpdFBvaW50cycpLFxuXHRcdGV2YWx1YXRlTWF0aDogcmVxdWlyZSgnLi9ldmFsdWF0ZU1hdGgnKSxcblx0XHRleHBhbmRBYmJyZXZpYXRpb246IHJlcXVpcmUoJy4vZXhwYW5kQWJicmV2aWF0aW9uJyksXG5cdFx0aW5jcmVtZW50RGVjcmVtZW50OiByZXF1aXJlKCcuL2luY3JlbWVudERlY3JlbWVudCcpLFxuXHRcdGxpbmVCcmVha3M6IHJlcXVpcmUoJy4vbGluZUJyZWFrcycpLFxuXHRcdGJhbGFuY2U6IHJlcXVpcmUoJy4vYmFsYW5jZScpLFxuXHRcdG1lcmdlTGluZXM6IHJlcXVpcmUoJy4vbWVyZ2VMaW5lcycpLFxuXHRcdHJlZmxlY3RDU1NWYWx1ZTogcmVxdWlyZSgnLi9yZWZsZWN0Q1NTVmFsdWUnKSxcblx0XHRyZW1vdmVUYWc6IHJlcXVpcmUoJy4vcmVtb3ZlVGFnJyksXG5cdFx0c2VsZWN0SXRlbTogcmVxdWlyZSgnLi9zZWxlY3RJdGVtJyksXG5cdFx0c2VsZWN0TGluZTogcmVxdWlyZSgnLi9zZWxlY3RMaW5lJyksXG5cdFx0c3BsaXRKb2luVGFnOiByZXF1aXJlKCcuL3NwbGl0Sm9pblRhZycpLFxuXHRcdHRvZ2dsZUNvbW1lbnQ6IHJlcXVpcmUoJy4vdG9nZ2xlQ29tbWVudCcpLFxuXHRcdHVwZGF0ZUltYWdlU2l6ZTogcmVxdWlyZSgnLi91cGRhdGVJbWFnZVNpemUnKSxcblx0XHR3cmFwV2l0aEFiYnJldmlhdGlvbjogcmVxdWlyZSgnLi93cmFwV2l0aEFiYnJldmlhdGlvbicpLFxuXHRcdHVwZGF0ZVRhZzogcmVxdWlyZSgnLi91cGRhdGVUYWcnKVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFkZEFjdGlvbihuYW1lLCBmbiwgb3B0aW9ucykge1xuXHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuXHRcdFx0b3B0aW9ucyA9IHtsYWJlbDogb3B0aW9uc307XG5cdFx0fVxuXG5cdFx0aWYgKCFvcHRpb25zLmxhYmVsKSB7XG5cdFx0XHRvcHRpb25zLmxhYmVsID0gaHVtYW5pemVBY3Rpb25OYW1lKG5hbWUpO1xuXHRcdH1cblx0XHRcblx0XHRhY3Rpb25zW25hbWVdID0ge1xuXHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdGZuOiBmbixcblx0XHRcdG9wdGlvbnM6IG9wdGlvbnNcblx0XHR9O1xuXHR9XG5cdFxuXHQvKipcblx0ICog4oCcSHVtYW5pemVz4oCdIGFjdGlvbiBuYW1lLCBtYWtlcyBpdCBtb3JlIHJlYWRhYmxlIGZvciBwZW9wbGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQWN0aW9uIG5hbWUgKGxpa2UgJ2V4cGFuZF9hYmJyZXZpYXRpb24nKVxuXHQgKiBAcmV0dXJuIEh1bWFuaXplZCBuYW1lIChsaWtlICdFeHBhbmQgQWJicmV2aWF0aW9uJylcblx0ICovXG5cdGZ1bmN0aW9uIGh1bWFuaXplQWN0aW9uTmFtZShuYW1lKSB7XG5cdFx0cmV0dXJuIHV0aWxzLnRyaW0obmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSBcblx0XHRcdCsgbmFtZS5zdWJzdHJpbmcoMSkucmVwbGFjZSgvX1thLXpdL2csIGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0XHRyZXR1cm4gJyAnICsgc3RyLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0fSkpO1xuXHR9XG5cblx0dmFyIGJpbmQgPSBmdW5jdGlvbihuYW1lLCBtZXRob2QpIHtcblx0XHR2YXIgbSA9IGFjdGlvbk1vZHVsZXNbbmFtZV07XG5cdFx0cmV0dXJuIG1bbWV0aG9kXS5iaW5kKG0pO1xuXHR9O1xuXG5cdC8vIFhYWCByZWdpc3RlciBkZWZhdWx0IGFjdGlvbnNcblx0YWRkQWN0aW9uKCdlbmNvZGVfZGVjb2RlX2RhdGFfdXJsJywgYmluZCgnYmFzZTY0JywgJ2VuY29kZURlY29kZURhdGFVcmxBY3Rpb24nKSwgJ0VuY29kZVxcXFxEZWNvZGUgZGF0YTpVUkwgaW1hZ2UnKTtcblx0YWRkQWN0aW9uKCdwcmV2X2VkaXRfcG9pbnQnLCBiaW5kKCdlZGl0UG9pbnRzJywgJ3ByZXZpb3VzRWRpdFBvaW50QWN0aW9uJyksICdQcmV2aW91cyBFZGl0IFBvaW50Jyk7XG5cdGFkZEFjdGlvbignbmV4dF9lZGl0X3BvaW50JywgYmluZCgnZWRpdFBvaW50cycsICduZXh0RWRpdFBvaW50QWN0aW9uJyksICdOZXh0IEVkaXQgUG9pbnQnKTtcblx0YWRkQWN0aW9uKCdldmFsdWF0ZV9tYXRoX2V4cHJlc3Npb24nLCBiaW5kKCdldmFsdWF0ZU1hdGgnLCAnZXZhbHVhdGVNYXRoQWN0aW9uJyksICdOdW1iZXJzL0V2YWx1YXRlIE1hdGggRXhwcmVzc2lvbicpO1xuXHRhZGRBY3Rpb24oJ2V4cGFuZF9hYmJyZXZpYXRpb25fd2l0aF90YWInLCBiaW5kKCdleHBhbmRBYmJyZXZpYXRpb24nLCAnZXhwYW5kQWJicmV2aWF0aW9uV2l0aFRhYkFjdGlvbicpLCB7aGlkZGVuOiB0cnVlfSk7XG5cdGFkZEFjdGlvbignZXhwYW5kX2FiYnJldmlhdGlvbicsIGJpbmQoJ2V4cGFuZEFiYnJldmlhdGlvbicsICdleHBhbmRBYmJyZXZpYXRpb25BY3Rpb24nKSwgJ0V4cGFuZCBBYmJyZXZpYXRpb24nKTtcblx0YWRkQWN0aW9uKCdpbnNlcnRfZm9ybWF0dGVkX2xpbmVfYnJlYWtfb25seScsIGJpbmQoJ2xpbmVCcmVha3MnLCAnaW5zZXJ0TGluZUJyZWFrT25seUFjdGlvbicpLCB7aGlkZGVuOiB0cnVlfSk7XG5cdGFkZEFjdGlvbignaW5zZXJ0X2Zvcm1hdHRlZF9saW5lX2JyZWFrJywgYmluZCgnbGluZUJyZWFrcycsICdpbnNlcnRMaW5lQnJlYWtBY3Rpb24nKSwge2hpZGRlbjogdHJ1ZX0pO1xuXHRhZGRBY3Rpb24oJ2JhbGFuY2VfaW53YXJkJywgYmluZCgnYmFsYW5jZScsICdiYWxhbmNlSW53YXJkQWN0aW9uJyksICdCYWxhbmNlIChpbndhcmQpJyk7XG5cdGFkZEFjdGlvbignYmFsYW5jZV9vdXR3YXJkJywgYmluZCgnYmFsYW5jZScsICdiYWxhbmNlT3V0d2FyZEFjdGlvbicpLCAnQmFsYW5jZSAob3V0d2FyZCknKTtcblx0YWRkQWN0aW9uKCdtYXRjaGluZ19wYWlyJywgYmluZCgnYmFsYW5jZScsICdnb1RvTWF0Y2hpbmdQYWlyQWN0aW9uJyksICdIVE1ML0dvIFRvIE1hdGNoaW5nIFRhZyBQYWlyJyk7XG5cdGFkZEFjdGlvbignbWVyZ2VfbGluZXMnLCBiaW5kKCdtZXJnZUxpbmVzJywgJ21lcmdlTGluZXNBY3Rpb24nKSwgJ01lcmdlIExpbmVzJyk7XG5cdGFkZEFjdGlvbigncmVmbGVjdF9jc3NfdmFsdWUnLCBiaW5kKCdyZWZsZWN0Q1NTVmFsdWUnLCAncmVmbGVjdENTU1ZhbHVlQWN0aW9uJyksICdDU1MvUmVmbGVjdCBWYWx1ZScpO1xuXHRhZGRBY3Rpb24oJ3JlbW92ZV90YWcnLCBiaW5kKCdyZW1vdmVUYWcnLCAncmVtb3ZlVGFnQWN0aW9uJyksICdIVE1ML1JlbW92ZSBUYWcnKTtcblx0YWRkQWN0aW9uKCdzZWxlY3RfbmV4dF9pdGVtJywgYmluZCgnc2VsZWN0SXRlbScsICdzZWxlY3ROZXh0SXRlbUFjdGlvbicpLCAnU2VsZWN0IE5leHQgSXRlbScpO1xuXHRhZGRBY3Rpb24oJ3NlbGVjdF9wcmV2aW91c19pdGVtJywgYmluZCgnc2VsZWN0SXRlbScsICdzZWxlY3RQcmV2aW91c0l0ZW1BY3Rpb24nKSwgJ1NlbGVjdCBQcmV2aW91cyBJdGVtJyk7XG5cdGFkZEFjdGlvbignc3BsaXRfam9pbl90YWcnLCBiaW5kKCdzcGxpdEpvaW5UYWcnLCAnc3BsaXRKb2luVGFnQWN0aW9uJyksICdIVE1ML1NwbGl0XFxcXEpvaW4gVGFnIERlY2xhcmF0aW9uJyk7XG5cdGFkZEFjdGlvbigndG9nZ2xlX2NvbW1lbnQnLCBiaW5kKCd0b2dnbGVDb21tZW50JywgJ3RvZ2dsZUNvbW1lbnRBY3Rpb24nKSwgJ1RvZ2dsZSBDb21tZW50Jyk7XG5cdGFkZEFjdGlvbigndXBkYXRlX2ltYWdlX3NpemUnLCBiaW5kKCd1cGRhdGVJbWFnZVNpemUnLCAndXBkYXRlSW1hZ2VTaXplQWN0aW9uJyksICdVcGRhdGUgSW1hZ2UgU2l6ZScpO1xuXHRhZGRBY3Rpb24oJ3dyYXBfd2l0aF9hYmJyZXZpYXRpb24nLCBiaW5kKCd3cmFwV2l0aEFiYnJldmlhdGlvbicsICd3cmFwV2l0aEFiYnJldmlhdGlvbkFjdGlvbicpLCAnV3JhcCBXaXRoIEFiYnJldmlhdGlvbicpO1xuXHRhZGRBY3Rpb24oJ3VwZGF0ZV90YWcnLCBiaW5kKCd1cGRhdGVUYWcnLCAndXBkYXRlVGFnQWN0aW9uJyksICdIVE1ML1VwZGF0ZSBUYWcnKTtcblxuXHRbMSwgLTEsIDEwLCAtMTAsIDAuMSwgLTAuMV0uZm9yRWFjaChmdW5jdGlvbihudW0pIHtcblx0XHR2YXIgcHJlZml4ID0gbnVtID4gMCA/ICdpbmNyZW1lbnQnIDogJ2RlY3JlbWVudCc7XG5cdFx0dmFyIHN1ZmZpeCA9IFN0cmluZyhNYXRoLmFicyhudW0pKS5yZXBsYWNlKCcuJywgJycpLnN1YnN0cmluZygwLCAyKTtcblx0XHR2YXIgYWN0aW9uSWQgPSBwcmVmaXggKyAnX251bWJlcl9ieV8nICsgc3VmZml4O1xuXHRcdHZhciBhY3Rpb25NZXRob2QgPSBwcmVmaXggKyBzdWZmaXggKyAnQWN0aW9uJztcblx0XHR2YXIgYWN0aW9uTGFiZWwgPSAnTnVtYmVycy8nICsgcHJlZml4LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJlZml4LnN1YnN0cmluZygxKSArICcgbnVtYmVyIGJ5ICcgKyBNYXRoLmFicyhudW0pO1xuXHRcdGFkZEFjdGlvbihhY3Rpb25JZCwgYmluZCgnaW5jcmVtZW50RGVjcmVtZW50JywgYWN0aW9uTWV0aG9kKSwgYWN0aW9uTGFiZWwpO1xuXHR9KTtcblx0XG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIG5ldyBhY3Rpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBBY3Rpb24gbmFtZVxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEFjdGlvbiBmdW5jdGlvblxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEN1c3RvbSBhY3Rpb24gb3B0aW9uczo8YnI+XG5cdFx0ICogPGI+bGFiZWw8L2I+IDogKDxjb2RlPlN0cmluZzwvY29kZT4pIOKAkyBIdW1hbi1yZWFkYWJsZSBhY3Rpb24gbmFtZS4gXG5cdFx0ICogTWF5IGNvbnRhaW4gJy8nIHN5bWJvbHMgYXMgc3VibWVudSBzZXBhcmF0b3JzPGJyPlxuXHRcdCAqIDxiPmhpZGRlbjwvYj4gOiAoPGNvZGU+Qm9vbGVhbjwvY29kZT4pIOKAkyBJbmRpY2F0ZXMgd2hldGhlciBhY3Rpb25cblx0XHQgKiBzaG91bGQgYmUgZGlzcGxheWVkIGluIG1lbnUgKDxjb2RlPmdldE1lbnUoKTwvY29kZT4gbWV0aG9kKVxuXHRcdCAqL1xuXHRcdGFkZDogYWRkQWN0aW9uLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYWN0aW9uIG9iamVjdFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEFjdGlvbiBuYW1lXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiBhY3Rpb25zW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSdW5zIEVtbWV0IGFjdGlvbi4gRm9yIGxpc3Qgb2YgYXZhaWxhYmxlIGFjdGlvbnMgYW5kIHRoZWlyXG5cdFx0ICogYXJndW1lbnRzIHNlZSA8aT5hY3Rpb25zPC9pPiBmb2xkZXIuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQWN0aW9uIG5hbWUgXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cy4gSXQgbWF5IGJlIGFycmF5IG9mIGFyZ3VtZW50c1xuXHRcdCAqIG9yIGlubGluZSBhcmd1bWVudHMuIFRoZSBmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgPGNvZGU+SUVtbWV0RWRpdG9yPC9jb2RlPiBpbnN0YW5jZVxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufSBTdGF0dXMgb2YgcGVyZm9ybWVkIG9wZXJhdGlvbiwgPGNvZGU+dHJ1ZTwvY29kZT5cblx0XHQgKiBtZWFucyBhY3Rpb24gd2FzIHBlcmZvcm1lZCBzdWNjZXNzZnVsbHkuXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiByZXF1aXJlKCdhY3Rpb24vbWFpbicpLnJ1bignZXhwYW5kX2FiYnJldmlhdGlvbicsIGVkaXRvcik7ICBcblx0XHQgKiByZXF1aXJlKCdhY3Rpb24vbWFpbicpLnJ1bignd3JhcF93aXRoX2FiYnJldmlhdGlvbicsIFtlZGl0b3IsICdkaXYnXSk7ICBcblx0XHQgKi9cblx0XHRydW46IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcblx0XHRcdGlmICghQXJyYXkuaXNBcnJheShhcmdzKSkge1xuXHRcdFx0XHRhcmdzID0gdXRpbHMudG9BcnJheShhcmd1bWVudHMsIDEpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgYWN0aW9uID0gdGhpcy5nZXQobmFtZSk7XG5cdFx0XHRpZiAoIWFjdGlvbikge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbiBcIicgKyBuYW1lICsgJ1wiIGlzIG5vdCBkZWZpbmVkJyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhY3Rpb24uZm4uYXBwbHkoYWN0aW9uLCBhcmdzKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgYWN0aW9ucyBhcyBvYmplY3Rcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gYWN0aW9ucztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgYWN0aW9ucyBhcyBhcnJheVxuXHRcdCAqIEByZXR1cm5zIHtBcnJheX1cblx0XHQgKi9cblx0XHRnZXRMaXN0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhbGwgPSB0aGlzLmdldEFsbCgpO1xuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKGFsbCkubWFwKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRyZXR1cm4gYWxsW2tleV07XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYWN0aW9ucyBsaXN0IGFzIHN0cnVjdHVyZWQgbWVudS4gSWYgYWN0aW9uIGhhcyA8aT5sYWJlbDwvaT4sXG5cdFx0ICogaXQgd2lsbCBiZSBzcGxpdHRlZCBieSAnLycgc3ltYm9sIGludG8gc3VibWVudXMgKGZvciBleGFtcGxlOiBcblx0XHQgKiBDU1MvUmVmbGVjdCBWYWx1ZSkgYW5kIGdyb3VwZWQgd2l0aCBvdGhlciBpdGVtc1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNraXBBY3Rpb25zIExpc3Qgb2YgYWN0aW9uIGlkZW50aWZpZXJzIHRoYXQgc2hvdWxkIGJlIFxuXHRcdCAqIHNraXBwZWQgZnJvbSBtZW51XG5cdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdCAqL1xuXHRcdGdldE1lbnU6IGZ1bmN0aW9uKHNraXBBY3Rpb25zKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHRza2lwQWN0aW9ucyA9IHNraXBBY3Rpb25zIHx8IFtdO1xuXHRcdFx0dGhpcy5nZXRMaXN0KCkuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcblx0XHRcdFx0aWYgKGFjdGlvbi5vcHRpb25zLmhpZGRlbiB8fCB+c2tpcEFjdGlvbnMuaW5kZXhPZihhY3Rpb24ubmFtZSkpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGFjdGlvbk5hbWUgPSBodW1hbml6ZUFjdGlvbk5hbWUoYWN0aW9uLm5hbWUpO1xuXHRcdFx0XHR2YXIgY3R4ID0gcmVzdWx0O1xuXHRcdFx0XHRpZiAoYWN0aW9uLm9wdGlvbnMubGFiZWwpIHtcblx0XHRcdFx0XHR2YXIgcGFydHMgPSBhY3Rpb24ub3B0aW9ucy5sYWJlbC5zcGxpdCgnLycpO1xuXHRcdFx0XHRcdGFjdGlvbk5hbWUgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBjcmVhdGUgc3VibWVudXMsIGlmIG5lZWRlZFxuXHRcdFx0XHRcdHZhciBtZW51TmFtZSwgc3VibWVudTtcblx0XHRcdFx0XHR3aGlsZSAoKG1lbnVOYW1lID0gcGFydHMuc2hpZnQoKSkpIHtcblx0XHRcdFx0XHRcdHN1Ym1lbnUgPSB1dGlscy5maW5kKGN0eCwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaXRlbS50eXBlID09ICdzdWJtZW51JyAmJiBpdGVtLm5hbWUgPT0gbWVudU5hbWU7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKCFzdWJtZW51KSB7XG5cdFx0XHRcdFx0XHRcdHN1Ym1lbnUgPSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogbWVudU5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogJ3N1Ym1lbnUnLFxuXHRcdFx0XHRcdFx0XHRcdGl0ZW1zOiBbXVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRjdHgucHVzaChzdWJtZW51KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y3R4ID0gc3VibWVudS5pdGVtcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGN0eC5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiAnYWN0aW9uJyxcblx0XHRcdFx0XHRuYW1lOiBhY3Rpb24ubmFtZSxcblx0XHRcdFx0XHRsYWJlbDogYWN0aW9uTmFtZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGFjdGlvbiBuYW1lIGFzc29jaWF0ZWQgd2l0aCBtZW51IGl0ZW0gdGl0bGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldEFjdGlvbk5hbWVGb3JNZW51VGl0bGU6IGZ1bmN0aW9uKHRpdGxlLCBtZW51KSB7XG5cdFx0XHRyZXR1cm4gdXRpbHMuZmluZChtZW51IHx8IHRoaXMuZ2V0TWVudSgpLCBmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0aWYgKHZhbC50eXBlID09ICdhY3Rpb24nKSB7XG5cdFx0XHRcdFx0aWYgKHZhbC5sYWJlbCA9PSB0aXRsZSB8fCB2YWwubmFtZSA9PSB0aXRsZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbC5uYW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRBY3Rpb25OYW1lRm9yTWVudVRpdGxlKHRpdGxlLCB2YWwuaXRlbXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4vYmFsYW5jZVwiOlwiYWN0aW9uXFxcXGJhbGFuY2UuanNcIixcIi4vYmFzZTY0XCI6XCJhY3Rpb25cXFxcYmFzZTY0LmpzXCIsXCIuL2VkaXRQb2ludHNcIjpcImFjdGlvblxcXFxlZGl0UG9pbnRzLmpzXCIsXCIuL2V2YWx1YXRlTWF0aFwiOlwiYWN0aW9uXFxcXGV2YWx1YXRlTWF0aC5qc1wiLFwiLi9leHBhbmRBYmJyZXZpYXRpb25cIjpcImFjdGlvblxcXFxleHBhbmRBYmJyZXZpYXRpb24uanNcIixcIi4vaW5jcmVtZW50RGVjcmVtZW50XCI6XCJhY3Rpb25cXFxcaW5jcmVtZW50RGVjcmVtZW50LmpzXCIsXCIuL2xpbmVCcmVha3NcIjpcImFjdGlvblxcXFxsaW5lQnJlYWtzLmpzXCIsXCIuL21lcmdlTGluZXNcIjpcImFjdGlvblxcXFxtZXJnZUxpbmVzLmpzXCIsXCIuL3JlZmxlY3RDU1NWYWx1ZVwiOlwiYWN0aW9uXFxcXHJlZmxlY3RDU1NWYWx1ZS5qc1wiLFwiLi9yZW1vdmVUYWdcIjpcImFjdGlvblxcXFxyZW1vdmVUYWcuanNcIixcIi4vc2VsZWN0SXRlbVwiOlwiYWN0aW9uXFxcXHNlbGVjdEl0ZW0uanNcIixcIi4vc2VsZWN0TGluZVwiOlwiYWN0aW9uXFxcXHNlbGVjdExpbmUuanNcIixcIi4vc3BsaXRKb2luVGFnXCI6XCJhY3Rpb25cXFxcc3BsaXRKb2luVGFnLmpzXCIsXCIuL3RvZ2dsZUNvbW1lbnRcIjpcImFjdGlvblxcXFx0b2dnbGVDb21tZW50LmpzXCIsXCIuL3VwZGF0ZUltYWdlU2l6ZVwiOlwiYWN0aW9uXFxcXHVwZGF0ZUltYWdlU2l6ZS5qc1wiLFwiLi91cGRhdGVUYWdcIjpcImFjdGlvblxcXFx1cGRhdGVUYWcuanNcIixcIi4vd3JhcFdpdGhBYmJyZXZpYXRpb25cIjpcImFjdGlvblxcXFx3cmFwV2l0aEFiYnJldmlhdGlvbi5qc1wifV0sXCJhY3Rpb25cXFxcbWVyZ2VMaW5lcy5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogTWVyZ2VzIHNlbGVjdGVkIGxpbmVzIG9yIGxpbmVzIGJldHdlZW4gWEhUTUwgdGFnIHBhaXJzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIGh0bWxNYXRjaGVyID0gcmVxdWlyZSgnLi4vYXNzZXRzL2h0bWxNYXRjaGVyJyk7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgZWRpdG9yVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9lZGl0b3InKTtcblx0dmFyIHJhbmdlID0gcmVxdWlyZSgnLi4vYXNzZXRzL3JhbmdlJyk7XG5cblx0cmV0dXJuIHtcblx0XHRtZXJnZUxpbmVzQWN0aW9uOiBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRcdHZhciBpbmZvID0gZWRpdG9yVXRpbHMub3V0cHV0SW5mbyhlZGl0b3IpO1xuXHRcdFxuXHRcdFx0dmFyIHNlbGVjdGlvbiA9IHJhbmdlKGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcblx0XHRcdGlmICghc2VsZWN0aW9uLmxlbmd0aCgpKSB7XG5cdFx0XHRcdC8vIGZpbmQgbWF0Y2hpbmcgdGFnXG5cdFx0XHRcdHZhciBwYWlyID0gaHRtbE1hdGNoZXIuZmluZChpbmZvLmNvbnRlbnQsIGVkaXRvci5nZXRDYXJldFBvcygpKTtcblx0XHRcdFx0aWYgKHBhaXIpIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBwYWlyLm91dGVyUmFuZ2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHNlbGVjdGlvbi5sZW5ndGgoKSkge1xuXHRcdFx0XHQvLyBnb3QgcmFuZ2UsIG1lcmdlIGxpbmVzXG5cdFx0XHRcdHZhciB0ZXh0ID0gIHNlbGVjdGlvbi5zdWJzdHJpbmcoaW5mby5jb250ZW50KTtcblx0XHRcdFx0dmFyIGxpbmVzID0gdXRpbHMuc3BsaXRCeUxpbmVzKHRleHQpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGxpbmVzW2ldID0gbGluZXNbaV0ucmVwbGFjZSgvXlxccysvLCAnJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHRleHQgPSBsaW5lcy5qb2luKCcnKS5yZXBsYWNlKC9cXHN7Mix9LywgJyAnKTtcblx0XHRcdFx0dmFyIHRleHRMZW4gPSB0ZXh0Lmxlbmd0aDtcblx0XHRcdFx0dGV4dCA9IHV0aWxzLmVzY2FwZVRleHQodGV4dCk7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlQ29udGVudCh0ZXh0LCBzZWxlY3Rpb24uc3RhcnQsIHNlbGVjdGlvbi5lbmQpO1xuXHRcdFx0XHRlZGl0b3IuY3JlYXRlU2VsZWN0aW9uKHNlbGVjdGlvbi5zdGFydCwgc2VsZWN0aW9uLnN0YXJ0ICsgdGV4dExlbik7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcbn0pO1xufSx7XCIuLi9hc3NldHMvaHRtbE1hdGNoZXJcIjpcImFzc2V0c1xcXFxodG1sTWF0Y2hlci5qc1wiLFwiLi4vYXNzZXRzL3JhbmdlXCI6XCJhc3NldHNcXFxccmFuZ2UuanNcIixcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCIsXCIuLi91dGlscy9lZGl0b3JcIjpcInV0aWxzXFxcXGVkaXRvci5qc1wifV0sXCJhY3Rpb25cXFxccmVmbGVjdENTU1ZhbHVlLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBSZWZsZWN0IENTUyB2YWx1ZTogdGFrZXMgcnVsZSdzIHZhbHVlIHVuZGVyIGNhcmV0IGFuZCBwYXN0ZXMgaXQgZm9yIHRoZSBzYW1lIFxuICogcnVsZXMgd2l0aCB2ZW5kb3IgcHJlZml4ZXNcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIGhhbmRsZXJMaXN0ID0gcmVxdWlyZSgnLi4vYXNzZXRzL2hhbmRsZXJMaXN0Jyk7XG5cdHZhciBwcmVmcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9wcmVmZXJlbmNlcycpO1xuXHR2YXIgY3NzUmVzb2x2ZXIgPSByZXF1aXJlKCcuLi9yZXNvbHZlci9jc3MnKTtcblx0dmFyIGNzc0VkaXRUcmVlID0gcmVxdWlyZSgnLi4vZWRpdFRyZWUvY3NzJyk7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgYWN0aW9uVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9hY3Rpb24nKTtcblx0dmFyIGVkaXRvclV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZWRpdG9yJyk7XG5cdHZhciBjc3NHcmFkaWVudCA9IHJlcXVpcmUoJy4uL3Jlc29sdmVyL2Nzc0dyYWRpZW50Jyk7XG5cblx0cHJlZnMuZGVmaW5lKCdjc3MucmVmbGVjdC5vbGRJRU9wYWNpdHknLCBmYWxzZSwgJ1N1cHBvcnQgSUU2LzcvOCBvcGFjaXR5IG5vdGF0aW9uLCBlLmcuIDxjb2RlPmZpbHRlcjphbHBoYShvcGFjaXR5PS4uLik8L2NvZGU+LlxcXG5cdFx0Tm90ZSB0aGF0IENTUzMgYW5kIFNWRyBhbHNvIHByb3ZpZGVzIDxjb2RlPmZpbHRlcjwvY29kZT4gcHJvcGVydHkgc28gdGhpcyBvcHRpb24gaXMgZGlzYWJsZWQgYnkgZGVmYXVsdC4nKVxuXG5cdC8qKlxuXHQgKiBAdHlwZSBIYW5kbGVyTGlzdCBMaXN0IG9mIHJlZ2lzdGVyZWQgaGFuZGxlcnNcblx0ICovXG5cdHZhciBoYW5kbGVycyA9IGhhbmRsZXJMaXN0LmNyZWF0ZSgpO1xuXHRcblx0ZnVuY3Rpb24gZG9DU1NSZWZsZWN0aW9uKGVkaXRvcikge1xuXHRcdHZhciBvdXRwdXRJbmZvID0gZWRpdG9yVXRpbHMub3V0cHV0SW5mbyhlZGl0b3IpO1xuXHRcdHZhciBjYXJldFBvcyA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdFxuXHRcdHZhciBjc3NSdWxlID0gY3NzRWRpdFRyZWUucGFyc2VGcm9tUG9zaXRpb24ob3V0cHV0SW5mby5jb250ZW50LCBjYXJldFBvcyk7XG5cdFx0aWYgKCFjc3NSdWxlKSByZXR1cm47XG5cdFx0XG5cdFx0dmFyIHByb3BlcnR5ID0gY3NzUnVsZS5pdGVtRnJvbVBvc2l0aW9uKGNhcmV0UG9zLCB0cnVlKTtcblx0XHQvLyBubyBwcm9wZXJ0eSB1bmRlciBjdXJzb3IsIG5vdGhpbmcgdG8gcmVmbGVjdFxuXHRcdGlmICghcHJvcGVydHkpIHJldHVybjtcblx0XHRcblx0XHR2YXIgb2xkUnVsZSA9IGNzc1J1bGUuc291cmNlO1xuXHRcdHZhciBvZmZzZXQgPSBjc3NSdWxlLm9wdGlvbnMub2Zmc2V0O1xuXHRcdHZhciBjYXJldERlbHRhID0gY2FyZXRQb3MgLSBvZmZzZXQgLSBwcm9wZXJ0eS5yYW5nZSgpLnN0YXJ0O1xuXHRcdFxuXHRcdGhhbmRsZXJzLmV4ZWMoZmFsc2UsIFtwcm9wZXJ0eV0pO1xuXHRcdFxuXHRcdGlmIChvbGRSdWxlICE9PSBjc3NSdWxlLnNvdXJjZSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogIGNzc1J1bGUuc291cmNlLFxuXHRcdFx0XHRzdGFydDogb2Zmc2V0LFxuXHRcdFx0XHRlbmQ6ICAgb2Zmc2V0ICsgb2xkUnVsZS5sZW5ndGgsXG5cdFx0XHRcdGNhcmV0OiBvZmZzZXQgKyBwcm9wZXJ0eS5yYW5nZSgpLnN0YXJ0ICsgY2FyZXREZWx0YVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHJlZ2V4cCB0aGF0IHNob3VsZCBtYXRjaCByZWZsZWN0ZWQgQ1NTIHByb3BlcnR5IG5hbWVzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEN1cnJlbnQgQ1NTIHByb3BlcnR5IG5hbWVcblx0ICogQHJldHVybiB7UmVnRXhwfVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UmVmbGVjdGVkQ1NTTmFtZShuYW1lKSB7XG5cdFx0bmFtZSA9IGNzc0VkaXRUcmVlLmJhc2VOYW1lKG5hbWUpO1xuXHRcdHZhciB2ZW5kb3JQcmVmaXggPSAnXig/OlxcXFwtXFxcXHcrXFxcXC0pPycsIG07XG5cdFx0XG5cdFx0aWYgKChuYW1lID09ICdvcGFjaXR5JyB8fCBuYW1lID09ICdmaWx0ZXInKSAmJiBwcmVmcy5nZXQoJ2Nzcy5yZWZsZWN0Lm9sZElFT3BhY2l0eScpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFJlZ0V4cCh2ZW5kb3JQcmVmaXggKyAnKD86b3BhY2l0eXxmaWx0ZXIpJCcpO1xuXHRcdH0gZWxzZSBpZiAoKG0gPSBuYW1lLm1hdGNoKC9eYm9yZGVyLXJhZGl1cy0odG9wfGJvdHRvbSkobGVmdHxyaWdodCkvKSkpIHtcblx0XHRcdC8vIE1vemlsbGEtc3R5bGUgYm9yZGVyIHJhZGl1c1xuXHRcdFx0cmV0dXJuIG5ldyBSZWdFeHAodmVuZG9yUHJlZml4ICsgJyg/OicgKyBuYW1lICsgJ3xib3JkZXItJyArIG1bMV0gKyAnLScgKyBtWzJdICsgJy1yYWRpdXMpJCcpO1xuXHRcdH0gZWxzZSBpZiAoKG0gPSBuYW1lLm1hdGNoKC9eYm9yZGVyLSh0b3B8Ym90dG9tKS0obGVmdHxyaWdodCktcmFkaXVzLykpKSB7IFxuXHRcdFx0cmV0dXJuIG5ldyBSZWdFeHAodmVuZG9yUHJlZml4ICsgJyg/OicgKyBuYW1lICsgJ3xib3JkZXItcmFkaXVzLScgKyBtWzFdICsgbVsyXSArICcpJCcpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbmV3IFJlZ0V4cCh2ZW5kb3JQcmVmaXggKyBuYW1lICsgJyQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWZsZWN0cyBpbm5lciBDU1MgcHJvcGVyaXRlcyBpbiBnaXZlbiB2YWx1ZVxuXHQgKiBhZ2FpbnMgbmFtZeKAmHMgdmVuZG9yIHByZWZpeC4gSW4gb3RoZXIgd29yZHMsIGl0IHRyaWVzXG5cdCAqIHRvIG1vZGlmeSBgdHJhbnNmb3JtIDAuMnMgbGluZWFyYCB2YWx1ZSBmb3IgYC13ZWJraXQtdHJhbnNpdGlvbmBcblx0ICogcHJvcGVydHlcblx0ICogQHBhcmFtICB7U3RyaW5nfSBuYW1lICBSZWNpZXZlciBDU1MgcHJvcGVydHkgbmFtZVxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiByZWZsZWN0VmFsdWVQYXJ0cyhuYW1lLCB2YWx1ZSkge1xuXHRcdC8vIGRldGVjdHMgYW5kIHVwZGF0ZXMgdmVuZG9yLXNwZWNpZmljIHByb3BlcnRpZXMgaW4gdmFsdWUsXG5cdFx0Ly8gZS5nLiAtd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtXG5cdFx0XG5cdFx0dmFyIHJlVmVuZG9yID0gL15cXC0oXFx3KylcXC0vO1xuXHRcdHZhciBwcm9wUHJlZml4ID0gcmVWZW5kb3IudGVzdChuYW1lKSA/IFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpIDogJyc7XG5cdFx0dmFyIHBhcnRzID0gY3NzRWRpdFRyZWUuZmluZFBhcnRzKHZhbHVlKTtcblxuXHRcdHBhcnRzLnJldmVyc2UoKTtcblx0XHRwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpIHtcblx0XHRcdHZhciBwYXJ0VmFsdWUgPSBwYXJ0LnN1YnN0cmluZyh2YWx1ZSkucmVwbGFjZShyZVZlbmRvciwgJycpO1xuXHRcdFx0dmFyIHByZWZpeGVzID0gY3NzUmVzb2x2ZXIudmVuZG9yUHJlZml4ZXMocGFydFZhbHVlKTtcblx0XHRcdGlmIChwcmVmaXhlcykge1xuXHRcdFx0XHQvLyBpZiBwcmVmaXhlcyBhcmUgbm90IG51bGwgdGhlbiBnaXZlbiB2YWx1ZSBjYW5cblx0XHRcdFx0Ly8gYmUgcmVzb2x2ZWQgYWdhaW5zdCBDYW4gSSBVc2UgZGF0YWJhc2UgYW5kIG1heSBvclxuXHRcdFx0XHQvLyBtYXkgbm90IGNvbnRhaW4gcHJlZml4ZWQgdmFyaWFudFxuXHRcdFx0XHRpZiAocHJvcFByZWZpeCAmJiB+cHJlZml4ZXMuaW5kZXhPZihwcm9wUHJlZml4KSkge1xuXHRcdFx0XHRcdHBhcnRWYWx1ZSA9ICctJyArIHByb3BQcmVmaXggKyAnLScgKyBwYXJ0VmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YWx1ZSA9IHV0aWxzLnJlcGxhY2VTdWJzdHJpbmcodmFsdWUsIHBhcnRWYWx1ZSwgcGFydCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZWZsZWN0cyB2YWx1ZSBmcm9tIDxjb2RlPmRvbm9yPC9jb2RlPiBpbnRvIDxjb2RlPnJlY2VpdmVyPC9jb2RlPlxuXHQgKiBAcGFyYW0ge0NTU1Byb3BlcnR5fSBkb25vciBEb25vciBDU1MgcHJvcGVydHkgZnJvbSB3aGljaCB2YWx1ZSBzaG91bGRcblx0ICogYmUgcmVmbGVjdGVkXG5cdCAqIEBwYXJhbSB7Q1NTUHJvcGVydHl9IHJlY2VpdmVyIFByb3BlcnR5IHRoYXQgc2hvdWxkIHJlY2VpdmUgcmVmbGVjdGVkIFxuXHQgKiB2YWx1ZSBmcm9tIGRvbm9yXG5cdCAqL1xuXHRmdW5jdGlvbiByZWZsZWN0VmFsdWUoZG9ub3IsIHJlY2VpdmVyKSB7XG5cdFx0dmFyIHZhbHVlID0gZ2V0UmVmbGVjdGVkVmFsdWUoZG9ub3IubmFtZSgpLCBkb25vci52YWx1ZSgpLCBcblx0XHRcdFx0cmVjZWl2ZXIubmFtZSgpLCByZWNlaXZlci52YWx1ZSgpKTtcblx0XHRcblx0XHR2YWx1ZSA9IHJlZmxlY3RWYWx1ZVBhcnRzKHJlY2VpdmVyLm5hbWUoKSwgdmFsdWUpO1xuXHRcdHJlY2VpdmVyLnZhbHVlKHZhbHVlKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmVmbGVjdGVkIGZvciA8Y29kZT5yZWZOYW1lPC9jb2RlPiBDU1MgcHJvcGVydHlcblx0ICogZnJvbSA8Y29kZT5jdXJOYW1lPC9jb2RlPiBwcm9wZXJ0eS4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGZvciBzcGVjaWFsIGNhc2VzLFxuXHQgKiB3aGVuIHRoZSBzYW1lIHJlc3VsdCBtdXN0IGJlIGFjaGlldmVkIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXMgZm9yIGRpZmZlcmVudFxuXHQgKiBicm93c2Vycy4gRm9yIGV4YW1wbGU6IG9w0LBjaXR5OjAuNTsg4oaSIGZpbHRlcjphbHBoYShvcGFjaXR5PTUwKTs8YnI+PGJyPlxuXHQgKiBcblx0ICogVGhpcyBmdW5jdGlvbiBkb2VzIHZhbHVlIGNvbnZlcnNpb24gYmV0d2VlbiBkaWZmZXJlbnQgQ1NTIHByb3BlcnRpZXNcblx0ICogXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjdXJOYW1lIEN1cnJlbnQgQ1NTIHByb3BlcnR5IG5hbWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGN1clZhbHVlIEN1cnJlbnQgQ1NTIHByb3BlcnR5IHZhbHVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByZWZOYW1lIFJlY2VpdmVyIENTUyBwcm9wZXJ0eSdzIG5hbWUgXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByZWZWYWx1ZSBSZWNlaXZlciBDU1MgcHJvcGVydHkncyB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IE5ldyB2YWx1ZSBmb3IgcmVjZWl2ZXIgcHJvcGVydHlcblx0ICovXG5cdGZ1bmN0aW9uIGdldFJlZmxlY3RlZFZhbHVlKGN1ck5hbWUsIGN1clZhbHVlLCByZWZOYW1lLCByZWZWYWx1ZSkge1xuXHRcdGN1ck5hbWUgPSBjc3NFZGl0VHJlZS5iYXNlTmFtZShjdXJOYW1lKTtcblx0XHRyZWZOYW1lID0gY3NzRWRpdFRyZWUuYmFzZU5hbWUocmVmTmFtZSk7XG5cdFx0XG5cdFx0aWYgKGN1ck5hbWUgPT0gJ29wYWNpdHknICYmIHJlZk5hbWUgPT0gJ2ZpbHRlcicpIHtcblx0XHRcdHJldHVybiByZWZWYWx1ZS5yZXBsYWNlKC9vcGFjaXR5PVteKV0qL2ksICdvcGFjaXR5PScgKyBNYXRoLmZsb29yKHBhcnNlRmxvYXQoY3VyVmFsdWUpICogMTAwKSk7XG5cdFx0fSBlbHNlIGlmIChjdXJOYW1lID09ICdmaWx0ZXInICYmIHJlZk5hbWUgPT0gJ29wYWNpdHknKSB7XG5cdFx0XHR2YXIgbSA9IGN1clZhbHVlLm1hdGNoKC9vcGFjaXR5PShbXildKikvaSk7XG5cdFx0XHRyZXR1cm4gbSA/IHV0aWxzLnByZXR0aWZ5TnVtYmVyKHBhcnNlSW50KG1bMV0sIDEwKSAvIDEwMCkgOiByZWZWYWx1ZTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGN1clZhbHVlO1xuXHR9XG5cdFxuXHRtb2R1bGUgPSBtb2R1bGUgfHwge307XG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHRcdHJlZmxlY3RDU1NWYWx1ZUFjdGlvbjogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldFN5bnRheCgpICE9ICdjc3MnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFjdGlvblV0aWxzLmNvbXBvdW5kVXBkYXRlKGVkaXRvciwgZG9DU1NSZWZsZWN0aW9uKGVkaXRvcikpO1xuXHRcdH0sXG5cblx0XHRfZGVmYXVsdEhhbmRsZXI6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG5cdFx0XHR2YXIgcmVOYW1lID0gZ2V0UmVmbGVjdGVkQ1NTTmFtZShwcm9wZXJ0eS5uYW1lKCkpO1xuXHRcdFx0cHJvcGVydHkucGFyZW50Lmxpc3QoKS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKHJlTmFtZS50ZXN0KHAubmFtZSgpKSkge1xuXHRcdFx0XHRcdHJlZmxlY3RWYWx1ZShwcm9wZXJ0eSwgcCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGRzIGN1c3RvbSByZWZsZWN0IGhhbmRsZXIuIFRoZSBwYXNzZWQgZnVuY3Rpb24gd2lsbCByZWNlaXZlIG1hdGNoZWRcblx0XHQgKiBDU1MgcHJvcGVydHkgKGFzIDxjb2RlPkNTU0VkaXRFbGVtZW50PC9jb2RlPiBvYmplY3QpIGFuZCBzaG91bGRcblx0XHQgKiByZXR1cm4gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgaXQgd2FzIHBlcmZvcm1lZCBzdWNjZXNzZnVsbHkgKGhhbmRsZWQgXG5cdFx0ICogcmVmbGVjdGlvbiksIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqL1xuXHRcdGFkZEhhbmRsZXI6IGZ1bmN0aW9uKGZuLCBvcHRpb25zKSB7XG5cdFx0XHRoYW5kbGVycy5hZGQoZm4sIG9wdGlvbnMpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyByZWdpc3RlcmVkIGhhbmRsZXJcblx0XHQgKiBAcmV0dXJuc1xuXHRcdCAqL1xuXHRcdHJlbW92ZUhhbmRsZXI6IGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHRoYW5kbGVycy5yZW1vdmUoZm4pO1xuXHRcdH1cblx0fTtcblxuXHQvLyBYWFggYWRkIGRlZmF1bHQgaGFuZGxlcnNcblx0aGFuZGxlcnMuYWRkKG1vZHVsZS5leHBvcnRzLl9kZWZhdWx0SGFuZGxlci5iaW5kKG1vZHVsZS5leHBvcnRzKSwge29yZGVyOiAtMX0pO1xuXHRoYW5kbGVycy5hZGQoY3NzR3JhZGllbnQucmVmbGVjdFZhbHVlSGFuZGxlci5iaW5kKGNzc0dyYWRpZW50KSk7XG5cblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufSk7XG59LHtcIi4uL2Fzc2V0cy9oYW5kbGVyTGlzdFwiOlwiYXNzZXRzXFxcXGhhbmRsZXJMaXN0LmpzXCIsXCIuLi9hc3NldHMvcHJlZmVyZW5jZXNcIjpcImFzc2V0c1xcXFxwcmVmZXJlbmNlcy5qc1wiLFwiLi4vZWRpdFRyZWUvY3NzXCI6XCJlZGl0VHJlZVxcXFxjc3MuanNcIixcIi4uL3Jlc29sdmVyL2Nzc1wiOlwicmVzb2x2ZXJcXFxcY3NzLmpzXCIsXCIuLi9yZXNvbHZlci9jc3NHcmFkaWVudFwiOlwicmVzb2x2ZXJcXFxcY3NzR3JhZGllbnQuanNcIixcIi4uL3V0aWxzL2FjdGlvblwiOlwidXRpbHNcXFxcYWN0aW9uLmpzXCIsXCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi4vdXRpbHMvZWRpdG9yXCI6XCJ1dGlsc1xcXFxlZGl0b3IuanNcIn1dLFwiYWN0aW9uXFxcXHJlbW92ZVRhZy5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogR3JhY2VmdWxseSByZW1vdmVzIHRhZyB1bmRlciBjdXJzb3JcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciBlZGl0b3JVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2VkaXRvcicpO1xuXHR2YXIgaHRtbE1hdGNoZXIgPSByZXF1aXJlKCcuLi9hc3NldHMvaHRtbE1hdGNoZXInKTtcblxuXHRyZXR1cm4ge1xuXHRcdHJlbW92ZVRhZ0FjdGlvbjogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHR2YXIgaW5mbyA9IGVkaXRvclV0aWxzLm91dHB1dEluZm8oZWRpdG9yKTtcblx0XHRcdFxuXHRcdFx0Ly8gc2VhcmNoIGZvciB0YWdcblx0XHRcdHZhciB0YWcgPSBodG1sTWF0Y2hlci50YWcoaW5mby5jb250ZW50LCBlZGl0b3IuZ2V0Q2FyZXRQb3MoKSk7XG5cdFx0XHRpZiAodGFnKSB7XG5cdFx0XHRcdGlmICghdGFnLmNsb3NlKSB7XG5cdFx0XHRcdFx0Ly8gc2ltcGx5IHJlbW92ZSB1bmFyeSB0YWdcblx0XHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQodXRpbHMuZ2V0Q2FyZXRQbGFjZWhvbGRlcigpLCB0YWcucmFuZ2Uuc3RhcnQsIHRhZy5yYW5nZS5lbmQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSB0YWcgYW5kIGl0cyBuZXdsaW5lc1xuXHRcdFx0XHRcdC8qKiBAdHlwZSBSYW5nZSAqL1xuXHRcdFx0XHRcdHZhciB0YWdDb250ZW50UmFuZ2UgPSB1dGlscy5uYXJyb3dUb05vblNwYWNlKGluZm8uY29udGVudCwgdGFnLmlubmVyUmFuZ2UpO1xuXHRcdFx0XHRcdC8qKiBAdHlwZSBSYW5nZSAqL1xuXHRcdFx0XHRcdHZhciBzdGFydExpbmVCb3VuZHMgPSB1dGlscy5maW5kTmV3bGluZUJvdW5kcyhpbmZvLmNvbnRlbnQsIHRhZ0NvbnRlbnRSYW5nZS5zdGFydCk7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0TGluZVBhZCA9IHV0aWxzLmdldExpbmVQYWRkaW5nKHN0YXJ0TGluZUJvdW5kcy5zdWJzdHJpbmcoaW5mby5jb250ZW50KSk7XG5cdFx0XHRcdFx0dmFyIHRhZ0NvbnRlbnQgPSB0YWdDb250ZW50UmFuZ2Uuc3Vic3RyaW5nKGluZm8uY29udGVudCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dGFnQ29udGVudCA9IHV0aWxzLnVuaW5kZW50U3RyaW5nKHRhZ0NvbnRlbnQsIHN0YXJ0TGluZVBhZCk7XG5cdFx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KHV0aWxzLmdldENhcmV0UGxhY2Vob2xkZXIoKSArIHV0aWxzLmVzY2FwZVRleHQodGFnQ29udGVudCksIHRhZy5vdXRlclJhbmdlLnN0YXJ0LCB0YWcub3V0ZXJSYW5nZS5lbmQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcbn0pO1xuXG59LHtcIi4uL2Fzc2V0cy9odG1sTWF0Y2hlclwiOlwiYXNzZXRzXFxcXGh0bWxNYXRjaGVyLmpzXCIsXCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi4vdXRpbHMvZWRpdG9yXCI6XCJ1dGlsc1xcXFxlZGl0b3IuanNcIn1dLFwiYWN0aW9uXFxcXHNlbGVjdEl0ZW0uanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEFjdGlvbnMgdGhhdCB1c2Ugc3RyZWFtIHBhcnNlcnMgYW5kIHRva2VuaXplcnMgZm9yIHRyYXZlcnNpbmc6XG4gKiAtLSBTZWFyY2ggZm9yIG5leHQvcHJldmlvdXMgaXRlbXMgaW4gSFRNTFxuICogLS0gU2VhcmNoIGZvciBuZXh0L3ByZXZpb3VzIGl0ZW1zIGluIENTU1xuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgcmFuZ2UgPSByZXF1aXJlKCcuLi9hc3NldHMvcmFuZ2UnKTtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciBlZGl0b3JVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2VkaXRvcicpO1xuXHR2YXIgYWN0aW9uVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9hY3Rpb24nKTtcblx0dmFyIHN0cmluZ1N0cmVhbSA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9zdHJpbmdTdHJlYW0nKTtcblx0dmFyIHhtbFBhcnNlciA9IHJlcXVpcmUoJy4uL3BhcnNlci94bWwnKTtcblx0dmFyIGNzc0VkaXRUcmVlID0gcmVxdWlyZSgnLi4vZWRpdFRyZWUvY3NzJyk7XG5cdHZhciBjc3NTZWN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWxzL2Nzc1NlY3Rpb25zJyk7XG5cblx0dmFyIHN0YXJ0VGFnID0gL148KFtcXHdcXDpcXC1dKykoKD86XFxzK1tcXHdcXC06XSsoPzpcXHMqPVxccyooPzooPzpcIlteXCJdKlwiKXwoPzonW14nXSonKXxbXj5cXHNdKykpPykqKVxccyooXFwvPyk+LztcblxuXHQvKipcblx0ICogR2VuZXJpYyBmdW5jdGlvbiBmb3Igc2VhcmNoaW5nIGZvciBpdGVtcyB0byBzZWxlY3Rcblx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmFja3dhcmQgU2VhcmNoIGJhY2t3YXJkIChzZWFyY2ggZm9yd2FyZCBvdGhlcndpc2UpXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGV4dHJhY3RGbiBGdW5jdGlvbiB0aGF0IGV4dHJhY3RzIGl0ZW0gY29udGVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSByYW5nZUZuIEZ1bmN0aW9uIHRoYXQgc2VhcmNoIGZvciBuZXh0IHRva2VuIHJhbmdlXG5cdCAqL1xuXHRmdW5jdGlvbiBmaW5kSXRlbShlZGl0b3IsIGlzQmFja3dhcmQsIGV4dHJhY3RGbiwgcmFuZ2VGbikge1xuXHRcdHZhciBjb250ZW50ID0gZWRpdG9yVXRpbHMub3V0cHV0SW5mbyhlZGl0b3IpLmNvbnRlbnQ7XG5cdFx0XG5cdFx0dmFyIGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcblx0XHR2YXIgaXRlbVJhbmdlLCBybmc7XG5cdFx0LyoqIEB0eXBlIFJhbmdlICovXG5cdFx0dmFyIHByZXZSYW5nZSA9IHJhbmdlKC0xLCAwKTtcblx0XHQvKiogQHR5cGUgUmFuZ2UgKi9cblx0XHR2YXIgc2VsID0gcmFuZ2UoZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuXHRcdFxuXHRcdHZhciBzZWFyY2hQb3MgPSBzZWwuc3RhcnQsIGxvb3AgPSAxMDAwMDA7IC8vIGVuZGxlc3MgbG9vcCBwcm90ZWN0aW9uXG5cdFx0d2hpbGUgKHNlYXJjaFBvcyA+PSAwICYmIHNlYXJjaFBvcyA8IGNvbnRlbnRMZW5ndGggJiYgLS1sb29wID4gMCkge1xuXHRcdFx0aWYgKCAoaXRlbVJhbmdlID0gZXh0cmFjdEZuKGNvbnRlbnQsIHNlYXJjaFBvcywgaXNCYWNrd2FyZCkpICkge1xuXHRcdFx0XHRpZiAocHJldlJhbmdlLmVxdWFsKGl0ZW1SYW5nZSkpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cHJldlJhbmdlID0gaXRlbVJhbmdlLmNsb25lKCk7XG5cdFx0XHRcdHJuZyA9IHJhbmdlRm4oaXRlbVJhbmdlLnN1YnN0cmluZyhjb250ZW50KSwgaXRlbVJhbmdlLnN0YXJ0LCBzZWwuY2xvbmUoKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocm5nKSB7XG5cdFx0XHRcdFx0ZWRpdG9yLmNyZWF0ZVNlbGVjdGlvbihybmcuc3RhcnQsIHJuZy5lbmQpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlYXJjaFBvcyA9IGlzQmFja3dhcmQgPyBpdGVtUmFuZ2Uuc3RhcnQgOiBpdGVtUmFuZ2UuZW5kIC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRzZWFyY2hQb3MgKz0gaXNCYWNrd2FyZCA/IC0xIDogMTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdFxuXHQvLyBYWFggSFRNTCBzZWN0aW9uXG5cdFxuXHQvKipcblx0ICogRmluZCBuZXh0IEhUTUwgaXRlbVxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBmaW5kTmV4dEhUTUxJdGVtKGVkaXRvcikge1xuXHRcdHZhciBpc0ZpcnN0ID0gdHJ1ZTtcblx0XHRyZXR1cm4gZmluZEl0ZW0oZWRpdG9yLCBmYWxzZSwgZnVuY3Rpb24oY29udGVudCwgc2VhcmNoUG9zKXtcblx0XHRcdGlmIChpc0ZpcnN0KSB7XG5cdFx0XHRcdGlzRmlyc3QgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIGZpbmRPcGVuaW5nVGFnRnJvbVBvc2l0aW9uKGNvbnRlbnQsIHNlYXJjaFBvcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZ2V0T3BlbmluZ1RhZ0Zyb21Qb3NpdGlvbihjb250ZW50LCBzZWFyY2hQb3MpO1xuXHRcdFx0fVxuXHRcdH0sIGZ1bmN0aW9uKHRhZywgb2Zmc2V0LCBzZWxSYW5nZSkge1xuXHRcdFx0cmV0dXJuIGdldFJhbmdlRm9ySFRNTEl0ZW0odGFnLCBvZmZzZXQsIHNlbFJhbmdlLCBmYWxzZSk7XG5cdFx0fSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBGaW5kIHByZXZpb3VzIEhUTUwgaXRlbVxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBmaW5kUHJldkhUTUxJdGVtKGVkaXRvcikge1xuXHRcdHJldHVybiBmaW5kSXRlbShlZGl0b3IsIHRydWUsIGdldE9wZW5pbmdUYWdGcm9tUG9zaXRpb24sIGZ1bmN0aW9uICh0YWcsIG9mZnNldCwgc2VsUmFuZ2UpIHtcblx0XHRcdHJldHVybiBnZXRSYW5nZUZvckhUTUxJdGVtKHRhZywgb2Zmc2V0LCBzZWxSYW5nZSwgdHJ1ZSk7XG5cdFx0fSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDcmVhdGVzIHBvc3NpYmxlIHNlbGVjdGlvbiByYW5nZXMgZm9yIEhUTUwgdGFnXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgT3JpZ2luYWwgSFRNTCBzb3VyY2UgZm9yIHRva2Vuc1xuXHQgKiBAcGFyYW0ge0FycmF5fSB0b2tlbnMgTGlzdCBvZiBIVE1MIHRva2Vuc1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRmdW5jdGlvbiBtYWtlUG9zc2libGVSYW5nZXNIVE1MKHNvdXJjZSwgdG9rZW5zLCBvZmZzZXQpIHtcblx0XHRvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0dmFyIGF0dHJTdGFydCA9IC0xLCBhdHRyTmFtZSA9ICcnLCBhdHRyVmFsdWUgPSAnJywgYXR0clZhbHVlUmFuZ2UsIHRhZ05hbWU7XG5cdFx0dG9rZW5zLmZvckVhY2goZnVuY3Rpb24odG9rKSB7XG5cdFx0XHRzd2l0Y2ggKHRvay50eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ3RhZyc6XG5cdFx0XHRcdFx0dGFnTmFtZSA9IHNvdXJjZS5zdWJzdHJpbmcodG9rLnN0YXJ0LCB0b2suZW5kKTtcblx0XHRcdFx0XHRpZiAoL148W1xcd1xcOlxcLV0vLnRlc3QodGFnTmFtZSkpIHtcblx0XHRcdFx0XHRcdC8vIGFkZCB0YWcgbmFtZVxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2gocmFuZ2Uoe1xuXHRcdFx0XHRcdFx0XHRzdGFydDogdG9rLnN0YXJ0ICsgMSwgXG5cdFx0XHRcdFx0XHRcdGVuZDogdG9rLmVuZFxuXHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnYXR0cmlidXRlJzpcblx0XHRcdFx0XHRhdHRyU3RhcnQgPSB0b2suc3RhcnQ7XG5cdFx0XHRcdFx0YXR0ck5hbWUgPSBzb3VyY2Uuc3Vic3RyaW5nKHRvay5zdGFydCwgdG9rLmVuZCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRcdFx0Ly8gYXR0cmlidXRlIHZhbHVlXG5cdFx0XHRcdFx0Ly8gcHVzaCBmdWxsIGF0dHJpYnV0ZSBmaXJzdFxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHJhbmdlKGF0dHJTdGFydCwgdG9rLmVuZCAtIGF0dHJTdGFydCkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGF0dHJWYWx1ZVJhbmdlID0gcmFuZ2UodG9rKTtcblx0XHRcdFx0XHRhdHRyVmFsdWUgPSBhdHRyVmFsdWVSYW5nZS5zdWJzdHJpbmcoc291cmNlKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBpcyB0aGlzIGEgcXVvdGVkIGF0dHJpYnV0ZT9cblx0XHRcdFx0XHRpZiAoaXNRdW90ZShhdHRyVmFsdWUuY2hhckF0KDApKSlcblx0XHRcdFx0XHRcdGF0dHJWYWx1ZVJhbmdlLnN0YXJ0Kys7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGlzUXVvdGUoYXR0clZhbHVlLmNoYXJBdChhdHRyVmFsdWUubGVuZ3RoIC0gMSkpKVxuXHRcdFx0XHRcdFx0YXR0clZhbHVlUmFuZ2UuZW5kLS07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goYXR0clZhbHVlUmFuZ2UpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChhdHRyTmFtZSA9PSAnY2xhc3MnKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSByZXN1bHQuY29uY2F0KGNsYXNzTmFtZVJhbmdlcyhhdHRyVmFsdWVSYW5nZS5zdWJzdHJpbmcoc291cmNlKSwgYXR0clZhbHVlUmFuZ2Uuc3RhcnQpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0XG5cdFx0Ly8gb2Zmc2V0IHJhbmdlc1xuXHRcdHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKGl0ZW0ubGVuZ3RoKCkpIHtcblx0XHRcdFx0aXRlbS5zaGlmdChvZmZzZXQpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIHJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0cmV0dXJuIHV0aWxzLnVuaXF1ZShyZXN1bHQsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG5cdFx0fSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHJhbmdlcyBvZiBjbGFzcyBuYW1lcyBpbiBcImNsYXNzXCIgYXR0cmlidXRlIHZhbHVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gY2xhc3NOYW1lUmFuZ2VzKGNsYXNzTmFtZSwgb2Zmc2V0KSB7XG5cdFx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdC8qKiBAdHlwZSBTdHJpbmdTdHJlYW0gKi9cblx0XHR2YXIgc3RyZWFtID0gc3RyaW5nU3RyZWFtLmNyZWF0ZShjbGFzc05hbWUpO1xuXHRcdFxuXHRcdC8vIHNraXAgd2hpdGVzcGFjZVxuXHRcdHN0cmVhbS5lYXRTcGFjZSgpO1xuXHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XG5cdFx0dmFyIGNoO1xuXHRcdHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSkge1xuXHRcdFx0aWYgKC9bXFxzXFx1MDBhMF0vLnRlc3QoY2gpKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKHJhbmdlKHN0cmVhbS5zdGFydCArIG9mZnNldCwgc3RyZWFtLnBvcyAtIHN0cmVhbS5zdGFydCAtIDEpKTtcblx0XHRcdFx0c3RyZWFtLmVhdFNwYWNlKCk7XG5cdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJlc3VsdC5wdXNoKHJhbmdlKHN0cmVhbS5zdGFydCArIG9mZnNldCwgc3RyZWFtLnBvcyAtIHN0cmVhbS5zdGFydCkpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGJlc3QgSFRNTCB0YWcgcmFuZ2UgbWF0Y2ggZm9yIGN1cnJlbnQgc2VsZWN0aW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0YWcgVGFnIGRlY2xhcmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGFnJ3MgcG9zaXRpb24gaW5kZXggaW5zaWRlIGNvbnRlbnRcblx0ICogQHBhcmFtIHtSYW5nZX0gc2VsUmFuZ2UgU2VsZWN0aW9uIHJhbmdlXG5cdCAqIEByZXR1cm4ge1JhbmdlfSBSZXR1cm5zIHJhbmdlIGlmIG5leHQgaXRlbSB3YXMgZm91bmQsIDxjb2RlPm51bGw8L2NvZGU+IG90aGVyd2lzZVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UmFuZ2VGb3JIVE1MSXRlbSh0YWcsIG9mZnNldCwgc2VsUmFuZ2UsIGlzQmFja3dhcmQpIHtcblx0XHR2YXIgcmFuZ2VzID0gbWFrZVBvc3NpYmxlUmFuZ2VzSFRNTCh0YWcsIHhtbFBhcnNlci5wYXJzZSh0YWcpLCBvZmZzZXQpO1xuXHRcdFxuXHRcdGlmIChpc0JhY2t3YXJkKVxuXHRcdFx0cmFuZ2VzLnJldmVyc2UoKTtcblx0XHRcblx0XHQvLyB0cnkgdG8gZmluZCBzZWxlY3RlZCByYW5nZVxuXHRcdHZhciBjdXJSYW5nZSA9IHV0aWxzLmZpbmQocmFuZ2VzLCBmdW5jdGlvbihyKSB7XG5cdFx0XHRyZXR1cm4gci5lcXVhbChzZWxSYW5nZSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0aWYgKGN1clJhbmdlKSB7XG5cdFx0XHR2YXIgaXggPSByYW5nZXMuaW5kZXhPZihjdXJSYW5nZSk7XG5cdFx0XHRpZiAoaXggPCByYW5nZXMubGVuZ3RoIC0gMSlcblx0XHRcdFx0cmV0dXJuIHJhbmdlc1tpeCArIDFdO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gbm8gc2VsZWN0ZWQgcmFuZ2UsIGZpbmQgbmVhcmVzdCBvbmVcblx0XHRpZiAoaXNCYWNrd2FyZClcblx0XHRcdC8vIHNlYXJjaCBiYWNrd2FyZFxuXHRcdFx0cmV0dXJuIHV0aWxzLmZpbmQocmFuZ2VzLCBmdW5jdGlvbihyKSB7XG5cdFx0XHRcdHJldHVybiByLnN0YXJ0IDwgc2VsUmFuZ2Uuc3RhcnQ7XG5cdFx0XHR9KTtcblx0XHRcblx0XHQvLyBzZWFyY2ggZm9yd2FyZFxuXHRcdC8vIHRvIGRlYWwgd2l0aCBvdmVybGFwcGluZyByYW5nZXMgKGxpa2UgZnVsbCBhdHRyaWJ1dGUgZGVmaW5pdGlvblxuXHRcdC8vIGFuZCBhdHRyaWJ1dGUgdmFsdWUpIGxldCdzIGZpbmQgcmFuZ2UgdW5kZXIgY2FyZXQgZmlyc3Rcblx0XHRpZiAoIWN1clJhbmdlKSB7XG5cdFx0XHR2YXIgbWF0Y2hlZFJhbmdlcyA9IHJhbmdlcy5maWx0ZXIoZnVuY3Rpb24ocikge1xuXHRcdFx0XHRyZXR1cm4gci5pbnNpZGUoc2VsUmFuZ2UuZW5kKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAobWF0Y2hlZFJhbmdlcy5sZW5ndGggPiAxKVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hlZFJhbmdlc1sxXTtcblx0XHR9XG5cdFx0XG5cdFx0XG5cdFx0cmV0dXJuIHV0aWxzLmZpbmQocmFuZ2VzLCBmdW5jdGlvbihyKSB7XG5cdFx0XHRyZXR1cm4gci5lbmQgPiBzZWxSYW5nZS5lbmQ7XG5cdFx0fSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBTZWFyY2ggZm9yIG9wZW5pbmcgdGFnIGluIGNvbnRlbnQsIHN0YXJ0aW5nIGF0IHNwZWNpZmllZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBXaGVyZSB0byBzZWFyY2ggdGFnXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgQ2hhcmFjdGVyIGluZGV4IHdoZXJlIHRvIHN0YXJ0IHNlYXJjaGluZ1xuXHQgKiBAcmV0dXJuIHtSYW5nZX0gUmV0dXJucyByYW5nZSBpZiB2YWxpZCBvcGVuaW5nIHRhZyB3YXMgZm91bmQsXG5cdCAqIDxjb2RlPm51bGw8L2NvZGU+IG90aGVyd2lzZVxuXHQgKi9cblx0ZnVuY3Rpb24gZmluZE9wZW5pbmdUYWdGcm9tUG9zaXRpb24oaHRtbCwgcG9zKSB7XG5cdFx0dmFyIHRhZztcblx0XHR3aGlsZSAocG9zID49IDApIHtcblx0XHRcdGlmICgodGFnID0gZ2V0T3BlbmluZ1RhZ0Zyb21Qb3NpdGlvbihodG1sLCBwb3MpKSlcblx0XHRcdFx0cmV0dXJuIHRhZztcblx0XHRcdHBvcy0tO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFdoZXJlIHRvIHNlYXJjaCB0YWdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvcyBDaGFyYWN0ZXIgaW5kZXggd2hlcmUgdG8gc3RhcnQgc2VhcmNoaW5nXG5cdCAqIEByZXR1cm4ge1JhbmdlfSBSZXR1cm5zIHJhbmdlIGlmIHZhbGlkIG9wZW5pbmcgdGFnIHdhcyBmb3VuZCxcblx0ICogPGNvZGU+bnVsbDwvY29kZT4gb3RoZXJ3aXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRPcGVuaW5nVGFnRnJvbVBvc2l0aW9uKGh0bWwsIHBvcykge1xuXHRcdHZhciBtO1xuXHRcdGlmIChodG1sLmNoYXJBdChwb3MpID09ICc8JyAmJiAobSA9IGh0bWwuc3Vic3RyaW5nKHBvcywgaHRtbC5sZW5ndGgpLm1hdGNoKHN0YXJ0VGFnKSkpIHtcblx0XHRcdHJldHVybiByYW5nZShwb3MsIG1bMF0pO1xuXHRcdH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gaXNRdW90ZShjaCkge1xuXHRcdHJldHVybiBjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIHJhbmdlcyBpbnNpZGUgZ2l2ZW4gcnVsZSwgYXZhaWxhYmxlIGZvciBzZWxlY3Rpb25cblx0ICogQHBhcmFtICB7Q1NTRWRpdENvbnRhaW5lcn0gcnVsZVxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIGZpbmRJbm5lclJhbmdlcyhydWxlKSB7XG5cdFx0Ly8gcnVsZSBzZWxlY3RvclxuXHRcdHZhciByYW5nZXMgPSBbcnVsZS5uYW1lUmFuZ2UodHJ1ZSldO1xuXG5cdFx0Ly8gZmluZCBuZXN0ZWQgc2VjdGlvbnMsIGtlZXAgc2VsZWN0b3JzIG9ubHlcblx0XHR2YXIgbmVzdGVkU2VjdGlvbnMgPSBjc3NTZWN0aW9ucy5uZXN0ZWRTZWN0aW9uc0luUnVsZShydWxlKTtcblx0XHRuZXN0ZWRTZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlY3Rpb24pIHtcblx0XHRcdHJhbmdlcy5wdXNoKHJhbmdlLmNyZWF0ZTIoc2VjdGlvbi5zdGFydCwgc2VjdGlvbi5fc2VsZWN0b3JFbmQpKTtcblx0XHR9KTtcblxuXHRcdC8vIGFkZCBmdWxsIHByb3BlcnR5IHJhbmdlcyBhbmQgdmFsdWVzXG5cdFx0cnVsZS5saXN0KCkuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuXHRcdFx0cmFuZ2VzID0gcmFuZ2VzLmNvbmNhdChtYWtlUG9zc2libGVSYW5nZXNDU1MocHJvcGVydHkpKTtcblx0XHR9KTtcblxuXHRcdHJhbmdlcyA9IHJhbmdlLnNvcnQocmFuZ2VzKTtcblxuXHRcdC8vIG9wdGltaXplIHJlc3VsdDogcmVtb3ZlIGVtcHR5IHJhbmdlcyBhbmQgZHVwbGljYXRlc1xuXHRcdHJhbmdlcyA9IHJhbmdlcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuICEhaXRlbS5sZW5ndGgoKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdXRpbHMudW5pcXVlKHJhbmdlcywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcblx0XHR9KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIE1ha2VzIGFsbCBwb3NzaWJsZSBzZWxlY3Rpb24gcmFuZ2VzIGZvciBzcGVjaWZpZWQgQ1NTIHByb3BlcnR5XG5cdCAqIEBwYXJhbSB7Q1NTUHJvcGVydHl9IHByb3BlcnR5XG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIG1ha2VQb3NzaWJsZVJhbmdlc0NTUyhwcm9wZXJ0eSkge1xuXHRcdC8vIGZpbmQgYWxsIHBvc3NpYmxlIHJhbmdlcywgc29ydGVkIGJ5IHBvc2l0aW9uIGFuZCBzaXplXG5cdFx0dmFyIHZhbHVlUmFuZ2UgPSBwcm9wZXJ0eS52YWx1ZVJhbmdlKHRydWUpO1xuXHRcdHZhciByZXN1bHQgPSBbcHJvcGVydHkucmFuZ2UodHJ1ZSksIHZhbHVlUmFuZ2VdO1xuXHRcdFxuXHRcdC8vIGxvY2F0ZSBwYXJ0cyBvZiBjb21wbGV4IHZhbHVlcy5cblx0XHQvLyBzb21lIGV4YW1wbGVzOlxuXHRcdC8vIOKAkyAxcHggc29saWQgcmVkOiAzIHBhcnRzXG5cdFx0Ly8g4oCTIGFyaWFsLCBzYW5zLXNlcmlmOiBlbnVtZXJhdGlvbiwgMiBwYXJ0c1xuXHRcdC8vIOKAkyB1cmwoaW1hZ2UucG5nKTogZnVuY3Rpb24gdmFsdWUgcGFydFxuXHRcdHZhciB2YWx1ZSA9IHByb3BlcnR5LnZhbHVlKCk7XG5cdFx0cHJvcGVydHkudmFsdWVQYXJ0cygpLmZvckVhY2goZnVuY3Rpb24ocikge1xuXHRcdFx0Ly8gYWRkIGFic29sdXRlIHJhbmdlXG5cdFx0XHR2YXIgY2xvbmUgPSByLmNsb25lKCk7XG5cdFx0XHRyZXN1bHQucHVzaChjbG9uZS5zaGlmdCh2YWx1ZVJhbmdlLnN0YXJ0KSk7XG5cdFx0XHRcblx0XHRcdC8qKiBAdHlwZSBTdHJpbmdTdHJlYW0gKi9cblx0XHRcdHZhciBzdHJlYW0gPSBzdHJpbmdTdHJlYW0uY3JlYXRlKHIuc3Vic3RyaW5nKHZhbHVlKSk7XG5cdFx0XHRpZiAoc3RyZWFtLm1hdGNoKC9eW1xcd1xcLV0rXFwoLywgdHJ1ZSkpIHtcblx0XHRcdFx0Ly8gd2UgaGF2ZSBhIGZ1bmN0aW9uLCBmaW5kIHZhbHVlcyBpbiBpdC5cblx0XHRcdFx0Ly8gYnV0IGZpcnN0IGFkZCBmdW5jdGlvbiBjb250ZW50c1xuXHRcdFx0XHRzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuXHRcdFx0XHRzdHJlYW0uYmFja1VwKDEpO1xuXHRcdFx0XHRzdHJlYW0uc2tpcFRvUGFpcignKCcsICcpJyk7XG5cdFx0XHRcdHN0cmVhbS5iYWNrVXAoMSk7XG5cdFx0XHRcdHZhciBmbkJvZHkgPSBzdHJlYW0uY3VycmVudCgpO1xuXHRcdFx0XHRyZXN1bHQucHVzaChyYW5nZShjbG9uZS5zdGFydCArIHN0cmVhbS5zdGFydCwgZm5Cb2R5KSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBmaW5kIHBhcnRzXG5cdFx0XHRcdGNzc0VkaXRUcmVlLmZpbmRQYXJ0cyhmbkJvZHkpLmZvckVhY2goZnVuY3Rpb24ocGFydCkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHJhbmdlKGNsb25lLnN0YXJ0ICsgc3RyZWFtLnN0YXJ0ICsgcGFydC5zdGFydCwgcGFydC5zdWJzdHJpbmcoZm5Cb2R5KSkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBUcmllcyB0byBmaW5kIG1hdGNoZWQgQ1NTIHByb3BlcnR5IGFuZCBuZWFyZXN0IHJhbmdlIGZvciBzZWxlY3Rpb25cblx0ICogQHBhcmFtIHtDU1NSdWxlfSBydWxlXG5cdCAqIEBwYXJhbSB7UmFuZ2V9IHNlbFJhbmdlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCYWNrd2FyZFxuXHQgKiBAcmV0dXJucyB7UmFuZ2V9XG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaGVkUmFuZ2VGb3JDU1NQcm9wZXJ0eShydWxlLCBzZWxSYW5nZSwgaXNCYWNrd2FyZCkge1xuXHRcdHZhciByYW5nZXMgPSBmaW5kSW5uZXJSYW5nZXMocnVsZSk7XG5cdFx0aWYgKGlzQmFja3dhcmQpIHtcblx0XHRcdHJhbmdlcy5yZXZlcnNlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIHJldHVybiBuZXh0IHRvIHNlbGVjdGVkIHJhbmdlLCBpZiBwb3NzaWJsZVxuXHRcdHZhciByID0gdXRpbHMuZmluZChyYW5nZXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHJldHVybiBpdGVtLmVxdWFsKHNlbFJhbmdlKTtcblx0XHR9KTtcblxuXHRcdGlmIChyKSB7XG5cdFx0XHRyZXR1cm4gcmFuZ2VzW3Jhbmdlcy5pbmRleE9mKHIpICsgMV07XG5cdFx0fVxuXG5cdFx0Ly8gZmluZCBtYXRjaGVkIGFuZCAocG9zc2libHkpIG92ZXJsYXBwaW5nIHJhbmdlc1xuXHRcdHZhciBuZXN0ZWQgPSByYW5nZXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHJldHVybiBpdGVtLmluc2lkZShzZWxSYW5nZS5lbmQpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKG5lc3RlZC5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBuZXN0ZWQuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhLmxlbmd0aCgpIC0gYi5sZW5ndGgoKTtcblx0XHRcdH0pWzBdO1xuXHRcdH1cblxuXHRcdC8vIHJldHVybiByYW5nZSBuZXh0IHRvIGNhcmV0XG5cdFx0dmFyIHRlc3QgPSBcblx0XHRyID0gdXRpbHMuZmluZChyYW5nZXMsIGlzQmFja3dhcmQgXG5cdFx0XHQ/IGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbS5lbmQgPCBzZWxSYW5nZS5zdGFydDt9XG5cdFx0XHQ6IGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbS5lbmQgPiBzZWxSYW5nZS5zdGFydDt9XG5cdFx0KTtcblxuXHRcdGlmICghcikge1xuXHRcdFx0Ly8gY2Fu4oCZdCBmaW5kIGFueXRoaW5nLCBqdXN0IHBpY2sgZmlyc3Qgb25lXG5cdFx0XHRyID0gcmFuZ2VzWzBdO1xuXHRcdH1cblxuXHRcdHJldHVybiByO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBmaW5kTmV4dENTU0l0ZW0oZWRpdG9yKSB7XG5cdFx0cmV0dXJuIGZpbmRJdGVtKGVkaXRvciwgZmFsc2UsIGNzc1NlY3Rpb25zLmxvY2F0ZVJ1bGUuYmluZChjc3NTZWN0aW9ucyksIGdldFJhbmdlRm9yTmV4dEl0ZW1JbkNTUyk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGZpbmRQcmV2Q1NTSXRlbShlZGl0b3IpIHtcblx0XHRyZXR1cm4gZmluZEl0ZW0oZWRpdG9yLCB0cnVlLCBjc3NTZWN0aW9ucy5sb2NhdGVSdWxlLmJpbmQoY3NzU2VjdGlvbnMpLCBnZXRSYW5nZUZvclByZXZJdGVtSW5DU1MpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyByYW5nZSBmb3IgaXRlbSB0byBiZSBzZWxlY3RlZCBpbiBDU1MgYWZ0ZXIgY3VycmVudCBjYXJldCBcblx0ICogKHNlbGVjdGlvbikgcG9zaXRpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IHJ1bGUgQ1NTIHJ1bGUgZGVjbGFyYXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBSdWxlJ3MgcG9zaXRpb24gaW5kZXggaW5zaWRlIGNvbnRlbnRcblx0ICogQHBhcmFtIHtSYW5nZX0gc2VsUmFuZ2UgU2VsZWN0aW9uIHJhbmdlXG5cdCAqIEByZXR1cm4ge1JhbmdlfSBSZXR1cm5zIHJhbmdlIGlmIG5leHQgaXRlbSB3YXMgZm91bmQsIDxjb2RlPm51bGw8L2NvZGU+IG90aGVyd2lzZVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UmFuZ2VGb3JOZXh0SXRlbUluQ1NTKHJ1bGUsIG9mZnNldCwgc2VsUmFuZ2UpIHtcblx0XHR2YXIgdHJlZSA9IGNzc0VkaXRUcmVlLnBhcnNlKHJ1bGUsIHtcblx0XHRcdG9mZnNldDogb2Zmc2V0XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gbWF0Y2hlZFJhbmdlRm9yQ1NTUHJvcGVydHkodHJlZSwgc2VsUmFuZ2UsIGZhbHNlKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgcmFuZ2UgZm9yIGl0ZW0gdG8gYmUgc2VsZWN0ZWQgaW4gQ1NTIGJlZm9yZSBjdXJyZW50IGNhcmV0IFxuXHQgKiAoc2VsZWN0aW9uKSBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcnVsZSBDU1MgcnVsZSBkZWNsYXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFJ1bGUncyBwb3NpdGlvbiBpbmRleCBpbnNpZGUgY29udGVudFxuXHQgKiBAcGFyYW0ge1JhbmdlfSBzZWxSYW5nZSBTZWxlY3Rpb24gcmFuZ2Vcblx0ICogQHJldHVybiB7UmFuZ2V9IFJldHVybnMgcmFuZ2UgaWYgcHJldmlvdXMgaXRlbSB3YXMgZm91bmQsIDxjb2RlPm51bGw8L2NvZGU+IG90aGVyd2lzZVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UmFuZ2VGb3JQcmV2SXRlbUluQ1NTKHJ1bGUsIG9mZnNldCwgc2VsUmFuZ2UpIHtcblx0XHR2YXIgdHJlZSA9IGNzc0VkaXRUcmVlLnBhcnNlKHJ1bGUsIHtcblx0XHRcdG9mZnNldDogb2Zmc2V0XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gbWF0Y2hlZFJhbmdlRm9yQ1NTUHJvcGVydHkodHJlZSwgc2VsUmFuZ2UsIHRydWUpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzZWxlY3ROZXh0SXRlbUFjdGlvbjogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHRpZiAoYWN0aW9uVXRpbHMuaXNTdXBwb3J0ZWRDU1MoZWRpdG9yLmdldFN5bnRheCgpKSkge1xuXHRcdFx0XHRyZXR1cm4gZmluZE5leHRDU1NJdGVtKGVkaXRvcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZmluZE5leHRIVE1MSXRlbShlZGl0b3IpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZWxlY3RQcmV2aW91c0l0ZW1BY3Rpb246IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0aWYgKGFjdGlvblV0aWxzLmlzU3VwcG9ydGVkQ1NTKGVkaXRvci5nZXRTeW50YXgoKSkpIHtcblx0XHRcdFx0cmV0dXJuIGZpbmRQcmV2Q1NTSXRlbShlZGl0b3IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZpbmRQcmV2SFRNTEl0ZW0oZWRpdG9yKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vYXNzZXRzL3JhbmdlXCI6XCJhc3NldHNcXFxccmFuZ2UuanNcIixcIi4uL2Fzc2V0cy9zdHJpbmdTdHJlYW1cIjpcImFzc2V0c1xcXFxzdHJpbmdTdHJlYW0uanNcIixcIi4uL2VkaXRUcmVlL2Nzc1wiOlwiZWRpdFRyZWVcXFxcY3NzLmpzXCIsXCIuLi9wYXJzZXIveG1sXCI6XCJwYXJzZXJcXFxceG1sLmpzXCIsXCIuLi91dGlscy9hY3Rpb25cIjpcInV0aWxzXFxcXGFjdGlvbi5qc1wiLFwiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4uL3V0aWxzL2Nzc1NlY3Rpb25zXCI6XCJ1dGlsc1xcXFxjc3NTZWN0aW9ucy5qc1wiLFwiLi4vdXRpbHMvZWRpdG9yXCI6XCJ1dGlsc1xcXFxlZGl0b3IuanNcIn1dLFwiYWN0aW9uXFxcXHNlbGVjdExpbmUuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFNlbGVjdCBjdXJyZW50IGxpbmUgKGZvciBzaW1wbGUgZWRpdG9ycyBsaWtlIGJyb3dzZXIncyAmbHQ7dGV4dGFyZWEmZ3Q7KVxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHRyZXR1cm4ge1xuXHRcdHNlbGVjdExpbmVBY3Rpb246IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0dmFyIHJhbmdlID0gZWRpdG9yLmdldEN1cnJlbnRMaW5lUmFuZ2UoKTtcblx0XHRcdGVkaXRvci5jcmVhdGVTZWxlY3Rpb24ocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH07XG59KTtcbn0se31dLFwiYWN0aW9uXFxcXHNwbGl0Sm9pblRhZy5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogU3BsaXRzIG9yIGpvaW5zIHRhZywgZS5nLiB0cmFuc2Zvcm1zIGl0IGludG8gYSBzaG9ydCBub3RhdGlvbiBhbmQgdmljZSB2ZXJzYTo8YnI+XG4gKiAmbHQ7ZGl2Jmd0OyZsdDsvZGl2Jmd0OyDihpIgJmx0O2RpdiAvJmd0OyA6IGpvaW48YnI+XG4gKiAmbHQ7ZGl2IC8mZ3Q7IOKGkiAmbHQ7ZGl2Jmd0OyZsdDsvZGl2Jmd0OyA6IHNwbGl0XG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgcmVzb3VyY2VzID0gcmVxdWlyZSgnLi4vYXNzZXRzL3Jlc291cmNlcycpO1xuXHR2YXIgbWF0Y2hlciA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9odG1sTWF0Y2hlcicpO1xuXHR2YXIgZWRpdG9yVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9lZGl0b3InKTtcblx0dmFyIHByb2ZpbGUgPSByZXF1aXJlKCcuLi9hc3NldHMvcHJvZmlsZScpO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9maWxlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YWdcblx0ICovXG5cdGZ1bmN0aW9uIGpvaW5UYWcoZWRpdG9yLCBwcm9maWxlLCB0YWcpIHtcblx0XHQvLyBlbXB0eSBjbG9zaW5nIHNsYXNoIGlzIGEgbm9uc2Vuc2UgZm9yIHRoaXMgYWN0aW9uXG5cdFx0dmFyIHNsYXNoID0gcHJvZmlsZS5zZWxmQ2xvc2luZygpIHx8ICcgLyc7XG5cdFx0dmFyIGNvbnRlbnQgPSB0YWcub3Blbi5yYW5nZS5zdWJzdHJpbmcodGFnLnNvdXJjZSkucmVwbGFjZSgvXFxzKj4kLywgc2xhc2ggKyAnPicpO1xuXHRcdFxuXHRcdHZhciBjYXJldFBvcyA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdFxuXHRcdC8vIHVwZGF0ZSBjYXJldCBwb3NpdGlvblxuXHRcdGlmIChjb250ZW50Lmxlbmd0aCArIHRhZy5vdXRlclJhbmdlLnN0YXJ0IDwgY2FyZXRQb3MpIHtcblx0XHRcdGNhcmV0UG9zID0gY29udGVudC5sZW5ndGggKyB0YWcub3V0ZXJSYW5nZS5zdGFydDtcblx0XHR9XG5cdFx0XG5cdFx0Y29udGVudCA9IHV0aWxzLmVzY2FwZVRleHQoY29udGVudCk7XG5cdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KGNvbnRlbnQsIHRhZy5vdXRlclJhbmdlLnN0YXJ0LCB0YWcub3V0ZXJSYW5nZS5lbmQpO1xuXHRcdGVkaXRvci5zZXRDYXJldFBvcyhjYXJldFBvcyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHNwbGl0VGFnKGVkaXRvciwgcHJvZmlsZSwgdGFnKSB7XG5cdFx0dmFyIGNhcmV0UG9zID0gZWRpdG9yLmdldENhcmV0UG9zKCk7XG5cdFx0XG5cdFx0Ly8gZGVmaW5lIHRhZyBjb250ZW50IGRlcGVuZGluZyBvbiBwcm9maWxlXG5cdFx0dmFyIHRhZ0NvbnRlbnQgPSAocHJvZmlsZS50YWdfbmwgPT09IHRydWUpID8gJ1xcblxcdFxcbicgOiAnJztcblx0XHR2YXIgY29udGVudCA9IHRhZy5vdXRlckNvbnRlbnQoKS5yZXBsYWNlKC9cXHMqXFwvPiQvLCAnPicpO1xuXHRcdGNhcmV0UG9zID0gdGFnLm91dGVyUmFuZ2Uuc3RhcnQgKyBjb250ZW50Lmxlbmd0aDtcblx0XHRjb250ZW50ICs9IHRhZ0NvbnRlbnQgKyAnPC8nICsgdGFnLm9wZW4ubmFtZSArICc+Jztcblx0XHRcblx0XHRjb250ZW50ID0gdXRpbHMuZXNjYXBlVGV4dChjb250ZW50KTtcblx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQoY29udGVudCwgdGFnLm91dGVyUmFuZ2Uuc3RhcnQsIHRhZy5vdXRlclJhbmdlLmVuZCk7XG5cdFx0ZWRpdG9yLnNldENhcmV0UG9zKGNhcmV0UG9zKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c3BsaXRKb2luVGFnQWN0aW9uOiBmdW5jdGlvbihlZGl0b3IsIHByb2ZpbGVOYW1lKSB7XG5cdFx0XHR2YXIgaW5mbyA9IGVkaXRvclV0aWxzLm91dHB1dEluZm8oZWRpdG9yLCBudWxsLCBwcm9maWxlTmFtZSk7XG5cdFx0XHR2YXIgY3VyUHJvZmlsZSA9IHByb2ZpbGUuZ2V0KGluZm8ucHJvZmlsZSk7XG5cdFx0XHRcblx0XHRcdC8vIGZpbmQgdGFnIGF0IGN1cnJlbnQgcG9zaXRpb25cblx0XHRcdHZhciB0YWcgPSBtYXRjaGVyLnRhZyhpbmZvLmNvbnRlbnQsIGVkaXRvci5nZXRDYXJldFBvcygpKTtcblx0XHRcdGlmICh0YWcpIHtcblx0XHRcdFx0cmV0dXJuIHRhZy5jbG9zZSBcblx0XHRcdFx0XHQ/IGpvaW5UYWcoZWRpdG9yLCBjdXJQcm9maWxlLCB0YWcpIFxuXHRcdFx0XHRcdDogc3BsaXRUYWcoZWRpdG9yLCBjdXJQcm9maWxlLCB0YWcpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xufSk7XG59LHtcIi4uL2Fzc2V0cy9odG1sTWF0Y2hlclwiOlwiYXNzZXRzXFxcXGh0bWxNYXRjaGVyLmpzXCIsXCIuLi9hc3NldHMvcHJvZmlsZVwiOlwiYXNzZXRzXFxcXHByb2ZpbGUuanNcIixcIi4uL2Fzc2V0cy9yZXNvdXJjZXNcIjpcImFzc2V0c1xcXFxyZXNvdXJjZXMuanNcIixcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCIsXCIuLi91dGlscy9lZGl0b3JcIjpcInV0aWxzXFxcXGVkaXRvci5qc1wifV0sXCJhY3Rpb25cXFxcdG9nZ2xlQ29tbWVudC5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogVG9nZ2xlcyBIVE1MIGFuZCBDU1MgY29tbWVudHMgZGVwZW5kaW5nIG9uIGN1cnJlbnQgY2FyZXQgY29udGV4dC4gVW5saWtlXG4gKiB0aGUgc2FtZSBhY3Rpb24gaW4gbW9zdCBlZGl0b3JzLCB0aGlzIGFjdGlvbiB0b2dnbGVzIGNvbW1lbnQgb24gY3VycmVudGx5XG4gKiBtYXRjaGVkIGl0ZW3igJRIVE1MIHRhZyBvciBDU1Mgc2VsZWN0b3LigJR3aGVuIG5vdGhpbmcgaXMgc2VsZWN0ZWQuXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBwcmVmcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9wcmVmZXJlbmNlcycpO1xuXHR2YXIgcmFuZ2UgPSByZXF1aXJlKCcuLi9hc3NldHMvcmFuZ2UnKTtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciBhY3Rpb25VdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2FjdGlvbicpO1xuXHR2YXIgZWRpdG9yVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9lZGl0b3InKTtcblx0dmFyIGh0bWxNYXRjaGVyID0gcmVxdWlyZSgnLi4vYXNzZXRzL2h0bWxNYXRjaGVyJyk7XG5cdHZhciBjc3NFZGl0VHJlZSA9IHJlcXVpcmUoJy4uL2VkaXRUcmVlL2NzcycpO1xuXG5cdC8qKlxuXHQgKiBUb2dnbGUgSFRNTCBjb21tZW50IG9uIGN1cnJlbnQgc2VsZWN0aW9uIG9yIHRhZ1xuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgY29tbWVudCB3YXMgdG9nZ2xlZFxuXHQgKi9cblx0ZnVuY3Rpb24gdG9nZ2xlSFRNTENvbW1lbnQoZWRpdG9yKSB7XG5cdFx0LyoqIEB0eXBlIFJhbmdlICovXG5cdFx0dmFyIHIgPSByYW5nZShlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XG5cdFx0dmFyIGluZm8gPSBlZGl0b3JVdGlscy5vdXRwdXRJbmZvKGVkaXRvcik7XG5cdFx0XHRcblx0XHRpZiAoIXIubGVuZ3RoKCkpIHtcblx0XHRcdC8vIG5vIHNlbGVjdGlvbiwgZmluZCBtYXRjaGluZyB0YWdcblx0XHRcdHZhciB0YWcgPSBodG1sTWF0Y2hlci50YWcoaW5mby5jb250ZW50LCBlZGl0b3IuZ2V0Q2FyZXRQb3MoKSk7XG5cdFx0XHRpZiAodGFnKSB7IC8vIGZvdW5kIHBhaXJcblx0XHRcdFx0ciA9IHRhZy5vdXRlclJhbmdlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZ2VuZXJpY0NvbW1lbnRUb2dnbGUoZWRpdG9yLCAnPCEtLScsICctLT4nLCByKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTaW1wbGUgQ1NTIGNvbW1lbnRpbmdcblx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIGNvbW1lbnQgd2FzIHRvZ2dsZWRcblx0ICovXG5cdGZ1bmN0aW9uIHRvZ2dsZUNTU0NvbW1lbnQoZWRpdG9yKSB7XG5cdFx0LyoqIEB0eXBlIFJhbmdlICovXG5cdFx0dmFyIHJuZyA9IHJhbmdlKGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcblx0XHR2YXIgaW5mbyA9IGVkaXRvclV0aWxzLm91dHB1dEluZm8oZWRpdG9yKTtcblx0XHRcdFxuXHRcdGlmICghcm5nLmxlbmd0aCgpKSB7XG5cdFx0XHQvLyBubyBzZWxlY3Rpb24sIHRyeSB0byBnZXQgY3VycmVudCBydWxlXG5cdFx0XHQvKiogQHR5cGUgQ1NTUnVsZSAqL1xuXHRcdFx0dmFyIHJ1bGUgPSBjc3NFZGl0VHJlZS5wYXJzZUZyb21Qb3NpdGlvbihpbmZvLmNvbnRlbnQsIGVkaXRvci5nZXRDYXJldFBvcygpKTtcblx0XHRcdGlmIChydWxlKSB7XG5cdFx0XHRcdHZhciBwcm9wZXJ0eSA9IGNzc0l0ZW1Gcm9tUG9zaXRpb24ocnVsZSwgZWRpdG9yLmdldENhcmV0UG9zKCkpO1xuXHRcdFx0XHRybmcgPSBwcm9wZXJ0eSBcblx0XHRcdFx0XHQ/IHByb3BlcnR5LnJhbmdlKHRydWUpIFxuXHRcdFx0XHRcdDogcmFuZ2UocnVsZS5uYW1lUmFuZ2UodHJ1ZSkuc3RhcnQsIHJ1bGUuc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0aWYgKCFybmcubGVuZ3RoKCkpIHtcblx0XHRcdC8vIHN0aWxsIG5vIHNlbGVjdGlvbiwgZ2V0IGN1cnJlbnQgbGluZVxuXHRcdFx0cm5nID0gcmFuZ2UoZWRpdG9yLmdldEN1cnJlbnRMaW5lUmFuZ2UoKSk7XG5cdFx0XHR1dGlscy5uYXJyb3dUb05vblNwYWNlKGluZm8uY29udGVudCwgcm5nKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGdlbmVyaWNDb21tZW50VG9nZ2xlKGVkaXRvciwgJy8qJywgJyovJywgcm5nKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgQ1NTIHByb3BlcnR5IGZyb20gPGNvZGU+cnVsZTwvY29kZT4gdGhhdCBtYXRjaGVzIHBhc3NlZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge0VkaXRDb250YWluZXJ9IHJ1bGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFic1Bvc1xuXHQgKiBAcmV0dXJucyB7RWRpdEVsZW1lbnR9XG5cdCAqL1xuXHRmdW5jdGlvbiBjc3NJdGVtRnJvbVBvc2l0aW9uKHJ1bGUsIGFic1Bvcykge1xuXHRcdC8vIGRvIG5vdCB1c2UgZGVmYXVsdCBFZGl0Q29udGFpbmVyLml0ZW1Gcm9tUG9zaXRpb24oKSBoZXJlLCBiZWNhdXNlXG5cdFx0Ly8gd2UgbmVlZCB0byBtYWtlIGEgZmV3IGFzc3VtcHRpb25zIHRvIG1ha2UgQ1NTIGNvbW1lbnRpbmcgbW9yZSByZWxpYWJsZVxuXHRcdHZhciByZWxQb3MgPSBhYnNQb3MgLSAocnVsZS5vcHRpb25zLm9mZnNldCB8fCAwKTtcblx0XHR2YXIgcmVTYWZlQ2hhciA9IC9eW1xcc1xcblxccl0vO1xuXHRcdHJldHVybiB1dGlscy5maW5kKHJ1bGUubGlzdCgpLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoaXRlbS5yYW5nZSgpLmVuZCA9PT0gcmVsUG9zKSB7XG5cdFx0XHRcdC8vIGF0IHRoZSBlbmQgb2YgcHJvcGVydHksIGJ1dCBvdXRzaWRlIG9mIGl0XG5cdFx0XHRcdC8vIGlmIHRoZXJl4oCZcyBhIHNwYWNlIGNoYXJhY3RlciBhdCBjdXJyZW50IHBvc2l0aW9uLFxuXHRcdFx0XHQvLyB1c2UgY3VycmVudCBwcm9wZXJ0eVxuXHRcdFx0XHRyZXR1cm4gcmVTYWZlQ2hhci50ZXN0KHJ1bGUuc291cmNlLmNoYXJBdChyZWxQb3MpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGl0ZW0ucmFuZ2UoKS5pbnNpZGUocmVsUG9zKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWFyY2ggZm9yIG5lYXJlc3QgY29tbWVudCBpbiA8Y29kZT5zdHI8L2NvZGU+LCBzdGFydGluZyBmcm9tIGluZGV4IDxjb2RlPmZyb208L2NvZGU+XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFdoZXJlIHRvIHNlYXJjaFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJvbSBTZWFyY2ggc3RhcnQgaW5kZXhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0YXJ0X3Rva2VuIENvbW1lbnQgc3RhcnQgc3RyaW5nXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBlbmRfdG9rZW4gQ29tbWVudCBlbmQgc3RyaW5nXG5cdCAqIEByZXR1cm4ge1JhbmdlfSBSZXR1cm5zIG51bGwgaWYgY29tbWVudCB3YXNuJ3QgZm91bmRcblx0ICovXG5cdGZ1bmN0aW9uIHNlYXJjaENvbW1lbnQodGV4dCwgZnJvbSwgc3RhcnRUb2tlbiwgZW5kVG9rZW4pIHtcblx0XHR2YXIgY29tbWVudFN0YXJ0ID0gLTE7XG5cdFx0dmFyIGNvbW1lbnRFbmQgPSAtMTtcblx0XHRcblx0XHR2YXIgaGFzTWF0Y2ggPSBmdW5jdGlvbihzdHIsIHN0YXJ0KSB7XG5cdFx0XHRyZXR1cm4gdGV4dC5zdWJzdHIoc3RhcnQsIHN0ci5sZW5ndGgpID09IHN0cjtcblx0XHR9O1xuXHRcdFx0XG5cdFx0Ly8gc2VhcmNoIGZvciBjb21tZW50IHN0YXJ0XG5cdFx0d2hpbGUgKGZyb20tLSkge1xuXHRcdFx0aWYgKGhhc01hdGNoKHN0YXJ0VG9rZW4sIGZyb20pKSB7XG5cdFx0XHRcdGNvbW1lbnRTdGFydCA9IGZyb207XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRpZiAoY29tbWVudFN0YXJ0ICE9IC0xKSB7XG5cdFx0XHQvLyBzZWFyY2ggZm9yIGNvbW1lbnQgZW5kXG5cdFx0XHRmcm9tID0gY29tbWVudFN0YXJ0O1xuXHRcdFx0dmFyIGNvbnRlbnRMZW4gPSB0ZXh0Lmxlbmd0aDtcblx0XHRcdHdoaWxlIChjb250ZW50TGVuID49IGZyb20rKykge1xuXHRcdFx0XHRpZiAoaGFzTWF0Y2goZW5kVG9rZW4sIGZyb20pKSB7XG5cdFx0XHRcdFx0Y29tbWVudEVuZCA9IGZyb20gKyBlbmRUb2tlbi5sZW5ndGg7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIChjb21tZW50U3RhcnQgIT0gLTEgJiYgY29tbWVudEVuZCAhPSAtMSkgXG5cdFx0XHQ/IHJhbmdlKGNvbW1lbnRTdGFydCwgY29tbWVudEVuZCAtIGNvbW1lbnRTdGFydCkgXG5cdFx0XHQ6IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJpYyBjb21tZW50IHRvZ2dsaW5nIHJvdXRpbmVcblx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudFN0YXJ0IENvbW1lbnQgc3RhcnQgdG9rZW5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnRFbmQgQ29tbWVudCBlbmQgdG9rZW5cblx0ICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgU2VsZWN0aW9uIHJhbmdlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBnZW5lcmljQ29tbWVudFRvZ2dsZShlZGl0b3IsIGNvbW1lbnRTdGFydCwgY29tbWVudEVuZCwgcmFuZ2UpIHtcblx0XHR2YXIgY29udGVudCA9IGVkaXRvclV0aWxzLm91dHB1dEluZm8oZWRpdG9yKS5jb250ZW50O1xuXHRcdHZhciBjYXJldFBvcyA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdHZhciBuZXdDb250ZW50ID0gbnVsbDtcblx0XHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBjb21tZW50IG1hcmtlcnMgZnJvbSBzdHJpbmdcblx0XHQgKiBAcGFyYW0ge1N0aW5nfSBzdHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlQ29tbWVudChzdHIpIHtcblx0XHRcdHJldHVybiBzdHJcblx0XHRcdFx0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXicgKyB1dGlscy5lc2NhcGVGb3JSZWdleHAoY29tbWVudFN0YXJ0KSArICdcXFxccyonKSwgZnVuY3Rpb24oc3RyKXtcblx0XHRcdFx0XHRjYXJldFBvcyAtPSBzdHIubGVuZ3RoO1xuXHRcdFx0XHRcdHJldHVybiAnJztcblx0XHRcdFx0fSkucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxccyonICsgdXRpbHMuZXNjYXBlRm9yUmVnZXhwKGNvbW1lbnRFbmQpICsgJyQnKSwgJycpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBmaXJzdCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGlzIHN1YnN0cmluZyBpcyBub3QgaW5zaWRlIFxuXHRcdC8vIGNvbW1lbnRcblx0XHR2YXIgY29tbWVudFJhbmdlID0gc2VhcmNoQ29tbWVudChjb250ZW50LCBjYXJldFBvcywgY29tbWVudFN0YXJ0LCBjb21tZW50RW5kKTtcblx0XHRpZiAoY29tbWVudFJhbmdlICYmIGNvbW1lbnRSYW5nZS5vdmVybGFwKHJhbmdlKSkge1xuXHRcdFx0Ly8gd2UncmUgaW5zaWRlIGNvbW1lbnQsIHJlbW92ZSBpdFxuXHRcdFx0cmFuZ2UgPSBjb21tZW50UmFuZ2U7XG5cdFx0XHRuZXdDb250ZW50ID0gcmVtb3ZlQ29tbWVudChyYW5nZS5zdWJzdHJpbmcoY29udGVudCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBzaG91bGQgYWRkIGNvbW1lbnRcblx0XHRcdC8vIG1ha2Ugc3VyZSB0aGF0IHRoZXJlJ3Mgbm8gY29tbWVudCBpbnNpZGUgc2VsZWN0aW9uXG5cdFx0XHRuZXdDb250ZW50ID0gY29tbWVudFN0YXJ0ICsgJyAnICtcblx0XHRcdFx0cmFuZ2Uuc3Vic3RyaW5nKGNvbnRlbnQpXG5cdFx0XHRcdFx0LnJlcGxhY2UobmV3IFJlZ0V4cCh1dGlscy5lc2NhcGVGb3JSZWdleHAoY29tbWVudFN0YXJ0KSArICdcXFxccyp8XFxcXHMqJyArIHV0aWxzLmVzY2FwZUZvclJlZ2V4cChjb21tZW50RW5kKSwgJ2cnKSwgJycpICtcblx0XHRcdFx0JyAnICsgY29tbWVudEVuZDtcblx0XHRcdFx0XG5cdFx0XHQvLyBhZGp1c3QgY2FyZXQgcG9zaXRpb25cblx0XHRcdGNhcmV0UG9zICs9IGNvbW1lbnRTdGFydC5sZW5ndGggKyAxO1xuXHRcdH1cblxuXHRcdC8vIHJlcGxhY2UgZWRpdG9yIGNvbnRlbnRcblx0XHRpZiAobmV3Q29udGVudCAhPT0gbnVsbCkge1xuXHRcdFx0bmV3Q29udGVudCA9IHV0aWxzLmVzY2FwZVRleHQobmV3Q29udGVudCk7XG5cdFx0XHRlZGl0b3Iuc2V0Q2FyZXRQb3MocmFuZ2Uuc3RhcnQpO1xuXHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KGVkaXRvclV0aWxzLnVuaW5kZW50KGVkaXRvciwgbmV3Q29udGVudCksIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuXHRcdFx0ZWRpdG9yLnNldENhcmV0UG9zKGNhcmV0UG9zKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0XG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogVG9nZ2xlIGNvbW1lbnQgb24gY3VycmVudCBlZGl0b3IncyBzZWxlY3Rpb24gb3IgSFRNTCB0YWcvQ1NTIHJ1bGVcblx0XHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdFx0ICovXG5cdFx0dG9nZ2xlQ29tbWVudEFjdGlvbjogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHR2YXIgaW5mbyA9IGVkaXRvclV0aWxzLm91dHB1dEluZm8oZWRpdG9yKTtcblx0XHRcdGlmIChhY3Rpb25VdGlscy5pc1N1cHBvcnRlZENTUyhpbmZvLnN5bnRheCkpIHtcblx0XHRcdFx0Ly8gaW4gY2FzZSBvdXIgZWRpdG9yIGlzIGdvb2QgZW5vdWdoIGFuZCBjYW4gcmVjb2duaXplIHN5bnRheCBmcm9tIFxuXHRcdFx0XHQvLyBjdXJyZW50IHRva2VuLCB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IGN1cnNvciBpcyBub3QgaW5zaWRlXG5cdFx0XHRcdC8vICdzdHlsZScgYXR0cmlidXRlIG9mIGh0bWwgZWxlbWVudFxuXHRcdFx0XHR2YXIgY2FyZXRQb3MgPSBlZGl0b3IuZ2V0Q2FyZXRQb3MoKTtcblx0XHRcdFx0dmFyIHRhZyA9IGh0bWxNYXRjaGVyLnRhZyhpbmZvLmNvbnRlbnQsIGNhcmV0UG9zKTtcblx0XHRcdFx0aWYgKHRhZyAmJiB0YWcub3Blbi5yYW5nZS5pbnNpZGUoY2FyZXRQb3MpKSB7XG5cdFx0XHRcdFx0aW5mby5zeW50YXggPSAnaHRtbCc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGNzc1N5bnRheGVzID0gcHJlZnMuZ2V0QXJyYXkoJ2Nzcy5zeW50YXhlcycpO1xuXHRcdFx0aWYgKH5jc3NTeW50YXhlcy5pbmRleE9mKGluZm8uc3ludGF4KSkge1xuXHRcdFx0XHRyZXR1cm4gdG9nZ2xlQ1NTQ29tbWVudChlZGl0b3IpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdG9nZ2xlSFRNTENvbW1lbnQoZWRpdG9yKTtcblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vYXNzZXRzL2h0bWxNYXRjaGVyXCI6XCJhc3NldHNcXFxcaHRtbE1hdGNoZXIuanNcIixcIi4uL2Fzc2V0cy9wcmVmZXJlbmNlc1wiOlwiYXNzZXRzXFxcXHByZWZlcmVuY2VzLmpzXCIsXCIuLi9hc3NldHMvcmFuZ2VcIjpcImFzc2V0c1xcXFxyYW5nZS5qc1wiLFwiLi4vZWRpdFRyZWUvY3NzXCI6XCJlZGl0VHJlZVxcXFxjc3MuanNcIixcIi4uL3V0aWxzL2FjdGlvblwiOlwidXRpbHNcXFxcYWN0aW9uLmpzXCIsXCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi4vdXRpbHMvZWRpdG9yXCI6XCJ1dGlsc1xcXFxlZGl0b3IuanNcIn1dLFwiYWN0aW9uXFxcXHVwZGF0ZUltYWdlU2l6ZS5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQXV0b21hdGljYWxseSB1cGRhdGVzIGltYWdlIHNpemUgYXR0cmlidXRlcyBpbiBIVE1MJ3MgJmx0O2ltZyZndDsgZWxlbWVudCBvclxuICogQ1NTIHJ1bGVcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciBlZGl0b3JVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2VkaXRvcicpO1xuXHR2YXIgYWN0aW9uVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9hY3Rpb24nKTtcblx0dmFyIHhtbEVkaXRUcmVlID0gcmVxdWlyZSgnLi4vZWRpdFRyZWUveG1sJyk7XG5cdHZhciBjc3NFZGl0VHJlZSA9IHJlcXVpcmUoJy4uL2VkaXRUcmVlL2NzcycpO1xuXHR2YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi4vdXRpbHMvYmFzZTY0Jyk7XG5cdHZhciBmaWxlID0gcmVxdWlyZSgnLi4vcGx1Z2luL2ZpbGUnKTtcblxuXHQvKipcblx0ICogVXBkYXRlcyBpbWFnZSBzaXplIG9mICZsdDtpbWcgc3JjPVwiXCImZ3Q7IHRhZ1xuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGVJbWFnZVNpemVIVE1MKGVkaXRvcikge1xuXHRcdHZhciBvZmZzZXQgPSBlZGl0b3IuZ2V0Q2FyZXRQb3MoKTtcblxuXHRcdC8vIGZpbmQgdGFnIGZyb20gY3VycmVudCBjYXJldCBwb3NpdGlvblxuXHRcdHZhciBpbmZvID0gZWRpdG9yVXRpbHMub3V0cHV0SW5mbyhlZGl0b3IpO1xuXHRcdHZhciB4bWxFbGVtID0geG1sRWRpdFRyZWUucGFyc2VGcm9tUG9zaXRpb24oaW5mby5jb250ZW50LCBvZmZzZXQsIHRydWUpO1xuXHRcdGlmICh4bWxFbGVtICYmICh4bWxFbGVtLm5hbWUoKSB8fCAnJykudG9Mb3dlckNhc2UoKSA9PSAnaW1nJykge1xuXHRcdFx0Z2V0SW1hZ2VTaXplRm9yU291cmNlKGVkaXRvciwgeG1sRWxlbS52YWx1ZSgnc3JjJyksIGZ1bmN0aW9uKHNpemUpIHtcblx0XHRcdFx0aWYgKHNpemUpIHtcblx0XHRcdFx0XHR2YXIgY29tcG91bmREYXRhID0geG1sRWxlbS5yYW5nZSh0cnVlKTtcblx0XHRcdFx0XHR4bWxFbGVtLnZhbHVlKCd3aWR0aCcsIHNpemUud2lkdGgpO1xuXHRcdFx0XHRcdHhtbEVsZW0udmFsdWUoJ2hlaWdodCcsIHNpemUuaGVpZ2h0LCB4bWxFbGVtLmluZGV4T2YoJ3dpZHRoJykgKyAxKTtcblxuXHRcdFx0XHRcdGFjdGlvblV0aWxzLmNvbXBvdW5kVXBkYXRlKGVkaXRvciwgdXRpbHMuZXh0ZW5kKGNvbXBvdW5kRGF0YSwge1xuXHRcdFx0XHRcdFx0ZGF0YTogeG1sRWxlbS50b1N0cmluZygpLFxuXHRcdFx0XHRcdFx0Y2FyZXQ6IG9mZnNldFxuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgaW1hZ2Ugc2l6ZSBvZiBDU1MgcHJvcGVydHlcblx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlSW1hZ2VTaXplQ1NTKGVkaXRvcikge1xuXHRcdHZhciBvZmZzZXQgPSBlZGl0b3IuZ2V0Q2FyZXRQb3MoKTtcblxuXHRcdC8vIGZpbmQgdGFnIGZyb20gY3VycmVudCBjYXJldCBwb3NpdGlvblxuXHRcdHZhciBpbmZvID0gZWRpdG9yVXRpbHMub3V0cHV0SW5mbyhlZGl0b3IpO1xuXHRcdHZhciBjc3NSdWxlID0gY3NzRWRpdFRyZWUucGFyc2VGcm9tUG9zaXRpb24oaW5mby5jb250ZW50LCBvZmZzZXQsIHRydWUpO1xuXHRcdGlmIChjc3NSdWxlKSB7XG5cdFx0XHQvLyBjaGVjayBpZiB0aGVyZSBpcyBwcm9wZXJ0eSB3aXRoIGltYWdlIHVuZGVyIGNhcmV0XG5cdFx0XHR2YXIgcHJvcCA9IGNzc1J1bGUuaXRlbUZyb21Qb3NpdGlvbihvZmZzZXQsIHRydWUpLCBtO1xuXHRcdFx0aWYgKHByb3AgJiYgKG0gPSAvdXJsXFwoKFtcIiddPykoLis/KVxcMVxcKS9pLmV4ZWMocHJvcC52YWx1ZSgpIHx8ICcnKSkpIHtcblx0XHRcdFx0Z2V0SW1hZ2VTaXplRm9yU291cmNlKGVkaXRvciwgbVsyXSwgZnVuY3Rpb24oc2l6ZSkge1xuXHRcdFx0XHRcdGlmIChzaXplKSB7XG5cdFx0XHRcdFx0XHR2YXIgY29tcG91bmREYXRhID0gY3NzUnVsZS5yYW5nZSh0cnVlKTtcblx0XHRcdFx0XHRcdGNzc1J1bGUudmFsdWUoJ3dpZHRoJywgc2l6ZS53aWR0aCArICdweCcpO1xuXHRcdFx0XHRcdFx0Y3NzUnVsZS52YWx1ZSgnaGVpZ2h0Jywgc2l6ZS5oZWlnaHQgKyAncHgnLCBjc3NSdWxlLmluZGV4T2YoJ3dpZHRoJykgKyAxKTtcblxuXHRcdFx0XHRcdFx0YWN0aW9uVXRpbHMuY29tcG91bmRVcGRhdGUoZWRpdG9yLCB1dGlscy5leHRlbmQoY29tcG91bmREYXRhLCB7XG5cdFx0XHRcdFx0XHRcdGRhdGE6IGNzc1J1bGUudG9TdHJpbmcoKSxcblx0XHRcdFx0XHRcdFx0Y2FyZXQ6IG9mZnNldFxuXHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaW1hZ2UgZGltZW5zaW9ucyBmb3Igc291cmNlXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBJbWFnZSBzb3VyY2UgKHBhdGggb3IgZGF0YTp1cmwpXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRJbWFnZVNpemVGb3JTb3VyY2UoZWRpdG9yLCBzcmMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGZpbGVDb250ZW50O1xuXHRcdGlmIChzcmMpIHtcblx0XHRcdC8vIGNoZWNrIGlmIGl0IGlzIGRhdGE6dXJsXG5cdFx0XHRpZiAoL15kYXRhOi8udGVzdChzcmMpKSB7XG5cdFx0XHRcdGZpbGVDb250ZW50ID0gYmFzZTY0LmRlY29kZSggc3JjLnJlcGxhY2UoL15kYXRhXFw6Lis/Oy4rPywvLCAnJykgKTtcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGFjdGlvblV0aWxzLmdldEltYWdlU2l6ZShmaWxlQ29udGVudCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZmlsZVBhdGggPSBlZGl0b3IuZ2V0RmlsZVBhdGgoKTtcblx0XHRcdGZpbGUubG9jYXRlRmlsZShmaWxlUGF0aCwgc3JjLCBmdW5jdGlvbihhYnNQYXRoKSB7XG5cdFx0XHRcdGlmIChhYnNQYXRoID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJDYW4ndCBmaW5kIFwiICsgc3JjICsgJyBmaWxlJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZpbGUucmVhZChhYnNQYXRoLCBmdW5jdGlvbihlcnIsIGNvbnRlbnQpIHtcblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyAnVW5hYmxlIHRvIHJlYWQgJyArIGFic1BhdGggKyAnOiAnICsgZXJyO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnRlbnQgPSBTdHJpbmcoY29udGVudCk7XG5cdFx0XHRcdFx0Y2FsbGJhY2soYWN0aW9uVXRpbHMuZ2V0SW1hZ2VTaXplKGNvbnRlbnQpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHVwZGF0ZUltYWdlU2l6ZUFjdGlvbjogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHQvLyB0aGlzIGFjdGlvbiB3aWxsIGRlZmluaXRlbHkgd29u4oCZdCB3b3JrIGluIFNBU1MgZGlhbGVjdCxcblx0XHRcdC8vIGJ1dCBtYXkgd29yayBpbiBTQ1NTIG9yIExFU1Ncblx0XHRcdGlmIChhY3Rpb25VdGlscy5pc1N1cHBvcnRlZENTUyhlZGl0b3IuZ2V0U3ludGF4KCkpKSB7XG5cdFx0XHRcdHVwZGF0ZUltYWdlU2l6ZUNTUyhlZGl0b3IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dXBkYXRlSW1hZ2VTaXplSFRNTChlZGl0b3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vZWRpdFRyZWUvY3NzXCI6XCJlZGl0VHJlZVxcXFxjc3MuanNcIixcIi4uL2VkaXRUcmVlL3htbFwiOlwiZWRpdFRyZWVcXFxceG1sLmpzXCIsXCIuLi9wbHVnaW4vZmlsZVwiOlwicGx1Z2luXFxcXGZpbGUuanNcIixcIi4uL3V0aWxzL2FjdGlvblwiOlwidXRpbHNcXFxcYWN0aW9uLmpzXCIsXCIuLi91dGlscy9iYXNlNjRcIjpcInV0aWxzXFxcXGJhc2U2NC5qc1wiLFwiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4uL3V0aWxzL2VkaXRvclwiOlwidXRpbHNcXFxcZWRpdG9yLmpzXCJ9XSxcImFjdGlvblxcXFx1cGRhdGVUYWcuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFVwZGF0ZSBUYWcgYWN0aW9uOiBhbGxvd3MgdXNlcnMgdG8gdXBkYXRlIGV4aXN0aW5nIEhUTUwgdGFncyBhbmQgYWRkL3JlbW92ZVxuICogYXR0cmlidXRlcyBvciBldmVuIHRhZyBuYW1lXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciB4bWxFZGl0VHJlZSA9IHJlcXVpcmUoJy4uL2VkaXRUcmVlL3htbCcpO1xuXHR2YXIgZWRpdG9yVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9lZGl0b3InKTtcblx0dmFyIGFjdGlvblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvYWN0aW9uJyk7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgcGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2VyL2FiYnJldmlhdGlvbicpO1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZXModGFnLCBhYmJyTm9kZSwgaXgpIHtcblx0XHR2YXIgY2xhc3NOYW1lcyA9IChhYmJyTm9kZS5hdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpLnNwbGl0KC9cXHMrL2cpO1xuXHRcdGlmIChpeCkge1xuXHRcdFx0Y2xhc3NOYW1lcy5wdXNoKCcrJyArIGFiYnJOb2RlLm5hbWUoKSk7XG5cdFx0fVxuXG5cdFx0dmFyIHIgPSBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiB1dGlscy5yZXBsYWNlQ291bnRlcihzdHIsIGFiYnJOb2RlLmNvdW50ZXIpO1xuXHRcdH07XG5cblx0XHQvLyB1cGRhdGUgY2xhc3Ncblx0XHRjbGFzc05hbWVzLmZvckVhY2goZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG5cdFx0XHRpZiAoIWNsYXNzTmFtZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNsYXNzTmFtZSA9IHIoY2xhc3NOYW1lKTtcblx0XHRcdHZhciBjaCA9IGNsYXNzTmFtZS5jaGFyQXQoMCk7XG5cdFx0XHRpZiAoY2ggPT0gJysnKSB7XG5cdFx0XHRcdHRhZy5hZGRDbGFzcyhjbGFzc05hbWUuc3Vic3RyKDEpKTtcblx0XHRcdH0gZWxzZSBpZiAoY2ggPT0gJy0nKSB7XG5cdFx0XHRcdHRhZy5yZW1vdmVDbGFzcyhjbGFzc05hbWUuc3Vic3RyKDEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhZy52YWx1ZSgnY2xhc3MnLCBjbGFzc05hbWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gdXBkYXRlIGF0dHJpYnV0ZXNcblx0XHRhYmJyTm9kZS5hdHRyaWJ1dGVMaXN0KCkuZm9yRWFjaChmdW5jdGlvbihhdHRyKSB7XG5cdFx0XHRpZiAoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2NsYXNzJykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjaCA9IGF0dHIubmFtZS5jaGFyQXQoMCk7XG5cdFx0XHRpZiAoY2ggPT0gJysnKSB7XG5cdFx0XHRcdHZhciBhdHRyTmFtZSA9IGF0dHIubmFtZS5zdWJzdHIoMSk7XG5cdFx0XHRcdHZhciB0YWdBdHRyID0gdGFnLmdldChhdHRyTmFtZSk7XG5cdFx0XHRcdGlmICh0YWdBdHRyKSB7XG5cdFx0XHRcdFx0dGFnQXR0ci52YWx1ZSh0YWdBdHRyLnZhbHVlKCkgKyByKGF0dHIudmFsdWUpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YWcudmFsdWUoYXR0ck5hbWUsIHIoYXR0ci52YWx1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGNoID09ICctJykge1xuXHRcdFx0XHR0YWcucmVtb3ZlKGF0dHIubmFtZS5zdWJzdHIoMSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFnLnZhbHVlKGF0dHIubmFtZSwgcihhdHRyLnZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblx0XG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogTWF0Y2hlcyBIVE1MIHRhZyB1bmRlciBjYXJldCBhbmQgdXBkYXRlcyBpdHMgZGVmaW5pdGlvblxuXHRcdCAqIGFjY29yZGluZyB0byBnaXZlbiBhYmJyZXZpYXRpb25cblx0XHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gRWRpdG9yIGluc3RhbmNlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFiYnIgQWJicmV2aWF0aW9uIHRvIHVwZGF0ZSB3aXRoXG5cdFx0ICovXG5cdFx0dXBkYXRlVGFnQWN0aW9uOiBmdW5jdGlvbihlZGl0b3IsIGFiYnIpIHtcblx0XHRcdGFiYnIgPSBhYmJyIHx8IGVkaXRvci5wcm9tcHQoXCJFbnRlciBhYmJyZXZpYXRpb25cIik7XG5cblx0XHRcdGlmICghYWJicikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb250ZW50ID0gZWRpdG9yLmdldENvbnRlbnQoKTtcblx0XHRcdHZhciBjdHggPSBhY3Rpb25VdGlscy5jYXB0dXJlQ29udGV4dChlZGl0b3IpO1xuXHRcdFx0dmFyIHRhZyA9IHRoaXMuZ2V0VXBkYXRlZFRhZyhhYmJyLCBjdHgsIGNvbnRlbnQpO1xuXG5cdFx0XHRpZiAoIXRhZykge1xuXHRcdFx0XHQvLyBub3RoaW5nIHRvIHVwZGF0ZVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGlmIHRhZyBuYW1lIHdhcyB1cGRhdGVkXG5cdFx0XHRpZiAodGFnLm5hbWUoKSAhPSBjdHgubmFtZSAmJiBjdHgubWF0Y2guY2xvc2UpIHtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KCc8LycgKyB0YWcubmFtZSgpICsgJz4nLCBjdHgubWF0Y2guY2xvc2UucmFuZ2Uuc3RhcnQsIGN0eC5tYXRjaC5jbG9zZS5yYW5nZS5lbmQsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQodGFnLnNvdXJjZSwgY3R4Lm1hdGNoLm9wZW4ucmFuZ2Uuc3RhcnQsIGN0eC5tYXRjaC5vcGVuLnJhbmdlLmVuZCwgdHJ1ZSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBYTUxFZGl0Q29udGFpbmVyIG5vZGUgd2l0aCB1cGRhdGVkIHRhZyBzdHJ1Y3R1cmVcblx0XHQgKiBvZiBleGlzdGluZyB0YWcgY29udGV4dC5cblx0XHQgKiBUaGlzIGRhdGEgY2FuIGJlIHVzZWQgdG8gbW9kaWZ5IGV4aXN0aW5nIHRhZ1xuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gYWJiciAgICBBYmJyZXZpYXRpb25cblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IGN0eCAgICAgVGFnIHRvIGJlIHVwZGF0ZWQgKGNhcHR1cmVkIHdpdGggYGh0bWxNYXRjaGVyYClcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGNvbnRlbnQgT3JpZ2luYWwgZWRpdG9yIGNvbnRlbnRcblx0XHQgKiBAcmV0dXJuIHtYTUxFZGl0Q29udGFpbmVyfVxuXHRcdCAqL1xuXHRcdGdldFVwZGF0ZWRUYWc6IGZ1bmN0aW9uKGFiYnIsIGN0eCwgY29udGVudCwgb3B0aW9ucykge1xuXHRcdFx0aWYgKCFjdHgpIHtcblx0XHRcdFx0Ly8gbm90aGluZyB0byB1cGRhdGVcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0cmVlID0gcGFyc2VyLnBhcnNlKGFiYnIsIG9wdGlvbnMgfHwge30pO1xuXG5cdFx0XHQvLyBmb3IgdGhpcyBhY3Rpb24gc29tZSBjaGFyYWN0ZXJzIGluIGFiYnJldmlhdGlvbiBoYXMgc3BlY2lhbFxuXHRcdFx0Ly8gbWVhbmluZy4gRm9yIGV4YW1wbGUsIGAuLWMyYCBtZWFucyDigJxyZW1vdmUgYGMyYCBjbGFzcyBmcm9tXG5cdFx0XHQvLyBlbGVtZW504oCdIGFuZCBgLitjM2AgbWVhbnMg4oCcYXBwZW5kIGNsYXNzIGBjM2AgdG8gZXhpc2luZyBvbmUuXG5cdFx0XHQvLyBcblx0XHRcdC8vIEJ1dCBgLitjM2AgYWJicmV2aWF0aW9uIHdpbGwgYWN0dWFsbHkgcHJvZHVjZSB0d28gZWxlbWVudHM6XG5cdFx0XHQvLyA8ZGl2IGNsYXNzPVwiXCI+IGFuZCA8YzM+LiBUaHVzLCB3ZSBoYXZlIHRvIHdhbGsgb24gZWFjaCBlbGVtZW50XG5cdFx0XHQvLyBvZiBwYXJzZWQgdHJlZSBhbmQgdXNlIHRoZWlyIGRlZmluaXRpb25zIHRvIHVwZGF0ZSBjdXJyZW50IGVsZW1lbnRcblx0XHRcdHZhciB0YWcgPSB4bWxFZGl0VHJlZS5wYXJzZShjdHgubWF0Y2gub3Blbi5yYW5nZS5zdWJzdHJpbmcoY29udGVudCksIHtcblx0XHRcdFx0b2Zmc2V0OiBjdHgubWF0Y2gub3V0ZXJSYW5nZS5zdGFydFxuXHRcdFx0fSk7XG5cblx0XHRcdHRyZWUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihub2RlLCBpKSB7XG5cdFx0XHRcdHVwZGF0ZUF0dHJpYnV0ZXModGFnLCBub2RlLCBpKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBpZiB0YWcgbmFtZSB3YXMgcmVzb2x2ZWQgYnkgaW1wbGljaXQgdGFnIG5hbWUgcmVzb2x2ZXIsXG5cdFx0XHQvLyB0aGVuIHVzZXIgb21pdHRlZCBpdCBpbiBhYmJyZXZpYXRpb24gYW5kIHdhbnRzIHRvIGtlZXBcblx0XHRcdC8vIG9yaWdpbmFsIHRhZyBuYW1lXG5cdFx0XHR2YXIgZWwgPSB0cmVlLmNoaWxkcmVuWzBdO1xuXHRcdFx0aWYgKCFlbC5kYXRhKCduYW1lUmVzb2x2ZWQnKSkge1xuXHRcdFx0XHR0YWcubmFtZShlbC5uYW1lKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH1cblx0fTtcbn0pO1xufSx7XCIuLi9lZGl0VHJlZS94bWxcIjpcImVkaXRUcmVlXFxcXHhtbC5qc1wiLFwiLi4vcGFyc2VyL2FiYnJldmlhdGlvblwiOlwicGFyc2VyXFxcXGFiYnJldmlhdGlvbi5qc1wiLFwiLi4vdXRpbHMvYWN0aW9uXCI6XCJ1dGlsc1xcXFxhY3Rpb24uanNcIixcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCIsXCIuLi91dGlscy9lZGl0b3JcIjpcInV0aWxzXFxcXGVkaXRvci5qc1wifV0sXCJhY3Rpb25cXFxcd3JhcFdpdGhBYmJyZXZpYXRpb24uanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEFjdGlvbiB0aGF0IHdyYXBzIGNvbnRlbnQgd2l0aCBhYmJyZXZpYXRpb24uIEZvciBjb252ZW5pZW5jZSwgYWN0aW9uIGlzIFxuICogZGVmaW5lZCBhcyByZXVzYWJsZSBtb2R1bGVcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHJhbmdlID0gcmVxdWlyZSgnLi4vYXNzZXRzL3JhbmdlJyk7XG5cdHZhciBodG1sTWF0Y2hlciA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9odG1sTWF0Y2hlcicpO1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblx0dmFyIGVkaXRvclV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZWRpdG9yJyk7XG5cdHZhciBhY3Rpb25VdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2FjdGlvbicpO1xuXHR2YXIgcGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2VyL2FiYnJldmlhdGlvbicpO1xuXHRcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBXcmFwcyBjb250ZW50IHdpdGggYWJicmV2aWF0aW9uXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IEVkaXRvciBpbnN0YW5jZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBhYmJyIEFiYnJldmlhdGlvbiB0byB3cmFwIHdpdGhcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4IFN5bnRheCB0eXBlIChodG1sLCBjc3MsIGV0Yy4pXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGUgT3V0cHV0IHByb2ZpbGUgbmFtZSAoaHRtbCwgeG1sLCB4aHRtbClcblx0XHQgKi9cblx0XHR3cmFwV2l0aEFiYnJldmlhdGlvbkFjdGlvbjogZnVuY3Rpb24oZWRpdG9yLCBhYmJyLCBzeW50YXgsIHByb2ZpbGUpIHtcblx0XHRcdHZhciBpbmZvID0gZWRpdG9yVXRpbHMub3V0cHV0SW5mbyhlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSk7XG5cdFx0XHRhYmJyID0gYWJiciB8fCBlZGl0b3IucHJvbXB0KFwiRW50ZXIgYWJicmV2aWF0aW9uXCIpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIWFiYnIpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGFiYnIgPSBTdHJpbmcoYWJicik7XG5cdFx0XHRcblx0XHRcdHZhciByID0gcmFuZ2UoZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXIubGVuZ3RoKCkpIHtcblx0XHRcdFx0Ly8gbm8gc2VsZWN0aW9uLCBmaW5kIHRhZyBwYWlyXG5cdFx0XHRcdHZhciBtYXRjaCA9IGh0bWxNYXRjaGVyLnRhZyhpbmZvLmNvbnRlbnQsIHIuc3RhcnQpO1xuXHRcdFx0XHRpZiAoIW1hdGNoKSB7ICAvLyBub3RoaW5nIHRvIHdyYXBcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHIgPSB1dGlscy5uYXJyb3dUb05vblNwYWNlKGluZm8uY29udGVudCwgbWF0Y2gucmFuZ2UpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHV0aWxzLmVzY2FwZVRleHQoci5zdWJzdHJpbmcoaW5mby5jb250ZW50KSk7XG5cdFx0XHR2YXIgcmVzdWx0ID0gcGFyc2VyLmV4cGFuZChhYmJyLCB7XG5cdFx0XHRcdHBhc3RlZENvbnRlbnQ6IGVkaXRvclV0aWxzLnVuaW5kZW50KGVkaXRvciwgbmV3Q29udGVudCksXG5cdFx0XHRcdHN5bnRheDogaW5mby5zeW50YXgsXG5cdFx0XHRcdHByb2ZpbGU6IGluZm8ucHJvZmlsZSxcblx0XHRcdFx0Y29udGV4dE5vZGU6IGFjdGlvblV0aWxzLmNhcHR1cmVDb250ZXh0KGVkaXRvcilcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlQ29udGVudChyZXN1bHQsIHIuc3RhcnQsIHIuZW5kKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vYXNzZXRzL2h0bWxNYXRjaGVyXCI6XCJhc3NldHNcXFxcaHRtbE1hdGNoZXIuanNcIixcIi4uL2Fzc2V0cy9yYW5nZVwiOlwiYXNzZXRzXFxcXHJhbmdlLmpzXCIsXCIuLi9wYXJzZXIvYWJicmV2aWF0aW9uXCI6XCJwYXJzZXJcXFxcYWJicmV2aWF0aW9uLmpzXCIsXCIuLi91dGlscy9hY3Rpb25cIjpcInV0aWxzXFxcXGFjdGlvbi5qc1wiLFwiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4uL3V0aWxzL2VkaXRvclwiOlwidXRpbHNcXFxcZWRpdG9yLmpzXCJ9XSxcImFzc2V0c1xcXFxjYW5pdXNlLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBQYXJzZWQgcmVzb3VyY2VzIChzbmlwcGV0cywgYWJicmV2aWF0aW9ucywgdmFyaWFibGVzLCBldGMuKSBmb3IgRW1tZXQuXG4gKiBDb250YWlucyBjb252ZW5pZW50IG1ldGhvZCB0byBnZXQgYWNjZXNzIGZvciBzbmlwcGV0cyB3aXRoIHJlc3BlY3Qgb2ZcbiAqIGluaGVyaXRhbmNlLiBBbHNvIHByb3ZpZGVzIGFiaWxpdHkgdG8gc3RvcmUgZGF0YSBpbiBkaWZmZXJlbnQgdm9jYWJ1bGFyaWVzXG4gKiAoJ3N5c3RlbScgYW5kICd1c2VyJykgZm9yIGZhc3QgYW5kIHNhZmUgcmVzb3VyY2UgdXBkYXRlXG4gKiBAYXV0aG9yIFNlcmdleSBDaGlrdXlvbm9rIChzZXJnZS5jaGVAZ21haWwuY29tKVxuICogQGxpbmsgaHR0cDovL2NoaWt1eW9ub2sucnVcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHByZWZzID0gcmVxdWlyZSgnLi9wcmVmZXJlbmNlcycpO1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuXHRwcmVmcy5kZWZpbmUoJ2Nhbml1c2UuZW5hYmxlZCcsIHRydWUsICdFbmFibGUgc3VwcG9ydCBvZiBDYW4gSSBVc2UgZGF0YWJhc2UuIFdoZW4gZW5hYmxlZCxcXFxuXHRcdENTUyBhYmJyZXZpYXRpb24gcmVzb2x2ZXIgd2lsbCBsb29rIGF0IENhbiBJIFVzZSBkYXRhYmFzZSBmaXJzdCBiZWZvcmUgZGV0ZWN0aW5nXFxcblx0XHRDU1MgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSByZXNvbHZlZCcpO1xuXG5cdHByZWZzLmRlZmluZSgnY2FuaXVzZS52ZW5kb3JzJywgJ2FsbCcsICdBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IHZlbmRvciBpZGVudGlmaWVyc1xcXG5cdFx0KGFzIGRlc2NyaWJlZCBpbiBDYW4gSSBVc2UgZGF0YWJhc2UpIHRoYXQgc2hvdWxkIGJlIHN1cHBvcnRlZFxcXG5cdFx0d2hlbiByZXNvbHZpbmcgdmVuZG9yLXByZWZpeGVkIHByb3BlcnRpZXMuIFNldCB2YWx1ZSB0byA8Y29kZT5hbGw8L2NvZGU+XFxcblx0XHR0byBzdXBwb3J0IGFsbCBhdmFpbGFibGUgcHJvcGVydGllcycpO1xuXG5cdHByZWZzLmRlZmluZSgnY2FuaXVzZS5lcmEnLCAnZS0yJywgJ0Jyb3dzZXIgZXJhLCBhcyBkZWZpbmVkIGluIENhbiBJIFVzZSBkYXRhYmFzZS5cXFxuXHRcdEV4YW1wbGVzOiA8Y29kZT5lMDwvY29kZT4gKGN1cnJlbnQgdmVyc2lvbiksIDxjb2RlPmUxPC9jb2RlPiAobmVhciBmdXR1cmUpXFxcblx0XHQ8Y29kZT5lLTI8L2NvZGU+ICgyIHZlcnNpb25zIGJhY2spIGFuZCBzbyBvbi4nKTtcblxuXHR2YXIgY3NzU2VjdGlvbnMgPSB7XG5cdFx0J2JvcmRlci1pbWFnZSc6IFsnYm9yZGVyLWltYWdlJ10sXG5cdFx0J2Nzcy1ib3hzaGFkb3cnOiBbJ2JveC1zaGFkb3cnXSxcblx0XHQnY3NzMy1ib3hzaXppbmcnOiBbJ2JveC1zaXppbmcnXSxcblx0XHQnbXVsdGljb2x1bW4nOiBbJ2NvbHVtbi13aWR0aCcsICdjb2x1bW4tY291bnQnLCAnY29sdW1ucycsICdjb2x1bW4tZ2FwJywgJ2NvbHVtbi1ydWxlLWNvbG9yJywgJ2NvbHVtbi1ydWxlLXN0eWxlJywgJ2NvbHVtbi1ydWxlLXdpZHRoJywgJ2NvbHVtbi1ydWxlJywgJ2NvbHVtbi1zcGFuJywgJ2NvbHVtbi1maWxsJ10sXG5cdFx0J2JvcmRlci1yYWRpdXMnOiBbJ2JvcmRlci1yYWRpdXMnLCAnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycsICdib3JkZXItdG9wLXJpZ2h0LXJhZGl1cycsICdib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cycsICdib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzJ10sXG5cdFx0J3RyYW5zZm9ybXMyZCc6IFsndHJhbnNmb3JtJ10sXG5cdFx0J2Nzcy1oeXBoZW5zJzogWydoeXBoZW5zJ10sXG5cdFx0J2Nzcy10cmFuc2l0aW9ucyc6IFsndHJhbnNpdGlvbicsICd0cmFuc2l0aW9uLXByb3BlcnR5JywgJ3RyYW5zaXRpb24tZHVyYXRpb24nLCAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLCAndHJhbnNpdGlvbi1kZWxheSddLFxuXHRcdCdmb250LWZlYXR1cmUnOiBbJ2ZvbnQtZmVhdHVyZS1zZXR0aW5ncyddLFxuXHRcdCdjc3MtYW5pbWF0aW9uJzogWydhbmltYXRpb24nLCAnYW5pbWF0aW9uLW5hbWUnLCAnYW5pbWF0aW9uLWR1cmF0aW9uJywgJ2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24nLCAnYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCcsICdhbmltYXRpb24tZGlyZWN0aW9uJywgJ2FuaW1hdGlvbi1wbGF5LXN0YXRlJywgJ2FuaW1hdGlvbi1kZWxheScsICdhbmltYXRpb24tZmlsbC1tb2RlJywgJ0BrZXlmcmFtZXMnXSxcblx0XHQnY3NzLWdyYWRpZW50cyc6IFsnbGluZWFyLWdyYWRpZW50J10sXG5cdFx0J2Nzcy1tYXNrcyc6IFsnbWFzay1pbWFnZScsICdtYXNrLXNvdXJjZS10eXBlJywgJ21hc2stcmVwZWF0JywgJ21hc2stcG9zaXRpb24nLCAnbWFzay1jbGlwJywgJ21hc2stb3JpZ2luJywgJ21hc2stc2l6ZScsICdtYXNrJywgJ21hc2stdHlwZScsICdtYXNrLWJveC1pbWFnZS1zb3VyY2UnLCAnbWFzay1ib3gtaW1hZ2Utc2xpY2UnLCAnbWFzay1ib3gtaW1hZ2Utd2lkdGgnLCAnbWFzay1ib3gtaW1hZ2Utb3V0c2V0JywgJ21hc2stYm94LWltYWdlLXJlcGVhdCcsICdtYXNrLWJveC1pbWFnZScsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJ10sXG5cdFx0J2Nzcy1mZWF0dXJlcXVlcmllcyc6IFsnQHN1cHBvcnRzJ10sXG5cdFx0J2ZsZXhib3gnOiBbJ2ZsZXgnLCAnaW5saW5lLWZsZXgnLCAnZmxleC1kaXJlY3Rpb24nLCAnZmxleC13cmFwJywgJ2ZsZXgtZmxvdycsICdvcmRlcicsICdmbGV4J10sXG5cdFx0J2NhbGMnOiBbJ2NhbGMnXSxcblx0XHQnb2JqZWN0LWZpdCc6IFsnb2JqZWN0LWZpdCcsICdvYmplY3QtcG9zaXRpb24nXSxcblx0XHQnY3NzLWdyaWQnOiBbJ2dyaWQnLCAnaW5saW5lLWdyaWQnLCAnZ3JpZC10ZW1wbGF0ZS1yb3dzJywgJ2dyaWQtdGVtcGxhdGUtY29sdW1ucycsICdncmlkLXRlbXBsYXRlLWFyZWFzJywgJ2dyaWQtdGVtcGxhdGUnLCAnZ3JpZC1hdXRvLXJvd3MnLCAnZ3JpZC1hdXRvLWNvbHVtbnMnLCAnIGdyaWQtYXV0by1mbG93JywgJ2dyaWQtYXV0by1wb3NpdGlvbicsICdncmlkJywgJyBncmlkLXJvdy1zdGFydCcsICdncmlkLWNvbHVtbi1zdGFydCcsICdncmlkLXJvdy1lbmQnLCAnZ3JpZC1jb2x1bW4tZW5kJywgJ2dyaWQtY29sdW1uJywgJ2dyaWQtcm93JywgJ2dyaWQtYXJlYScsICdqdXN0aWZ5LXNlbGYnLCAnanVzdGlmeS1pdGVtcycsICdhbGlnbi1zZWxmJywgJ2FsaWduLWl0ZW1zJ10sXG5cdFx0J2Nzcy1yZXBlYXRpbmctZ3JhZGllbnRzJzogWydyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50J10sXG5cdFx0J2Nzcy1maWx0ZXJzJzogWydmaWx0ZXInXSxcblx0XHQndXNlci1zZWxlY3Qtbm9uZSc6IFsndXNlci1zZWxlY3QnXSxcblx0XHQnaW50cmluc2ljLXdpZHRoJzogWydtaW4tY29udGVudCcsICdtYXgtY29udGVudCcsICdmaXQtY29udGVudCcsICdmaWxsLWF2YWlsYWJsZSddLFxuXHRcdCdjc3MzLXRhYnNpemUnOiBbJ3RhYi1zaXplJ11cblx0fTtcblxuXHQvKiogQHR5cGUge09iamVjdH0gVGhlIENhbiBJIFVzZSBkYXRhYmFzZSBmb3IgQ1NTICovXG5cdHZhciBjc3NEQiA9IG51bGw7XG5cdC8qKiBAdHlwZSB7T2JqZWN0fSBBIGxpc3Qgb2YgYXZhaWxhYmxlIHZlbmRvcnMgKGJyb3dzZXJzKSBhbmQgdGhlaXIgcHJlZml4ZXMgKi9cblx0dmFyIHZlbmRvcnNEQiA9IG51bGw7XG5cdHZhciBlcmFzREIgPSBudWxsO1xuXG5cdGZ1bmN0aW9uIGludGVyc2VjdGlvbihhcnIxLCBhcnIyKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBzbWFsbGVyID0gYXJyMSwgbGFyZ2VyID0gYXJyMjtcblx0XHRpZiAoc21hbGxlci5sZW5ndGggPiBsYXJnZXIubGVuZ3RoKSB7XG5cdFx0XHRzbWFsbGVyID0gYXJyMjtcblx0XHRcdGxhcmdlciA9IGFycjE7XG5cdFx0fVxuXHRcdGxhcmdlci5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmICh+c21hbGxlci5pbmRleE9mKGl0ZW0pKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2VzIHJhdyBDYW4gSSBVc2UgZGF0YWJhc2UgZm9yIGJldHRlciBsb29rdXBzXG5cdCAqIEBwYXJhbSAge1N0cmluZ30gZGF0YSBSYXcgZGF0YWJhc2Vcblx0ICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW1pemVkIFBhc3MgYHRydWVgIGlmIGdpdmVuIGBkYXRhYCBpcyBhbHJlYWR5IG9wdGltaXplZFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqL1xuXHRmdW5jdGlvbiBwYXJzZURCKGRhdGEsIG9wdGltaXplZCkge1xuXHRcdGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuXHRcdFx0ZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFvcHRpbWl6ZWQpIHtcblx0XHRcdGRhdGEgPSBvcHRpbWl6ZShkYXRhKTtcblx0XHR9XG5cblx0XHR2ZW5kb3JzREIgPSBkYXRhLnZlbmRvcnM7XG5cdFx0Y3NzREIgPSBkYXRhLmNzcztcblx0XHRlcmFzREIgPSBkYXRhLmVyYTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0IHJlcXVpcmVkIGRhdGEgb25seSBmcm9tIENJVSBkYXRhYmFzZVxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgUmF3IENhbiBJIFVzZSBkYXRhYmFzZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgT3B0aW1pemVkIGRhdGFiYXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBvcHRpbWl6ZShkYXRhKSB7XG5cdFx0aWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG5cdFx0XHRkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVuZG9yczogcGFyc2VWZW5kb3JzKGRhdGEpLFxuXHRcdFx0Y3NzOiBwYXJzZUNTUyhkYXRhKSxcblx0XHRcdGVyYTogcGFyc2VFcmEoZGF0YSlcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB2ZW5kb3IgZGF0YVxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VWZW5kb3JzKGRhdGEpIHtcblx0XHR2YXIgb3V0ID0ge307XG5cdFx0T2JqZWN0LmtleXMoZGF0YS5hZ2VudHMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dmFyIGFnZW50ID0gZGF0YS5hZ2VudHNbbmFtZV07XG5cdFx0XHRvdXRbbmFtZV0gPSB7XG5cdFx0XHRcdHByZWZpeDogYWdlbnQucHJlZml4LFxuXHRcdFx0XHR2ZXJzaW9uczogYWdlbnQudmVyc2lvbnNcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgQ1NTIGRhdGEgZnJvbSBDYW4gSSBVc2UgcmF3IGRhdGFiYXNlXG5cdCAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqL1xuXHRmdW5jdGlvbiBwYXJzZUNTUyhkYXRhKSB7XG5cdFx0dmFyIG91dCA9IHt9O1xuXHRcdHZhciBjc3NDYXRlZ29yaWVzID0gZGF0YS5jYXRzLkNTUztcblx0XHRPYmplY3Qua2V5cyhkYXRhLmRhdGEpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dmFyIHNlY3Rpb24gPSBkYXRhLmRhdGFbbmFtZV07XG5cdFx0XHRpZiAobmFtZSBpbiBjc3NTZWN0aW9ucykge1xuXHRcdFx0XHRjc3NTZWN0aW9uc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKGt3KSB7XG5cdFx0XHRcdFx0b3V0W2t3XSA9IHNlY3Rpb24uc3RhdHM7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgZXJhIGRhdGEgZnJvbSBDYW4gSSBVc2UgcmF3IGRhdGFiYXNlXG5cdCAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIHBhcnNlRXJhKGRhdGEpIHtcblx0XHQvLyBzb21lIHJ1bnRpbWVzIChsaWtlIE1vemlsbGEgUmhpbm8pIGRvZXMgbm90IHByZXNlcnZlc1xuXHRcdC8vIGtleSBvcmRlciBzbyB3ZSBoYXZlIHRvIHNvcnQgdmFsdWVzIG1hbnVhbGx5XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKGRhdGEuZXJhcykuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQoYS5zdWJzdHIoMSkpIC0gcGFyc2VJbnQoYi5zdWJzdHIoMSkpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVycyBsaXN0IG9mIHN1cHBvcnRlZCB2ZW5kb3JzLCBkZXBlbmRpbmcgb24gdXNlciBwcmVmZXJlbmNlc1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIGdldFZlbmRvcnNMaXN0KCkge1xuXHRcdHZhciBhbGxWZW5kb3JzID0gT2JqZWN0LmtleXModmVuZG9yc0RCKTtcblx0XHR2YXIgdmVuZG9ycyA9IHByZWZzLmdldEFycmF5KCdjYW5pdXNlLnZlbmRvcnMnKTtcblx0XHRpZiAoIXZlbmRvcnMgfHwgdmVuZG9yc1swXSA9PSAnYWxsJykge1xuXHRcdFx0cmV0dXJuIGFsbFZlbmRvcnM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbihhbGxWZW5kb3JzLCB2ZW5kb3JzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHNpemUgb2YgdmVyc2lvbiBzbGljZSBhcyBkZWZpbmVkIGJ5IGVyYSBpZGVudGlmaWVyXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICovXG5cdGZ1bmN0aW9uIGdldFZlcnNpb25TbGljZSgpIHtcblx0XHR2YXIgZXJhID0gcHJlZnMuZ2V0KCdjYW5pdXNlLmVyYScpO1xuXHRcdHZhciBpeCA9IGVyYXNEQi5pbmRleE9mKGVyYSk7XG5cdFx0aWYgKCF+aXgpIHtcblx0XHRcdGl4ID0gZXJhc0RCLmluZGV4T2YoJ2UtMicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBpeDtcblx0fVxuXG5cdC8vIHRyeSB0byBsb2FkIGNhbml1c2UgZGF0YWJhc2Vcblx0Ly8gaGlkZSBpdCBmcm9tIFJlcXVpcmUuSlMgcGFyc2VyXG5cdHZhciBkYiA9IG51bGw7XG5cdChmdW5jdGlvbihyKSB7XG5cdFx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICd1bmRlZmluZWQnIHx8ICFkZWZpbmUuYW1kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYiA9IHIoJ2Nhbml1c2UtZGIvZGF0YS5qc29uJyk7XG5cdFx0XHR9IGNhdGNoKGUpIHt9XG5cdFx0fVxuXHR9KShyZXF1aXJlKTtcblxuXHRpZiAoZGIpIHtcblx0XHRwYXJzZURCKGRiKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bG9hZDogcGFyc2VEQixcblx0XHRvcHRpbWl6ZTogb3B0aW1pemUsXG5cblx0XHQvKipcblx0XHQgKiBSZXNvbHZlcyBwcmVmaXhlcyBmb3IgZ2l2ZW4gcHJvcGVydHlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgQSBwcm9wZXJ0eSB0byByZXNvbHZlLiBJdCBjYW4gc3RhcnQgd2l0aCBgQGAgc3ltYm9sXG5cdFx0ICogKENTUyBzZWN0aW9uLCBsaWtlIGBAa2V5ZnJhbWVzYCkgb3IgYDpgIChDU1MgdmFsdWUsIGxpa2UgYGZsZXhgKVxuXHRcdCAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiByZXNvbHZlZCBwcmVmaXhlcyBvciA8Y29kZT5udWxsPC9jb2RlPlxuXHRcdCAqIGlmIHByZWZpeGVzIGNhbid0IGJlIHJlc29sdmVkLiBFbXB0eSBhcnJheSBtZWFucyBwcm9wZXJ0eSBoYXMgbm8gdmVuZG9yXG5cdFx0ICogcHJlZml4ZXNcblx0XHQgKi9cblx0XHRyZXNvbHZlUHJlZml4ZXM6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG5cdFx0XHRpZiAoIXByZWZzLmdldCgnY2FuaXVzZS5lbmFibGVkJykgfHwgIWNzc0RCIHx8ICEocHJvcGVydHkgaW4gY3NzREIpKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcHJlZml4ZXMgPSBbXTtcblx0XHRcdHZhciBwcm9wU3RhdHMgPSBjc3NEQltwcm9wZXJ0eV07XG5cdFx0XHR2YXIgdmVyc2lvbnMgPSBnZXRWZXJzaW9uU2xpY2UoKTtcblxuXHRcdFx0Z2V0VmVuZG9yc0xpc3QoKS5mb3JFYWNoKGZ1bmN0aW9uKHZlbmRvcikge1xuXHRcdFx0XHR2YXIgdmVuZG9yVmVzaW9ucyA9IHZlbmRvcnNEQlt2ZW5kb3JdLnZlcnNpb25zLnNsaWNlKHZlcnNpb25zKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIHY7IGkgPCB2ZW5kb3JWZXNpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0diA9IHZlbmRvclZlc2lvbnNbaV07XG5cdFx0XHRcdFx0aWYgKCF2KSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAofnByb3BTdGF0c1t2ZW5kb3JdW3ZdLmluZGV4T2YoJ3gnKSkge1xuXHRcdFx0XHRcdFx0cHJlZml4ZXMucHVzaCh2ZW5kb3JzREJbdmVuZG9yXS5wcmVmaXgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHV0aWxzLnVuaXF1ZShwcmVmaXhlcykuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufSk7XG5cbn0se1wiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4vcHJlZmVyZW5jZXNcIjpcImFzc2V0c1xcXFxwcmVmZXJlbmNlcy5qc1wifV0sXCJhc3NldHNcXFxcZWxlbWVudHMuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIE1vZHVsZSB0aGF0IGNvbnRhaW5zIGZhY3RvcmllcyBmb3IgZWxlbWVudCB0eXBlcyB1c2VkIGJ5IEVtbWV0XG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBmYWN0b3JpZXMgPSB7fTtcblx0dmFyIHJlQXR0cnMgPSAvKFtAXFwhXT8pKFtcXHdcXC06XSspXFxzKj1cXHMqKFsnXCJdKSguKj8pXFwzL2c7XG5cblx0Ly8gcmVnaXN0ZXIgcmVzb3VyY2UgcmVmZXJlbmNlc1xuXHRmdW5jdGlvbiBjb21tb25GYWN0b3J5KHZhbHVlKSB7XG5cdFx0cmV0dXJuIHtkYXRhOiB2YWx1ZX07XG5cdH1cblxuXHRtb2R1bGUgPSBtb2R1bGUgfHwge307XG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBuZXcgZWxlbWVudCBmYWN0b3J5XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgRWxlbWVudCBpZGVudGlmaWVyXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZmFjdG9yeSBGdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGVsZW1lbnQgb2Ygc3BlY2lmaWVkIFxuXHRcdCAqIHR5cGUuIFRoZSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHRoaXMgZmFjdG9yeSBpcyBhdXRvbWF0aWNhbGx5IFxuXHRcdCAqIGF1Z21lbnRlZCB3aXRoIDxjb2RlPnR5cGU8L2NvZGU+IHByb3BlcnR5IHBvaW50aW5nIHRvIGVsZW1lbnRcblx0XHQgKiA8Y29kZT5uYW1lPC9jb2RlPlxuXHRcdCAqIEBtZW1iZXJPZiBlbGVtZW50c1xuXHRcdCAqL1xuXHRcdGFkZDogZnVuY3Rpb24obmFtZSwgZmFjdG9yeSkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0ZmFjdG9yaWVzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gZmFjdG9yeS5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuXHRcdFx0XHRpZiAoZWxlbSlcblx0XHRcdFx0XHRlbGVtLnR5cGUgPSBuYW1lO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBmYWN0b3J5IGZvciBzcGVjaWZpZWQgbmFtZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdFx0ICogQHJldHVybnMge0Z1bmN0aW9ufVxuXHRcdCAqL1xuXHRcdGdldDogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuIGZhY3Rvcmllc1tuYW1lXTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgbmV3IGVsZW1lbnQgd2l0aCBzcGVjaWZpZWQgdHlwZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdFx0dmFyIGZhY3RvcnkgPSB0aGlzLmdldChuYW1lKTtcblx0XHRcdHJldHVybiBmYWN0b3J5ID8gZmFjdG9yeS5hcHBseSh0aGlzLCBhcmdzKSA6IG51bGw7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBwYXNzZWQgZWxlbWVudCBpcyBvZiBzcGVjaWZpZWQgdHlwZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpczogZnVuY3Rpb24oZWxlbSwgdHlwZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudHlwZShlbGVtKSA9PT0gdHlwZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0eXBlIG9mIGVsZW1lbnRcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IGVsZW1cblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dHlwZTogZnVuY3Rpb24oZWxlbSkge1xuXHRcdFx0cmV0dXJuIGVsZW0gJiYgZWxlbS50eXBlO1xuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBFbGVtZW50IGZhY3Rvcnlcblx0ICogQHBhcmFtIHtTdHJpbmd9IGVsZW1lbnROYW1lIE5hbWUgb2Ygb3V0cHV0IGVsZW1lbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIEF0dHJpYnV0ZXMgZGVmaW5pdGlvbi4gWW91IG1heSBhbHNvIHBhc3Ncblx0ICogPGNvZGU+QXJyYXk8L2NvZGU+IHdoZXJlIGVhY2ggY29udGFpbnMgb2JqZWN0IHdpdGggPGNvZGU+bmFtZTwvY29kZT4gXG5cdCAqIGFuZCA8Y29kZT52YWx1ZTwvY29kZT4gcHJvcGVydGllcywgb3IgPGNvZGU+T2JqZWN0PC9jb2RlPlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRW1wdHkgSXMgZXhwYW5kZWQgZWxlbWVudCBzaG91bGQgYmUgZW1wdHlcblx0ICovXG5cdG1vZHVsZS5leHBvcnRzLmFkZCgnZWxlbWVudCcsIGZ1bmN0aW9uKGVsZW1lbnROYW1lLCBhdHRycywgaXNFbXB0eSkge1xuXHRcdHZhciByZXQgPSB7XG5cdFx0XHRuYW1lOiBlbGVtZW50TmFtZSxcblx0XHRcdGlzX2VtcHR5OiAhIWlzRW1wdHlcblx0XHR9O1xuXG5cdFx0aWYgKGF0dHJzKSB7XG5cdFx0XHRyZXQuYXR0cmlidXRlcyA9IFtdO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG5cdFx0XHRcdHJldC5hdHRyaWJ1dGVzID0gYXR0cnM7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dmFyIG07XG5cdFx0XHRcdHdoaWxlICgobSA9IHJlQXR0cnMuZXhlYyhhdHRycykpKSB7XG5cdFx0XHRcdFx0cmV0LmF0dHJpYnV0ZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiBtWzJdLFxuXHRcdFx0XHRcdFx0dmFsdWU6IG1bNF0sXG5cdFx0XHRcdFx0XHRpc0RlZmF1bHQ6IG1bMV0gPT0gJ0AnLFxuXHRcdFx0XHRcdFx0aXNJbXBsaWVkOiBtWzFdID09ICchJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXQuYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGF0dHJzKS5tYXAoZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lLCBcblx0XHRcdFx0XHRcdHZhbHVlOiBhdHRyc1tuYW1lXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gcmV0O1xuXHR9KTtcblx0XG5cdG1vZHVsZS5leHBvcnRzLmFkZCgnc25pcHBldCcsIGNvbW1vbkZhY3RvcnkpO1xuXHRtb2R1bGUuZXhwb3J0cy5hZGQoJ3JlZmVyZW5jZScsIGNvbW1vbkZhY3RvcnkpO1xuXHRtb2R1bGUuZXhwb3J0cy5hZGQoJ2VtcHR5JywgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9KTtcblx0XG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn0pO1xufSx7fV0sXCJhc3NldHNcXFxcaGFuZGxlckxpc3QuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRoYXQgcHJvdmlkZXMgb3JkZXJlZCBzdG9yYWdlIG9mIGZ1bmN0aW9uIGhhbmRsZXJzLiBcbiAqIE1hbnkgRW1tZXQgbW9kdWxlcycgZnVuY3Rpb25hbGl0eSBjYW4gYmUgZXh0ZW5kZWQvb3ZlcnJpZGRlbiBieSBjdXN0b21cbiAqIGZ1bmN0aW9uLiBUaGlzIG1vZHVsZXMgcHJvdmlkZXMgdW5pZmllZCBzdG9yYWdlIG9mIGhhbmRsZXIgZnVuY3Rpb25zLCB0aGVpciBcbiAqIG1hbmFnZW1lbnQgYW5kIGV4ZWN1dGlvblxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblx0XG5cdC8qKlxuXHQgKiBAdHlwZSBIYW5kbGVyTGlzdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEhhbmRsZXJMaXN0KCkge1xuXHRcdHRoaXMuX2xpc3QgPSBbXTtcblx0fVxuXHRcblx0SGFuZGxlckxpc3QucHJvdG90eXBlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEFkZHMgZnVuY3Rpb24gaGFuZGxlclxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEhhbmRsZXJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBIYW5kbGVyIG9wdGlvbnMuIFBvc3NpYmxlIHZhbHVlcyBhcmU6PGJyPjxicj5cblx0XHQgKiA8Yj5vcmRlcjwvYj4gOiAoPGNvZGU+TnVtYmVyPC9jb2RlPikg4oCTIG9yZGVyIGluIGhhbmRsZXIgbGlzdC4gSGFuZGxlcnNcblx0XHQgKiB3aXRoIGhpZ2hlciBvcmRlciB2YWx1ZSB3aWxsIGJlIGV4ZWN1dGVkIGVhcmxpZXIuXG5cdFx0ICovXG5cdFx0YWRkOiBmdW5jdGlvbihmbiwgb3B0aW9ucykge1xuXHRcdFx0Ly8gVE9ETyBoYWNrIGZvciBzdGFibGUgc29ydCwgcmVtb3ZlIGFmdGVyIGZpeGluZyBgbGlzdCgpYFxuXHRcdFx0dmFyIG9yZGVyID0gdGhpcy5fbGlzdC5sZW5ndGg7XG5cdFx0XHRpZiAob3B0aW9ucyAmJiAnb3JkZXInIGluIG9wdGlvbnMpIHtcblx0XHRcdFx0b3JkZXIgPSBvcHRpb25zLm9yZGVyICogMTAwMDA7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9saXN0LnB1c2godXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLCB7b3JkZXI6IG9yZGVyLCBmbjogZm59KSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIGhhbmRsZXIgZnJvbSBsaXN0XG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0XHQgKi9cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHV0aWxzLmZpbmQodGhpcy5fbGlzdCwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gaXRlbS5mbiA9PT0gZm47XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpdGVtKSB7XG5cdFx0XHRcdHRoaXMuX2xpc3Quc3BsaWNlKHRoaXMuX2xpc3QuaW5kZXhPZihpdGVtKSwgMSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIG9yZGVyZWQgbGlzdCBvZiBoYW5kbGVycy4gQnkgZGVmYXVsdCwgaGFuZGxlcnMgXG5cdFx0ICogd2l0aCB0aGUgc2FtZSA8Y29kZT5vcmRlcjwvY29kZT4gb3B0aW9uIHJldHVybmVkIGluIHJldmVyc2Ugb3JkZXIsIFxuXHRcdCAqIGkuZS4gdGhlIGxhdHRlciBmdW5jdGlvbiB3YXMgYWRkZWQgaW50byB0aGUgaGFuZGxlcnMgbGlzdCwgdGhlIGhpZ2hlciBcblx0XHQgKiBpdCB3aWxsIGJlIGluIHRoZSByZXR1cm5lZCBhcnJheSBcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0bGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBUT0RPIG1ha2Ugc3RhYmxlIHNvcnRcblx0XHRcdHJldHVybiB0aGlzLl9saXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYi5vcmRlciAtIGEub3JkZXI7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgb3JkZXJlZCBsaXN0IG9mIGhhbmRsZXIgZnVuY3Rpb25zXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdCAqL1xuXHRcdGxpc3RGbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5saXN0KCkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuIGl0ZW0uZm47XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4ZWN1dGVzIGhhbmRsZXIgZnVuY3Rpb25zIGluIHRoZWlyIGRlc2lnbmF0ZWQgb3JkZXIuIElmIGZ1bmN0aW9uXG5cdFx0ICogcmV0dXJucyA8Y29kZT5za2lwVmFsPC9jb2RlPiwgbWVhbmluZyB0aGF0IGZ1bmN0aW9uIHdhcyB1bmFibGUgdG8gXG5cdFx0ICogaGFuZGxlIHBhc3NlZCA8Y29kZT5hcmdzPC9jb2RlPiwgdGhlIG5leHQgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZFxuXHRcdCAqIGFuZCBzbyBvbi5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc2tpcFZhbHVlIElmIGZ1bmN0aW9uIHJldHVybnMgdGhpcyB2YWx1ZSwgZXhlY3V0ZSBcblx0XHQgKiBuZXh0IGhhbmRsZXIuXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYXJncyBBcmd1bWVudHMgdG8gcGFzcyB0byBoYW5kbGVyIGZ1bmN0aW9uXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgYW55IG9mIHJlZ2lzdGVyZWQgaGFuZGxlcnMgcGVyZm9ybWVkXG5cdFx0ICogc3VjY2Vzc2Z1bGx5ICBcblx0XHQgKi9cblx0XHRleGVjOiBmdW5jdGlvbihza2lwVmFsdWUsIGFyZ3MpIHtcblx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0dmFyIHJlc3VsdCA9IG51bGw7XG5cdFx0XHR1dGlscy5maW5kKHRoaXMubGlzdCgpLCBmdW5jdGlvbihoKSB7XG5cdFx0XHRcdHJlc3VsdCA9IGguZm4uYXBwbHkoaCwgYXJncyk7XG5cdFx0XHRcdGlmIChyZXN1bHQgIT09IHNraXBWYWx1ZSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH07XG5cdFxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIEZhY3RvcnkgbWV0aG9kIHRoYXQgcHJvZHVjZXMgPGNvZGU+SGFuZGxlckxpc3Q8L2NvZGU+IGluc3RhbmNlXG5cdFx0ICogQHJldHVybnMge0hhbmRsZXJMaXN0fVxuXHRcdCAqIEBtZW1iZXJPZiBoYW5kbGVyTGlzdFxuXHRcdCAqL1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEhhbmRsZXJMaXN0KCk7XG5cdFx0fVxuXHR9O1xufSk7XG59LHtcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCJ9XSxcImFzc2V0c1xcXFxodG1sTWF0Y2hlci5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSFRNTCBtYXRjaGVyOiB0YWtlcyBzdHJpbmcgYW5kIHNlYXJjaGVzIGZvciBIVE1MIHRhZyBwYWlycyBmb3IgZ2l2ZW4gcG9zaXRpb24gXG4gKiBcbiAqIFVubGlrZSDigJxjbGFzc2lj4oCdIG1hdGNoZXJzLCBpdCBwYXJzZXMgY29udGVudCBmcm9tIHRoZSBzcGVjaWZpZWQgXG4gKiBwb3NpdGlvbiwgbm90IGZyb20gdGhlIHN0YXJ0LCBzbyBpdCBtYXkgd29yayBldmVuIG91dHNpZGUgSFRNTCBkb2N1bWVudHNcbiAqIChmb3IgZXhhbXBsZSwgaW5zaWRlIHN0cmluZ3Mgb2YgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzIGxpa2UgSmF2YVNjcmlwdCwgUHl0aG9uIFxuICogZXRjLilcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpO1xuXG5cdC8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuXHR2YXIgcmVPcGVuVGFnID0gL148KFtcXHdcXDpcXC1dKykoKD86XFxzK1tcXHdcXC06XSsoPzpcXHMqPVxccyooPzooPzpcIlteXCJdKlwiKXwoPzonW14nXSonKXxbXj5cXHNdKykpPykqKVxccyooXFwvPyk+Lztcblx0dmFyIHJlQ2xvc2VUYWcgPSAvXjxcXC8oW1xcd1xcOlxcLV0rKVtePl0qPi87XG5cblx0ZnVuY3Rpb24gb3BlblRhZyhpLCBtYXRjaCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiBtYXRjaFsxXSxcblx0XHRcdHNlbGZDbG9zZTogISFtYXRjaFszXSxcblx0XHRcdC8qKiBAdHlwZSBSYW5nZSAqL1xuXHRcdFx0cmFuZ2U6IHJhbmdlKGksIG1hdGNoWzBdKSxcblx0XHRcdHR5cGU6ICdvcGVuJ1xuXHRcdH07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNsb3NlVGFnKGksIG1hdGNoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWU6IG1hdGNoWzFdLFxuXHRcdFx0LyoqIEB0eXBlIFJhbmdlICovXG5cdFx0XHRyYW5nZTogcmFuZ2UoaSwgbWF0Y2hbMF0pLFxuXHRcdFx0dHlwZTogJ2Nsb3NlJ1xuXHRcdH07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNvbW1lbnQoaSwgbWF0Y2gpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0LyoqIEB0eXBlIFJhbmdlICovXG5cdFx0XHRyYW5nZTogcmFuZ2UoaSwgdHlwZW9mIG1hdGNoID09ICdudW1iZXInID8gbWF0Y2ggLSBpIDogbWF0Y2hbMF0pLFxuXHRcdFx0dHlwZTogJ2NvbW1lbnQnXG5cdFx0fTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZXMgbmV3IHRhZyBtYXRjaGVyIHNlc3Npb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIodGV4dCkge1xuXHRcdHZhciBtZW1vID0ge30sIG07XG5cdFx0cmV0dXJuIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVGVzdCBpZiBnaXZlbiBwb3NpdGlvbiBtYXRjaGVzIG9wZW5pbmcgdGFnXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gaVxuXHRcdFx0ICogQHJldHVybnMge09iamVjdH0gTWF0Y2hlZCB0YWcgb2JqZWN0XG5cdFx0XHQgKi9cblx0XHRcdG9wZW46IGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0dmFyIG0gPSB0aGlzLm1hdGNoZXMoaSk7XG5cdFx0XHRcdHJldHVybiBtICYmIG0udHlwZSA9PSAnb3BlbicgPyBtIDogbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGVzdCBpZiBnaXZlbiBwb3NpdGlvbiBtYXRjaGVzIGNsb3NpbmcgdGFnXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gaVxuXHRcdFx0ICogQHJldHVybnMge09iamVjdH0gTWF0Y2hlZCB0YWcgb2JqZWN0XG5cdFx0XHQgKi9cblx0XHRcdGNsb3NlOiBmdW5jdGlvbihpKSB7XG5cdFx0XHRcdHZhciBtID0gdGhpcy5tYXRjaGVzKGkpO1xuXHRcdFx0XHRyZXR1cm4gbSAmJiBtLnR5cGUgPT0gJ2Nsb3NlJyA/IG0gOiBudWxsO1xuXHRcdFx0fSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNYXRjaGVzIGVpdGhlciBvcGVuaW5nIG9yIGNsb3NpbmcgdGFnIGZvciBnaXZlbiBwb3NpdGlvblxuXHRcdFx0ICogQHBhcmFtIGlcblx0XHRcdCAqIEByZXR1cm5zXG5cdFx0XHQgKi9cblx0XHRcdG1hdGNoZXM6IGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0dmFyIGtleSA9ICdwJyArIGk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIShrZXkgaW4gbWVtbykpIHtcblx0XHRcdFx0XHRtZW1vW2tleV0gPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAodGV4dC5jaGFyQXQoaSkgPT0gJzwnKSB7XG5cdFx0XHRcdFx0XHR2YXIgc3Vic3RyID0gdGV4dC5zbGljZShpKTtcblx0XHRcdFx0XHRcdGlmICgobSA9IHN1YnN0ci5tYXRjaChyZU9wZW5UYWcpKSkge1xuXHRcdFx0XHRcdFx0XHRtZW1vW2tleV0gPSBvcGVuVGFnKGksIG0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICgobSA9IHN1YnN0ci5tYXRjaChyZUNsb3NlVGFnKSkpIHtcblx0XHRcdFx0XHRcdFx0bWVtb1trZXldID0gY2xvc2VUYWcoaSwgbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbWVtb1trZXldO1xuXHRcdFx0fSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIG9yaWdpbmFsIHRleHRcblx0XHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0XHRcdHRleHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGV4dDtcblx0XHRcdH0sXG5cblx0XHRcdGNsZWFuOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWVtbyA9IHRleHQgPSBtID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBtYXRjaGVzKHRleHQsIHBvcywgcGF0dGVybikge1xuXHRcdHJldHVybiB0ZXh0LnN1YnN0cmluZyhwb3MsIHBvcyArIHBhdHRlcm4ubGVuZ3RoKSA9PSBwYXR0ZXJuO1xuXHR9XG5cdFxuXHQvKipcblx0ICogU2VhcmNoIGZvciBjbG9zaW5nIHBhaXIgb2Ygb3BlbmluZyB0YWdcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wZW4gT3BlbiB0YWcgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IG1hdGNoZXIgTWF0Y2hlciBpbnN0YW5jZVxuXHQgKi9cblx0ZnVuY3Rpb24gZmluZENsb3NpbmdQYWlyKG9wZW4sIG1hdGNoZXIpIHtcblx0XHR2YXIgc3RhY2sgPSBbXSwgdGFnID0gbnVsbDtcblx0XHR2YXIgdGV4dCA9IG1hdGNoZXIudGV4dCgpO1xuXHRcdFxuXHRcdGZvciAodmFyIHBvcyA9IG9wZW4ucmFuZ2UuZW5kLCBsZW4gPSB0ZXh0Lmxlbmd0aDsgcG9zIDwgbGVuOyBwb3MrKykge1xuXHRcdFx0aWYgKG1hdGNoZXModGV4dCwgcG9zLCAnPCEtLScpKSB7XG5cdFx0XHRcdC8vIHNraXAgdG8gZW5kIG9mIGNvbW1lbnRcblx0XHRcdFx0Zm9yICh2YXIgaiA9IHBvczsgaiA8IGxlbjsgaisrKSB7XG5cdFx0XHRcdFx0aWYgKG1hdGNoZXModGV4dCwgaiwgJy0tPicpKSB7XG5cdFx0XHRcdFx0XHRwb3MgPSBqICsgMztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoKHRhZyA9IG1hdGNoZXIubWF0Y2hlcyhwb3MpKSkge1xuXHRcdFx0XHRpZiAodGFnLnR5cGUgPT0gJ29wZW4nICYmICF0YWcuc2VsZkNsb3NlKSB7XG5cdFx0XHRcdFx0c3RhY2sucHVzaCh0YWcubmFtZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFnLnR5cGUgPT0gJ2Nsb3NlJykge1xuXHRcdFx0XHRcdGlmICghc3RhY2subGVuZ3RoKSB7IC8vIGZvdW5kIHZhbGlkIHBhaXI/XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGFnLm5hbWUgPT0gb3Blbi5uYW1lID8gdGFnIDogbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgY3VycmVudCBjbG9zaW5nIHRhZyBtYXRjaGVzIHByZXZpb3VzbHkgb3BlbmVkIG9uZVxuXHRcdFx0XHRcdGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PSB0YWcubmFtZSkge1xuXHRcdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0d2hpbGUgKHN0YWNrLmxlbmd0aCAmJiAhZm91bmQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGxhc3QgPSBzdGFjay5wb3AoKTtcblx0XHRcdFx0XHRcdFx0aWYgKGxhc3QgPT0gdGFnLm5hbWUpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKCFzdGFjay5sZW5ndGggJiYgIWZvdW5kKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0YWcubmFtZSA9PSBvcGVuLm5hbWUgPyB0YWcgOiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBvcyA9IHRhZy5yYW5nZS5lbmQgLSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBNYWluIGZ1bmN0aW9uOiBzZWFyY2ggZm9yIHRhZyBwYWlyIGluIDxjb2RlPnRleHQ8L2NvZGU+IGZvciBnaXZlbiBcblx0XHQgKiBwb3NpdGlvblxuXHRcdCAqIEBtZW1iZXJPZiBodG1sTWF0Y2hlclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3Ncblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGZpbmQ6IGZ1bmN0aW9uKHRleHQsIHBvcykge1xuXHRcdFx0dmFyIG1hdGNoZXIgPSBjcmVhdGVNYXRjaGVyKHRleHQpOyBcblx0XHRcdHZhciBvcGVuID0gbnVsbCwgY2xvc2UgPSBudWxsO1xuXHRcdFx0dmFyIGosIGpsO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gcG9zOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoKG9wZW4gPSBtYXRjaGVyLm9wZW4oaSkpKSB7XG5cdFx0XHRcdFx0Ly8gZm91bmQgb3BlbmluZyB0YWdcblx0XHRcdFx0XHRpZiAob3Blbi5zZWxmQ2xvc2UpIHtcblx0XHRcdFx0XHRcdGlmIChvcGVuLnJhbmdlLmNtcChwb3MsICdsdCcsICdndCcpKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGluc2lkZSBzZWxmLWNsb3NpbmcgdGFnLCBmb3VuZCBtYXRjaFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gb3V0c2lkZSBzZWxmLWNsb3NpbmcgdGFnLCBjb250aW51ZVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNsb3NlID0gZmluZENsb3NpbmdQYWlyKG9wZW4sIG1hdGNoZXIpO1xuXHRcdFx0XHRcdGlmIChjbG9zZSkge1xuXHRcdFx0XHRcdFx0Ly8gZm91bmQgY2xvc2luZyB0YWcuXG5cdFx0XHRcdFx0XHR2YXIgciA9IHJhbmdlLmNyZWF0ZTIob3Blbi5yYW5nZS5zdGFydCwgY2xvc2UucmFuZ2UuZW5kKTtcblx0XHRcdFx0XHRcdGlmIChyLmNvbnRhaW5zKHBvcykpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChvcGVuLnJhbmdlLmNvbnRhaW5zKHBvcykpIHtcblx0XHRcdFx0XHRcdC8vIHdlIGluc2lkZSBlbXB0eSBIVE1MIHRhZyBsaWtlIDxicj5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRvcGVuID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIGlmIChtYXRjaGVzKHRleHQsIGksICctLT4nKSkge1xuXHRcdFx0XHRcdC8vIHNraXAgYmFjayB0byBjb21tZW50IHN0YXJ0XG5cdFx0XHRcdFx0Zm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHRpZiAobWF0Y2hlcyh0ZXh0LCBqLCAnLS0+JykpIHtcblx0XHRcdFx0XHRcdFx0Ly8gZm91bmQgYW5vdGhlciBjb21tZW50IGVuZCwgZG8gbm90aGluZ1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobWF0Y2hlcyh0ZXh0LCBqLCAnPCEtLScpKSB7XG5cdFx0XHRcdFx0XHRcdGkgPSBqO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAobWF0Y2hlcyh0ZXh0LCBpLCAnPCEtLScpKSB7XG5cdFx0XHRcdFx0Ly8gd2UncmUgaW5zaWRlIGNvbW1lbnQsIG1hdGNoIGl0XG5cdFx0XHRcdFx0Zm9yIChqID0gaSArIDQsIGpsID0gdGV4dC5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRpZiAobWF0Y2hlcyh0ZXh0LCBqLCAnLS0+JykpIHtcblx0XHRcdFx0XHRcdFx0aiArPSAzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0b3BlbiA9IGNvbW1lbnQoaSwgaik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0bWF0Y2hlci5jbGVhbigpO1xuXG5cdFx0XHRpZiAob3Blbikge1xuXHRcdFx0XHR2YXIgb3V0ZXJSYW5nZSA9IG51bGw7XG5cdFx0XHRcdHZhciBpbm5lclJhbmdlID0gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjbG9zZSkge1xuXHRcdFx0XHRcdG91dGVyUmFuZ2UgPSByYW5nZS5jcmVhdGUyKG9wZW4ucmFuZ2Uuc3RhcnQsIGNsb3NlLnJhbmdlLmVuZCk7XG5cdFx0XHRcdFx0aW5uZXJSYW5nZSA9IHJhbmdlLmNyZWF0ZTIob3Blbi5yYW5nZS5lbmQsIGNsb3NlLnJhbmdlLnN0YXJ0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvdXRlclJhbmdlID0gaW5uZXJSYW5nZSA9IHJhbmdlLmNyZWF0ZTIob3Blbi5yYW5nZS5zdGFydCwgb3Blbi5yYW5nZS5lbmQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAob3Blbi50eXBlID09ICdjb21tZW50Jykge1xuXHRcdFx0XHRcdC8vIGFkanVzdCBwb3NpdGlvbnMgb2YgaW5uZXIgcmFuZ2UgZm9yIGNvbW1lbnRcblx0XHRcdFx0XHR2YXIgX2MgPSBvdXRlclJhbmdlLnN1YnN0cmluZyh0ZXh0KTtcblx0XHRcdFx0XHRpbm5lclJhbmdlLnN0YXJ0ICs9IF9jLmxlbmd0aCAtIF9jLnJlcGxhY2UoL148XFwhLS1cXHMqLywgJycpLmxlbmd0aDtcblx0XHRcdFx0XHRpbm5lclJhbmdlLmVuZCAtPSBfYy5sZW5ndGggLSBfYy5yZXBsYWNlKC9cXHMqLS0+JC8sICcnKS5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0b3Blbjogb3Blbixcblx0XHRcdFx0XHRjbG9zZTogY2xvc2UsXG5cdFx0XHRcdFx0dHlwZTogb3Blbi50eXBlID09ICdjb21tZW50JyA/ICdjb21tZW50JyA6ICd0YWcnLFxuXHRcdFx0XHRcdGlubmVyUmFuZ2U6IGlubmVyUmFuZ2UsXG5cdFx0XHRcdFx0aW5uZXJDb250ZW50OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmlubmVyUmFuZ2Uuc3Vic3RyaW5nKHRleHQpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b3V0ZXJSYW5nZTogb3V0ZXJSYW5nZSxcblx0XHRcdFx0XHRvdXRlckNvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3V0ZXJSYW5nZS5zdWJzdHJpbmcodGV4dCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRyYW5nZTogIWlubmVyUmFuZ2UubGVuZ3RoKCkgfHwgIWlubmVyUmFuZ2UuY21wKHBvcywgJ2x0ZScsICdndGUnKSA/IG91dGVyUmFuZ2UgOiBpbm5lclJhbmdlLFxuXHRcdFx0XHRcdGNvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMucmFuZ2Uuc3Vic3RyaW5nKHRleHQpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c291cmNlOiB0ZXh0XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgc2FtZSBhcyA8Y29kZT5maW5kKCk8L2NvZGU+IG1ldGhvZCwgYnV0IHJlc3RyaWN0cyBtYXRjaGVkIHJlc3VsdCBcblx0XHQgKiB0byA8Y29kZT50YWc8L2NvZGU+IHR5cGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcG9zXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHR0YWc6IGZ1bmN0aW9uKHRleHQsIHBvcykge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuZmluZCh0ZXh0LCBwb3MpO1xuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudHlwZSA9PSAndGFnJykge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn0pO1xufSx7XCIuL3JhbmdlXCI6XCJhc3NldHNcXFxccmFuZ2UuanNcIn1dLFwiYXNzZXRzXFxcXGxvZ2dlci5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogU2ltcGxlIGxvZ2dlciBmb3IgRW1tZXRcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0cmV0dXJuIHtcblx0XHRsb2c6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHR5cGVvZiBjb25zb2xlICE9ICd1bmRlZmluZWQnICYmIGNvbnNvbGUubG9nKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KVxufSx7fV0sXCJhc3NldHNcXFxccHJlZmVyZW5jZXMuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIENvbW1vbiBtb2R1bGUncyBwcmVmZXJlbmNlcyBzdG9yYWdlLiBUaGlzIG1vZHVsZSBcbiAqIHByb3ZpZGVzIGdlbmVyYWwgc3RvcmFnZSBmb3IgYWxsIG1vZHVsZSBwcmVmZXJlbmNlcywgdGhlaXIgZGVzY3JpcHRpb24gYW5kXG4gKiBkZWZhdWx0IHZhbHVlcy48YnI+PGJyPlxuICogXG4gKiBUaGlzIG1vZHVsZSBjYW4gYWxzbyBiZSB1c2VkIHRvIGxpc3QgYWxsIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIHRvIGNyZWF0ZSBcbiAqIFVJIGZvciB1cGRhdGluZyBwcm9wZXJ0aWVzXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG5cdHZhciBwcmVmZXJlbmNlcyA9IHt9O1xuXHR2YXIgZGVmYXVsdHMgPSB7fTtcblx0dmFyIF9kYmdEZWZhdWx0cyA9IG51bGw7XG5cdHZhciBfZGJnUHJlZmVyZW5jZXMgPSBudWxsO1xuXG5cdGZ1bmN0aW9uIHRvQm9vbGVhbih2YWwpIHtcblx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhbCA9IHZhbC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIHZhbCA9PSAneWVzJyB8fCB2YWwgPT0gJ3RydWUnIHx8IHZhbCA9PSAnMSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICEhdmFsO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBpc1ZhbHVlT2JqKG9iaikge1xuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xuXHRcdFx0JiYgIUFycmF5LmlzQXJyYXkob2JqKSBcblx0XHRcdCYmICd2YWx1ZScgaW4gb2JqIFxuXHRcdFx0JiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPCAzO1xuXHR9XG5cdFxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgbmV3IHByZWZlcmVuY2UgaXRlbSB3aXRoIGRlZmF1bHQgdmFsdWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcmVmZXJlbmNlIG5hbWUuIFlvdSBjYW4gYWxzbyBwYXNzIG9iamVjdFxuXHRcdCAqIHdpdGggbWFueSBvcHRpb25zXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFByZWZlcmVuY2UgZGVmYXVsdCB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBJdGVtIHRleHR1YWwgZGVzY3JpcHRpb25cblx0XHQgKiBAbWVtYmVyT2YgcHJlZmVyZW5jZXNcblx0XHQgKi9cblx0XHRkZWZpbmU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBkZXNjcmlwdGlvbikge1xuXHRcdFx0dmFyIHByZWZzID0gbmFtZTtcblx0XHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cHJlZnMgPSB7fTtcblx0XHRcdFx0cHJlZnNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRPYmplY3Qua2V5cyhwcmVmcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG5cdFx0XHRcdHZhciB2ID0gcHJlZnNba107XG5cdFx0XHRcdGRlZmF1bHRzW2tdID0gaXNWYWx1ZU9iaih2KSA/IHYgOiB7dmFsdWU6IHZ9O1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHByZWZlcmVuY2UgaXRlbSB2YWx1ZS4gUHJlZmVyZW5jZSB2YWx1ZSBzaG91bGQgYmUgZGVmaW5lZFxuXHRcdCAqIGZpcnN0IHdpdGggPGNvZGU+ZGVmaW5lPC9jb2RlPiBtZXRob2QuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgUHJlZmVyZW5jZSBuYW1lLiBZb3UgY2FuIGFsc28gcGFzcyBvYmplY3Rcblx0XHQgKiB3aXRoIG1hbnkgb3B0aW9uc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBQcmVmZXJlbmNlIGRlZmF1bHQgdmFsdWVcblx0XHQgKiBAbWVtYmVyT2YgcHJlZmVyZW5jZXNcblx0XHQgKi9cblx0XHRzZXQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHR2YXIgcHJlZnMgPSBuYW1lO1xuXHRcdFx0aWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRwcmVmcyA9IHt9O1xuXHRcdFx0XHRwcmVmc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRPYmplY3Qua2V5cyhwcmVmcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG5cdFx0XHRcdHZhciB2ID0gcHJlZnNba107XG5cdFx0XHRcdGlmICghKGsgaW4gZGVmYXVsdHMpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcIicgKyBrICsgJ1wiIGlzIG5vdCBkZWZpbmVkLiBZb3Ugc2hvdWxkIGRlZmluZSBpdCBmaXJzdCB3aXRoIGBkZWZpbmVgIG1ldGhvZCBvZiBjdXJyZW50IG1vZHVsZScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBkbyBub3Qgc2V0IHZhbHVlIGlmIGl0IGVxdWFscyB0byBkZWZhdWx0IHZhbHVlXG5cdFx0XHRcdGlmICh2ICE9PSBkZWZhdWx0c1trXS52YWx1ZSkge1xuXHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHZhbHVlIG9mIGNvcnJlY3QgdHlwZVxuXHRcdFx0XHRcdHN3aXRjaCAodHlwZW9mIGRlZmF1bHRzW2tdLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdib29sZWFuJzpcblx0XHRcdFx0XHRcdFx0diA9IHRvQm9vbGVhbih2KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdudW1iZXInOlxuXHRcdFx0XHRcdFx0XHR2ID0gcGFyc2VJbnQodiArICcnLCAxMCkgfHwgMDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OiAvLyBjb252ZXJ0IHRvIHN0cmluZ1xuXHRcdFx0XHRcdFx0XHRpZiAodiAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdHYgKz0gJyc7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwcmVmZXJlbmNlc1trXSA9IHY7XG5cdFx0XHRcdH0gZWxzZSBpZiAoayBpbiBwcmVmZXJlbmNlcykge1xuXHRcdFx0XHRcdGRlbGV0ZSBwcmVmZXJlbmNlc1trXTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHByZWZlcmVuY2UgdmFsdWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgPGNvZGU+dW5kZWZpbmVkPC9jb2RlPiBpZiBwcmVmZXJlbmNlIGlzIFxuXHRcdCAqIG5vdCBkZWZpbmVkXG5cdFx0ICovXG5cdFx0Z2V0OiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRpZiAobmFtZSBpbiBwcmVmZXJlbmNlcykge1xuXHRcdFx0XHRyZXR1cm4gcHJlZmVyZW5jZXNbbmFtZV07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChuYW1lIGluIGRlZmF1bHRzKSB7XG5cdFx0XHRcdHJldHVybiBkZWZhdWx0c1tuYW1lXS52YWx1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHZvaWQgMDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgY29tbWEtc2VwYXJhdGVkIHByZWZlcmVuY2UgdmFsdWUgYXMgYXJyYXkgb2YgdmFsdWVzXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgPGNvZGU+dW5kZWZpbmVkPC9jb2RlPiBpZiBwcmVmZXJlbmNlIGlzIFxuXHRcdCAqIG5vdCBkZWZpbmVkLCA8Y29kZT5udWxsPC9jb2RlPiBpZiBzdHJpbmcgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhcnJheVxuXHRcdCAqL1xuXHRcdGdldEFycmF5OiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR2YXIgdmFsID0gdGhpcy5nZXQobmFtZSk7XG5cdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsID09PSBudWxsIHx8IHZhbCA9PT0gJycpICB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHR2YWwgPSB2YWwuc3BsaXQoJywnKS5tYXAodXRpbHMudHJpbSk7XG5cdFx0XHRpZiAoIXZhbC5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGNvbW1hIGFuZCBjb2xvbi1zZXBhcmF0ZWQgcHJlZmVyZW5jZSB2YWx1ZSBhcyBkaWN0aW9uYXJ5XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldERpY3Q6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHRcdHRoaXMuZ2V0QXJyYXkobmFtZSkuZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gdmFsLnNwbGl0KCc6Jyk7XG5cdFx0XHRcdHJlc3VsdFtwYXJ0c1swXV0gPSBwYXJ0c1sxXTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBkZXNjcmlwdGlvbiBvZiBwcmVmZXJlbmNlIGl0ZW1cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcmVmZXJlbmNlIG5hbWVcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGRlc2NyaXB0aW9uOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gbmFtZSBpbiBkZWZhdWx0cyA/IGRlZmF1bHRzW25hbWVdLmRlc2NyaXB0aW9uIDogdm9pZCAwO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29tcGxldGVseSByZW1vdmVzIHNwZWNpZmllZCBwcmVmZXJlbmNlKHMpXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgUHJlZmVyZW5jZSBuYW1lIChvciBhcnJheSBvZiBuYW1lcylcblx0XHQgKi9cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdGlmICghQXJyYXkuaXNBcnJheShuYW1lKSkge1xuXHRcdFx0XHRuYW1lID0gW25hbWVdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRuYW1lLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gcHJlZmVyZW5jZXMpIHtcblx0XHRcdFx0XHRkZWxldGUgcHJlZmVyZW5jZXNba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGtleSBpbiBkZWZhdWx0cykge1xuXHRcdFx0XHRcdGRlbGV0ZSBkZWZhdWx0c1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgc29ydGVkIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSBwcm9wZXJ0aWVzXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdCAqL1xuXHRcdGxpc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKGRlZmF1bHRzKS5zb3J0KCkubWFwKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG5hbWU6IGtleSxcblx0XHRcdFx0XHR2YWx1ZTogdGhpcy5nZXQoa2V5KSxcblx0XHRcdFx0XHR0eXBlOiB0eXBlb2YgZGVmYXVsdHNba2V5XS52YWx1ZSxcblx0XHRcdFx0XHRkZXNjcmlwdGlvbjogZGVmYXVsdHNba2V5XS5kZXNjcmlwdGlvblxuXHRcdFx0XHR9O1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBMb2FkcyB1c2VyLWRlZmluZWQgcHJlZmVyZW5jZXMgZnJvbSBKU09OXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGpzb25cblx0XHQgKiBAcmV0dXJuc1xuXHRcdCAqL1xuXHRcdGxvYWQ6IGZ1bmN0aW9uKGpzb24pIHtcblx0XHRcdE9iamVjdC5rZXlzKGpzb24pLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdHRoaXMuc2V0KGtleSwganNvbltrZXldKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGhhc2ggb2YgdXNlci1tb2RpZmllZCBwcmVmZXJlbmNlc1xuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0ZXhwb3J0TW9kaWZpZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHV0aWxzLmV4dGVuZCh7fSwgcHJlZmVyZW5jZXMpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVzZXQgdG8gZGVmYXVsdHNcblx0XHQgKiBAcmV0dXJuc1xuXHRcdCAqL1xuXHRcdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHByZWZlcmVuY2VzID0ge307XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBGb3IgdW5pdCB0ZXN0aW5nOiB1c2UgZW1wdHkgc3RvcmFnZVxuXHRcdCAqL1xuXHRcdF9zdGFydFRlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0X2RiZ0RlZmF1bHRzID0gZGVmYXVsdHM7XG5cdFx0XHRfZGJnUHJlZmVyZW5jZXMgPSBwcmVmZXJlbmNlcztcblx0XHRcdGRlZmF1bHRzID0ge307XG5cdFx0XHRwcmVmZXJlbmNlcyA9IHt9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRm9yIHVuaXQgdGVzdGluZzogcmVzdG9yZSBvcmlnaW5hbCBzdG9yYWdlXG5cdFx0ICovXG5cdFx0X3N0b3BUZXN0OiBmdW5jdGlvbigpIHtcblx0XHRcdGRlZmF1bHRzID0gX2RiZ0RlZmF1bHRzO1xuXHRcdFx0cHJlZmVyZW5jZXMgPSBfZGJnUHJlZmVyZW5jZXM7XG5cdFx0fVxuXHR9O1xufSk7XG59LHtcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCJ9XSxcImFzc2V0c1xcXFxwcm9maWxlLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBPdXRwdXQgcHJvZmlsZSBtb2R1bGUuXG4gKiBQcm9maWxlIGRlZmluZXMgaG93IFhIVE1MIG91dHB1dCBkYXRhIHNob3VsZCBsb29rIGxpa2VcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciByZXNvdXJjZXMgPSByZXF1aXJlKCcuL3Jlc291cmNlcycpO1xuXHR2YXIgcHJlZnMgPSByZXF1aXJlKCcuL3ByZWZlcmVuY2VzJyk7XG5cblx0cHJlZnMuZGVmaW5lKCdwcm9maWxlLmFsbG93Q29tcGFjdEJvb2xlYW4nLCB0cnVlLCBcblx0XHQnVGhpcyBvcHRpb24gY2FuIGJlIHVzZWQgdG8gZ2xvYmFsbHkgZGlzYWJsZSBjb21wYWN0IGZvcm0gb2YgYm9vbGVhbiAnICsgXG5cdFx0J2F0dHJpYnVlcyAoYXR0cmlidXRlcyB3aGVyZSBuYW1lIGFuZCB2YWx1ZSBhcmUgZXF1YWwpLiBXaXRoIGNvbXBhY3QnICtcblx0XHQnZm9ybSBlbmFibGVkLCBIVE1MIHRhZ3MgY2FuIGJlIG91dHB1dHRlZCBhcyA8Y29kZT4mbHQ7ZGl2IGNvbnRlbnRlZGl0YWJsZSZndDs8L2NvZGU+ICcgK1xuXHRcdCdpbnN0ZWFkIG9mIDxjb2RlPiZsdDtkaXYgY29udGVudGVkaXRhYmxlPVwiY29udGVudGVkaXRhYmxlXCImZ3Q7PC9jb2RlPicpO1xuXG5cdHByZWZzLmRlZmluZSgncHJvZmlsZS5ib29sZWFuQXR0cmlidXRlcycsICdeY29udGVudGVkaXRhYmxlfHNlYW1sZXNzfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjaGVja2VkfGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGZvcm1ub3ZhbGlkYXRlfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG11dGVkfG5vdmFsaWRhdGV8cmVhZG9ubHl8cmVxdWlyZWR8cmV2ZXJzZWR8c2VsZWN0ZWR8dHlwZW11c3RtYXRjaCQnLCBcblx0XHQnQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgYm9vbGVhbiBieSBkZWZhdWx0LicgKyBcblx0XHQnSWYgYXR0cmlidXRlIG5hbWUgbWF0Y2hlcyB0aGlzIGV4cHJlc3Npb24sIHlvdSBkb27igJl0IGhhdmUgdG8gd3JpdGUgZG90ICcgK1xuXHRcdCdhZnRlciBhdHRyaWJ1dGUgbmFtZSBpbiBFbW1ldCBhYmJyZXZpYXRpb24gdG8gbWFyayBpdCBhcyBib29sZWFuLicpO1xuXG5cdHZhciBwcm9maWxlcyA9IHt9O1xuXHRcblx0dmFyIGRlZmF1bHRQcm9maWxlID0ge1xuXHRcdHRhZ19jYXNlOiAnYXNpcycsXG5cdFx0YXR0cl9jYXNlOiAnYXNpcycsXG5cdFx0YXR0cl9xdW90ZXM6ICdkb3VibGUnLFxuXHRcdFxuXHRcdC8vIEVhY2ggdGFnIG9uIG5ldyBsaW5lXG5cdFx0dGFnX25sOiAnZGVjaWRlJyxcblx0XHRcblx0XHQvLyBXaXRoIHRhZ19ubCA9PT0gdHJ1ZSwgZGVmaW5lcyBpZiBsZWFmIG5vZGUgKGUuZy4gbm9kZSB3aXRoIG5vIGNoaWxkcmVuKVxuXHRcdC8vIHNob3VsZCBoYXZlIGZvcm1hdHRlZCBsaW5lIGJyZWFrc1xuXHRcdHRhZ19ubF9sZWFmOiBmYWxzZSxcblx0XHRcblx0XHRwbGFjZV9jdXJzb3I6IHRydWUsXG5cdFx0XG5cdFx0Ly8gSW5kZW50IHRhZ3Ncblx0XHRpbmRlbnQ6IHRydWUsXG5cdFx0XG5cdFx0Ly8gSG93IG1hbnkgaW5saW5lIGVsZW1lbnRzIHNob3VsZCBiZSB0byBmb3JjZSBsaW5lIGJyZWFrIFxuXHRcdC8vIChzZXQgdG8gMCB0byBkaXNhYmxlKVxuXHRcdGlubGluZV9icmVhazogMyxcblxuXHRcdC8vIFByb2R1Y2UgY29tcGFjdCBub3RhdGlvbiBvZiBib29sZWFuIGF0dHJpYnVlczpcblx0XHQvLyBhdHRyaWJ1dGVzIHdoZXJlIG5hbWUgYW5kIHZhbHVlIGFyZSBlcXVhbC5cblx0XHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIEhUTUwgZmlsdGVyIHdpbGxcblx0XHQvLyBwcm9kdWNlIDxkaXYgY29udGVudGVkaXRhYmxlPiBpbnN0ZWFkIG9mIDxkaXYgY29udGVudGVkaXRhYmxlPVwiY29udGVudGVkaXRhYmxlXCI+XG5cdFx0Y29tcGFjdF9ib29sOiBmYWxzZSxcblx0XHRcblx0XHQvLyBVc2Ugc2VsZi1jbG9zaW5nIHN0eWxlIGZvciB3cml0aW5nIGVtcHR5IGVsZW1lbnRzLCBlLmcuIDxiciAvPiBvciA8YnI+XG5cdFx0c2VsZl9jbG9zaW5nX3RhZzogJ3hodG1sJyxcblx0XHRcblx0XHQvLyBQcm9maWxlLWxldmVsIG91dHB1dCBmaWx0ZXJzLCByZS1kZWZpbmVzIHN5bnRheCBmaWx0ZXJzIFxuXHRcdGZpbHRlcnM6ICcnLFxuXHRcdFxuXHRcdC8vIEFkZGl0aW9uYWwgZmlsdGVycyBhcHBsaWVkIHRvIGFiYnJldmlhdGlvbi5cblx0XHQvLyBVbmxpa2UgXCJmaWx0ZXJzXCIsIHRoaXMgcHJlZmVyZW5jZSBkb2Vzbid0IG92ZXJyaWRlIGRlZmF1bHQgZmlsdGVyc1xuXHRcdC8vIGJ1dCBhZGQgdGhlIGluc3RlYWQgZXZlcnkgdGltZSBnaXZlbiBwcm9maWxlIGlzIGNob3NlblxuXHRcdGV4dHJhRmlsdGVyczogJydcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHR5cGUgT3V0cHV0UHJvZmlsZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0ZnVuY3Rpb24gT3V0cHV0UHJvZmlsZShvcHRpb25zKSB7XG5cdFx0dXRpbHMuZXh0ZW5kKHRoaXMsIGRlZmF1bHRQcm9maWxlLCBvcHRpb25zKTtcblx0fVxuXHRcblx0T3V0cHV0UHJvZmlsZS5wcm90b3R5cGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogVHJhbnNmb3JtcyB0YWcgbmFtZSBjYXNlIGRlcGVuZGluZyBvbiBjdXJyZW50IHByb2ZpbGUgc2V0dGluZ3Ncblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBTdHJpbmcgdG8gdHJhbnNmb3JtXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHR0YWdOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gc3RyaW5nQ2FzZShuYW1lLCB0aGlzLnRhZ19jYXNlKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zZm9ybXMgYXR0cmlidXRlIG5hbWUgY2FzZSBkZXBlbmRpbmcgb24gY3VycmVudCBwcm9maWxlIHNldHRpbmdzIFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFN0cmluZyB0byB0cmFuc2Zvcm1cblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGF0dHJpYnV0ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiBzdHJpbmdDYXNlKG5hbWUsIHRoaXMuYXR0cl9jYXNlKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgcXVvdGUgY2hhcmFjdGVyIGZvciBjdXJyZW50IHByb2ZpbGVcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGF0dHJpYnV0ZVF1b3RlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHJfcXVvdGVzID09ICdzaW5nbGUnID8gXCInXCIgOiAnXCInO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHNlbGYtY2xvc2luZyB0YWcgc3ltYm9sIGZvciBjdXJyZW50IHByb2ZpbGVcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHNlbGZDbG9zaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLnNlbGZfY2xvc2luZ190YWcgPT0gJ3hodG1sJylcblx0XHRcdFx0cmV0dXJuICcgLyc7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLnNlbGZfY2xvc2luZ190YWcgPT09IHRydWUpXG5cdFx0XHRcdHJldHVybiAnLyc7XG5cdFx0XHRcblx0XHRcdHJldHVybiAnJztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgY3Vyc29yIHRva2VuIGJhc2VkIG9uIGN1cnJlbnQgcHJvZmlsZSBzZXR0aW5nc1xuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0Y3Vyc29yOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBsYWNlX2N1cnNvciA/IHV0aWxzLmdldENhcmV0UGxhY2Vob2xkZXIoKSA6ICcnO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBuYW1lIGlzIGJvb2xlYW4sXG5cdFx0ICogZS5nLiB3cml0dGVuIGFzIGBjb250ZW50ZWRpdGFibGVgIGluc3RlYWQgb2YgXG5cdFx0ICogYGNvbnRlbnRlZGl0YWJsZT1cImNvbnRlbnRlZGl0YWJsZVwiYFxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gIG5hbWUgQXR0cmlidXRlIG5hbWVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzQm9vbGVhbjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmIChuYW1lID09IHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYm9vbEF0dHJzID0gcHJlZnMuZ2V0KCdwcm9maWxlLmJvb2xlYW5BdHRyaWJ1dGVzJyk7XG5cdFx0XHRpZiAoIXZhbHVlICYmIGJvb2xBdHRycykge1xuXHRcdFx0XHRib29sQXR0cnMgPSBuZXcgUmVnRXhwKGJvb2xBdHRycywgJ2knKTtcblx0XHRcdFx0cmV0dXJuIGJvb2xBdHRycy50ZXN0KG5hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIGNvbXBhY3QgYm9vbGVhbiBhdHRyaWJ1dGUgcmVjb3JkIGlzIFxuXHRcdCAqIGFsbG93ZWQgZm9yIGN1cnJlbnQgcHJvZmlsZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0YWxsb3dDb21wYWN0Qm9vbGVhbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb21wYWN0X2Jvb2wgJiYgcHJlZnMuZ2V0KCdwcm9maWxlLmFsbG93Q29tcGFjdEJvb2xlYW4nKTtcblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY29udmVydHMgc3RyaW5nIGNhc2UgZGVwZW5kaW5nIG9uIFxuXHQgKiA8Y29kZT5jYXNlVmFsdWU8L2NvZGU+IFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byB0cmFuc2Zvcm1cblx0ICogQHBhcmFtIHtTdHJpbmd9IGNhc2VWYWx1ZSBDYXNlIHZhbHVlOiBjYW4gYmUgPGk+bG93ZXI8L2k+LCBcblx0ICogPGk+dXBwZXI8L2k+IGFuZCA8aT5sZWF2ZTwvaT5cblx0ICogQHJldHVybnMge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIHN0cmluZ0Nhc2Uoc3RyLCBjYXNlVmFsdWUpIHtcblx0XHRzd2l0Y2ggKFN0cmluZyhjYXNlVmFsdWUgfHwgJycpLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdGNhc2UgJ2xvd2VyJzpcblx0XHRcdFx0cmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0Y2FzZSAndXBwZXInOlxuXHRcdFx0XHRyZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBzdHI7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDcmVhdGVzIG5ldyBvdXRwdXQgcHJvZmlsZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcm9maWxlIG5hbWVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUHJvZmlsZSBvcHRpb25zXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVQcm9maWxlKG5hbWUsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gcHJvZmlsZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IG5ldyBPdXRwdXRQcm9maWxlKG9wdGlvbnMpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjcmVhdGVEZWZhdWx0UHJvZmlsZXMoKSB7XG5cdFx0Y3JlYXRlUHJvZmlsZSgneGh0bWwnKTtcblx0XHRjcmVhdGVQcm9maWxlKCdodG1sJywge3NlbGZfY2xvc2luZ190YWc6IGZhbHNlLCBjb21wYWN0X2Jvb2w6IHRydWV9KTtcblx0XHRjcmVhdGVQcm9maWxlKCd4bWwnLCB7c2VsZl9jbG9zaW5nX3RhZzogdHJ1ZSwgdGFnX25sOiB0cnVlfSk7XG5cdFx0Y3JlYXRlUHJvZmlsZSgncGxhaW4nLCB7dGFnX25sOiBmYWxzZSwgaW5kZW50OiBmYWxzZSwgcGxhY2VfY3Vyc29yOiBmYWxzZX0pO1xuXHRcdGNyZWF0ZVByb2ZpbGUoJ2xpbmUnLCB7dGFnX25sOiBmYWxzZSwgaW5kZW50OiBmYWxzZSwgZXh0cmFGaWx0ZXJzOiAncyd9KTtcblx0XHRjcmVhdGVQcm9maWxlKCdjc3MnLCB7dGFnX25sOiB0cnVlfSk7XG5cdFx0Y3JlYXRlUHJvZmlsZSgnY3NzX2xpbmUnLCB7dGFnX25sOiBmYWxzZX0pO1xuXHR9XG5cdFxuXHRjcmVhdGVEZWZhdWx0UHJvZmlsZXMoKTtcblx0XG5cdHJldHVybiAge1xuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgbmV3IG91dHB1dCBwcm9maWxlIGFuZCBhZGRzIGl0IGludG8gaW50ZXJuYWwgZGljdGlvbmFyeVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFByb2ZpbGUgbmFtZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFByb2ZpbGUgb3B0aW9uc1xuXHRcdCAqIEBtZW1iZXJPZiBlbW1ldC5wcm9maWxlXG5cdFx0ICogQHJldHVybnMge09iamVjdH0gTmV3IHByb2ZpbGVcblx0XHQgKi9cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpXG5cdFx0XHRcdHJldHVybiBjcmVhdGVQcm9maWxlKG5hbWUsIG9wdGlvbnMpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHQvLyBjcmVhdGUgcHJvZmlsZSBvYmplY3Qgb25seVxuXHRcdFx0XHRyZXR1cm4gbmV3IE91dHB1dFByb2ZpbGUodXRpbHMuZGVmYXVsdHMobmFtZSB8fCB7fSwgZGVmYXVsdFByb2ZpbGUpKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgcHJvZmlsZSBieSBpdHMgbmFtZS4gSWYgcHJvZmlsZSB3YXNuJ3QgZm91bmQsIHJldHVybnNcblx0XHQgKiAncGxhaW4nIHByb2ZpbGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcm9maWxlIG5hbWUuIE1pZ2h0IGJlIHByb2ZpbGUgaXRzZWxmXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN5bnRheC4gT3B0aW9uYWwuIEN1cnJlbnQgZWRpdG9yIHN5bnRheC4gSWYgZGVmaW5lZCxcblx0XHQgKiBwcm9maWxlIGlzIHNlYXJjaGVkIGluIHJlc291cmNlcyBmaXJzdCwgdGhlbiBpbiBwcmVkZWZpbmVkIHByb2ZpbGVzXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRnZXQ6IGZ1bmN0aW9uKG5hbWUsIHN5bnRheCkge1xuXHRcdFx0aWYgKCFuYW1lICYmIHN5bnRheCkge1xuXHRcdFx0XHQvLyBzZWFyY2ggaW4gdXNlciByZXNvdXJjZXMgZmlyc3Rcblx0XHRcdFx0dmFyIHByb2ZpbGUgPSByZXNvdXJjZXMuZmluZEl0ZW0oc3ludGF4LCAncHJvZmlsZScpO1xuXHRcdFx0XHRpZiAocHJvZmlsZSkge1xuXHRcdFx0XHRcdG5hbWUgPSBwcm9maWxlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICghbmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gcHJvZmlsZXMucGxhaW47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChuYW1lIGluc3RhbmNlb2YgT3V0cHV0UHJvZmlsZSkge1xuXHRcdFx0XHRyZXR1cm4gbmFtZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gcHJvZmlsZXMpIHtcblx0XHRcdFx0cmV0dXJuIHByb2ZpbGVzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZShuYW1lKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERlbGV0ZXMgcHJvZmlsZSB3aXRoIHNwZWNpZmllZCBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgUHJvZmlsZSBuYW1lXG5cdFx0ICovXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRuYW1lID0gKG5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRpZiAobmFtZSBpbiBwcm9maWxlcylcblx0XHRcdFx0ZGVsZXRlIHByb2ZpbGVzW25hbWVdO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVzZXRzIGFsbCB1c2VyLWRlZmluZWQgcHJvZmlsZXNcblx0XHQgKi9cblx0XHRyZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRwcm9maWxlcyA9IHt9O1xuXHRcdFx0Y3JlYXRlRGVmYXVsdFByb2ZpbGVzKCk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyBzdHJpbmcgY2FzZSBkZXBlbmRpbmcgb24gXG5cdFx0ICogPGNvZGU+Y2FzZVZhbHVlPC9jb2RlPiBcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byB0cmFuc2Zvcm1cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY2FzZVZhbHVlIENhc2UgdmFsdWU6IGNhbiBiZSA8aT5sb3dlcjwvaT4sIFxuXHRcdCAqIDxpPnVwcGVyPC9pPiBhbmQgPGk+bGVhdmU8L2k+XG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRzdHJpbmdDYXNlOiBzdHJpbmdDYXNlXG5cdH07XG59KTtcblxufSx7XCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi9wcmVmZXJlbmNlc1wiOlwiYXNzZXRzXFxcXHByZWZlcmVuY2VzLmpzXCIsXCIuL3Jlc291cmNlc1wiOlwiYXNzZXRzXFxcXHJlc291cmNlcy5qc1wifV0sXCJhc3NldHNcXFxccmFuZ2UuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEhlbHBlciBtb2R1bGUgdG8gd29yayB3aXRoIHJhbmdlc1xuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHRmdW5jdGlvbiBjbXAoYSwgYiwgb3ApIHtcblx0XHRzd2l0Y2ggKG9wKSB7XG5cdFx0XHRjYXNlICdlcSc6XG5cdFx0XHRjYXNlICc9PSc6XG5cdFx0XHRcdHJldHVybiBhID09PSBiO1xuXHRcdFx0Y2FzZSAnbHQnOlxuXHRcdFx0Y2FzZSAnPCc6XG5cdFx0XHRcdHJldHVybiBhIDwgYjtcblx0XHRcdGNhc2UgJ2x0ZSc6XG5cdFx0XHRjYXNlICc8PSc6XG5cdFx0XHRcdHJldHVybiBhIDw9IGI7XG5cdFx0XHRjYXNlICdndCc6XG5cdFx0XHRjYXNlICc+Jzpcblx0XHRcdFx0cmV0dXJuIGEgPiBiO1xuXHRcdFx0Y2FzZSAnZ3RlJzpcblx0XHRcdGNhc2UgJz49Jzpcblx0XHRcdFx0cmV0dXJuIGEgPj0gYjtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQHR5cGUgUmFuZ2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGFydFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGVuXG5cdCAqL1xuXHRmdW5jdGlvbiBSYW5nZShzdGFydCwgbGVuKSB7XG5cdFx0aWYgKHR5cGVvZiBzdGFydCA9PT0gJ29iamVjdCcgJiYgJ3N0YXJ0JyBpbiBzdGFydCkge1xuXHRcdFx0Ly8gY3JlYXRlIHJhbmdlIGZyb20gb2JqZWN0IHN0dWJcblx0XHRcdHRoaXMuc3RhcnQgPSBNYXRoLm1pbihzdGFydC5zdGFydCwgc3RhcnQuZW5kKTtcblx0XHRcdHRoaXMuZW5kID0gTWF0aC5tYXgoc3RhcnQuc3RhcnQsIHN0YXJ0LmVuZCk7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHN0YXJ0KSkge1xuXHRcdFx0dGhpcy5zdGFydCA9IHN0YXJ0WzBdO1xuXHRcdFx0dGhpcy5lbmQgPSBzdGFydFsxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGVuID0gdHlwZW9mIGxlbiA9PT0gJ3N0cmluZycgPyBsZW4ubGVuZ3RoIDogK2xlbjtcblx0XHRcdHRoaXMuc3RhcnQgPSBzdGFydDtcblx0XHRcdHRoaXMuZW5kID0gc3RhcnQgKyBsZW47XG5cdFx0fVxuXHR9XG5cdFxuXHRSYW5nZS5wcm90b3R5cGUgPSB7XG5cdFx0bGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiBwYXNzZWQgcmFuZ2UgaXMgZXF1YWxzIHRvIGN1cnJlbnQgb25lXG5cdFx0ICogQHBhcmFtIHtSYW5nZX0gcmFuZ2Vcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRlcXVhbDogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHRcdHJldHVybiB0aGlzLmNtcChyYW5nZSwgJ2VxJywgJ2VxJyk7XG4vL1x0XHRcdHJldHVybiB0aGlzLnN0YXJ0ID09PSByYW5nZS5zdGFydCAmJiB0aGlzLmVuZCA9PT0gcmFuZ2UuZW5kO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2hpZnRzIGluZGV4ZXMgcG9zaXRpb24gd2l0aCBwYXNzZWQgPGNvZGU+ZGVsdGE8L2NvZGU+XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG5cdFx0ICogQHJldHVybnMge1JhbmdlfSByYW5nZSBpdHNlbGZcblx0XHQgKi9cblx0XHRzaGlmdDogZnVuY3Rpb24oZGVsdGEpIHtcblx0XHRcdHRoaXMuc3RhcnQgKz0gZGVsdGE7XG5cdFx0XHR0aGlzLmVuZCArPSBkZWx0YTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgdHdvIHJhbmdlcyBhcmUgb3ZlcmxhcHBlZFxuXHRcdCAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b3ZlcmxhcDogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHRcdHJldHVybiByYW5nZS5zdGFydCA8PSB0aGlzLmVuZCAmJiByYW5nZS5lbmQgPj0gdGhpcy5zdGFydDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEZpbmRzIGludGVyc2VjdGlvbiBvZiB0d28gcmFuZ2VzXG5cdFx0ICogQHBhcmFtIHtSYW5nZX0gcmFuZ2Vcblx0XHQgKiBAcmV0dXJucyB7UmFuZ2V9IDxjb2RlPm51bGw8L2NvZGU+IGlmIHJhbmdlcyBkb2VzIG5vdCBvdmVybGFwXG5cdFx0ICovXG5cdFx0aW50ZXJzZWN0aW9uOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdFx0aWYgKHRoaXMub3ZlcmxhcChyYW5nZSkpIHtcblx0XHRcdFx0dmFyIHN0YXJ0ID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnQsIHRoaXMuc3RhcnQpO1xuXHRcdFx0XHR2YXIgZW5kID0gTWF0aC5taW4ocmFuZ2UuZW5kLCB0aGlzLmVuZCk7XG5cdFx0XHRcdHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSB1bmlvbiBvZiB0aGUgdGhvdyByYW5nZXMuXG5cdFx0ICogQHBhcmFtIHtSYW5nZX0gcmFuZ2Vcblx0XHQgKiBAcmV0dXJucyB7UmFuZ2V9IDxjb2RlPm51bGw8L2NvZGU+IGlmIHJhbmdlcyBhcmUgbm90IG92ZXJsYXBwZWRcblx0XHQgKi9cblx0XHR1bmlvbjogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHRcdGlmICh0aGlzLm92ZXJsYXAocmFuZ2UpKSB7XG5cdFx0XHRcdHZhciBzdGFydCA9IE1hdGgubWluKHJhbmdlLnN0YXJ0LCB0aGlzLnN0YXJ0KTtcblx0XHRcdFx0dmFyIGVuZCA9IE1hdGgubWF4KHJhbmdlLmVuZCwgdGhpcy5lbmQpO1xuXHRcdFx0XHRyZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIEJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBhIHNwZWNpZmllZCBwb3NpdGlvbiBcblx0XHQgKiBpcyBpbiBhIGdpdmVuIHJhbmdlLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBsb2Ncblx0XHQgKi9cblx0XHRpbnNpZGU6IGZ1bmN0aW9uKGxvYykge1xuXHRcdFx0cmV0dXJuIHRoaXMuY21wKGxvYywgJ2x0ZScsICdndCcpO1xuLy9cdFx0XHRyZXR1cm4gdGhpcy5zdGFydCA8PSBsb2MgJiYgdGhpcy5lbmQgPiBsb2M7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgQm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGEgc3BlY2lmaWVkIHBvc2l0aW9uIFxuXHRcdCAqIGlzIGluIGEgZ2l2ZW4gcmFuZ2UsIGJ1dCBub3QgZXF1YWxzIGJvdW5kcy5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gbG9jXG5cdFx0ICovXG5cdFx0Y29udGFpbnM6IGZ1bmN0aW9uKGxvYykge1xuXHRcdFx0cmV0dXJuIHRoaXMuY21wKGxvYywgJ2x0JywgJ2d0Jyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBjdXJyZW50IHJhbmdlIGNvbXBsZXRlbHkgaW5jbHVkZXMgc3BlY2lmaWVkIG9uZVxuXHRcdCAqIEBwYXJhbSB7UmFuZ2V9IHJcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gXG5cdFx0ICovXG5cdFx0aW5jbHVkZTogZnVuY3Rpb24ocikge1xuXHRcdFx0cmV0dXJuIHRoaXMuY21wKHIsICdsdGUnLCAnZ3RlJyk7XG4vL1x0XHRcdHJldHVybiB0aGlzLnN0YXJ0IDw9IHIuc3RhcnQgJiYgdGhpcy5lbmQgPj0gci5lbmQ7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBMb3ctbGV2ZWwgY29tcGFyaXNpb24gbWV0aG9kXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGxvY1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBsZWZ0IExlZnQgY29tcGFyaXNvbiBvcGVyYXRvclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSByaWdodCBSaWdodCBjb21hcHJpc29uIG9wZXJhdG9yXG5cdFx0ICovXG5cdFx0Y21wOiBmdW5jdGlvbihsb2MsIGxlZnQsIHJpZ2h0KSB7XG5cdFx0XHR2YXIgYSwgYjtcblx0XHRcdGlmIChsb2MgaW5zdGFuY2VvZiBSYW5nZSkge1xuXHRcdFx0XHRhID0gbG9jLnN0YXJ0O1xuXHRcdFx0XHRiID0gbG9jLmVuZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGEgPSBiID0gbG9jO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY21wKHRoaXMuc3RhcnQsIGEsIGxlZnQgfHwgJzw9JykgJiYgY21wKHRoaXMuZW5kLCBiLCByaWdodCB8fCAnPicpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBzdWJzdHJpbmcgb2Ygc3BlY2lmaWVkIDxjb2RlPnN0cjwvY29kZT4gZm9yIGN1cnJlbnQgcmFuZ2Vcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRzdWJzdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHRoaXMubGVuZ3RoKCkgPiAwIFxuXHRcdFx0XHQ/IHN0ci5zdWJzdHJpbmcodGhpcy5zdGFydCwgdGhpcy5lbmQpIFxuXHRcdFx0XHQ6ICcnO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBjb3B5IG9mIGN1cnJlbnQgcmFuZ2Vcblx0XHQgKiBAcmV0dXJucyB7UmFuZ2V9XG5cdFx0ICovXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLmxlbmd0aCgpKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIHtBcnJheX1cblx0XHQgKi9cblx0XHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbdGhpcy5zdGFydCwgdGhpcy5lbmRdO1xuXHRcdH0sXG5cdFx0XG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVPZigpO1xuXHRcdH0sXG5cblx0XHR2YWx1ZU9mOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAneycgKyB0aGlzLnN0YXJ0ICsgJywgJyArIHRoaXMubGVuZ3RoKCkgKyAnfSc7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIG5ldyByYW5nZSBvYmplY3QgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0YXJ0IFJhbmdlIHN0YXJ0IG9yIGFycmF5IHdpdGggJ3N0YXJ0JyBhbmQgJ2VuZCdcblx0ICogYXMgdHdvIGZpcnN0IGluZGV4ZXMgb3Igb2JqZWN0IHdpdGggJ3N0YXJ0JyBhbmQgJ2VuZCcgcHJvcGVydGllc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbGVuIFJhbmdlIGxlbmd0aCBvciBzdHJpbmcgdG8gcHJvZHVjZSByYW5nZSBmcm9tXG5cdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0ICovXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RhcnQsIGxlbikge1xuXHRcdGlmICh0eXBlb2Ygc3RhcnQgPT0gJ3VuZGVmaW5lZCcgfHwgc3RhcnQgPT09IG51bGwpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdGlmIChzdGFydCBpbnN0YW5jZW9mIFJhbmdlKVxuXHRcdFx0cmV0dXJuIHN0YXJ0O1xuXHRcdFxuXHRcdGlmICh0eXBlb2Ygc3RhcnQgPT0gJ29iamVjdCcgJiYgJ3N0YXJ0JyBpbiBzdGFydCAmJiAnZW5kJyBpbiBzdGFydCkge1xuXHRcdFx0bGVuID0gc3RhcnQuZW5kIC0gc3RhcnQuc3RhcnQ7XG5cdFx0XHRzdGFydCA9IHN0YXJ0LnN0YXJ0O1xuXHRcdH1cblx0XHRcdFxuXHRcdHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGxlbik7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMuY3JlYXRlID0gbW9kdWxlLmV4cG9ydHM7XG5cblx0bW9kdWxlLmV4cG9ydHMuaXNSYW5nZSA9IGZ1bmN0aW9uKHZhbCkge1xuXHRcdHJldHVybiB2YWwgaW5zdGFuY2VvZiBSYW5nZTtcblx0fTtcblxuXHQvKipcblx0ICogPGNvZGU+UmFuZ2U8L2NvZGU+IG9iamVjdCBmYWN0b3J5LCB0aGUgc2FtZSBhcyA8Y29kZT50aGlzLmNyZWF0ZSgpPC9jb2RlPlxuXHQgKiBidXQgbGFzdCBhcmd1bWVudCByZXByZXNlbnRzIGVuZCBvZiByYW5nZSwgbm90IGxlbmd0aFxuXHQgKiBAcmV0dXJucyB7UmFuZ2V9XG5cdCAqL1xuXHRtb2R1bGUuZXhwb3J0cy5jcmVhdGUyID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuXHRcdGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmIHR5cGVvZiBlbmQgPT09ICdudW1iZXInKSB7XG5cdFx0XHRlbmQgLT0gc3RhcnQ7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0aGlzLmNyZWF0ZShzdGFydCwgZW5kKTtcblx0fTtcblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgc29ydHMgcmFuZ2VzIGluIG9yZGVyIGFzIHRoZXlcblx0ICogYXBwZWFyIGluIHRleHRcblx0ICogQHBhcmFtICB7QXJyYXl9IHJhbmdlc1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdG1vZHVsZS5leHBvcnRzLnNvcnQgPSBmdW5jdGlvbihyYW5nZXMsIHJldmVyc2UpIHtcblx0XHRyYW5nZXMgPSByYW5nZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRpZiAoYS5zdGFydCA9PT0gYi5zdGFydCkge1xuXHRcdFx0XHRyZXR1cm4gYi5lbmQgLSBhLmVuZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuXHRcdH0pO1xuXG5cdFx0cmV2ZXJzZSAmJiByYW5nZXMucmV2ZXJzZSgpO1xuXHRcdHJldHVybiByYW5nZXM7XG5cdH07XG5cblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufSk7XG59LHt9XSxcImFzc2V0c1xcXFxyZXNvdXJjZXMuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFBhcnNlZCByZXNvdXJjZXMgKHNuaXBwZXRzLCBhYmJyZXZpYXRpb25zLCB2YXJpYWJsZXMsIGV0Yy4pIGZvciBFbW1ldC5cbiAqIENvbnRhaW5zIGNvbnZlbmllbnQgbWV0aG9kIHRvIGdldCBhY2Nlc3MgZm9yIHNuaXBwZXRzIHdpdGggcmVzcGVjdCBvZlxuICogaW5oZXJpdGFuY2UuIEFsc28gcHJvdmlkZXMgYWJpbGl0eSB0byBzdG9yZSBkYXRhIGluIGRpZmZlcmVudCB2b2NhYnVsYXJpZXNcbiAqICgnc3lzdGVtJyBhbmQgJ3VzZXInKSBmb3IgZmFzdCBhbmQgc2FmZSByZXNvdXJjZSB1cGRhdGVcbiAqIEBhdXRob3IgU2VyZ2V5IENoaWt1eW9ub2sgKHNlcmdlLmNoZUBnbWFpbC5jb20pXG4gKiBAbGluayBodHRwOi8vY2hpa3V5b25vay5ydVxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgaGFuZGxlckxpc3QgPSByZXF1aXJlKCcuL2hhbmRsZXJMaXN0Jyk7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgZWxlbWVudHMgPSByZXF1aXJlKCcuL2VsZW1lbnRzJyk7XG5cdHZhciBsb2dnZXIgPSByZXF1aXJlKCcuLi9hc3NldHMvbG9nZ2VyJyk7XG5cdHZhciBzdHJpbmdTY29yZSA9IHJlcXVpcmUoJy4uL3ZlbmRvci9zdHJpbmdTY29yZScpO1xuXHR2YXIgY3NzUmVzb2x2ZXIgPSByZXF1aXJlKCcuLi9yZXNvbHZlci9jc3MnKTtcblxuXHR2YXIgVk9DX1NZU1RFTSA9ICdzeXN0ZW0nO1xuXHR2YXIgVk9DX1VTRVIgPSAndXNlcic7XG5cblx0dmFyIGNhY2hlID0ge307XG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgWE1MIHRhZyBtYXRjaGluZyAqL1xuXHR2YXIgcmVUYWcgPSAvXjwoXFx3K1xcOj9bXFx3XFwtXSopKCg/OlxccytbQFxcIV0/W1xcd1xcOlxcLV0rXFxzKj1cXHMqKFsnXCJdKS4qP1xcMykqKVxccyooXFwvPyk+LztcblxuXHR2YXIgc3lzdGVtU2V0dGluZ3MgPSB7fTtcblx0dmFyIHVzZXJTZXR0aW5ncyA9IHt9O1xuXG5cdC8qKiBAdHlwZSBIYW5kbGVyTGlzdCBMaXN0IG9mIHJlZ2lzdGVyZWQgYWJicmV2aWF0aW9uIHJlc29sdmVycyAqL1xuXHR2YXIgcmVzb2x2ZXJzID0gaGFuZGxlckxpc3QuY3JlYXRlKCk7XG5cblx0ZnVuY3Rpb24gZWFjaChvYmosIGZuKSB7XG5cdFx0aWYgKCFvYmopIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRmbihvYmpba2V5XSwga2V5KTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemVzIGNhcmV0IHBsY2Vob2xkZXIgaW4gcGFzc2VkIHRleHQ6IHJlcGxhY2VzIHwgY2hhcmFjdGVyIHdpdGhcblx0ICogZGVmYXVsdCBjYXJldCBwbGFjZWhvbGRlclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gbm9ybWFsaXplQ2FyZXRQbGFjZWhvbGRlcih0ZXh0KSB7XG5cdFx0cmV0dXJuIHV0aWxzLnJlcGxhY2VVbmVzY2FwZWRTeW1ib2wodGV4dCwgJ3wnLCB1dGlscy5nZXRDYXJldFBsYWNlaG9sZGVyKCkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VJdGVtKG5hbWUsIHZhbHVlLCB0eXBlKSB7XG5cdFx0dmFsdWUgPSBub3JtYWxpemVDYXJldFBsYWNlaG9sZGVyKHZhbHVlKTtcblxuXHRcdGlmICh0eXBlID09ICdzbmlwcGV0cycpIHtcblx0XHRcdHJldHVybiBlbGVtZW50cy5jcmVhdGUoJ3NuaXBwZXQnLCB2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGUgPT0gJ2FiYnJldmlhdGlvbnMnKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VBYmJyZXZpYXRpb24obmFtZSwgdmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgc2luZ2xlIGFiYnJldmlhdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEFiYnJldmlhdGlvbiBuYW1lXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBBYmJyZXZpYXRpb24gdmFsdWVcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VBYmJyZXZpYXRpb24oa2V5LCB2YWx1ZSkge1xuXHRcdGtleSA9IHV0aWxzLnRyaW0oa2V5KTtcblx0XHR2YXIgbTtcblx0XHRpZiAoKG0gPSByZVRhZy5leGVjKHZhbHVlKSkpIHtcblx0XHRcdHJldHVybiBlbGVtZW50cy5jcmVhdGUoJ2VsZW1lbnQnLCBtWzFdLCBtWzJdLCBtWzRdID09ICcvJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFzc3VtZSBpdCdzIHJlZmVyZW5jZSB0byBhbm90aGVyIGFiYnJldmlhdGlvblxuXHRcdFx0cmV0dXJuIGVsZW1lbnRzLmNyZWF0ZSgncmVmZXJlbmNlJywgdmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemVzIHNuaXBwZXQga2V5IG5hbWUgZm9yIGJldHRlciBmdXp6eSBzZWFyY2hcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gbm9ybWFsaXplTmFtZShzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLzokLywgJycpLnJlcGxhY2UoLzovZywgJy0nKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cGFuZFNuaXBwZXRzRGVmaW5pdGlvbihzbmlwcGV0cykge1xuXHRcdHZhciBvdXQgPSB7fTtcblx0XHRlYWNoKHNuaXBwZXRzLCBmdW5jdGlvbih2YWwsIGtleSkge1xuXHRcdFx0dmFyIGl0ZW1zID0ga2V5LnNwbGl0KCd8Jyk7XG5cdFx0XHQvLyBkbyBub3QgdXNlIGl0ZXJhdG9ycyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG5cdFx0XHRmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0b3V0W2l0ZW1zW2ldXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblxuXHR1dGlscy5leHRlbmQoZXhwb3J0cywge1xuXHRcdC8qKlxuXHRcdCAqIFNldHMgbmV3IHVucGFyc2VkIGRhdGEgZm9yIHNwZWNpZmllZCBzZXR0aW5ncyB2b2NhYnVsYXJ5XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBWb2NhYnVsYXJ5IHR5cGUgKCdzeXN0ZW0nIG9yICd1c2VyJylcblx0XHQgKiBAbWVtYmVyT2YgcmVzb3VyY2VzXG5cdFx0ICovXG5cdFx0c2V0Vm9jYWJ1bGFyeTogZnVuY3Rpb24oZGF0YSwgdHlwZSkge1xuXHRcdFx0Y2FjaGUgPSB7fTtcblxuXHRcdFx0Ly8gc2VjdGlvbnMgbGlrZSBcInNuaXBwZXRzXCIgYW5kIFwiYWJicmV2aWF0aW9uc1wiIGNvdWxkIGhhdmVcblx0XHRcdC8vIGRlZmluaXRpb25zIGxpa2UgYFwiZnxmc1wiOiBcImZpZWxkc2V0XCJgIHdoaWNoIGlzIHRoZSBzYW1lIGFzIGRpc3RpbmN0XG5cdFx0XHQvLyBcImZcIiBhbmQgXCJmc1wiIGtleXMgYm90aCBlcXVhbHMgdG8gXCJmaWVsZHNldFwiLlxuXHRcdFx0Ly8gV2Ugc2hvdWxkIHBhcnNlIHRoZXNlIGRlZmluaXRpb25zIGZpcnN0XG5cdFx0XHR2YXIgdm9jID0ge307XG5cdFx0XHRlYWNoKGRhdGEsIGZ1bmN0aW9uKHNlY3Rpb24sIHN5bnRheCkge1xuXHRcdFx0XHR2YXIgX3NlY3Rpb24gPSB7fTtcblx0XHRcdFx0ZWFjaChzZWN0aW9uLCBmdW5jdGlvbihzdWJzZWN0aW9uLCBuYW1lKSB7XG5cdFx0XHRcdFx0aWYgKG5hbWUgPT0gJ2FiYnJldmlhdGlvbnMnIHx8IG5hbWUgPT0gJ3NuaXBwZXRzJykge1xuXHRcdFx0XHRcdFx0c3Vic2VjdGlvbiA9IGV4cGFuZFNuaXBwZXRzRGVmaW5pdGlvbihzdWJzZWN0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X3NlY3Rpb25bbmFtZV0gPSBzdWJzZWN0aW9uO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR2b2Nbc3ludGF4XSA9IF9zZWN0aW9uO1xuXHRcdFx0fSk7XG5cblxuXHRcdFx0aWYgKHR5cGUgPT0gVk9DX1NZU1RFTSkge1xuXHRcdFx0XHRzeXN0ZW1TZXR0aW5ncyA9IHZvYztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVzZXJTZXR0aW5ncyA9IHZvYztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyByZXNvdXJjZSB2b2NhYnVsYXJ5IGJ5IGl0cyBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVm9jYWJ1bGFyeSBuYW1lICgnc3lzdGVtJyBvciAndXNlcicpXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldFZvY2FidWxhcnk6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiBuYW1lID09IFZPQ19TWVNURU0gPyBzeXN0ZW1TZXR0aW5ncyA6IHVzZXJTZXR0aW5ncztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyByZXNvdXJjZSAoYWJicmV2aWF0aW9uLCBzbmlwcGV0LCBldGMuKSBtYXRjaGVkIGZvciBwYXNzZWRcblx0XHQgKiBhYmJyZXZpYXRpb25cblx0XHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4XG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRnZXRNYXRjaGVkUmVzb3VyY2U6IGZ1bmN0aW9uKG5vZGUsIHN5bnRheCkge1xuXHRcdFx0cmV0dXJuIHJlc29sdmVycy5leGVjKG51bGwsIHV0aWxzLnRvQXJyYXkoYXJndW1lbnRzKSlcblx0XHRcdFx0fHwgdGhpcy5maW5kU25pcHBldChzeW50YXgsIG5vZGUubmFtZSgpKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB2YXJpYWJsZSB2YWx1ZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuICh0aGlzLmdldFNlY3Rpb24oJ3ZhcmlhYmxlcycpIHx8IHt9KVtuYW1lXTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgcnVudGltZSB2YXJpYWJsZSBpbiB1c2VyIHN0b3JhZ2Vcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBWYXJpYWJsZSBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFZhcmlhYmxlIHZhbHVlXG5cdFx0ICovXG5cdFx0c2V0VmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcblx0XHRcdHZhciB2b2MgPSB0aGlzLmdldFZvY2FidWxhcnkoJ3VzZXInKSB8fCB7fTtcblx0XHRcdGlmICghKCd2YXJpYWJsZXMnIGluIHZvYykpXG5cdFx0XHRcdHZvYy52YXJpYWJsZXMgPSB7fTtcblxuXHRcdFx0dm9jLnZhcmlhYmxlc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5zZXRWb2NhYnVsYXJ5KHZvYywgJ3VzZXInKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgdGhlcmUgYXJlIHJlc291cmNlcyBmb3Igc3BlY2lmaWVkIHN5bnRheFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXhcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGhhc1N5bnRheDogZnVuY3Rpb24oc3ludGF4KSB7XG5cdFx0XHRyZXR1cm4gc3ludGF4IGluIHRoaXMuZ2V0Vm9jYWJ1bGFyeShWT0NfVVNFUilcblx0XHRcdFx0fHwgc3ludGF4IGluIHRoaXMuZ2V0Vm9jYWJ1bGFyeShWT0NfU1lTVEVNKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIG5ldyBhYmJyZXZpYXRpb24gcmVzb2x2ZXIuXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQWJicmV2aWF0aW9uIHJlc29sdmVyIHdoaWNoIHdpbGwgcmVjZWl2ZVxuXHRcdCAqIGFiYnJldmlhdGlvbiBhcyBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBwYXJzZWQgYWJicmV2aWF0aW9uXG5cdFx0ICogb2JqZWN0IGlmIGFiYnJldmlhdGlvbiBoYXMgaGFuZGxlZCBzdWNjZXNzZnVsbHksIDxjb2RlPm51bGw8L2NvZGU+XG5cdFx0ICogb3RoZXJ3aXNlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBsaXN0IGFzIGRlc2NyaWJlZCBpblxuXHRcdCAqIHtAbGluayBIYW5kbGVyTGlzdCNhZGQoKX0gbWV0aG9kXG5cdFx0ICovXG5cdFx0YWRkUmVzb2x2ZXI6IGZ1bmN0aW9uKGZuLCBvcHRpb25zKSB7XG5cdFx0XHRyZXNvbHZlcnMuYWRkKGZuLCBvcHRpb25zKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlUmVzb2x2ZXI6IGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHRyZXNvbHZlcnMucmVtb3ZlKGZuKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhY3R1YWwgc2VjdGlvbiBkYXRhLCBtZXJnZWQgZnJvbSBib3RoXG5cdFx0ICogc3lzdGVtIGFuZCB1c2VyIGRhdGFcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBTZWN0aW9uIG5hbWUgKHN5bnRheClcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gLi4uYXJncyBTdWJzZWN0aW9uc1xuXHRcdCAqIEByZXR1cm5zXG5cdFx0ICovXG5cdFx0Z2V0U2VjdGlvbjogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0aWYgKCFuYW1lKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0aWYgKCEobmFtZSBpbiBjYWNoZSkpIHtcblx0XHRcdFx0Y2FjaGVbbmFtZV0gPSB1dGlscy5kZWVwTWVyZ2Uoe30sIHN5c3RlbVNldHRpbmdzW25hbWVdLCB1c2VyU2V0dGluZ3NbbmFtZV0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGF0YSA9IGNhY2hlW25hbWVdLCBzdWJzZWN0aW9ucyA9IHV0aWxzLnRvQXJyYXkoYXJndW1lbnRzLCAxKSwga2V5O1xuXHRcdFx0d2hpbGUgKGRhdGEgJiYgKGtleSA9IHN1YnNlY3Rpb25zLnNoaWZ0KCkpKSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gZGF0YSkge1xuXHRcdFx0XHRcdGRhdGEgPSBkYXRhW2tleV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIGZvciBhIGl0ZW0gaW5zaWRlIHRvcCBsZXZlbCBzZWN0aW9ucyAoc3ludGF4ZXMpXG5cdFx0ICogd2l0aCByZXNwZWN0IG9mIGBleHRlbmRzYCBhdHRyaWJ1dGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdG9wU2VjdGlvbiBUb3Agc2VjdGlvbiBuYW1lIChzeW50YXgpXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN1YnNlY3Rpb24gSW5uZXIgc2VjdGlvbiBuYW1lXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRmaW5kSXRlbTogZnVuY3Rpb24odG9wU2VjdGlvbiwgc3Vic2VjdGlvbikge1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLmdldFNlY3Rpb24odG9wU2VjdGlvbik7XG5cdFx0XHR3aGlsZSAoZGF0YSkge1xuXHRcdFx0XHRpZiAoc3Vic2VjdGlvbiBpbiBkYXRhKVxuXHRcdFx0XHRcdHJldHVybiBkYXRhW3N1YnNlY3Rpb25dO1xuXG5cdFx0XHRcdGRhdGEgPSB0aGlzLmdldFNlY3Rpb24oZGF0YVsnZXh0ZW5kcyddKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVjdXJzaXZlbHkgc2VhcmNoZXMgZm9yIGEgc25pcHBldCBkZWZpbml0aW9uIGluc2lkZSBzeW50YXggc2VjdGlvbi5cblx0XHQgKiBEZWZpbml0aW9uIGlzIHNlYXJjaGVkIGluc2lkZSBgc25pcHBldHNgIGFuZCBgYWJicmV2aWF0aW9uc2Bcblx0XHQgKiBzdWJzZWN0aW9uc1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXggVG9wLWxldmVsIHNlY3Rpb24gbmFtZSAoc3ludGF4KVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFNuaXBwZXQgbmFtZVxuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0ZmluZFNuaXBwZXQ6IGZ1bmN0aW9uKHN5bnRheCwgbmFtZSwgbWVtbykge1xuXHRcdFx0aWYgKCFzeW50YXggfHwgIW5hbWUpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRtZW1vID0gbWVtbyB8fCBbXTtcblxuXHRcdFx0dmFyIG5hbWVzID0gW25hbWVdO1xuXHRcdFx0Ly8gY3JlYXRlIGF1dG9tYXRpYyBhbGlhc2VzIHRvIHByb3BlcnRpZXMgd2l0aCBjb2xvbnMsXG5cdFx0XHQvLyBlLmcuIHBvcy1hID09IHBvczphXG5cdFx0XHRpZiAofm5hbWUuaW5kZXhPZignLScpKSB7XG5cdFx0XHRcdG5hbWVzLnB1c2gobmFtZS5yZXBsYWNlKC9cXC0vZywgJzonKSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkYXRhID0gdGhpcy5nZXRTZWN0aW9uKHN5bnRheCksIG1hdGNoZWRJdGVtID0gbnVsbDtcblx0XHRcdFsnc25pcHBldHMnLCAnYWJicmV2aWF0aW9ucyddLnNvbWUoZnVuY3Rpb24oc2VjdGlvbk5hbWUpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSB0aGlzLmdldFNlY3Rpb24oc3ludGF4LCBzZWN0aW9uTmFtZSk7XG5cdFx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5hbWVzLnNvbWUoZnVuY3Rpb24obikge1xuXHRcdFx0XHRcdFx0aWYgKGRhdGFbbl0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoZWRJdGVtID0gcGFyc2VJdGVtKG4sIGRhdGFbbl0sIHNlY3Rpb25OYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdG1lbW8ucHVzaChzeW50YXgpO1xuXHRcdFx0aWYgKCFtYXRjaGVkSXRlbSAmJiBkYXRhWydleHRlbmRzJ10gJiYgIX5tZW1vLmluZGV4T2YoZGF0YVsnZXh0ZW5kcyddKSkge1xuXHRcdFx0XHQvLyB0cnkgdG8gZmluZCBpdGVtIGluIHBhcmVudCBzeW50YXggc2VjdGlvblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5maW5kU25pcHBldChkYXRhWydleHRlbmRzJ10sIG5hbWUsIG1lbW8pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlZEl0ZW07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGZ1enp5IHNlYXJjaCBvZiBzbmlwcGV0IGRlZmluaXRpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4IFRvcC1sZXZlbCBzZWN0aW9uIG5hbWUgKHN5bnRheClcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBTbmlwcGV0IG5hbWVcblx0XHQgKiBAcmV0dXJuc1xuXHRcdCAqL1xuXHRcdGZ1enp5RmluZFNuaXBwZXQ6IGZ1bmN0aW9uKHN5bnRheCwgbmFtZSwgbWluU2NvcmUpIHtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmZ1enp5RmluZE1hdGNoZXMoc3ludGF4LCBuYW1lLCBtaW5TY29yZSlbMF07XG5cdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQudmFsdWUucGFyc2VkVmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGZ1enp5RmluZE1hdGNoZXM6IGZ1bmN0aW9uKHN5bnRheCwgbmFtZSwgbWluU2NvcmUpIHtcblx0XHRcdG1pblNjb3JlID0gbWluU2NvcmUgfHwgMC4zO1xuXHRcdFx0bmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG5cdFx0XHR2YXIgc25pcHBldHMgPSB0aGlzLmdldEFsbFNuaXBwZXRzKHN5bnRheCk7XG5cblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyhzbmlwcGV0cylcblx0XHRcdFx0Lm1hcChmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBzbmlwcGV0c1trZXldO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRrZXk6IGtleSxcblx0XHRcdFx0XHRcdHNjb3JlOiBzdHJpbmdTY29yZS5zY29yZSh2YWx1ZS5uaywgbmFtZSwgMC4xKSxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRcdHJldHVybiBpdGVtLnNjb3JlID49IG1pblNjb3JlO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEuc2NvcmUgLSBiLnNjb3JlO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQucmV2ZXJzZSgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHBsYWluIGRpY3Rpb25hcnkgb2YgYWxsIGF2YWlsYWJsZSBhYmJyZXZpYXRpb25zIGFuZCBzbmlwcGV0c1xuXHRcdCAqIGZvciBzcGVjaWZpZWQgc3ludGF4IHdpdGggcmVzcGVjdCBvZiBpbmhlcml0YW5jZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXhcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldEFsbFNuaXBwZXRzOiBmdW5jdGlvbihzeW50YXgpIHtcblx0XHRcdHZhciBjYWNoZUtleSA9ICdhbGwtJyArIHN5bnRheDtcblx0XHRcdGlmICghY2FjaGVbY2FjaGVLZXldKSB7XG5cdFx0XHRcdHZhciBzdGFjayA9IFtdLCBzZWN0aW9uS2V5ID0gc3ludGF4O1xuXHRcdFx0XHR2YXIgbWVtbyA9IFtdO1xuXG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuZ2V0U2VjdGlvbihzZWN0aW9uS2V5KTtcblx0XHRcdFx0XHRpZiAoIXNlY3Rpb24pXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFsnc25pcHBldHMnLCAnYWJicmV2aWF0aW9ucyddLmZvckVhY2goZnVuY3Rpb24oc2VjdGlvbk5hbWUpIHtcblx0XHRcdFx0XHRcdHZhciBzdGFja0l0ZW0gPSB7fTtcblx0XHRcdFx0XHRcdGVhY2goc2VjdGlvbltzZWN0aW9uTmFtZV0gfHwgbnVsbCwgZnVuY3Rpb24odiwgaykge1xuXHRcdFx0XHRcdFx0XHRzdGFja0l0ZW1ba10gPSB7XG5cdFx0XHRcdFx0XHRcdFx0bms6IG5vcm1hbGl6ZU5hbWUoayksXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWU6IHYsXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VkVmFsdWU6IHBhcnNlSXRlbShrLCB2LCBzZWN0aW9uTmFtZSksXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogc2VjdGlvbk5hbWVcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRzdGFjay5wdXNoKHN0YWNrSXRlbSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRtZW1vLnB1c2goc2VjdGlvbktleSk7XG5cdFx0XHRcdFx0c2VjdGlvbktleSA9IHNlY3Rpb25bJ2V4dGVuZHMnXTtcblx0XHRcdFx0fSB3aGlsZSAoc2VjdGlvbktleSAmJiAhfm1lbW8uaW5kZXhPZihzZWN0aW9uS2V5KSk7XG5cblxuXHRcdFx0XHRjYWNoZVtjYWNoZUtleV0gPSB1dGlscy5leHRlbmQuYXBwbHkodXRpbHMsIHN0YWNrLnJldmVyc2UoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjYWNoZVtjYWNoZUtleV07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbmV3bGluZSBjaGFyYWN0ZXJcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldE5ld2xpbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5sID0gdGhpcy5nZXRWYXJpYWJsZSgnbmV3bGluZScpO1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBubCA9PT0gJ3N0cmluZycgPyBubCA6ICdcXG4nO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXRzIG5ldyBuZXdsaW5lIGNoYXJhY3RlciB0aGF0IHdpbGwgYmUgdXNlZCBpbiBvdXRwdXRcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdFx0ICovXG5cdFx0c2V0TmV3bGluZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHR0aGlzLnNldFZhcmlhYmxlKCduZXdsaW5lJywgc3RyKTtcblx0XHRcdHRoaXMuc2V0VmFyaWFibGUoJ25sJywgc3RyKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIFhYWCBhZGQgZGVmYXVsdCByZXNvbHZlcnNcblx0ZXhwb3J0cy5hZGRSZXNvbHZlcihjc3NSZXNvbHZlci5yZXNvbHZlLmJpbmQoY3NzUmVzb2x2ZXIpKTtcblxuXHQvLyB0cnkgdG8gbG9hZCBzbmlwcGV0c1xuXHQvLyBoaWRlIGl0IGZyb20gUmVxdWlyZS5KUyBwYXJzZXJcblx0KGZ1bmN0aW9uKHIpIHtcblx0XHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ3VuZGVmaW5lZCcgfHwgIWRlZmluZS5hbWQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGV4cG9ydHMuc2V0Vm9jYWJ1bGFyeShyKCcuLi9zbmlwcGV0cy5qc29uJyksIFZPQ19TWVNURU0pO1xuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cdH0pKHJlcXVpcmUpO1xuXG5cblx0cmV0dXJuIGV4cG9ydHM7XG59KTtcblxufSx7XCIuLi9hc3NldHMvbG9nZ2VyXCI6XCJhc3NldHNcXFxcbG9nZ2VyLmpzXCIsXCIuLi9yZXNvbHZlci9jc3NcIjpcInJlc29sdmVyXFxcXGNzcy5qc1wiLFwiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4uL3ZlbmRvci9zdHJpbmdTY29yZVwiOlwidmVuZG9yXFxcXHN0cmluZ1Njb3JlLmpzXCIsXCIuL2VsZW1lbnRzXCI6XCJhc3NldHNcXFxcZWxlbWVudHMuanNcIixcIi4vaGFuZGxlckxpc3RcIjpcImFzc2V0c1xcXFxoYW5kbGVyTGlzdC5qc1wifV0sXCJhc3NldHNcXFxcc3RyaW5nU3RyZWFtLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBBIHRyaW1tZWQgdmVyc2lvbiBvZiBDb2RlTWlycm9yJ3MgU3RyaW5nU3RyZWFtIG1vZHVsZSBmb3Igc3RyaW5nIHBhcnNpbmdcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0LyoqXG5cdCAqIEB0eXBlIFN0cmluZ1N0cmVhbVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBBc3N1bWluZyB0aGF0IGJvdW5kIHN0cmluZyBzaG91bGQgYmVcblx0ICogaW1tdXRhYmxlXG5cdCAqL1xuXHRmdW5jdGlvbiBTdHJpbmdTdHJlYW0oc3RyaW5nKSB7XG5cdFx0dGhpcy5wb3MgPSB0aGlzLnN0YXJ0ID0gMDtcblx0XHR0aGlzLnN0cmluZyA9IHN0cmluZztcblx0XHR0aGlzLl9sZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHR9XG5cdFxuXHRTdHJpbmdTdHJlYW0ucHJvdG90eXBlID0ge1xuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBzdHJlYW0gaXMgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRlb2w6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucG9zID49IHRoaXMuX2xlbmd0aDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBzdHJlYW0gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0c29sOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBvcyA9PT0gMDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIG5leHQgY2hhcmFjdGVyIGluIHRoZSBzdHJlYW0gd2l0aG91dCBhZHZhbmNpbmcgaXQuIFxuXHRcdCAqIFdpbGwgcmV0dXJuIDxjb2RlPnVuZGVmaW5lZDwvY29kZT4gYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHBlZWs6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBuZXh0IGNoYXJhY3RlciBpbiB0aGUgc3RyZWFtIGFuZCBhZHZhbmNlcyBpdC5cblx0XHQgKiBBbHNvIHJldHVybnMgPGNvZGU+dW5kZWZpbmVkPC9jb2RlPiB3aGVuIG5vIG1vcmUgY2hhcmFjdGVycyBhcmUgYXZhaWxhYmxlLlxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0bmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5wb3MgPCB0aGlzLl9sZW5ndGgpXG5cdFx0XHRcdHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MrKyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBtYXRjaCBjYW4gYmUgYSBjaGFyYWN0ZXIsIGEgcmVndWxhciBleHByZXNzaW9uLCBvciBhIGZ1bmN0aW9uIHRoYXRcblx0XHQgKiB0YWtlcyBhIGNoYXJhY3RlciBhbmQgcmV0dXJucyBhIGJvb2xlYW4uIElmIHRoZSBuZXh0IGNoYXJhY3RlciBpbiB0aGVcblx0XHQgKiBzdHJlYW0gJ21hdGNoZXMnIHRoZSBnaXZlbiBhcmd1bWVudCwgaXQgaXMgY29uc3VtZWQgYW5kIHJldHVybmVkLlxuXHRcdCAqIE90aGVyd2lzZSwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaFxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0ZWF0OiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0dmFyIGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSwgb2s7XG5cdFx0XHRpZiAodHlwZW9mIG1hdGNoID09IFwic3RyaW5nXCIpXG5cdFx0XHRcdG9rID0gY2ggPT0gbWF0Y2g7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdG9rID0gY2ggJiYgKG1hdGNoLnRlc3QgPyBtYXRjaC50ZXN0KGNoKSA6IG1hdGNoKGNoKSk7XG5cdFx0XHRcblx0XHRcdGlmIChvaykge1xuXHRcdFx0XHQrK3RoaXMucG9zO1xuXHRcdFx0XHRyZXR1cm4gY2g7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXBlYXRlZGx5IGNhbGxzIDxjb2RlPmVhdDwvY29kZT4gd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnQsIHVudGlsIGl0XG5cdFx0ICogZmFpbHMuIFJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgYW55IGNoYXJhY3RlcnMgd2VyZSBlYXRlbi5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRlYXRXaGlsZTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdHZhciBzdGFydCA9IHRoaXMucG9zO1xuXHRcdFx0d2hpbGUgKHRoaXMuZWF0KG1hdGNoKSkge31cblx0XHRcdHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2hvcnRjdXQgZm9yIDxjb2RlPmVhdFdoaWxlPC9jb2RlPiB3aGVuIG1hdGNoaW5nIHdoaXRlLXNwYWNlLlxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGVhdFNwYWNlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzdGFydCA9IHRoaXMucG9zO1xuXHRcdFx0d2hpbGUgKC9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpXG5cdFx0XHRcdCsrdGhpcy5wb3M7XG5cdFx0XHRyZXR1cm4gdGhpcy5wb3MgPiBzdGFydDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIE1vdmVzIHRoZSBwb3NpdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuXHRcdCAqL1xuXHRcdHNraXBUb0VuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnBvcyA9IHRoaXMuX2xlbmd0aDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNraXBzIHRvIHRoZSBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIGdpdmVuIGNoYXJhY3RlciwgaWYgZm91bmQgb24gdGhlXG5cdFx0ICogY3VycmVudCBsaW5lIChkb2Vzbid0IGFkdmFuY2UgdGhlIHN0cmVhbSBpZiB0aGUgY2hhcmFjdGVyIGRvZXMgbm90XG5cdFx0ICogb2NjdXIgb24gdGhlIGxpbmUpLiBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYXJhY3RlciB3YXMgZm91bmQuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNoXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0c2tpcFRvOiBmdW5jdGlvbihjaCkge1xuXHRcdFx0dmFyIGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuXHRcdFx0aWYgKGZvdW5kID4gLTEpIHtcblx0XHRcdFx0dGhpcy5wb3MgPSBmb3VuZDtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBTa2lwcyB0byA8Y29kZT5jbG9zZTwvY29kZT4gY2hhcmFjdGVyIHdoaWNoIGlzIHBhaXIgdG8gPGNvZGU+b3BlbjwvY29kZT5cblx0XHQgKiBjaGFyYWN0ZXIsIGNvbnNpZGVyaW5nIHBvc3NpYmxlIHBhaXIgbmVzdGluZy4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG5cdFx0ICogdG8gY29uc3VtZSBwYWlyIG9mIGNoYXJhY3RlcnMsIGxpa2Ugb3BlbmluZyBhbmQgY2xvc2luZyBicmFjZXNcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gb3BlblxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjbG9zZVxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIHBhaXIgd2FzIHN1Y2Nlc3NmdWxseVxuXHRcdCAqIGNvbnN1bWVkXG5cdFx0ICovXG5cdFx0c2tpcFRvUGFpcjogZnVuY3Rpb24ob3BlbiwgY2xvc2UsIHNraXBTdHJpbmcpIHtcblx0XHRcdHZhciBicmFjZUNvdW50ID0gMCwgY2g7XG5cdFx0XHR2YXIgcG9zID0gdGhpcy5wb3MsIGxlbiA9IHRoaXMuX2xlbmd0aDtcblx0XHRcdHdoaWxlIChwb3MgPCBsZW4pIHtcblx0XHRcdFx0Y2ggPSB0aGlzLnN0cmluZy5jaGFyQXQocG9zKyspO1xuXHRcdFx0XHRpZiAoY2ggPT0gb3Blbikge1xuXHRcdFx0XHRcdGJyYWNlQ291bnQrKztcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSBjbG9zZSkge1xuXHRcdFx0XHRcdGJyYWNlQ291bnQtLTtcblx0XHRcdFx0XHRpZiAoYnJhY2VDb3VudCA8IDEpIHtcblx0XHRcdFx0XHRcdHRoaXMucG9zID0gcG9zO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHNraXBTdHJpbmcgJiYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpKSB7XG5cdFx0XHRcdFx0dGhpcy5za2lwU3RyaW5nKGNoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEEgaGVscGVyIGZ1bmN0aW9uIHdoaWNoLCBpbiBjYXNlIG9mIGVpdGhlciBzaW5nbGUgb3Jcblx0XHQgKiBkb3VibGUgcXVvdGUgd2FzIGZvdW5kIGluIGN1cnJlbnQgcG9zaXRpb24sIHNraXBzIGVudGlyZVxuXHRcdCAqIHN0cmluZyAocXVvdGVkIHZhbHVlKVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdldGhlciBxdW90ZWQgc3RyaW5nIHdhcyBza2lwcGVkXG5cdFx0ICovXG5cdFx0c2tpcFF1b3RlZDogZnVuY3Rpb24obm9CYWNrdXApIHtcblx0XHRcdHZhciBjaCA9IHRoaXMuc3RyaW5nLmNoYXJBdChub0JhY2t1cCA/IHRoaXMucG9zIDogdGhpcy5wb3MgLSAxKTtcblx0XHRcdGlmIChjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gXCInXCIpIHtcblx0XHRcdFx0aWYgKG5vQmFja3VwKSB7XG5cdFx0XHRcdFx0dGhpcy5wb3MrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5za2lwU3RyaW5nKGNoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQSBjdXN0b20gZnVuY3Rpb24gdG8gc2tpcCBzdHJpbmcgbGl0ZXJhbCwgZS5nLiBhIFwiZG91YmxlLXF1b3RlZFwiXG5cdFx0ICogb3IgJ3NpbmdsZS1xdW90ZWQnIHZhbHVlXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBxdW90ZSBBbiBvcGVuaW5nIHF1b3RlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRza2lwU3RyaW5nOiBmdW5jdGlvbihxdW90ZSkge1xuXHRcdFx0dmFyIHBvcyA9IHRoaXMucG9zLCBsZW4gPSB0aGlzLl9sZW5ndGgsIGNoO1xuXHRcdFx0d2hpbGUgKHBvcyA8IGxlbikge1xuXHRcdFx0XHRjaCA9IHRoaXMuc3RyaW5nLmNoYXJBdChwb3MrKyk7XG5cdFx0XHRcdGlmIChjaCA9PSAnXFxcXCcpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSBxdW90ZSkge1xuXHRcdFx0XHRcdHRoaXMucG9zID0gcG9zO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEJhY2tzIHVwIHRoZSBzdHJlYW0gbiBjaGFyYWN0ZXJzLiBCYWNraW5nIGl0IHVwIGZ1cnRoZXIgdGhhbiB0aGVcblx0XHQgKiBzdGFydCBvZiB0aGUgY3VycmVudCB0b2tlbiB3aWxsIGNhdXNlIHRoaW5ncyB0byBicmVhaywgc28gYmUgY2FyZWZ1bC5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gblxuXHRcdCAqL1xuXHRcdGJhY2tVcCA6IGZ1bmN0aW9uKG4pIHtcblx0XHRcdHRoaXMucG9zIC09IG47XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBBY3QgbGlrZSBhIG11bHRpLWNoYXJhY3RlciA8Y29kZT5lYXQ8L2NvZGU+4oCUaWYgPGNvZGU+Y29uc3VtZTwvY29kZT4gaXMgdHJ1ZSBvclxuXHRcdCAqIG5vdCBnaXZlbuKAlG9yIGEgbG9vay1haGVhZCB0aGF0IGRvZXNuJ3QgdXBkYXRlIHRoZSBzdHJlYW0gcG9zaXRpb27igJRpZlxuXHRcdCAqIGl0IGlzIGZhbHNlLiA8Y29kZT5wYXR0ZXJuPC9jb2RlPiBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFcblx0XHQgKiByZWd1bGFyIGV4cHJlc3Npb24gc3RhcnRpbmcgd2l0aCBeLiBXaGVuIGl0IGlzIGEgc3RyaW5nLFxuXHRcdCAqIDxjb2RlPmNhc2VJbnNlbnNpdGl2ZTwvY29kZT4gY2FuIGJlIHNldCB0byB0cnVlIHRvIG1ha2UgdGhlIG1hdGNoXG5cdFx0ICogY2FzZS1pbnNlbnNpdGl2ZS4gV2hlbiBzdWNjZXNzZnVsbHkgbWF0Y2hpbmcgYSByZWd1bGFyIGV4cHJlc3Npb24sXG5cdFx0ICogdGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgdGhlIGFycmF5IHJldHVybmVkIGJ5IDxjb2RlPm1hdGNoPC9jb2RlPixcblx0XHQgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIGV4dHJhY3QgbWF0Y2hlZCBncm91cHMuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbnN1bWVcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhc2VJbnNlbnNpdGl2ZVxuXHRcdCAqIEByZXR1cm5zXG5cdFx0ICovXG5cdFx0bWF0Y2g6IGZ1bmN0aW9uKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBwYXR0ZXJuID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0dmFyIGNhc2VkID0gY2FzZUluc2Vuc2l0aXZlXG5cdFx0XHRcdFx0PyBmdW5jdGlvbihzdHIpIHtyZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7fVxuXHRcdFx0XHRcdDogZnVuY3Rpb24oc3RyKSB7cmV0dXJuIHN0cjt9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNhc2VkKHRoaXMuc3RyaW5nKS5pbmRleE9mKGNhc2VkKHBhdHRlcm4pLCB0aGlzLnBvcykgPT0gdGhpcy5wb3MpIHtcblx0XHRcdFx0XHRpZiAoY29uc3VtZSAhPT0gZmFsc2UpXG5cdFx0XHRcdFx0XHR0aGlzLnBvcyArPSBwYXR0ZXJuLmxlbmd0aDtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG1hdGNoID0gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKHBhdHRlcm4pO1xuXHRcdFx0XHRpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpXG5cdFx0XHRcdFx0dGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHN0cmluZyBiZXR3ZWVuIHRoZSBzdGFydCBvZiB0aGUgY3VycmVudCB0b2tlbiBhbmQgdGhlIFxuXHRcdCAqIGN1cnJlbnQgc3RyZWFtIHBvc2l0aW9uLlxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0Y3VycmVudDogZnVuY3Rpb24oYmFja1VwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MgLSAoYmFja1VwID8gMSA6IDApKTtcblx0XHR9XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gbmV3IFN0cmluZ1N0cmVhbShzdHJpbmcpO1xuXHR9O1xuXG5cdC8qKiBAZGVwcmVjYXRlZCAqL1xuXHRtb2R1bGUuZXhwb3J0cy5jcmVhdGUgPSBtb2R1bGUuZXhwb3J0cztcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufSk7XG59LHt9XSxcImFzc2V0c1xcXFx0YWJTdG9wcy5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgZm9yIGhhbmRsaW5nIHRhYnN0b3BzIHRva2VucyBnZW5lcmF0ZWQgYnkgRW1tZXQncyBcbiAqIFwiRXhwYW5kIEFiYnJldmlhdGlvblwiIGFjdGlvbi4gVGhlIG1haW4gPGNvZGU+ZXh0cmFjdDwvY29kZT4gbWV0aG9kIHdpbGwgdGFrZVxuICogcmF3IHRleHQgKGZvciBleGFtcGxlOiA8aT4kezB9IHNvbWUgJHsxOnRleHR9PC9pPiksIGZpbmQgYWxsIHRhYnN0b3BzIFxuICogb2NjdXJyZW5jZXMsIHJlcGxhY2UgdGhlbSB3aXRoIHRva2VucyBzdWl0YWJsZSBmb3IgeW91ciBlZGl0b3Igb2YgY2hvaWNlIGFuZCBcbiAqIHJldHVybiBvYmplY3Qgd2l0aCBwcm9jZXNzZWQgdGV4dCBhbmQgbGlzdCBvZiBmb3VuZCB0YWJzdG9wcyBhbmQgdGhlaXIgcmFuZ2VzLlxuICogRm9yIHNha2Ugb2YgcG9ydGFiaWxpdHkgKE9iamVjdGl2ZS1DL0phdmEpIHRoZSB0YWJzdG9wcyBsaXN0IGlzIGEgcGxhaW4gXG4gKiBzb3J0ZWQgYXJyYXkgd2l0aCBwbGFpbiBvYmplY3RzLlxuICogXG4gKiBQbGFjZWhvbGRlcnMgd2l0aCB0aGUgc2FtZSBhcmUgbWVhbnQgdG8gYmUgPGk+bGlua2VkPC9pPiBpbiB5b3VyIGVkaXRvci5cbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciBzdHJpbmdTdHJlYW0gPSByZXF1aXJlKCcuL3N0cmluZ1N0cmVhbScpO1xuXHR2YXIgcmVzb3VyY2VzID0gcmVxdWlyZSgnLi9yZXNvdXJjZXMnKTtcblxuXHQvKipcblx0ICogR2xvYmFsIHBsYWNlaG9sZGVyIHZhbHVlLCBhdXRvbWF0aWNhbGx5IGluY3JlbWVudGVkIGJ5IFxuXHQgKiA8Y29kZT52YXJpYWJsZXNSZXNvbHZlcigpPC9jb2RlPiBmdW5jdGlvblxuXHQgKi9cblx0dmFyIHN0YXJ0UGxhY2Vob2xkZXJOdW0gPSAxMDA7XG5cdHZhciB0YWJzdG9wSW5kZXggPSAwO1xuXHRcblx0dmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHRcdHJlcGxhY2VDYXJldHM6IGZhbHNlLFxuXHRcdGVzY2FwZTogZnVuY3Rpb24oY2gpIHtcblx0XHRcdHJldHVybiAnXFxcXCcgKyBjaDtcblx0XHR9LFxuXHRcdHRhYnN0b3A6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHJldHVybiBkYXRhLnRva2VuO1xuXHRcdH0sXG5cdFx0dmFyaWFibGU6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHJldHVybiBkYXRhLnRva2VuO1xuXHRcdH1cblx0fTtcblx0XG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogTWFpbiBmdW5jdGlvbiB0aGF0IGxvb2tzIGZvciBhIHRhYnN0b3BzIGluIHByb3ZpZGVkIDxjb2RlPnRleHQ8L2NvZGU+XG5cdFx0ICogYW5kIHJldHVybnMgYSBwcm9jZXNzZWQgdmVyc2lvbiBvZiA8Y29kZT50ZXh0PC9jb2RlPiB3aXRoIGV4cGFuZGVkIFxuXHRcdCAqIHBsYWNlaG9sZGVycyBhbmQgbGlzdCBvZiB0YWJzdG9wcyBmb3VuZC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHRvIHByb2Nlc3Ncblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBMaXN0IG9mIHByb2Nlc3NvciBvcHRpb25zOjxicj5cblx0XHQgKiBcblx0XHQgKiA8Yj5yZXBsYWNlQ2FyZXRzPC9iPiA6IDxjb2RlPkJvb2xlYW48L2NvZGU+IOKAlCByZXBsYWNlIGFsbCBkZWZhdWx0XG5cdFx0ICogY2FyZXQgcGxhY2Vob2xkZXJzIChsaWtlIDxpPnslOjplbW1ldC1jYXJldDo6JX08L2k+KSB3aXRoIDxpPiR7MDpjYXJldH08L2k+PGJyPlxuXHRcdCAqIFxuXHRcdCAqIDxiPmVzY2FwZTwvYj4gOiA8Y29kZT5GdW5jdGlvbjwvY29kZT4g4oCUIGZ1bmN0aW9uIHRoYXQgaGFuZGxlIGVzY2FwZWRcblx0XHQgKiBjaGFyYWN0ZXJzIChtb3N0bHkgJyQnKS4gQnkgZGVmYXVsdCwgaXQgcmV0dXJucyB0aGUgY2hhcmFjdGVyIGl0c2VsZiBcblx0XHQgKiB0byBiZSBkaXNwbGF5ZWQgYXMgaXMgaW4gb3V0cHV0LCBidXQgc29tZXRpbWVzIHlvdSB3aWxsIHVzZSBcblx0XHQgKiA8Y29kZT5leHRyYWN0PC9jb2RlPiBtZXRob2QgYXMgaW50ZXJtZWRpYXRlIHNvbHV0aW9uIGZvciBmdXJ0aGVyIFxuXHRcdCAqIHByb2Nlc3NpbmcgYW5kIHdhbnQgdG8ga2VlcCBjaGFyYWN0ZXIgZXNjYXBlZC4gVGh1cywgeW91IHNob3VsZCBvdmVycmlkZVxuXHRcdCAqIDxjb2RlPmVzY2FwZTwvY29kZT4gbWV0aG9kIHRvIHJldHVybiBlc2NhcGVkIHN5bWJvbCAoZS5nLiAnXFxcXCQnKTxicj5cblx0XHQgKiBcblx0XHQgKiA8Yj50YWJzdG9wPC9iPiA6IDxjb2RlPkZ1bmN0aW9uPC9jb2RlPiDigJMgYSB0YWJzdG9wIGhhbmRsZXIuIFJlY2VpdmVzIFxuXHRcdCAqIGEgc2luZ2xlIGFyZ3VtZW50IOKAkyBhbiBvYmplY3QgZGVzY3JpYmluZyB0b2tlbjogaXRzIHBvc2l0aW9uLCBudW1iZXIgXG5cdFx0ICogZ3JvdXAsIHBsYWNlaG9sZGVyIGFuZCB0b2tlbiBpdHNlbGYuIFNob3VsZCByZXR1cm4gYSByZXBsYWNlbWVudCBcblx0XHQgKiBzdHJpbmcgdGhhdCB3aWxsIGFwcGVhciBpbiBmaW5hbCBvdXRwdXRcblx0XHQgKiBcblx0XHQgKiA8Yj52YXJpYWJsZTwvYj4gOiA8Y29kZT5GdW5jdGlvbjwvY29kZT4g4oCTIHZhcmlhYmxlIGhhbmRsZXIuIFJlY2VpdmVzIFxuXHRcdCAqIGEgc2luZ2xlIGFyZ3VtZW50IOKAkyBhbiBvYmplY3QgZGVzY3JpYmluZyB0b2tlbjogaXRzIHBvc2l0aW9uLCBuYW1lIFxuXHRcdCAqIGFuZCBvcmlnaW5hbCB0b2tlbiBpdHNlbGYuIFNob3VsZCByZXR1cm4gYSByZXBsYWNlbWVudCBcblx0XHQgKiBzdHJpbmcgdGhhdCB3aWxsIGFwcGVhciBpbiBmaW5hbCBvdXRwdXRcblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3Qgd2l0aCBwcm9jZXNzZWQgPGNvZGU+dGV4dDwvY29kZT4gcHJvcGVydHlcblx0XHQgKiBhbmQgYXJyYXkgb2YgPGNvZGU+dGFic3RvcHM8L2NvZGU+IGZvdW5kXG5cdFx0ICogQG1lbWJlck9mIHRhYlN0b3BzXG5cdFx0ICovXG5cdFx0ZXh0cmFjdDogZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuXHRcdFx0Ly8gcHJlcGFyZSBkZWZhdWx0c1xuXHRcdFx0dmFyIHBsYWNlaG9sZGVycyA9IHtjYXJldHM6ICcnfTtcblx0XHRcdHZhciBtYXJrcyA9IFtdO1xuXHRcdFx0XG5cdFx0XHRvcHRpb25zID0gdXRpbHMuZXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucywge1xuXHRcdFx0XHR0YWJzdG9wOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdFx0dmFyIHRva2VuID0gZGF0YS50b2tlbjtcblx0XHRcdFx0XHR2YXIgcmV0ID0gJyc7XG5cdFx0XHRcdFx0aWYgKGRhdGEucGxhY2Vob2xkZXIgPT0gJ2N1cnNvcicpIHtcblx0XHRcdFx0XHRcdG1hcmtzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRzdGFydDogZGF0YS5zdGFydCxcblx0XHRcdFx0XHRcdFx0ZW5kOiBkYXRhLnN0YXJ0ICsgdG9rZW4ubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRncm91cDogJ2NhcmV0cycsXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiAnJ1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHVuaWZ5IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBzaW5nbGUgZ3JvdXBcblx0XHRcdFx0XHRcdGlmICgncGxhY2Vob2xkZXInIGluIGRhdGEpXG5cdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyc1tkYXRhLmdyb3VwXSA9IGRhdGEucGxhY2Vob2xkZXI7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChkYXRhLmdyb3VwIGluIHBsYWNlaG9sZGVycylcblx0XHRcdFx0XHRcdFx0cmV0ID0gcGxhY2Vob2xkZXJzW2RhdGEuZ3JvdXBdO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRtYXJrcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0c3RhcnQ6IGRhdGEuc3RhcnQsXG5cdFx0XHRcdFx0XHRcdGVuZDogZGF0YS5zdGFydCArIHRva2VuLmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0Z3JvdXA6IGRhdGEuZ3JvdXAsXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiByZXRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW47XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAob3B0aW9ucy5yZXBsYWNlQ2FyZXRzKSB7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cCggdXRpbHMuZXNjYXBlRm9yUmVnZXhwKCB1dGlscy5nZXRDYXJldFBsYWNlaG9sZGVyKCkgKSwgJ2cnKSwgJyR7MDpjdXJzb3J9Jyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGxvY2F0ZSB0YWJzdG9wcyBhbmQgdW5pZnkgZ3JvdXAncyBwbGFjZWhvbGRlcnNcblx0XHRcdHRleHQgPSB0aGlzLnByb2Nlc3NUZXh0KHRleHQsIG9wdGlvbnMpO1xuXHRcdFx0XG5cdFx0XHQvLyBub3csIHJlcGxhY2UgYWxsIHRhYnN0b3BzIHdpdGggcGxhY2Vob2xkZXJzXG5cdFx0XHR2YXIgYnVmID0gJycsIGxhc3RJeCA9IDA7XG5cdFx0XHR2YXIgdGFiU3RvcHMgPSBtYXJrcy5tYXAoZnVuY3Rpb24obWFyaykge1xuXHRcdFx0XHRidWYgKz0gdGV4dC5zdWJzdHJpbmcobGFzdEl4LCBtYXJrLnN0YXJ0KTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBwb3MgPSBidWYubGVuZ3RoO1xuXHRcdFx0XHR2YXIgcGggPSBwbGFjZWhvbGRlcnNbbWFyay5ncm91cF0gfHwgJyc7XG5cdFx0XHRcdFxuXHRcdFx0XHRidWYgKz0gcGg7XG5cdFx0XHRcdGxhc3RJeCA9IG1hcmsuZW5kO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRncm91cDogbWFyay5ncm91cCxcblx0XHRcdFx0XHRzdGFydDogcG9zLFxuXHRcdFx0XHRcdGVuZDogIHBvcyArIHBoLmxlbmd0aFxuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdGJ1ZiArPSB0ZXh0LnN1YnN0cmluZyhsYXN0SXgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0ZXh0OiBidWYsXG5cdFx0XHRcdHRhYnN0b3BzOiB0YWJTdG9wcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG5cdFx0XHRcdH0pXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGV4dCBwcm9jZXNzaW5nIHJvdXRpbmUuIExvY2F0ZXMgZXNjYXBlZCBjaGFyYWN0ZXJzIGFuZCB0YWJzdG9wcyBhbmRcblx0XHQgKiByZXBsYWNlcyB0aGVtIHdpdGggdmFsdWVzIHJldHVybmVkIGJ5IGhhbmRsZXJzIGRlZmluZWQgaW4gXG5cdFx0ICogPGNvZGU+b3B0aW9uczwvY29kZT5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFNlZSA8Y29kZT5leHRyYWN0PC9jb2RlPiBtZXRob2Qgb3B0aW9ucyBcblx0XHQgKiBkZXNjcmlwdGlvblxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cHJvY2Vzc1RleHQ6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSB1dGlscy5leHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblx0XHRcdFxuXHRcdFx0dmFyIGJ1ZiA9ICcnO1xuXHRcdFx0LyoqIEB0eXBlIFN0cmluZ1N0cmVhbSAqL1xuXHRcdFx0dmFyIHN0cmVhbSA9IHN0cmluZ1N0cmVhbS5jcmVhdGUodGV4dCk7XG5cdFx0XHR2YXIgY2gsIG0sIGE7XG5cdFx0XHRcblx0XHRcdHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSkge1xuXHRcdFx0XHRpZiAoY2ggPT0gJ1xcXFwnICYmICFzdHJlYW0uZW9sKCkpIHtcblx0XHRcdFx0XHQvLyBoYW5kbGUgZXNjYXBlZCBjaGFyYWN0ZXJcblx0XHRcdFx0XHRidWYgKz0gb3B0aW9ucy5lc2NhcGUoc3RyZWFtLm5leHQoKSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGEgPSBjaDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjaCA9PSAnJCcpIHtcblx0XHRcdFx0XHQvLyBsb29rcyBsaWtlIGEgdGFic3RvcFxuXHRcdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3MgLSAxO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICgobSA9IHN0cmVhbS5tYXRjaCgvXlswLTldKy8pKSkge1xuXHRcdFx0XHRcdFx0Ly8gaXQncyAkTlxuXHRcdFx0XHRcdFx0YSA9IG9wdGlvbnMudGFic3RvcCh7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0OiBidWYubGVuZ3RoLCBcblx0XHRcdFx0XHRcdFx0Z3JvdXA6IHN0cmVhbS5jdXJyZW50KCkuc3Vic3RyKDEpLFxuXHRcdFx0XHRcdFx0XHR0b2tlbjogc3RyZWFtLmN1cnJlbnQoKVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICgobSA9IHN0cmVhbS5tYXRjaCgvXlxceyhbYS16X1xcLV1bXFx3XFwtXSopXFx9LykpKSB7XG5cdFx0XHRcdFx0XHQvLyAke3ZhcmlhYmxlfVxuXHRcdFx0XHRcdFx0YSA9IG9wdGlvbnMudmFyaWFibGUoe1xuXHRcdFx0XHRcdFx0XHRzdGFydDogYnVmLmxlbmd0aCwgXG5cdFx0XHRcdFx0XHRcdG5hbWU6IG1bMV0sXG5cdFx0XHRcdFx0XHRcdHRva2VuOiBzdHJlYW0uY3VycmVudCgpXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKChtID0gc3RyZWFtLm1hdGNoKC9eXFx7KFswLTldKykoOi4rPyk/XFx9LywgZmFsc2UpKSkge1xuXHRcdFx0XHRcdFx0Ly8gJHtOOnZhbHVlfSBvciAke059IHBsYWNlaG9sZGVyXG5cdFx0XHRcdFx0XHQvLyBwYXJzZSBwbGFjZWhvbGRlciwgaW5jbHVkaW5nIG5lc3RlZCBvbmVzXG5cdFx0XHRcdFx0XHRzdHJlYW0uc2tpcFRvUGFpcigneycsICd9Jyk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHZhciBvYmogPSB7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0OiBidWYubGVuZ3RoLCBcblx0XHRcdFx0XHRcdFx0Z3JvdXA6IG1bMV0sXG5cdFx0XHRcdFx0XHRcdHRva2VuOiBzdHJlYW0uY3VycmVudCgpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR2YXIgcGxhY2Vob2xkZXIgPSBvYmoudG9rZW4uc3Vic3RyaW5nKG9iai5ncm91cC5sZW5ndGggKyAyLCBvYmoudG9rZW4ubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChwbGFjZWhvbGRlcikge1xuXHRcdFx0XHRcdFx0XHRvYmoucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlci5zdWJzdHIoMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGEgPSBvcHRpb25zLnRhYnN0b3Aob2JqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGJ1ZiArPSBhO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gYnVmO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVXBncmFkZXMgdGFic3RvcHMgaW4gb3V0cHV0IG5vZGUgaW4gb3JkZXIgdG8gcHJldmVudCBuYW1pbmcgY29uZmxpY3RzXG5cdFx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUYWIgaW5kZXggb2Zmc2V0XG5cdFx0ICogQHJldHVybnMge051bWJlcn0gTWF4aW11bSB0YWJzdG9wIGluZGV4IGluIGVsZW1lbnRcblx0XHQgKi9cblx0XHR1cGdyYWRlOiBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcblx0XHRcdHZhciBtYXhOdW0gPSAwO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRcdHRhYnN0b3A6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0XHR2YXIgZ3JvdXAgPSBwYXJzZUludChkYXRhLmdyb3VwLCAxMCk7XG5cdFx0XHRcdFx0aWYgKGdyb3VwID4gbWF4TnVtKSBtYXhOdW0gPSBncm91cDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChkYXRhLnBsYWNlaG9sZGVyKVxuXHRcdFx0XHRcdFx0cmV0dXJuICckeycgKyAoZ3JvdXAgKyBvZmZzZXQpICsgJzonICsgZGF0YS5wbGFjZWhvbGRlciArICd9Jztcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyZXR1cm4gJyR7JyArIChncm91cCArIG9mZnNldCkgKyAnfSc7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFsnc3RhcnQnLCAnZW5kJywgJ2NvbnRlbnQnXS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0bm9kZVtwXSA9IHRoaXMucHJvY2Vzc1RleHQobm9kZVtwXSwgb3B0aW9ucyk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG1heE51bTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIFxuXHRcdCAqIDxjb2RlPnJlcGxhY2VWYXJpYWJsZXMoKTwvY29kZT4gbWV0aG9kIGZyb20ge0BsaW5rIHV0aWxzfVxuXHRcdCAqIG1vZHVsZS4gVGhpcyBjYWxsYmFjayB3aWxsIHJlcGxhY2UgdmFyaWFibGUgZGVmaW5pdGlvbnMgKGxpa2UgXG5cdFx0ICogJHt2YXJfbmFtZX0pIHdpdGggdGhlaXIgdmFsdWUgZGVmaW5lZCBpbiA8aT5yZXNvdXJjZTwvaT4gbW9kdWxlLFxuXHRcdCAqIG9yIG91dHB1dHMgdGFic3RvcCB3aXRoIHZhcmlhYmxlIG5hbWUgb3RoZXJ3aXNlLlxuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZSBDb250ZXh0IG5vZGVcblx0XHQgKiBAcmV0dXJucyB7RnVuY3Rpb259XG5cdFx0ICovXG5cdFx0dmFyaWFibGVzUmVzb2x2ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBwbGFjZWhvbGRlck1lbW8gPSB7fTtcblx0XHRcdHJldHVybiBmdW5jdGlvbihzdHIsIHZhck5hbWUpIHtcblx0XHRcdFx0Ly8gZG8gbm90IG1hcmsgYGNoaWxkYCB2YXJpYWJsZSBhcyBwbGFjZWhvbGRlciDigJMgaXTigJhzIGEgcmVzZXJ2ZWRcblx0XHRcdFx0Ly8gdmFyaWFibGUgbmFtZVxuXHRcdFx0XHRpZiAodmFyTmFtZSA9PSAnY2hpbGQnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cjtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHZhck5hbWUgPT0gJ2N1cnNvcicpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHMuZ2V0Q2FyZXRQbGFjZWhvbGRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgYXR0ciA9IG5vZGUuYXR0cmlidXRlKHZhck5hbWUpO1xuXHRcdFx0XHRpZiAodHlwZW9mIGF0dHIgIT09ICd1bmRlZmluZWQnICYmIGF0dHIgIT09IHN0cikge1xuXHRcdFx0XHRcdHJldHVybiBhdHRyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgdmFyVmFsdWUgPSByZXNvdXJjZXMuZ2V0VmFyaWFibGUodmFyTmFtZSk7XG5cdFx0XHRcdGlmICh2YXJWYWx1ZSkge1xuXHRcdFx0XHRcdHJldHVybiB2YXJWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gb3V0cHV0IGFzIHBsYWNlaG9sZGVyXG5cdFx0XHRcdGlmICghcGxhY2Vob2xkZXJNZW1vW3Zhck5hbWVdKSB7XG5cdFx0XHRcdFx0cGxhY2Vob2xkZXJNZW1vW3Zhck5hbWVdID0gc3RhcnRQbGFjZWhvbGRlck51bSsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiAnJHsnICsgcGxhY2Vob2xkZXJNZW1vW3Zhck5hbWVdICsgJzonICsgdmFyTmFtZSArICd9Jztcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2UgdmFyaWFibGVzIGxpa2UgJHt2YXJ9IGluIHN0cmluZ1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdmFycyBWYXJpYWJsZSBzZXQgKGRlZmF1bHRzIHRvIHZhcmlhYmxlcyBkZWZpbmVkIGluIFxuXHRcdCAqIDxjb2RlPnNuaXBwZXRzLmpzb248L2NvZGU+KSBvciB2YXJpYWJsZSByZXNvbHZlciAoPGNvZGU+RnVuY3Rpb248L2NvZGU+KVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRyZXBsYWNlVmFyaWFibGVzOiBmdW5jdGlvbihzdHIsIHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0dmFyIHJlc29sdmVyID0gdHlwZW9mIHZhcnMgPT09ICdmdW5jdGlvbicgPyB2YXJzIDogZnVuY3Rpb24oc3RyLCBwMSkge1xuXHRcdFx0XHRyZXR1cm4gcDEgaW4gdmFycyA/IHZhcnNbcDFdIDogbnVsbDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnByb2Nlc3NUZXh0KHN0ciwge1xuXHRcdFx0XHR2YXJpYWJsZTogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRcdHZhciBuZXdWYWx1ZSA9IHJlc29sdmVyKGRhdGEudG9rZW4sIGRhdGEubmFtZSwgZGF0YSk7XG5cdFx0XHRcdFx0aWYgKG5ld1ZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHQvLyB0cnkgdG8gZmluZCB2YXJpYWJsZSBpbiByZXNvdXJjZXNcblx0XHRcdFx0XHRcdG5ld1ZhbHVlID0gcmVzb3VyY2VzLmdldFZhcmlhYmxlKGRhdGEubmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChuZXdWYWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICd1bmRlZmluZWQnKVxuXHRcdFx0XHRcdFx0Ly8gbm90aGluZyBmb3VuZCwgcmV0dXJuIHRva2VuIGl0c2VsZlxuXHRcdFx0XHRcdFx0bmV3VmFsdWUgPSBkYXRhLnRva2VuO1xuXHRcdFx0XHRcdHJldHVybiBuZXdWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXNldHMgZ2xvYmFsIHRhYnN0b3AgaW5kZXguIFdoZW4gcGFyc2VkIHRyZWUgaXMgY29udmVydGVkIHRvIG91dHB1dFxuXHRcdCAqIHN0cmluZyAoPGNvZGU+QWJicmV2aWF0aW9uTm9kZS50b1N0cmluZygpPC9jb2RlPiksIGFsbCB0YWJzdG9wcyBcblx0XHQgKiBkZWZpbmVkIGluIHNuaXBwZXRzIGFuZCBlbGVtZW50cyBhcmUgdXBncmFkZWQgaW4gb3JkZXIgdG8gcHJldmVudFxuXHRcdCAqIG5hbWluZyBjb25mbGljdHMgb2YgbmVzdGVkLiBGb3IgZXhhbXBsZSwgPGNvZGU+JHsxfTwvY29kZT4gb2YgYSBub2RlXG5cdFx0ICogc2hvdWxkIG5vdCBiZSBsaW5rZWQgd2l0aCB0aGUgc2FtZSBwbGFjZWhpbGRlciBvZiB0aGUgY2hpbGQgbm9kZS5cblx0XHQgKiBCeSBkZWZhdWx0LCA8Y29kZT5BYmJyZXZpYXRpb25Ob2RlLnRvU3RyaW5nKCk8L2NvZGU+IGF1dG9tYXRpY2FsbHlcblx0XHQgKiB1cGdyYWRlcyB0YWJzdG9wcyBvZiB0aGUgc2FtZSBpbmRleCBmb3IgZWFjaCBub2RlIGFuZCB3cml0ZXMgbWF4aW11bVxuXHRcdCAqIHRhYnN0b3AgaW5kZXggaW50byB0aGUgPGNvZGU+dGFic3RvcEluZGV4PC9jb2RlPiB2YXJpYWJsZS4gVG8ga2VlcFxuXHRcdCAqIHRoaXMgdmFyaWFibGUgYXQgcmVhc29uYWJsZSB2YWx1ZSwgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2FsbCBcblx0XHQgKiA8Y29kZT5yZXNldFRhYnN0b3BJbmRleCgpPC9jb2RlPiBtZXRob2QgZWFjaCB0aW1lIHlvdSBleHBhbmQgdmFyaWFibGUgXG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRyZXNldFRhYnN0b3BJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0YWJzdG9wSW5kZXggPSAwO1xuXHRcdFx0c3RhcnRQbGFjZWhvbGRlck51bSA9IDEwMDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogT3V0cHV0IHByb2Nlc3NvciBmb3IgYWJicmV2aWF0aW9uIHBhcnNlciB0aGF0IHdpbGwgdXBncmFkZSB0YWJzdG9wcyBcblx0XHQgKiBvZiBwYXJzZWQgbm9kZSBpbiBvcmRlciB0byBwcmV2ZW50IHRhYnN0b3AgaW5kZXggY29uZmxpY3RzXG5cdFx0ICovXG5cdFx0YWJick91dHB1dFByb2Nlc3NvcjogZnVuY3Rpb24odGV4dCwgbm9kZSwgdHlwZSkge1xuXHRcdFx0dmFyIG1heE51bSA9IDA7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRcblx0XHRcdHZhciB0c09wdGlvbnMgPSB7XG5cdFx0XHRcdHRhYnN0b3A6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0XHR2YXIgZ3JvdXAgPSBwYXJzZUludChkYXRhLmdyb3VwLCAxMCk7XG5cdFx0XHRcdFx0aWYgKGdyb3VwID09PSAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuICckezB9Jztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZ3JvdXAgPiBtYXhOdW0pIG1heE51bSA9IGdyb3VwO1xuXHRcdFx0XHRcdGlmIChkYXRhLnBsYWNlaG9sZGVyKSB7XG5cdFx0XHRcdFx0XHQvLyByZXNwZWN0IG5lc3RlZCBwbGFjZWhvbGRlcnNcblx0XHRcdFx0XHRcdHZhciBpeCA9IGdyb3VwICsgdGFic3RvcEluZGV4O1xuXHRcdFx0XHRcdFx0dmFyIHBsYWNlaG9sZGVyID0gdGhhdC5wcm9jZXNzVGV4dChkYXRhLnBsYWNlaG9sZGVyLCB0c09wdGlvbnMpO1xuXHRcdFx0XHRcdFx0cmV0dXJuICckeycgKyBpeCArICc6JyArIHBsYWNlaG9sZGVyICsgJ30nO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJyR7JyArIChncm91cCArIHRhYnN0b3BJbmRleCkgKyAnfSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyB1cGdyYWRlIHRhYnN0b3BzXG5cdFx0XHR0ZXh0ID0gdGhpcy5wcm9jZXNzVGV4dCh0ZXh0LCB0c09wdGlvbnMpO1xuXHRcdFx0XG5cdFx0XHQvLyByZXNvbHZlIHZhcmlhYmxlc1xuXHRcdFx0dGV4dCA9IHRoaXMucmVwbGFjZVZhcmlhYmxlcyh0ZXh0LCB0aGlzLnZhcmlhYmxlc1Jlc29sdmVyKG5vZGUpKTtcblx0XHRcdFxuXHRcdFx0dGFic3RvcEluZGV4ICs9IG1heE51bSArIDE7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4vcmVzb3VyY2VzXCI6XCJhc3NldHNcXFxccmVzb3VyY2VzLmpzXCIsXCIuL3N0cmluZ1N0cmVhbVwiOlwiYXNzZXRzXFxcXHN0cmluZ1N0cmVhbS5qc1wifV0sXCJhc3NldHNcXFxcdG9rZW5JdGVyYXRvci5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSGVscGVyIGNsYXNzIGZvciBjb252ZW5pZW50IHRva2VuIGl0ZXJhdGlvblxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQvKipcblx0ICogQHR5cGUgVG9rZW5JdGVyYXRvclxuXHQgKiBAcGFyYW0ge0FycmF5fSB0b2tlbnNcblx0ICogQHR5cGUgVG9rZW5JdGVyYXRvclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFRva2VuSXRlcmF0b3IodG9rZW5zKSB7XG5cdFx0LyoqIEB0eXBlIEFycmF5ICovXG5cdFx0dGhpcy50b2tlbnMgPSB0b2tlbnM7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSAwO1xuXHRcdHRoaXMucmVzZXQoKTtcblx0fVxuXHRcblx0VG9rZW5JdGVyYXRvci5wcm90b3R5cGUgPSB7XG5cdFx0bmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5oYXNOZXh0KCkpIHtcblx0XHRcdFx0dmFyIHRva2VuID0gdGhpcy50b2tlbnNbKyt0aGlzLl9pXTtcblx0XHRcdFx0dGhpcy5fcG9zaXRpb24gPSB0b2tlbi5zdGFydDtcblx0XHRcdFx0cmV0dXJuIHRva2VuO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5faSA9IHRoaXMuX2lsO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdFxuXHRcdGN1cnJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuX2ldO1xuXHRcdH0sXG5cblx0XHRwZWVrOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLl9pICsgaV07XG5cdFx0fSxcblx0XHRcblx0XHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcG9zaXRpb247XG5cdFx0fSxcblx0XHRcblx0XHRoYXNOZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9pIDwgdGhpcy5faWwgLSAxO1xuXHRcdH0sXG5cdFx0XG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5faSA9IDA7XG5cdFx0XHR0aGlzLl9pbCA9IHRoaXMudG9rZW5zLmxlbmd0aDtcblx0XHR9LFxuXHRcdFxuXHRcdGl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuX2ldO1xuXHRcdH0sXG5cdFx0XG5cdFx0aXRlbU5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuX2kgKyAxXTtcblx0XHR9LFxuXHRcdFxuXHRcdGl0ZW1QcmV2OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLl9pIC0gMV07XG5cdFx0fSxcblx0XHRcblx0XHRuZXh0VW50aWw6IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgdG9rZW47XG5cdFx0XHR2YXIgdGVzdCA9IHR5cGVvZiB0eXBlID09ICdzdHJpbmcnIFxuXHRcdFx0XHQ/IGZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGUgPT0gdHlwZTt9IFxuXHRcdFx0XHQ6IHR5cGU7XG5cdFx0XHRcblx0XHRcdHdoaWxlICgodG9rZW4gPSB0aGlzLm5leHQoKSkpIHtcblx0XHRcdFx0aWYgKGNhbGxiYWNrKVxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgdG9rZW4pO1xuXHRcdFx0XHRpZiAodGVzdC5jYWxsKHRoaXMsIHRva2VuKSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHRyZXR1cm4ge1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24odG9rZW5zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuSXRlcmF0b3IodG9rZW5zKTtcblx0XHR9XG5cdH07XG59KTtcbn0se31dLFwiZWRpdFRyZWVcXFxcYmFzZS5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgZWRpdCB0cmVlIGludGVyZmFjZS5cbiAqIEVkaXQgdHJlZSBpcyBhIG5hbWVkIGNvbnRhaW5lciBvZiBlZGl0YWJsZSDigJxuYW1lLXZhbHVl4oCdIGNoaWxkIGVsZW1lbnRzLCBcbiAqIHBhcnNlZCBmcm9tIDxjb2RlPnNvdXJjZTwvY29kZT4uIFRoaXMgY29udGFpbmVyIHByb3ZpZGVzIGNvbnZlbmllbnQgbWV0aG9kc1xuICogZm9yIGVkaXRpbmcvYWRkaW5nL3JlbW92aW5nIGNoaWxkIGVsZW1lbnRzLiBBbGwgdGhlc2UgdXBkYXRlIGFjdGlvbnMgYXJlXG4gKiBpbnN0YW50bHkgcmVmbGVjdGVkIGluIHRoZSA8Y29kZT5zb3VyY2U8L2NvZGU+IGNvZGUgd2l0aCByZXNwZWN0IG9mIGZvcm1hdHRpbmcuXG4gKiA8YnI+PGJyPlxuICogRm9yIGV4YW1wbGUsIGRldmVsb3BlciBjYW4gY3JlYXRlIGFuIGVkaXQgdHJlZSBmcm9tIENTUyBydWxlIGFuZCBhZGQgb3IgXG4gKiByZW1vdmUgcHJvcGVydGllcyBmcm9tIGl04oCTYWxsIGNoYW5nZXMgd2lsbCBiZSBpbW1lZGlhdGVseSByZWZsZWN0ZWQgaW4gdGhlIFxuICogb3JpZ2luYWwgc291cmNlLlxuICogPGJyPjxicj5cbiAqIEFsbCBjbGFzc2VzIGRlZmluZWQgaW4gdGhpcyBtb2R1bGUgc2hvdWxkIGJlIGV4dGVuZGVkIHRoZSBzYW1lIHdheSBhcyBpblxuICogQmFja2JvbmUgZnJhbWV3b3JrOiB1c2luZyA8Y29kZT5leHRlbmQ8L2NvZGU+IG1ldGhvZCB0byBjcmVhdGUgbmV3IGNsYXNzIGFuZCBcbiAqIDxjb2RlPmluaXRpYWxpemU8L2NvZGU+IG1ldGhvZCB0byBkZWZpbmUgY3VzdG9tIGNsYXNzIGNvbnN0cnVjdG9yLlxuICogXG4gKiBAZXhhbXBsZVxuICogPHByZT48Y29kZT5cbiAqIHZhciBNeUNsYXNzID0gcmVxdWlyZSgnZWRpdFRyZWUvYmFzZScpLkVkaXRFbGVtZW50LmV4dGVuZCh7XG4gKiAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gKiAgICAgLy8gY29uc3RydWN0b3IgY29kZSBoZXJlXG4gKiAgIH1cbiAqIH0pO1xuICogXG4gKiB2YXIgZWxlbSA9IG5ldyBNeUNsYXNzKCk7IFxuICogPC9jb2RlPjwvcHJlPlxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgcmFuZ2UgPSByZXF1aXJlKCcuLi9hc3NldHMvcmFuZ2UnKTtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciBrbGFzcyA9IHJlcXVpcmUoJy4uL3ZlbmRvci9rbGFzcycpO1xuXHRcblx0LyoqXG5cdCAqIE5hbWVkIGNvbnRhaW5lciBvZiBlZGl0ZWQgc291cmNlXG5cdCAqIEB0eXBlIEVkaXRDb250YWluZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0ZnVuY3Rpb24gRWRpdENvbnRhaW5lcihzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoe29mZnNldDogMH0sIG9wdGlvbnMpO1xuXHRcdC8qKlxuXHRcdCAqIFNvdXJjZSBjb2RlIG9mIGVkaXRlZCBzdHJ1Y3R1cmUuIEFsbCBjaGFuZ2VzIGluIHRoZSBzdHJ1Y3R1cmUgYXJlIFxuXHRcdCAqIGltbWVkaWF0ZWx5IHJlZmxlY3RlZCBpbnRvIHRoaXMgcHJvcGVydHlcblx0XHQgKi9cblx0XHR0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblx0XHRcblx0XHQvKiogXG5cdFx0ICogTGlzdCBvZiBhbGwgZWRpdGFibGUgY2hpbGRyZW5cblx0XHQgKiBAcHJpdmF0ZSBcblx0XHQgKi9cblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEhhc2ggb2YgYWxsIHBvc2l0aW9ucyBvZiBjb250YWluZXJcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IHtcblx0XHRcdG5hbWU6IDBcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogVGhlIHNlbGYtcHJvcGFnYXRpbmcgZXh0ZW5kIGZ1bmN0aW9uIGZvciBjbGFzc2VzLlxuXHQgKiBAdHlwZSBGdW5jdGlvblxuXHQgKi9cblx0RWRpdENvbnRhaW5lci5leHRlbmQgPSBrbGFzcy5leHRlbmQ7XG5cdFxuXHRFZGl0Q29udGFpbmVyLnByb3RvdHlwZSA9IHtcblx0XHR0eXBlOiAnY29udGFpbmVyJyxcblx0XHQvKipcblx0XHQgKiBDaGlsZCBjbGFzcyBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG5cblx0XHQvKipcblx0XHQgKiBNYWtlIHBvc2l0aW9uIGFic29sdXRlXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gbnVtXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpc0Fic29sdXRlXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0X3BvczogZnVuY3Rpb24obnVtLCBpc0Fic29sdXRlKSB7XG5cdFx0XHRyZXR1cm4gbnVtICsgKGlzQWJzb2x1dGUgPyB0aGlzLm9wdGlvbnMub2Zmc2V0IDogMCk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXBsYWNlIHN1YnN0cmluZyBvZiB0YWcncyBzb3VyY2Vcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gZW5kXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfdXBkYXRlU291cmNlOiBmdW5jdGlvbih2YWx1ZSwgc3RhcnQsIGVuZCkge1xuXHRcdFx0Ly8gY3JlYXRlIG1vZGlmaWNhdGlvbiByYW5nZVxuXHRcdFx0dmFyIHIgPSByYW5nZS5jcmVhdGUoc3RhcnQsIHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnID8gMCA6IGVuZCAtIHN0YXJ0KTtcblx0XHRcdHZhciBkZWx0YSA9IHZhbHVlLmxlbmd0aCAtIHIubGVuZ3RoKCk7XG5cdFx0XHRcblx0XHRcdHZhciB1cGRhdGUgPSBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0T2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcblx0XHRcdFx0XHRpZiAob2JqW2tdID49IHIuZW5kKSB7XG5cdFx0XHRcdFx0XHRvYmpba10gKz0gZGVsdGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIHVwZGF0ZSBhZmZlY3RlZCBwb3NpdGlvbnMgb2YgY3VycmVudCBjb250YWluZXJcblx0XHRcdHVwZGF0ZSh0aGlzLl9wb3NpdGlvbnMpO1xuXHRcdFx0XG5cdFx0XHQvLyB1cGRhdGUgYWZmZWN0ZWQgcG9zaXRpb25zIG9mIGNoaWxkcmVuXG5cdFx0XHR2YXIgcmVjdXJzaXZlVXBkYXRlID0gZnVuY3Rpb24oaXRlbXMpIHtcblx0XHRcdFx0aXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdFx0dXBkYXRlKGl0ZW0uX3Bvc2l0aW9ucyk7XG5cdFx0XHRcdFx0aWYgKGl0ZW0udHlwZSA9PSAnY29udGFpbmVyJykge1xuXHRcdFx0XHRcdFx0cmVjdXJzaXZlVXBkYXRlKGl0ZW0ubGlzdCgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblxuXHRcdFx0cmVjdXJzaXZlVXBkYXRlKHRoaXMubGlzdCgpKTtcblx0XHRcdHRoaXMuc291cmNlID0gdXRpbHMucmVwbGFjZVN1YnN0cmluZyh0aGlzLnNvdXJjZSwgdmFsdWUsIHIpO1xuXHRcdH0sXG5cdFx0XHRcblx0XHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgbmV3IGF0dHJpYnV0ZSBcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFByb3BlcnR5IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvcyBQb3NpdGlvbiBhdCB3aGljaCB0byBpbnNlcnQgbmV3IHByb3BlcnR5LiBCeSBcblx0XHQgKiBkZWZhdWx0IHRoZSBwcm9wZXJ0eSBpcyBpbnNlcnRlZCBhdCB0aGUgZW5kIG9mIHJ1bGUgXG5cdFx0ICogQHJldHVybnMge0VkaXRFbGVtZW50fSBOZXdseSBjcmVhdGVkIGVsZW1lbnRcblx0XHQgKi9cblx0XHRhZGQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwb3MpIHtcblx0XHRcdC8vIHRoaXMgaXMgYWJzdHJhY3QgaW1wbGVtZW50YXRpb25cblx0XHRcdHZhciBpdGVtID0gbmV3IEVkaXRFbGVtZW50KG5hbWUsIHZhbHVlKTtcblx0XHRcdHRoaXMuX2NoaWxkcmVuLnB1c2goaXRlbSk7XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYXR0cmlidXRlIG9iamVjdFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEF0dHJpYnV0ZSBuYW1lIG9yIGl0cyBpbmRleFxuXHRcdCAqIEByZXR1cm5zIHtFZGl0RWxlbWVudH1cblx0XHQgKi9cblx0XHRnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubGlzdCgpW25hbWVdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHJldHVybiB1dGlscy5maW5kKHRoaXMubGlzdCgpLCBmdW5jdGlvbihwcm9wKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb3AubmFtZSgpID09PSBuYW1lO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGFsbCBjaGlsZHJlbiBieSBuYW1lIG9yIGluZGV4ZXNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbmFtZSBFbGVtZW50IG5hbWUocykgb3IgaW5kZXhlcyAoPGNvZGU+U3RyaW5nPC9jb2RlPixcblx0XHQgKiA8Y29kZT5BcnJheTwvY29kZT4sIDxjb2RlPk51bWJlcjwvY29kZT4pXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdCAqL1xuXHRcdGdldEFsbDogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KG5hbWUpKVxuXHRcdFx0XHRuYW1lID0gW25hbWVdO1xuXHRcdFx0XG5cdFx0XHQvLyBzcGxpdCBuYW1lcyBhbmQgaW5kZXhlc1xuXHRcdFx0dmFyIG5hbWVzID0gW10sIGluZGV4ZXMgPSBbXTtcblx0XHRcdG5hbWUuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRuYW1lcy5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdGluZGV4ZXMucHVzaChpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmxpc3QoKS5maWx0ZXIoZnVuY3Rpb24oYXR0cmlidXRlLCBpKSB7XG5cdFx0XHRcdHJldHVybiB+aW5kZXhlcy5pbmRleE9mKGkpIHx8IH5uYW1lcy5pbmRleE9mKGF0dHJpYnV0ZS5uYW1lKCkpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbGlzdCBvZiBhbGwgZWRpdGFibGUgY2hpbGQgZWxlbWVudHNcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0bGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW47XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBjaGlsZCBlbGVtZW50XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgUHJvcGVydHkgbmFtZSBvciBpdHMgaW5kZXhcblx0XHQgKi9cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXQobmFtZSk7XG5cdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGVTb3VyY2UoJycsIGVsZW1lbnQuZnVsbFJhbmdlKCkpO1xuXHRcdFx0XHR2YXIgaXggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGVsZW1lbnQpO1xuXHRcdFx0XHRpZiAofml4KSB7XG5cdFx0XHRcdFx0dGhpcy5fY2hpbGRyZW4uc3BsaWNlKGl4LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBpbmRleCBvZiBlZGl0YmxlIGNoaWxkIGluIGxpc3Rcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuXHRcdCAqIEByZXR1cm5zIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0aW5kZXhPZjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuIHRoaXMubGlzdCgpLmluZGV4T2YodGhpcy5nZXQoaXRlbSkpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBvciB1cGRhdGVzIGVsZW1lbnQgdmFsdWUuIElmIHN1Y2ggZWxlbWVudCBkb2Vzbid0IGV4aXN0cyxcblx0XHQgKiBpdCB3aWxsIGJlIGNyZWF0ZWQgYXV0b21hdGljYWxseSBhbmQgYWRkZWQgYXQgdGhlIGVuZCBvZiBjaGlsZCBsaXN0LlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEVsZW1lbnQgbmFtZSBvciBpdHMgaW5kZXhcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgTmV3IGVsZW1lbnQgdmFsdWVcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcG9zKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0KG5hbWUpO1xuXHRcdFx0aWYgKGVsZW1lbnQpXG5cdFx0XHRcdHJldHVybiBlbGVtZW50LnZhbHVlKHZhbHVlKTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0Ly8gbm8gc3VjaCBlbGVtZW50IOKAlCBjcmVhdGUgaXRcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkKG5hbWUsIHZhbHVlLCBwb3MpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhbGwgdmFsdWVzIG9mIGNoaWxkIGVsZW1lbnRzIGZvdW5kIGJ5IDxjb2RlPmdldEFsbCgpPC9jb2RlPlxuXHRcdCAqIG1ldGhvZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuYW1lIEVsZW1lbnQgbmFtZShzKSBvciBpbmRleGVzICg8Y29kZT5TdHJpbmc8L2NvZGU+LFxuXHRcdCAqIDxjb2RlPkFycmF5PC9jb2RlPiwgPGNvZGU+TnVtYmVyPC9jb2RlPilcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0dmFsdWVzOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRBbGwobmFtZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQudmFsdWUoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2V0cyBvciBnZXRzIGNvbnRhaW5lciBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbCBOZXcgbmFtZS4gSWYgbm90IHBhc3NlZCwgY3VycmVudCBcblx0XHQgKiBuYW1lIGlzIHJldHVybmVkXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdG5hbWU6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuX25hbWUgIT09ICh2YWwgPSBTdHJpbmcodmFsKSkpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlU291cmNlKHZhbCwgdGhpcy5fcG9zaXRpb25zLm5hbWUsIHRoaXMuX3Bvc2l0aW9ucy5uYW1lICsgdGhpcy5fbmFtZS5sZW5ndGgpO1xuXHRcdFx0XHR0aGlzLl9uYW1lID0gdmFsO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5fbmFtZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbmFtZSByYW5nZSBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWJzb2x1dGUgUmV0dXJuIGFic29sdXRlIHJhbmdlICh3aXRoIHJlc3BlY3Qgb2YgXG5cdFx0ICogcnVsZSBvZmZzZXQpXG5cdFx0ICogQHJldHVybnMge1JhbmdlfVxuXHRcdCAqL1xuXHRcdG5hbWVSYW5nZTogZnVuY3Rpb24oaXNBYnNvbHV0ZSkge1xuXHRcdFx0cmV0dXJuIHJhbmdlLmNyZWF0ZSh0aGlzLl9wb3NpdGlvbnMubmFtZSArIChpc0Fic29sdXRlID8gdGhpcy5vcHRpb25zLm9mZnNldCA6IDApLCB0aGlzLm5hbWUoKSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgcmFuZ2Ugb2YgY3VycmVudCBzb3VyY2Vcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWJzb2x1dGVcblx0XHQgKi9cblx0XHRyYW5nZTogZnVuY3Rpb24oaXNBYnNvbHV0ZSkge1xuXHRcdFx0cmV0dXJuIHJhbmdlLmNyZWF0ZShpc0Fic29sdXRlID8gdGhpcy5vcHRpb25zLm9mZnNldCA6IDAsIHRoaXMudmFsdWVPZigpKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgZWxlbWVudCB0aGF0IGJlbG9uZ3MgdG8gc3BlY2lmaWVkIHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBYnNvbHV0ZVxuXHRcdCAqIEByZXR1cm5zIHtFZGl0RWxlbWVudH1cblx0XHQgKi9cblx0XHRpdGVtRnJvbVBvc2l0aW9uOiBmdW5jdGlvbihwb3MsIGlzQWJzb2x1dGUpIHtcblx0XHRcdHJldHVybiB1dGlscy5maW5kKHRoaXMubGlzdCgpLCBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLnJhbmdlKGlzQWJzb2x1dGUpLmluc2lkZShwb3MpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHNvdXJjZSBjb2RlIG9mIGN1cnJlbnQgY29udGFpbmVyIFxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVPZigpO1xuXHRcdH0sXG5cblx0XHR2YWx1ZU9mOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnNvdXJjZTtcblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtFZGl0Q29udGFpbmVyfSBwYXJlbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IG5hbWVUb2tlblxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVUb2tlblxuXHQgKi9cblx0ZnVuY3Rpb24gRWRpdEVsZW1lbnQocGFyZW50LCBuYW1lVG9rZW4sIHZhbHVlVG9rZW4pIHtcblx0XHQvKiogQHR5cGUgRWRpdENvbnRhaW5lciAqL1xuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXHRcdFxuXHRcdHRoaXMuX25hbWUgPSBuYW1lVG9rZW4udmFsdWU7XG5cdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZVRva2VuID8gdmFsdWVUb2tlbi52YWx1ZSA6ICcnO1xuXHRcdFxuXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IHtcblx0XHRcdG5hbWU6IG5hbWVUb2tlbi5zdGFydCxcblx0XHRcdHZhbHVlOiB2YWx1ZVRva2VuID8gdmFsdWVUb2tlbi5zdGFydCA6IC0xXG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRoZSBzZWxmLXByb3BhZ2F0aW5nIGV4dGVuZCBmdW5jdGlvbiBmb3IgY2xhc3Nlcy5cblx0ICogQHR5cGUgRnVuY3Rpb25cblx0ICovXG5cdEVkaXRFbGVtZW50LmV4dGVuZCA9IGtsYXNzLmV4dGVuZDtcblx0XG5cdEVkaXRFbGVtZW50LnByb3RvdHlwZSA9IHtcblx0XHR0eXBlOiAnZWxlbWVudCcsXG5cblx0XHQvKipcblx0XHQgKiBDaGlsZCBjbGFzcyBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogTWFrZSBwb3NpdGlvbiBhYnNvbHV0ZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBYnNvbHV0ZVxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdF9wb3M6IGZ1bmN0aW9uKG51bSwgaXNBYnNvbHV0ZSkge1xuXHRcdFx0cmV0dXJuIG51bSArIChpc0Fic29sdXRlID8gdGhpcy5wYXJlbnQub3B0aW9ucy5vZmZzZXQgOiAwKTtcblx0XHR9LFxuXHRcdFx0XG5cdFx0LyoqXG5cdFx0ICogU2V0cyBvZiBnZXRzIGVsZW1lbnQgdmFsdWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsIE5ldyBlbGVtZW50IHZhbHVlLiBJZiBub3QgcGFzc2VkLCBjdXJyZW50IFxuXHRcdCAqIHZhbHVlIGlzIHJldHVybmVkXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5fdmFsdWUgIT09ICh2YWwgPSBTdHJpbmcodmFsKSkpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnQuX3VwZGF0ZVNvdXJjZSh2YWwsIHRoaXMudmFsdWVSYW5nZSgpKTtcblx0XHRcdFx0dGhpcy5fdmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNldHMgb2YgZ2V0cyBlbGVtZW50IG5hbWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsIE5ldyBlbGVtZW50IG5hbWUuIElmIG5vdCBwYXNzZWQsIGN1cnJlbnQgXG5cdFx0ICogbmFtZSBpcyByZXR1cm5lZFxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0bmFtZTogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5fbmFtZSAhPT0gKHZhbCA9IFN0cmluZyh2YWwpKSkge1xuXHRcdFx0XHR0aGlzLnBhcmVudC5fdXBkYXRlU291cmNlKHZhbCwgdGhpcy5uYW1lUmFuZ2UoKSk7XG5cdFx0XHRcdHRoaXMuX25hbWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl9uYW1lO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBwb3NpdGlvbiBvZiBlbGVtZW50IG5hbWUgdG9rZW5cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWJzb2x1dGUgUmV0dXJuIGFic29sdXRlIHBvc2l0aW9uXG5cdFx0ICogQHJldHVybnMge051bWJlcn1cblx0XHQgKi9cblx0XHRuYW1lUG9zaXRpb246IGZ1bmN0aW9uKGlzQWJzb2x1dGUpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wb3ModGhpcy5fcG9zaXRpb25zLm5hbWUsIGlzQWJzb2x1dGUpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBwb3NpdGlvbiBvZiBlbGVtZW50IHZhbHVlIHRva2VuXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpc0Fic29sdXRlIFJldHVybiBhYnNvbHV0ZSBwb3NpdGlvblxuXHRcdCAqIEByZXR1cm5zIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dmFsdWVQb3NpdGlvbjogZnVuY3Rpb24oaXNBYnNvbHV0ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Bvcyh0aGlzLl9wb3NpdGlvbnMudmFsdWUsIGlzQWJzb2x1dGUpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBlbGVtZW50IG5hbWVcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWJzb2x1dGUgUmV0dXJuIGFic29sdXRlIHJhbmdlIFxuXHRcdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0XHQgKi9cblx0XHRyYW5nZTogZnVuY3Rpb24oaXNBYnNvbHV0ZSkge1xuXHRcdFx0cmV0dXJuIHJhbmdlLmNyZWF0ZSh0aGlzLm5hbWVQb3NpdGlvbihpc0Fic29sdXRlKSwgdGhpcy52YWx1ZU9mKCkpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBmdWxsIGVsZW1lbnQgcmFuZ2UsIGluY2x1ZGluZyBwb3NzaWJsZSBpbmRlbnRhdGlvblxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBYnNvbHV0ZSBSZXR1cm4gYWJzb2x1dGUgcmFuZ2Vcblx0XHQgKiBAcmV0dXJucyB7UmFuZ2V9XG5cdFx0ICovXG5cdFx0ZnVsbFJhbmdlOiBmdW5jdGlvbihpc0Fic29sdXRlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yYW5nZShpc0Fic29sdXRlKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgZWxlbWVudCBuYW1lIHJhbmdlXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpc0Fic29sdXRlIFJldHVybiBhYnNvbHV0ZSByYW5nZVxuXHRcdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0XHQgKi9cblx0XHRuYW1lUmFuZ2U6IGZ1bmN0aW9uKGlzQWJzb2x1dGUpIHtcblx0XHRcdHJldHVybiByYW5nZS5jcmVhdGUodGhpcy5uYW1lUG9zaXRpb24oaXNBYnNvbHV0ZSksIHRoaXMubmFtZSgpKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgZWxlbWVudCB2YWx1ZSByYW5nZVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBYnNvbHV0ZSBSZXR1cm4gYWJzb2x1dGUgcmFuZ2Vcblx0XHQgKiBAcmV0dXJucyB7UmFuZ2V9XG5cdFx0ICovXG5cdFx0dmFsdWVSYW5nZTogZnVuY3Rpb24oaXNBYnNvbHV0ZSkge1xuXHRcdFx0cmV0dXJuIHJhbmdlLmNyZWF0ZSh0aGlzLnZhbHVlUG9zaXRpb24oaXNBYnNvbHV0ZSksIHRoaXMudmFsdWUoKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGN1cnJlbnQgZWxlbWVudCBzdHJpbmcgcmVwcmVzZW50YXRpb25cblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlT2YoKTtcblx0XHR9LFxuXHRcdFxuXHRcdHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSgpICsgdGhpcy52YWx1ZSgpO1xuXHRcdH1cblx0fTtcblx0XG5cdHJldHVybiB7XG5cdFx0RWRpdENvbnRhaW5lcjogRWRpdENvbnRhaW5lcixcblx0XHRFZGl0RWxlbWVudDogRWRpdEVsZW1lbnQsXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyB0b2tlbiB0aGF0IGNhbiBiZSBmZWQgdG8gPGNvZGU+RWRpdEVsZW1lbnQ8L2NvZGU+XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcblx0XHQgKiBAcmV0dXJuc1xuXHRcdCAqL1xuXHRcdGNyZWF0ZVRva2VuOiBmdW5jdGlvbihzdGFydCwgdmFsdWUsIHR5cGUpIHtcblx0XHRcdHZhciBvYmogPSB7XG5cdFx0XHRcdHN0YXJ0OiBzdGFydCB8fCAwLFxuXHRcdFx0XHR2YWx1ZTogdmFsdWUgfHwgJycsXG5cdFx0XHRcdHR5cGU6IHR5cGVcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdG9iai5lbmQgPSBvYmouc3RhcnQgKyBvYmoudmFsdWUubGVuZ3RoO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vYXNzZXRzL3JhbmdlXCI6XCJhc3NldHNcXFxccmFuZ2UuanNcIixcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCIsXCIuLi92ZW5kb3Iva2xhc3NcIjpcInZlbmRvclxcXFxrbGFzcy5qc1wifV0sXCJlZGl0VHJlZVxcXFxjc3MuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIENTUyBFZGl0VHJlZSBpcyBhIG1vZHVsZSB0aGF0IGNhbiBwYXJzZSBhIENTUyBydWxlIGludG8gYSB0cmVlIHdpdGggXG4gKiBjb252ZW5pZW50IG1ldGhvZHMgZm9yIGFkZGluZywgbW9kaWZ5aW5nIGFuZCByZW1vdmluZyBDU1MgcHJvcGVydGllcy4gVGhlc2UgXG4gKiBjaGFuZ2VzIGNhbiBiZSB3cml0dGVuIGJhY2sgdG8gc3RyaW5nIHdpdGggcmVzcGVjdCBvZiBjb2RlIGZvcm1hdHRpbmcuXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgZWRpdFRyZWUgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblx0dmFyIGNzc1BhcnNlciA9IHJlcXVpcmUoJy4uL3BhcnNlci9jc3MnKTtcblx0dmFyIGNzc1NlY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbHMvY3NzU2VjdGlvbnMnKTtcblx0dmFyIHJhbmdlID0gcmVxdWlyZSgnLi4vYXNzZXRzL3JhbmdlJyk7XG5cdHZhciBzdHJpbmdTdHJlYW0gPSByZXF1aXJlKCcuLi9hc3NldHMvc3RyaW5nU3RyZWFtJyk7XG5cdHZhciB0b2tlbkl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vYXNzZXRzL3Rva2VuSXRlcmF0b3InKTtcblxuXHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdFx0c3R5bGVCZWZvcmU6ICdcXG5cXHQnLFxuXHRcdHN0eWxlU2VwYXJhdG9yOiAnOiAnLFxuXHRcdG9mZnNldDogMFxuXHR9O1xuXHRcblx0dmFyIHJlU3BhY2VTdGFydCA9IC9eXFxzKy87XG5cdHZhciByZVNwYWNlRW5kID0gL1xccyskLztcblx0dmFyIFdISVRFU1BBQ0VfUkVNT1ZFX0ZST01fU1RBUlQgPSAxO1xuXHR2YXIgV0hJVEVTUEFDRV9SRU1PVkVfRlJPTV9FTkQgICA9IDI7XG5cdFxuXHQvKipcblx0ICogTW9kaWZpZXMgZ2l2ZW4gcmFuZ2UgdG8gcmVtb3ZlIHdoaXRlc3BhY2UgZnJvbSBiZWdpbm5pbmdcblx0ICogYW5kL29yIGZyb20gdGhlIGVuZFxuXHQgKiBAcGFyYW0gIHtSYW5nZX0gcm5nIFJhbmdlIHRvIG1vZGlmeVxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgIFRleHQgdGhhdCByYW5nZSBiZWxvbmdzIHRvXG5cdCAqIEBwYXJhbSAge051bWJlcn0gbWFzayAgTWFzayBpbmRpY2F0aW5nIGZyb20gd2hpY2ggZW5kIFxuXHQgKiB3aGl0ZXNwYWNlIHNob3VsZCBiZSByZW1vdmVkXG5cdCAqIEByZXR1cm4ge1JhbmdlfVxuXHQgKi9cblx0ZnVuY3Rpb24gdHJpbVdoaXRlc3BhY2VJblJhbmdlKHJuZywgdGV4dCwgbWFzaykge1xuXHRcdG1hc2sgPSBtYXNrIHx8IChXSElURVNQQUNFX1JFTU9WRV9GUk9NX1NUQVJUIHwgV0hJVEVTUEFDRV9SRU1PVkVfRlJPTV9FTkQpO1xuXHRcdHRleHQgPSBybmcuc3Vic3RyaW5nKHRleHQpO1xuXHRcdHZhciBtO1xuXHRcdGlmICgobWFzayAmIFdISVRFU1BBQ0VfUkVNT1ZFX0ZST01fU1RBUlQpICYmIChtID0gdGV4dC5tYXRjaChyZVNwYWNlU3RhcnQpKSkge1xuXHRcdFx0cm5nLnN0YXJ0ICs9IG1bMF0ubGVuZ3RoO1xuXHRcdH1cblxuXHRcdGlmICgobWFzayAmIFdISVRFU1BBQ0VfUkVNT1ZFX0ZST01fRU5EKSAmJiAobSA9IHRleHQubWF0Y2gocmVTcGFjZUVuZCkpKSB7XG5cdFx0XHRybmcuZW5kIC09IG1bMF0ubGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8vIGluIGNhc2UgZ2l2ZW4gcmFuZ2UgaXMganVzdCBhIHdoYXRlc3BhY2Vcblx0XHRpZiAocm5nLmVuZCA8IHJuZy5zdGFydCkge1xuXHRcdFx0cm5nLmVuZCA9IHJuZy5zdGFydDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcm5nO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN1bWVzIENTUyBwcm9wZXJ0eSBhbmQgdmFsdWUgZnJvbSBjdXJyZW50IHRva2VuXG5cdCAqIGl0ZXJhdG9yIHN0YXRlLiBPZmZzZXRzIGl0ZXJhdG9yIHBvaW50ZXIgaW50byB0b2tlblxuXHQgKiB0aGF0IGNhbiBiZSB1c2VkIGZvciBuZXh0IHZhbHVlIGNvbnNtcHRpb25cblx0ICogQHBhcmFtICB7VG9rZW5JdGVyYXRvcn0gaXRcblx0ICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0XG5cdCAqIEByZXR1cm4ge09iamVjdH0gICAgT2JqZWN0IHdpdGggYG5hbWVgIGFuZCBgdmFsdWVgIHByb3BlcnRpZXMgXG5cdCAqIGFyIHJhbmdlcy4gVmFsdWUgcmFuZ2UgY2FuIGJlIHplcm8tbGVuZ3RoLlxuXHQgKi9cblx0ZnVuY3Rpb24gY29uc3VtZVNpbmdsZVByb3BlcnR5KGl0LCB0ZXh0KSB7XG5cdFx0dmFyIG5hbWUsIHZhbHVlLCBlbmQ7XG5cdFx0dmFyIHRva2VuID0gaXQuY3VycmVudCgpO1xuXG5cdFx0aWYgKCF0b2tlbikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gc2tpcCB3aGl0ZXNwYWNlXG5cdFx0dmFyIHdzID0geyd3aGl0ZSc6IDEsICdsaW5lJzogMSwgJ2NvbW1lbnQnOiAxfTtcblx0XHR3aGlsZSAoKHRva2VuID0gaXQuY3VycmVudCgpKSkge1xuXHRcdFx0aWYgKCEodG9rZW4udHlwZSBpbiB3cykpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpdC5uZXh0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFpdC5oYXNOZXh0KCkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIGNvbnN1bWUgcHJvcGVydHkgbmFtZVxuXHRcdHRva2VuID0gaXQuY3VycmVudCgpO1xuXHRcdG5hbWUgPSByYW5nZSh0b2tlbi5zdGFydCwgdG9rZW4udmFsdWUpO1xuXHRcdHZhciBpc0F0UHJvcGVydHkgPSB0b2tlbi52YWx1ZS5jaGFyQXQoMCkgPT0gJ0AnO1xuXHRcdHdoaWxlICh0b2tlbiA9IGl0Lm5leHQoKSkge1xuXHRcdFx0bmFtZS5lbmQgPSB0b2tlbi5lbmQ7XG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PSAnOicgfHwgdG9rZW4udHlwZSA9PSAnd2hpdGUnKSB7XG5cdFx0XHRcdG5hbWUuZW5kID0gdG9rZW4uc3RhcnQ7XG5cdFx0XHRcdGl0Lm5leHQoKTtcblx0XHRcdFx0aWYgKHRva2VuLnR5cGUgPT0gJzonIHx8IGlzQXRQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdC8vIFhYWCBJIHJlYWxseSBhc2hhbWUgb2YgdGhpcyBoYXJkY29kZSwgYnV0IEkgbmVlZFxuXHRcdFx0XHRcdC8vIHRvIHN0b3AgcGFyc2luZyBpZiB0aGlzIGlzIGFuIFNDU1MgbWl4aW4gY2FsbCxcblx0XHRcdFx0XHQvLyBmb3IgZXhhbXBsZTogQGluY2x1ZGUgYm9yZGVyLXJhZGl1cygxMHB4KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT0gJzsnIHx8IHRva2VuLnR5cGUgPT0gJ2xpbmUnKSB7XG5cdFx0XHRcdC8vIHRoZXJl4oCZcyBubyB2YWx1ZSwgbG9va3MgbGlrZSBhIG1peGluXG5cdFx0XHRcdC8vIG9yIGEgc3BlY2lhbCB1c2UgY2FzZTpcblx0XHRcdFx0Ly8gdXNlciBpcyB3cml0aW5nIGEgbmV3IHByb3BlcnR5IG9yIGFiYnJldmlhdGlvblxuXHRcdFx0XHRuYW1lLmVuZCA9IHRva2VuLnN0YXJ0O1xuXHRcdFx0XHR2YWx1ZSA9IHJhbmdlKHRva2VuLnN0YXJ0LCAwKTtcblx0XHRcdFx0aXQubmV4dCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0b2tlbiA9IGl0LmN1cnJlbnQoKTtcblx0XHRpZiAoIXZhbHVlICYmIHRva2VuKSB7XG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PSAnbGluZScpIHtcblx0XHRcdFx0bGFzdE5ld2xpbmUgPSB0b2tlbjtcblx0XHRcdH1cblx0XHRcdC8vIGNvbnN1bWUgdmFsdWVcblx0XHRcdHZhbHVlID0gcmFuZ2UodG9rZW4uc3RhcnQsIHRva2VuLnZhbHVlKTtcblx0XHRcdHZhciBsYXN0TmV3bGluZTtcblx0XHRcdHdoaWxlICgodG9rZW4gPSBpdC5uZXh0KCkpKSB7XG5cdFx0XHRcdHZhbHVlLmVuZCA9IHRva2VuLmVuZDtcblx0XHRcdFx0aWYgKHRva2VuLnR5cGUgPT0gJ2xpbmUnKSB7XG5cdFx0XHRcdFx0bGFzdE5ld2xpbmUgPSB0b2tlbjtcblx0XHRcdFx0fSBlbHNlIGlmICh0b2tlbi50eXBlID09ICd9JyB8fCB0b2tlbi50eXBlID09ICc7Jykge1xuXHRcdFx0XHRcdHZhbHVlLmVuZCA9IHRva2VuLnN0YXJ0O1xuXHRcdFx0XHRcdGlmICh0b2tlbi50eXBlID09ICc7Jykge1xuXHRcdFx0XHRcdFx0ZW5kID0gcmFuZ2UodG9rZW4uc3RhcnQsIHRva2VuLnZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aXQubmV4dCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT0gJzonICYmIGxhc3ROZXdsaW5lKSB7XG5cdFx0XHRcdFx0Ly8gQSBzcGVjaWFsIGNhc2U6IFxuXHRcdFx0XHRcdC8vIHVzZXIgaXMgd3JpdGluZyBhIHZhbHVlIGJlZm9yZSBleGlzdGluZ1xuXHRcdFx0XHRcdC8vIHByb3BlcnR5LCBidXQgZGlkbuKAmXQgaW5zZXJ0ZWQgY2xvc2luZyBzZW1pLWNvbG9uLlxuXHRcdFx0XHRcdC8vIEluIHRoaXMgY2FzZSwgbGltaXQgdmFsdWUgcmFuZ2UgdG8gcHJldmlvdXNcblx0XHRcdFx0XHQvLyBuZXdsaW5lXG5cdFx0XHRcdFx0dmFsdWUuZW5kID0gbGFzdE5ld2xpbmUuc3RhcnQ7XG5cdFx0XHRcdFx0aXQuX2kgPSBpdC50b2tlbnMuaW5kZXhPZihsYXN0TmV3bGluZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXZhbHVlKSB7XG5cdFx0XHR2YWx1ZSA9IHJhbmdlKG5hbWUuZW5kLCAwKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogdHJpbVdoaXRlc3BhY2VJblJhbmdlKG5hbWUsIHRleHQpLFxuXHRcdFx0dmFsdWU6IHRyaW1XaGl0ZXNwYWNlSW5SYW5nZSh2YWx1ZSwgdGV4dCwgV0hJVEVTUEFDRV9SRU1PVkVfRlJPTV9TVEFSVCB8IChlbmQgPyBXSElURVNQQUNFX1JFTU9WRV9GUk9NX0VORCA6IDApKSxcblx0XHRcdGVuZDogZW5kIHx8IHJhbmdlKHZhbHVlLmVuZCwgMClcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmRzIHBhcnRzIG9mIGNvbXBsZXggQ1NTIHZhbHVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGxpc3Qgb2YgPGNvZGU+UmFuZ2U8L2NvZGU+J3Ncblx0ICovXG5cdGZ1bmN0aW9uIGZpbmRQYXJ0cyhzdHIpIHtcblx0XHQvKiogQHR5cGUgU3RyaW5nU3RyZWFtICovXG5cdFx0dmFyIHN0cmVhbSA9IHN0cmluZ1N0cmVhbS5jcmVhdGUoc3RyKTtcblx0XHR2YXIgY2g7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBzZXAgPSAvW1xcc1xcdTAwYTAsO10vO1xuXHRcdFxuXHRcdHZhciBhZGQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHN0cmVhbS5uZXh0KCk7XG5cdFx0XHRyZXN1bHQucHVzaChyYW5nZShzdHJlYW0uc3RhcnQsIHN0cmVhbS5jdXJyZW50KCkpKTtcblx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBza2lwIHdoaXRlc3BhY2Vcblx0XHRzdHJlYW0uZWF0U3BhY2UoKTtcblx0XHRzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuXHRcdFxuXHRcdHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSkge1xuXHRcdFx0aWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcblx0XHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdFx0aWYgKCFzdHJlYW0uc2tpcFRvKGNoKSkgYnJlYWs7XG5cdFx0XHRcdGFkZCgpO1xuXHRcdFx0fSBlbHNlIGlmIChjaCA9PSAnKCcpIHtcblx0XHRcdFx0Ly8gZnVuY3Rpb24gZm91bmQsIG1heSBoYXZlIG5lc3RlZCBmdW5jdGlvblxuXHRcdFx0XHRzdHJlYW0uYmFja1VwKDEpO1xuXHRcdFx0XHRpZiAoIXN0cmVhbS5za2lwVG9QYWlyKCcoJywgJyknKSkgYnJlYWs7XG5cdFx0XHRcdHN0cmVhbS5iYWNrVXAoMSk7XG5cdFx0XHRcdGFkZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHNlcC50ZXN0KGNoKSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHJhbmdlKHN0cmVhbS5zdGFydCwgc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGggLSAxKSk7XG5cdFx0XHRcdFx0c3RyZWFtLmVhdFdoaWxlKHNlcCk7XG5cdFx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRhZGQoKTtcblxuXHRcdHJldHVybiB1dGlscy51bmlxdWUocmVzdWx0LmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRyZXR1cm4gISFpdGVtLmxlbmd0aCgpO1xuXHRcdH0pKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFBhcnNlcyBDU1MgcHJvcGVydGllcyBmcm9tIGdpdmVuIENTUyBzb3VyY2Vcblx0ICogYW5kIGFkZHMgdGhlbSB0byBDU1NFZGl0Q29udGFpbmVyIG5vZGVcblx0ICogQHBhcmFtICB7Q1NTRWRpdENvbnRhaW5lcn0gbm9kZVxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9IHNvdXJjZSBDU1Mgc291cmNlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgT2Zmc2V0IG9mIHByb3BlcnRpZXMgc3Vic2V0IGZyb20gb3JpZ2luYWwgc291cmNlXG5cdCAqL1xuXHRmdW5jdGlvbiBjb25zdW1lUHJvcGVydGllcyhub2RlLCBzb3VyY2UsIG9mZnNldCkge1xuXHRcdHZhciBsaXN0ID0gZXh0cmFjdFByb3BlcnRpZXNGcm9tU291cmNlKHNvdXJjZSwgb2Zmc2V0KTtcblxuXHRcdGxpc3QuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuXHRcdFx0bm9kZS5fY2hpbGRyZW4ucHVzaChuZXcgQ1NTRWRpdEVsZW1lbnQobm9kZSxcblx0XHRcdFx0ZWRpdFRyZWUuY3JlYXRlVG9rZW4ocHJvcGVydHkubmFtZS5zdGFydCwgcHJvcGVydHkubmFtZVRleHQpLFxuXHRcdFx0XHRlZGl0VHJlZS5jcmVhdGVUb2tlbihwcm9wZXJ0eS52YWx1ZS5zdGFydCwgcHJvcGVydHkudmFsdWVUZXh0KSxcblx0XHRcdFx0ZWRpdFRyZWUuY3JlYXRlVG9rZW4ocHJvcGVydHkuZW5kLnN0YXJ0LCBwcm9wZXJ0eS5lbmRUZXh0KVxuXHRcdFx0XHQpKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgZ2l2ZW4gQ1NTIHNvdXJjZSBhbmQgcmV0dXJucyBsaXN0IG9mIHJhbmdlcyBvZiBsb2NhdGVkIENTUyBwcm9wZXJ0aWVzLlxuXHQgKiBOb3JtYWxseSwgQ1NTIHNvdXJjZSBtdXN0IGNvbnRhaW4gcHJvcGVydGllcyBvbmx5LCBpdCBtdXN0IGJlLFxuXHQgKiBmb3IgZXhhbXBsZSwgYSBjb250ZW50IG9mIENTUyBzZWxlY3RvciBvciB0ZXh0IGJldHdlZW4gbmVzdGVkXG5cdCAqIENTUyBzZWN0aW9uc1xuXHQgKiBAcGFyYW0gIHtTdHJpbmd9IHNvdXJjZSBDU1Mgc291cmNlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgT2Zmc2V0IG9mIHByb3BlcnRpZXMgc3Vic2V0IGZyb20gb3JpZ2luYWwgc291cmNlLlxuXHQgKiBVc2VkIHRvIHByb3ZpZGUgcHJvcGVyIHJhbmdlcyBvZiBsb2NhdGVzIGl0ZW1zXG5cdCAqL1xuXHRmdW5jdGlvbiBleHRyYWN0UHJvcGVydGllc0Zyb21Tb3VyY2Uoc291cmNlLCBvZmZzZXQpIHtcblx0XHRvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0XHRzb3VyY2UgPSBzb3VyY2UucmVwbGFjZShyZVNwYWNlRW5kLCAnJyk7XG5cdFx0dmFyIG91dCA9IFtdO1xuXG5cdFx0aWYgKCFzb3VyY2UpIHtcblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fVxuXG5cdFx0dmFyIHRva2VucyA9IGNzc1BhcnNlci5wYXJzZShzb3VyY2UpO1xuXHRcdHZhciBpdCA9IHRva2VuSXRlcmF0b3IuY3JlYXRlKHRva2Vucyk7XG5cdFx0dmFyIHByb3BlcnR5O1xuXG5cdFx0d2hpbGUgKChwcm9wZXJ0eSA9IGNvbnN1bWVTaW5nbGVQcm9wZXJ0eShpdCwgc291cmNlKSkpIHtcblx0XHRcdG91dC5wdXNoKHtcblx0XHRcdFx0bmFtZVRleHQ6IHByb3BlcnR5Lm5hbWUuc3Vic3RyaW5nKHNvdXJjZSksXG5cdFx0XHRcdG5hbWU6IHByb3BlcnR5Lm5hbWUuc2hpZnQob2Zmc2V0KSxcblxuXHRcdFx0XHR2YWx1ZVRleHQ6IHByb3BlcnR5LnZhbHVlLnN1YnN0cmluZyhzb3VyY2UpLFxuXHRcdFx0XHR2YWx1ZTogcHJvcGVydHkudmFsdWUuc2hpZnQob2Zmc2V0KSxcblxuXHRcdFx0XHRlbmRUZXh0OiBwcm9wZXJ0eS5lbmQuc3Vic3RyaW5nKHNvdXJjZSksXG5cdFx0XHRcdGVuZDogcHJvcGVydHkuZW5kLnNoaWZ0KG9mZnNldClcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAY2xhc3Ncblx0ICogQGV4dGVuZHMgRWRpdENvbnRhaW5lclxuXHQgKi9cblx0dmFyIENTU0VkaXRDb250YWluZXIgPSBlZGl0VHJlZS5FZGl0Q29udGFpbmVyLmV4dGVuZCh7XG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHR1dGlscy5leHRlbmQodGhpcy5vcHRpb25zLCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cdFx0XHRcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcblx0XHRcdFx0c291cmNlID0gY3NzUGFyc2VyLnRvU291cmNlKHNvdXJjZSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBhbGxSdWxlcyA9IGNzc1NlY3Rpb25zLmZpbmRBbGxSdWxlcyhzb3VyY2UpO1xuXHRcdFx0dmFyIGN1cnJlbnRSdWxlID0gYWxsUnVsZXMuc2hpZnQoKTtcblxuXHRcdFx0Ly8ga2VlcCB0b3AtbGV2ZWwgcnVsZXMgb25seSBzaW5jZSB0aGV5IHdpbGxcblx0XHRcdC8vIGJlIHBhcnNlZCBieSBuZXN0ZWQgQ1NTRWRpdENvbnRhaW5lciBjYWxsXG5cdFx0XHR2YXIgdG9wTGV2ZWxSdWxlcyA9IFtdO1xuXHRcdFx0YWxsUnVsZXMuZm9yRWFjaChmdW5jdGlvbihyKSB7XG5cdFx0XHRcdHZhciBpc1RvcExldmVsID0gIXV0aWxzLmZpbmQodG9wTGV2ZWxSdWxlcywgZnVuY3Rpb24odHIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHIuY29udGFpbnMocik7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChpc1RvcExldmVsKSB7XG5cdFx0XHRcdFx0dG9wTGV2ZWxSdWxlcy5wdXNoKHIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXG5cdFx0XHR2YXIgc2VsZWN0b3JSYW5nZSA9IHJhbmdlLmNyZWF0ZTIoY3VycmVudFJ1bGUuc3RhcnQsIGN1cnJlbnRSdWxlLl9zZWxlY3RvckVuZCk7XG5cdFx0XHR0aGlzLl9uYW1lID0gc2VsZWN0b3JSYW5nZS5zdWJzdHJpbmcoc291cmNlKTtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5uYW1lID0gc2VsZWN0b3JSYW5nZS5zdGFydDtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5jb250ZW50U3RhcnQgPSBjdXJyZW50UnVsZS5fY29udGVudFN0YXJ0ICsgMTtcblxuXHRcdFx0dmFyIHNlY3Rpb25PZmZzZXQgPSBjdXJyZW50UnVsZS5fY29udGVudFN0YXJ0ICsgMTtcblx0XHRcdHZhciBzZWN0aW9uRW5kID0gY3VycmVudFJ1bGUuZW5kIC0gMTtcblxuXHRcdFx0Ly8gcGFyc2UgcHJvcGVydGllcyBiZXR3ZWVuIG5lc3RlZCBydWxlc1xuXHRcdFx0Ly8gYW5kIGFkZCBuZXN0ZWQgcnVsZXMgYXMgY2hpbGRyZW5cblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHRvcExldmVsUnVsZXMuZm9yRWFjaChmdW5jdGlvbihyKSB7XG5cdFx0XHRcdGNvbnN1bWVQcm9wZXJ0aWVzKHRoYXQsIHNvdXJjZS5zdWJzdHJpbmcoc2VjdGlvbk9mZnNldCwgci5zdGFydCksIHNlY3Rpb25PZmZzZXQpO1xuXHRcdFx0XHR2YXIgb3B0ID0gdXRpbHMuZXh0ZW5kKHt9LCB0aGF0Lm9wdGlvbnMsIHtvZmZzZXQ6IHIuc3RhcnQgKyB0aGF0Lm9wdGlvbnMub2Zmc2V0fSk7XG5cdFx0XHRcdC8vIFhYWCBJIHRoaW5rIEkgZG9u4oCZdCBuZWVkIG5lc3RlZCBjb250YWluZXJzIGhlcmVcblx0XHRcdFx0Ly8gVGhleSBzaG91bGQgYmUgaGFuZGxlZCBzZXBhcmF0ZWx5XG5cdFx0XHRcdC8vIHRoYXQuX2NoaWxkcmVuLnB1c2gobmV3IENTU0VkaXRDb250YWluZXIoci5zdWJzdHJpbmcoc291cmNlKSwgb3B0KSk7XG5cdFx0XHRcdHNlY3Rpb25PZmZzZXQgPSByLmVuZDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBjb25zdW1lIHRoZSByZXN0IG9mIGRhdGFcblx0XHRcdGNvbnN1bWVQcm9wZXJ0aWVzKHRoaXMsIHNvdXJjZS5zdWJzdHJpbmcoc2VjdGlvbk9mZnNldCwgY3VycmVudFJ1bGUuZW5kIC0gMSksIHNlY3Rpb25PZmZzZXQpO1xuXHRcdFx0dGhpcy5fc2F2ZVN0eWxlKCk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1lbWJlcnMgYWxsIHN0eWxlcyBvZiBwcm9wZXJ0aWVzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfc2F2ZVN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzdGFydCA9IHRoaXMuX3Bvc2l0aW9ucy5jb250ZW50U3RhcnQ7XG5cdFx0XHR2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG5cdFx0XHRcblx0XHRcdHRoaXMubGlzdCgpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAocC50eXBlID09PSAnY29udGFpbmVyJykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHAuc3R5bGVCZWZvcmUgPSBzb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0LCBwLm5hbWVQb3NpdGlvbigpKTtcblx0XHRcdFx0Ly8gYSBzbWFsbCBoYWNrIGhlcmU6XG5cdFx0XHRcdC8vIFNvbWV0aW1lcyB1c2VycyBhZGQgZW1wdHkgbGluZXMgYmVmb3JlIHByb3BlcnRpZXMgdG8gbG9naWNhbGx5XG5cdFx0XHRcdC8vIHNlcGFyYXRlIGdyb3VwcyBvZiBwcm9wZXJ0aWVzLiBJbiB0aGlzIGNhc2UsIGEgYmxpbmQgY29weSBvZlxuXHRcdFx0XHQvLyBjaGFyYWN0ZXJzIGJldHdlZW4gcnVsZXMgbWF5IGxlYWQgdG8gdW5kZXNpcmVkIGJlaGF2aW9yLFxuXHRcdFx0XHQvLyBlc3BlY2lhbGx5IHdoZW4gY3VycmVudCBydWxlIGlzIGR1cGxpY2F0ZWQgb3IgdXNlZCBhcyBhIGRvbm9yXG5cdFx0XHRcdC8vIHRvIGNyZWF0ZSBuZXcgcnVsZS5cblx0XHRcdFx0Ly8gVG8gc29sdmUgdGhpcyBpc3N1ZSwgd2XigJhsbCB0YWtlIG9ubHkgbGFzdCBuZXdsaW5lIGluZGVudGF0aW9uXG5cdFx0XHRcdHZhciBsaW5lcyA9IHV0aWxzLnNwbGl0QnlMaW5lcyhwLnN0eWxlQmVmb3JlKTtcblx0XHRcdFx0aWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRwLnN0eWxlQmVmb3JlID0gJ1xcbicgKyBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cC5zdHlsZVNlcGFyYXRvciA9IHNvdXJjZS5zdWJzdHJpbmcocC5uYW1lUmFuZ2UoKS5lbmQsIHAudmFsdWVQb3NpdGlvbigpKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGdyYWNlZnVsIGFuZCBuYWl2ZSBjb21tZW50cyByZW1vdmFsIFxuXHRcdFx0XHR2YXIgcGFydHMgPSBwLnN0eWxlQmVmb3JlLnNwbGl0KCcqLycpO1xuXHRcdFx0XHRwLnN0eWxlQmVmb3JlID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdHAuc3R5bGVTZXBhcmF0b3IgPSBwLnN0eWxlU2VwYXJhdG9yLnJlcGxhY2UoL1xcL1xcKi4qP1xcKlxcLy9nLCAnJyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRzdGFydCA9IHAucmFuZ2UoKS5lbmQ7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBwb3NpdGlvbiBvZiBlbGVtZW50IG5hbWUgdG9rZW5cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWJzb2x1dGUgUmV0dXJuIGFic29sdXRlIHBvc2l0aW9uXG5cdFx0ICogQHJldHVybnMge051bWJlcn1cblx0XHQgKi9cblx0XHRuYW1lUG9zaXRpb246IGZ1bmN0aW9uKGlzQWJzb2x1dGUpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wb3ModGhpcy5fcG9zaXRpb25zLm5hbWUsIGlzQWJzb2x1dGUpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBwb3NpdGlvbiBvZiBlbGVtZW50IHZhbHVlIHRva2VuXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpc0Fic29sdXRlIFJldHVybiBhYnNvbHV0ZSBwb3NpdGlvblxuXHRcdCAqIEByZXR1cm5zIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dmFsdWVQb3NpdGlvbjogZnVuY3Rpb24oaXNBYnNvbHV0ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Bvcyh0aGlzLl9wb3NpdGlvbnMuY29udGVudFN0YXJ0LCBpc0Fic29sdXRlKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBlbGVtZW50IHZhbHVlIHJhbmdlXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpc0Fic29sdXRlIFJldHVybiBhYnNvbHV0ZSByYW5nZVxuXHRcdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0XHQgKi9cblx0XHR2YWx1ZVJhbmdlOiBmdW5jdGlvbihpc0Fic29sdXRlKSB7XG5cdFx0XHRyZXR1cm4gcmFuZ2UuY3JlYXRlMih0aGlzLnZhbHVlUG9zaXRpb24oaXNBYnNvbHV0ZSksIHRoaXMuX3Bvcyh0aGlzLnZhbHVlT2YoKS5sZW5ndGgsIGlzQWJzb2x1dGUpIC0gMSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBBZGRzIG5ldyBDU1MgcHJvcGVydHkgXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgUHJvcGVydHkgbmFtZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgUG9zaXRpb24gYXQgd2hpY2ggdG8gaW5zZXJ0IG5ldyBwcm9wZXJ0eS4gQnkgXG5cdFx0ICogZGVmYXVsdCB0aGUgcHJvcGVydHkgaXMgaW5zZXJ0ZWQgYXQgdGhlIGVuZCBvZiBydWxlIFxuXHRcdCAqIEByZXR1cm5zIHtDU1NFZGl0UHJvcGVydHl9XG5cdFx0ICovXG5cdFx0YWRkOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcG9zKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMubGlzdCgpO1xuXHRcdFx0dmFyIHN0YXJ0ID0gdGhpcy5fcG9zaXRpb25zLmNvbnRlbnRTdGFydDtcblx0XHRcdHZhciBzdHlsZXMgPSB1dGlscy5waWNrKHRoaXMub3B0aW9ucywgJ3N0eWxlQmVmb3JlJywgJ3N0eWxlU2VwYXJhdG9yJyk7XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlb2YgcG9zID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRwb3MgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqIEB0eXBlIENTU0VkaXRQcm9wZXJ0eSAqL1xuXHRcdFx0dmFyIGRvbm9yID0gbGlzdFtwb3NdO1xuXHRcdFx0aWYgKGRvbm9yKSB7XG5cdFx0XHRcdHN0YXJ0ID0gZG9ub3IuZnVsbFJhbmdlKCkuc3RhcnQ7XG5cdFx0XHR9IGVsc2UgaWYgKChkb25vciA9IGxpc3RbcG9zIC0gMV0pKSB7XG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGF0IGRvbm9yIGhhcyB0ZXJtaW5hdGluZyBzZW1pY29sb25cblx0XHRcdFx0ZG9ub3IuZW5kKCc7Jyk7XG5cdFx0XHRcdHN0YXJ0ID0gZG9ub3IucmFuZ2UoKS5lbmQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChkb25vcikge1xuXHRcdFx0XHRzdHlsZXMgPSB1dGlscy5waWNrKGRvbm9yLCAnc3R5bGVCZWZvcmUnLCAnc3R5bGVTZXBhcmF0b3InKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIG5hbWVUb2tlbiA9IGVkaXRUcmVlLmNyZWF0ZVRva2VuKHN0YXJ0ICsgc3R5bGVzLnN0eWxlQmVmb3JlLmxlbmd0aCwgbmFtZSk7XG5cdFx0XHR2YXIgdmFsdWVUb2tlbiA9IGVkaXRUcmVlLmNyZWF0ZVRva2VuKG5hbWVUb2tlbi5lbmQgKyBzdHlsZXMuc3R5bGVTZXBhcmF0b3IubGVuZ3RoLCB2YWx1ZSk7XG5cdFx0XHRcblx0XHRcdHZhciBwcm9wZXJ0eSA9IG5ldyBDU1NFZGl0RWxlbWVudCh0aGlzLCBuYW1lVG9rZW4sIHZhbHVlVG9rZW4sXG5cdFx0XHRcdFx0ZWRpdFRyZWUuY3JlYXRlVG9rZW4odmFsdWVUb2tlbi5lbmQsICc7JykpO1xuXHRcdFx0XG5cdFx0XHR1dGlscy5leHRlbmQocHJvcGVydHksIHN0eWxlcyk7XG5cdFx0XHRcblx0XHRcdC8vIHdyaXRlIG5ldyBwcm9wZXJ0eSBpbnRvIHRoZSBzb3VyY2Vcblx0XHRcdHRoaXMuX3VwZGF0ZVNvdXJjZShwcm9wZXJ0eS5zdHlsZUJlZm9yZSArIHByb3BlcnR5LnRvU3RyaW5nKCksIHN0YXJ0KTtcblx0XHRcdFxuXHRcdFx0Ly8gaW5zZXJ0IG5ldyBwcm9wZXJ0eVxuXHRcdFx0dGhpcy5fY2hpbGRyZW4uc3BsaWNlKHBvcywgMCwgcHJvcGVydHkpO1xuXHRcdFx0cmV0dXJuIHByb3BlcnR5O1xuXHRcdH1cblx0fSk7XG5cdFxuXHQvKipcblx0ICogQGNsYXNzXG5cdCAqIEB0eXBlIENTU0VkaXRFbGVtZW50XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0dmFyIENTU0VkaXRFbGVtZW50ID0gZWRpdFRyZWUuRWRpdEVsZW1lbnQuZXh0ZW5kKHtcblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbihydWxlLCBuYW1lLCB2YWx1ZSwgZW5kKSB7XG5cdFx0XHR0aGlzLnN0eWxlQmVmb3JlID0gcnVsZS5vcHRpb25zLnN0eWxlQmVmb3JlO1xuXHRcdFx0dGhpcy5zdHlsZVNlcGFyYXRvciA9IHJ1bGUub3B0aW9ucy5zdHlsZVNlcGFyYXRvcjtcblx0XHRcdFxuXHRcdFx0dGhpcy5fZW5kID0gZW5kLnZhbHVlO1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zLmVuZCA9IGVuZC5zdGFydDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgcmFuZ2VzIG9mIGNvbXBsZXggdmFsdWUgcGFydHNcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgPGNvZGU+bnVsbDwvY29kZT4gaWYgdmFsdWUgaXMgbm90IGNvbXBsZXhcblx0XHQgKi9cblx0XHR2YWx1ZVBhcnRzOiBmdW5jdGlvbihpc0Fic29sdXRlKSB7XG5cdFx0XHR2YXIgcGFydHMgPSBmaW5kUGFydHModGhpcy52YWx1ZSgpKTtcblx0XHRcdGlmIChpc0Fic29sdXRlKSB7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLnZhbHVlUG9zaXRpb24odHJ1ZSk7XG5cdFx0XHRcdHBhcnRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRcdHAuc2hpZnQob2Zmc2V0KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBwYXJ0cztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0cyBvZiBnZXRzIGVsZW1lbnQgdmFsdWUuIFxuXHRcdCAqIFdoZW4gc2V0dGluZyB2YWx1ZSwgdGhpcyBpbXBsZW1lbnRhdGlvbiB3aWxsIGVuc3VyZSB0aGF0IHlvdXIgaGF2ZSBcblx0XHQgKiBwcm9wZXIgbmFtZS12YWx1ZSBzZXBhcmF0b3Jcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsIE5ldyBlbGVtZW50IHZhbHVlLiBJZiBub3QgcGFzc2VkLCBjdXJyZW50IFxuXHRcdCAqIHZhbHVlIGlzIHJldHVybmVkXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHR2YXIgaXNVcGRhdGluZyA9IHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnO1xuXHRcdFx0dmFyIGFsbEl0ZW1zID0gdGhpcy5wYXJlbnQubGlzdCgpO1xuXHRcdFx0aWYgKGlzVXBkYXRpbmcgJiYgdGhpcy5pc0luY29tcGxldGUoKSkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdHZhciBkb25vciA9IHV0aWxzLmZpbmQoYWxsSXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbSAhPT0gc2VsZiAmJiAhaXRlbS5pc0luY29tcGxldGUoKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dGhpcy5zdHlsZVNlcGFyYXRvciA9IGRvbm9yIFxuXHRcdFx0XHRcdD8gZG9ub3Iuc3R5bGVTZXBhcmF0b3IgXG5cdFx0XHRcdFx0OiB0aGlzLnBhcmVudC5vcHRpb25zLnN0eWxlU2VwYXJhdG9yO1xuXHRcdFx0XHR0aGlzLnBhcmVudC5fdXBkYXRlU291cmNlKHRoaXMuc3R5bGVTZXBhcmF0b3IsIHJhbmdlKHRoaXMudmFsdWVSYW5nZSgpLnN0YXJ0LCAwKSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX19zdXBlcl9fLnZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoaXNVcGRhdGluZykge1xuXHRcdFx0XHQvLyBtYWtlIHN1cmUgY3VycmVudCBwcm9wZXJ0eSBoYXMgdGVybWluYXRpbmcgc2VtaS1jb2xvblxuXHRcdFx0XHQvLyBpZiBpdOKAmXMgbm90IHRoZSBsYXN0IG9uZVxuXHRcdFx0XHR2YXIgaXggPSBhbGxJdGVtcy5pbmRleE9mKHRoaXMpO1xuXHRcdFx0XHRpZiAoaXggIT09IGFsbEl0ZW1zLmxlbmd0aCAtIDEgJiYgIXRoaXMuZW5kKCkpIHtcblx0XHRcdFx0XHR0aGlzLmVuZCgnOycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRlc3QgaWYgY3VycmVudCBlbGVtZW50IGlzIGluY29tcGxldGUsIGUuZy4gaGFzIG5vIGV4cGxpY2l0XG5cdFx0ICogbmFtZS12YWx1ZSBzZXBhcmF0b3Jcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBbZGVzY3JpcHRpb25dXG5cdFx0ICovXG5cdFx0aXNJbmNvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLm5hbWVSYW5nZSgpLmVuZCA9PT0gdGhpcy52YWx1ZVJhbmdlKCkuc3RhcnQ7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBTZXRzIG9mIGdldHMgcHJvcGVydHkgZW5kIHZhbHVlIChiYXNpY2FsbHksIGl0J3MgYSBzZW1pY29sb24pXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbCBOZXcgZW5kIHZhbHVlLiBJZiBub3QgcGFzc2VkLCBjdXJyZW50IFxuXHRcdCAqIHZhbHVlIGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0ZW5kOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLl9lbmQgIT09IHZhbCkge1xuXHRcdFx0XHR0aGlzLnBhcmVudC5fdXBkYXRlU291cmNlKHZhbCwgdGhpcy5fcG9zaXRpb25zLmVuZCwgdGhpcy5fcG9zaXRpb25zLmVuZCArIHRoaXMuX2VuZC5sZW5ndGgpO1xuXHRcdFx0XHR0aGlzLl9lbmQgPSB2YWw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl9lbmQ7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGZ1bGwgcnVsZSByYW5nZSwgd2l0aCBpbmRlbnRhdGlvblxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBYnNvbHV0ZSBSZXR1cm4gYWJzb2x1dGUgcmFuZ2UgKHdpdGggcmVzcGVjdCBvZlxuXHRcdCAqIHJ1bGUgb2Zmc2V0KVxuXHRcdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0XHQgKi9cblx0XHRmdWxsUmFuZ2U6IGZ1bmN0aW9uKGlzQWJzb2x1dGUpIHtcblx0XHRcdHZhciByID0gdGhpcy5yYW5nZShpc0Fic29sdXRlKTtcblx0XHRcdHIuc3RhcnQgLT0gdGhpcy5zdHlsZUJlZm9yZS5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gcjtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbSBzdHJpbmcgcmVwcmVzZW50YXRpb25cblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSgpICsgdGhpcy5zdHlsZVNlcGFyYXRvciArIHRoaXMudmFsdWUoKSArIHRoaXMuZW5kKCk7XG5cdFx0fVxuXHR9KTtcblx0XG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogUGFyc2VzIENTUyBydWxlIGludG8gZWRpdGFibGUgdHJlZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2Vcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqIEBtZW1iZXJPZiBlbW1ldC5jc3NFZGl0VHJlZVxuXHRcdCAqIEByZXR1cm5zIHtFZGl0Q29udGFpbmVyfVxuXHRcdCAqL1xuXHRcdHBhcnNlOiBmdW5jdGlvbihzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBuZXcgQ1NTRWRpdENvbnRhaW5lcihzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRXh0cmFjdCBhbmQgcGFyc2UgQ1NTIHJ1bGUgZnJvbSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gPGNvZGU+Y29udGVudDwvY29kZT4gXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnQgQ1NTIHNvdXJjZSBjb2RlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvcyBDaGFyYWN0ZXIgcG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgc291cmNlIGNvZGUgZXh0cmFjdGlvblxuXHRcdCAqIEByZXR1cm5zIHtFZGl0Q29udGFpbmVyfVxuXHRcdCAqL1xuXHRcdHBhcnNlRnJvbVBvc2l0aW9uOiBmdW5jdGlvbihjb250ZW50LCBwb3MsIGlzQmFja3dhcmQpIHtcblx0XHRcdHZhciBib3VuZHMgPSBjc3NTZWN0aW9ucy5sb2NhdGVSdWxlKGNvbnRlbnQsIHBvcywgaXNCYWNrd2FyZCk7XG5cdFx0XHRpZiAoIWJvdW5kcyB8fCAhYm91bmRzLmluc2lkZShwb3MpKSB7XG5cdFx0XHRcdC8vIG5vIG1hdGNoaW5nIENTUyBydWxlIG9yIGNhcmV0IG91dHNpZGUgcnVsZSBib3VuZHNcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlKGJvdW5kcy5zdWJzdHJpbmcoY29udGVudCksIHtcblx0XHRcdFx0b2Zmc2V0OiBib3VuZHMuc3RhcnRcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBMb2NhdGVzIENTUyBwcm9wZXJ0eSBpbiBnaXZlbiBDU1MgY29kZSBmcmFnbWVudCB1bmRlciBzcGVjaWZpZWQgY2hhcmFjdGVyIHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBjc3MgQ1NTIGNvZGUgb3IgcGFyc2VkIENTU0VkaXRDb250YWluZXJcblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHBvcyBDaGFyYWN0ZXIgcG9zaXRpb24gd2hlcmUgdG8gc2VhcmNoIENTUyBwcm9wZXJ0eVxuXHRcdCAqIEByZXR1cm4ge0NTU0VkaXRFbGVtZW50fVxuXHRcdCAqL1xuXHRcdHByb3BlcnR5RnJvbVBvc2l0aW9uOiBmdW5jdGlvbihjc3MsIHBvcykge1xuXHRcdFx0dmFyIGNzc1Byb3AgPSBudWxsO1xuXHRcdFx0LyoqIEB0eXBlIEVkaXRDb250YWluZXIgKi9cblx0XHRcdHZhciBjc3NSdWxlID0gdHlwZW9mIGNzcyA9PT0gJ3N0cmluZycgPyB0aGlzLnBhcnNlRnJvbVBvc2l0aW9uKGNzcywgcG9zLCB0cnVlKSA6IGNzcztcblx0XHRcdGlmIChjc3NSdWxlKSB7XG5cdFx0XHRcdGNzc1Byb3AgPSBjc3NSdWxlLml0ZW1Gcm9tUG9zaXRpb24ocG9zLCB0cnVlKTtcblx0XHRcdFx0aWYgKCFjc3NQcm9wKSB7XG5cdFx0XHRcdFx0Ly8gaW4gY2FzZSB1c2VyIGp1c3Qgc3RhcnRlZCB3cml0aW5nIENTUyBwcm9wZXJ0eVxuXHRcdFx0XHRcdC8vIGFuZCBkaWRuJ3QgaW5jbHVkZSBzZW1pY29sb27igJN0cnkgYW5vdGhlciBhcHByb2FjaFxuXHRcdFx0XHRcdGNzc1Byb3AgPSB1dGlscy5maW5kKGNzc1J1bGUubGlzdCgpLCBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5yYW5nZSh0cnVlKS5lbmQgPT0gcG9zO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjc3NQcm9wO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyB2ZW5kb3IgcHJlZml4IGZyb20gQ1NTIHByb3BlcnR5XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5XG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGJhc2VOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gbmFtZS5yZXBsYWNlKC9eXFxzKlxcLVxcdytcXC0vLCAnJyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBGaW5kcyBwYXJ0cyBvZiBjb21wbGV4IENTUyB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0ZmluZFBhcnRzOiBmaW5kUGFydHMsXG5cblx0XHRleHRyYWN0UHJvcGVydGllc0Zyb21Tb3VyY2U6IGV4dHJhY3RQcm9wZXJ0aWVzRnJvbVNvdXJjZVxuXHR9O1xufSk7XG59LHtcIi4uL2Fzc2V0cy9yYW5nZVwiOlwiYXNzZXRzXFxcXHJhbmdlLmpzXCIsXCIuLi9hc3NldHMvc3RyaW5nU3RyZWFtXCI6XCJhc3NldHNcXFxcc3RyaW5nU3RyZWFtLmpzXCIsXCIuLi9hc3NldHMvdG9rZW5JdGVyYXRvclwiOlwiYXNzZXRzXFxcXHRva2VuSXRlcmF0b3IuanNcIixcIi4uL3BhcnNlci9jc3NcIjpcInBhcnNlclxcXFxjc3MuanNcIixcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCIsXCIuLi91dGlscy9jc3NTZWN0aW9uc1wiOlwidXRpbHNcXFxcY3NzU2VjdGlvbnMuanNcIixcIi4vYmFzZVwiOlwiZWRpdFRyZWVcXFxcYmFzZS5qc1wifV0sXCJlZGl0VHJlZVxcXFx4bWwuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFhNTCBFZGl0VHJlZSBpcyBhIG1vZHVsZSB0aGF0IGNhbiBwYXJzZSBhbiBYTUwvSFRNTCBlbGVtZW50IGludG8gYSB0cmVlIHdpdGggXG4gKiBjb252ZW5pZW50IG1ldGhvZHMgZm9yIGFkZGluZywgbW9kaWZ5aW5nIGFuZCByZW1vdmluZyBhdHRyaWJ1dGVzLiBUaGVzZSBcbiAqIGNoYW5nZXMgY2FuIGJlIHdyaXR0ZW4gYmFjayB0byBzdHJpbmcgd2l0aCByZXNwZWN0IG9mIGNvZGUgZm9ybWF0dGluZy5cbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIGVkaXRUcmVlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cdHZhciB4bWxQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXIveG1sJyk7XG5cdHZhciByYW5nZSA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9yYW5nZScpO1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuXHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdFx0c3R5bGVCZWZvcmU6ICcgJyxcblx0XHRzdHlsZVNlcGFyYXRvcjogJz0nLFxuXHRcdHN0eWxlUXVvdGU6ICdcIicsXG5cdFx0b2Zmc2V0OiAwXG5cdH07XG5cdFxuXHR2YXIgc3RhcnRUYWcgPSAvXjwoW1xcd1xcOlxcLV0rKSgoPzpcXHMrW1xcd1xcLTpdKyg/Olxccyo9XFxzKig/Oig/OlwiW15cIl0qXCIpfCg/OidbXiddKicpfFtePlxcc10rKSk/KSopXFxzKihcXC8/KT4vbTtcblx0XG5cdHZhciBYTUxFZGl0Q29udGFpbmVyID0gZWRpdFRyZWUuRWRpdENvbnRhaW5lci5leHRlbmQoe1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0dXRpbHMuZGVmYXVsdHModGhpcy5vcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMubmFtZSA9IDE7XG5cdFx0XHRcblx0XHRcdHZhciBhdHRyVG9rZW4gPSBudWxsO1xuXHRcdFx0dmFyIHRva2VucyA9IHhtbFBhcnNlci5wYXJzZShzb3VyY2UpO1xuXHRcdFx0XG5cdFx0XHR0b2tlbnMuZm9yRWFjaChmdW5jdGlvbih0b2tlbikge1xuXHRcdFx0XHR0b2tlbi52YWx1ZSA9IHJhbmdlLmNyZWF0ZSh0b2tlbikuc3Vic3RyaW5nKHNvdXJjZSk7XG5cdFx0XHRcdHN3aXRjaCAodG9rZW4udHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ3RhZyc6XG5cdFx0XHRcdFx0XHRpZiAoL148W15cXC9dKy8udGVzdCh0b2tlbi52YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbmFtZSA9IHRva2VuLnZhbHVlLnN1YnN0cmluZygxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSAnYXR0cmlidXRlJzpcblx0XHRcdFx0XHRcdC8vIGFkZCBlbXB0eSBhdHRyaWJ1dGVcblx0XHRcdFx0XHRcdGlmIChhdHRyVG9rZW4pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY2hpbGRyZW4ucHVzaChuZXcgWE1MRWRpdEVsZW1lbnQodGhpcywgYXR0clRva2VuKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGF0dHJUb2tlbiA9IHRva2VuO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlICdzdHJpbmcnOlxuXHRcdFx0XHRcdFx0dGhpcy5fY2hpbGRyZW4ucHVzaChuZXcgWE1MRWRpdEVsZW1lbnQodGhpcywgYXR0clRva2VuLCB0b2tlbikpO1xuXHRcdFx0XHRcdFx0YXR0clRva2VuID0gbnVsbDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0aWYgKGF0dHJUb2tlbikge1xuXHRcdFx0XHR0aGlzLl9jaGlsZHJlbi5wdXNoKG5ldyBYTUxFZGl0RWxlbWVudCh0aGlzLCBhdHRyVG9rZW4pKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5fc2F2ZVN0eWxlKCk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1lbWJlcnMgYWxsIHN0eWxlcyBvZiBwcm9wZXJ0aWVzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfc2F2ZVN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzdGFydCA9IHRoaXMubmFtZVJhbmdlKCkuZW5kO1xuXHRcdFx0dmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmxpc3QoKS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cC5zdHlsZUJlZm9yZSA9IHNvdXJjZS5zdWJzdHJpbmcoc3RhcnQsIHAubmFtZVBvc2l0aW9uKCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHAudmFsdWVQb3NpdGlvbigpICE9PSAtMSkge1xuXHRcdFx0XHRcdHAuc3R5bGVTZXBhcmF0b3IgPSBzb3VyY2Uuc3Vic3RyaW5nKHAubmFtZVBvc2l0aW9uKCkgKyBwLm5hbWUoKS5sZW5ndGgsIHAudmFsdWVQb3NpdGlvbigpIC0gcC5zdHlsZVF1b3RlLmxlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHN0YXJ0ID0gcC5yYW5nZSgpLmVuZDtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWRkcyBuZXcgYXR0cmlidXRlIFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFByb3BlcnR5IG5hbWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgUHJvcGVydHkgdmFsdWVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcG9zIFBvc2l0aW9uIGF0IHdoaWNoIHRvIGluc2VydCBuZXcgcHJvcGVydHkuIEJ5IFxuXHRcdCAqIGRlZmF1bHQgdGhlIHByb3BlcnR5IGlzIGluc2VydGVkIGF0IHRoZSBlbmQgb2YgcnVsZSBcblx0XHQgKi9cblx0XHRhZGQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwb3MpIHtcblx0XHRcdHZhciBsaXN0ID0gdGhpcy5saXN0KCk7XG5cdFx0XHR2YXIgc3RhcnQgPSB0aGlzLm5hbWVSYW5nZSgpLmVuZDtcblx0XHRcdHZhciBzdHlsZXMgPSB1dGlscy5waWNrKHRoaXMub3B0aW9ucywgJ3N0eWxlQmVmb3JlJywgJ3N0eWxlU2VwYXJhdG9yJywgJ3N0eWxlUXVvdGUnKTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGVvZiBwb3MgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHBvcyA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8qKiBAdHlwZSBYTUxFZGl0QXR0cmlidXRlICovXG5cdFx0XHR2YXIgZG9ub3IgPSBsaXN0W3Bvc107XG5cdFx0XHRpZiAoZG9ub3IpIHtcblx0XHRcdFx0c3RhcnQgPSBkb25vci5mdWxsUmFuZ2UoKS5zdGFydDtcblx0XHRcdH0gZWxzZSBpZiAoKGRvbm9yID0gbGlzdFtwb3MgLSAxXSkpIHtcblx0XHRcdFx0c3RhcnQgPSBkb25vci5yYW5nZSgpLmVuZDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGRvbm9yKSB7XG5cdFx0XHRcdHN0eWxlcyA9IHV0aWxzLnBpY2soZG9ub3IsICdzdHlsZUJlZm9yZScsICdzdHlsZVNlcGFyYXRvcicsICdzdHlsZVF1b3RlJyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHZhbHVlID0gc3R5bGVzLnN0eWxlUXVvdGUgKyB2YWx1ZSArIHN0eWxlcy5zdHlsZVF1b3RlO1xuXHRcdFx0XG5cdFx0XHR2YXIgYXR0cmlidXRlID0gbmV3IFhNTEVkaXRFbGVtZW50KHRoaXMsIFxuXHRcdFx0XHRcdGVkaXRUcmVlLmNyZWF0ZVRva2VuKHN0YXJ0ICsgc3R5bGVzLnN0eWxlQmVmb3JlLmxlbmd0aCwgbmFtZSksXG5cdFx0XHRcdFx0ZWRpdFRyZWUuY3JlYXRlVG9rZW4oc3RhcnQgKyBzdHlsZXMuc3R5bGVCZWZvcmUubGVuZ3RoICsgbmFtZS5sZW5ndGggXG5cdFx0XHRcdFx0XHRcdCsgc3R5bGVzLnN0eWxlU2VwYXJhdG9yLmxlbmd0aCwgdmFsdWUpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFxuXHRcdFx0dXRpbHMuZXh0ZW5kKGF0dHJpYnV0ZSwgc3R5bGVzKTtcblx0XHRcdFxuXHRcdFx0Ly8gd3JpdGUgbmV3IGF0dHJpYnV0ZSBpbnRvIHRoZSBzb3VyY2Vcblx0XHRcdHRoaXMuX3VwZGF0ZVNvdXJjZShhdHRyaWJ1dGUuc3R5bGVCZWZvcmUgKyBhdHRyaWJ1dGUudG9TdHJpbmcoKSwgc3RhcnQpO1xuXHRcdFx0XG5cdFx0XHQvLyBpbnNlcnQgbmV3IGF0dHJpYnV0ZVxuXHRcdFx0dGhpcy5fY2hpbGRyZW4uc3BsaWNlKHBvcywgMCwgYXR0cmlidXRlKTtcblx0XHRcdHJldHVybiBhdHRyaWJ1dGU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEEgc3BlY2lhbCBjYXNlIG9mIGF0dHJpYnV0ZSBlZGl0aW5nOiBhZGRzIGNsYXNzIHZhbHVlIHRvIGV4aXN0aW5nXG5cdFx0ICogYGNsYXNzYCBhdHRyaWJ1dGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcblx0XHQgKi9cblx0XHRhZGRDbGFzczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBhdHRyID0gdGhpcy5nZXQoJ2NsYXNzJyk7XG5cdFx0XHR2YWx1ZSA9IHV0aWxzLnRyaW0odmFsdWUpO1xuXHRcdFx0aWYgKCFhdHRyKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFkZCgnY2xhc3MnLCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjbGFzc1ZhbCA9IGF0dHIudmFsdWUoKTtcblx0XHRcdHZhciBjbGFzc0xpc3QgPSAnICcgKyBjbGFzc1ZhbC5yZXBsYWNlKC9cXG4vZywgJyAnKSArICcgJztcblx0XHRcdGlmICghfmNsYXNzTGlzdC5pbmRleE9mKCcgJyArIHZhbHVlICsgJyAnKSkge1xuXHRcdFx0XHRhdHRyLnZhbHVlKGNsYXNzVmFsICsgJyAnICsgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBIHNwZWNpYWwgY2FzZSBvZiBhdHRyaWJ1dGUgZWRpdGluZzogcmVtb3ZlcyBjbGFzcyB2YWx1ZSBmcm9tIGV4aXN0aW5nXG5cdFx0ICogYGNsYXNzYCBhdHRyaWJ1dGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcblx0XHQgKi9cblx0XHRyZW1vdmVDbGFzczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBhdHRyID0gdGhpcy5nZXQoJ2NsYXNzJyk7XG5cdFx0XHR2YWx1ZSA9IHV0aWxzLnRyaW0odmFsdWUpO1xuXHRcdFx0aWYgKCFhdHRyKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlQ2xhc3MgPSBuZXcgUmVnRXhwKCcoXnxcXFxccyspJyArIHV0aWxzLmVzY2FwZUZvclJlZ2V4cCh2YWx1ZSkpO1xuXHRcdFx0dmFyIGNsYXNzVmFsID0gYXR0ci52YWx1ZSgpLnJlcGxhY2UocmVDbGFzcywgJycpO1xuXHRcdFx0aWYgKCF1dGlscy50cmltKGNsYXNzVmFsKSkge1xuXHRcdFx0XHR0aGlzLnJlbW92ZSgnY2xhc3MnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHIudmFsdWUoY2xhc3NWYWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdFxuXHR2YXIgWE1MRWRpdEVsZW1lbnQgPSBlZGl0VHJlZS5FZGl0RWxlbWVudC5leHRlbmQoe1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhcmVudCwgbmFtZVRva2VuLCB2YWx1ZVRva2VuKSB7XG5cdFx0XHR0aGlzLnN0eWxlQmVmb3JlID0gcGFyZW50Lm9wdGlvbnMuc3R5bGVCZWZvcmU7XG5cdFx0XHR0aGlzLnN0eWxlU2VwYXJhdG9yID0gcGFyZW50Lm9wdGlvbnMuc3R5bGVTZXBhcmF0b3I7XG5cdFx0XHRcblx0XHRcdHZhciB2YWx1ZSA9ICcnLCBxdW90ZSA9IHBhcmVudC5vcHRpb25zLnN0eWxlUXVvdGU7XG5cdFx0XHRpZiAodmFsdWVUb2tlbikge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlVG9rZW4udmFsdWU7XG5cdFx0XHRcdHF1b3RlID0gdmFsdWUuY2hhckF0KDApO1xuXHRcdFx0XHRpZiAocXVvdGUgPT0gJ1wiJyB8fCBxdW90ZSA9PSBcIidcIikge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1b3RlID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChxdW90ZSAmJiB2YWx1ZS5jaGFyQXQodmFsdWUubGVuZ3RoIC0gMSkgPT0gcXVvdGUpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLnN0eWxlUXVvdGUgPSBxdW90ZTtcblx0XHRcdFxuXHRcdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy52YWx1ZSA9IHZhbHVlVG9rZW4gPyB2YWx1ZVRva2VuLnN0YXJ0ICsgcXVvdGUubGVuZ3RoIDogLTE7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGZ1bGwgcnVsZSByYW5nZSwgd2l0aCBpbmRlbnRhdGlvblxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBYnNvbHV0ZSBSZXR1cm4gYWJzb2x1dGUgcmFuZ2UgKHdpdGggcmVzcGVjdCBvZlxuXHRcdCAqIHJ1bGUgb2Zmc2V0KVxuXHRcdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0XHQgKi9cblx0XHRmdWxsUmFuZ2U6IGZ1bmN0aW9uKGlzQWJzb2x1dGUpIHtcblx0XHRcdHZhciByID0gdGhpcy5yYW5nZShpc0Fic29sdXRlKTtcblx0XHRcdHIuc3RhcnQgLT0gdGhpcy5zdHlsZUJlZm9yZS5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gcjtcblx0XHR9LFxuXHRcdFxuXHRcdHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSgpICsgdGhpcy5zdHlsZVNlcGFyYXRvclxuXHRcdFx0XHQrIHRoaXMuc3R5bGVRdW90ZSArIHRoaXMudmFsdWUoKSArIHRoaXMuc3R5bGVRdW90ZTtcblx0XHR9XG5cdH0pO1xuXHRcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBQYXJzZXMgSFRNTCBlbGVtZW50IGludG8gZWRpdGFibGUgdHJlZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2Vcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqIEBtZW1iZXJPZiBlbW1ldC5odG1sRWRpdFRyZWVcblx0XHQgKiBAcmV0dXJucyB7RWRpdENvbnRhaW5lcn1cblx0XHQgKi9cblx0XHRwYXJzZTogZnVuY3Rpb24oc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFhNTEVkaXRDb250YWluZXIoc291cmNlLCBvcHRpb25zKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4dHJhY3QgYW5kIHBhcnNlIEhUTUwgZnJvbSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gPGNvZGU+Y29udGVudDwvY29kZT4gXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnQgQ1NTIHNvdXJjZSBjb2RlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvcyBDaGFyYWN0ZXIgcG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgc291cmNlIGNvZGUgZXh0cmFjdGlvblxuXHRcdCAqIEByZXR1cm5zIHtYTUxFZGl0RWxlbWVudH1cblx0XHQgKi9cblx0XHRwYXJzZUZyb21Qb3NpdGlvbjogZnVuY3Rpb24oY29udGVudCwgcG9zLCBpc0JhY2t3YXJkKSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5leHRyYWN0VGFnKGNvbnRlbnQsIHBvcywgaXNCYWNrd2FyZCk7XG5cdFx0XHRpZiAoIWJvdW5kcyB8fCAhYm91bmRzLmluc2lkZShwb3MpKVxuXHRcdFx0XHQvLyBubyBtYXRjaGluZyBIVE1MIHRhZyBvciBjYXJldCBvdXRzaWRlIHRhZyBib3VuZHNcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlKGJvdW5kcy5zdWJzdHJpbmcoY29udGVudCksIHtcblx0XHRcdFx0b2Zmc2V0OiBib3VuZHMuc3RhcnRcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRXh0cmFjdHMgbmVhcmVzdCBIVE1MIHRhZyByYW5nZSBmcm9tIDxjb2RlPmNvbnRlbnQ8L2NvZGU+LCBzdGFydGluZyBhdCBcblx0XHQgKiA8Y29kZT5wb3M8L2NvZGU+IHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcG9zXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpc0JhY2t3YXJkXG5cdFx0ICogQHJldHVybnMge1JhbmdlfVxuXHRcdCAqL1xuXHRcdGV4dHJhY3RUYWc6IGZ1bmN0aW9uKGNvbnRlbnQsIHBvcywgaXNCYWNrd2FyZCkge1xuXHRcdFx0dmFyIGxlbiA9IGNvbnRlbnQubGVuZ3RoLCBpO1xuXHRcdFx0XG5cdFx0XHQvLyBtYXggZXh0cmFjdGlvbiBsZW5ndGguIEkgZG9uJ3QgdGhpbmsgdGhlcmUgbWF5IGJlIHRhZ3MgbGFyZ2VyIFxuXHRcdFx0Ly8gdGhhbiAyMDAwIGNoYXJhY3RlcnMgbGVuZ3RoXG5cdFx0XHR2YXIgbWF4TGVuID0gTWF0aC5taW4oMjAwMCwgbGVuKTtcblx0XHRcdFxuXHRcdFx0LyoqIEB0eXBlIFJhbmdlICovXG5cdFx0XHR2YXIgciA9IG51bGw7XG5cdFx0XHRcblx0XHRcdHZhciBtYXRjaCA9IGZ1bmN0aW9uKHBvcykge1xuXHRcdFx0XHR2YXIgbTtcblx0XHRcdFx0aWYgKGNvbnRlbnQuY2hhckF0KHBvcykgPT0gJzwnICYmIChtID0gY29udGVudC5zdWJzdHIocG9zLCBtYXhMZW4pLm1hdGNoKHN0YXJ0VGFnKSkpXG5cdFx0XHRcdFx0cmV0dXJuIHJhbmdlLmNyZWF0ZShwb3MsIG1bMF0pO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbG9va3VwIGJhY2t3YXJkLCBpbiBjYXNlIHdlIGFyZSBpbnNpZGUgdGFnIGFscmVhZHlcblx0XHRcdGZvciAoaSA9IHBvczsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKChyID0gbWF0Y2goaSkpKSBicmVhaztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHIgJiYgKHIuaW5zaWRlKHBvcykgfHwgaXNCYWNrd2FyZCkpXG5cdFx0XHRcdHJldHVybiByO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXIgJiYgaXNCYWNrd2FyZClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdC8vIHNlYXJjaCBmb3J3YXJkXG5cdFx0XHRmb3IgKGkgPSBwb3M7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZiAoKHIgPSBtYXRjaChpKSkpXG5cdFx0XHRcdFx0cmV0dXJuIHI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSk7XG59LHtcIi4uL2Fzc2V0cy9yYW5nZVwiOlwiYXNzZXRzXFxcXHJhbmdlLmpzXCIsXCIuLi9wYXJzZXIveG1sXCI6XCJwYXJzZXJcXFxceG1sLmpzXCIsXCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi9iYXNlXCI6XCJlZGl0VHJlZVxcXFxiYXNlLmpzXCJ9XSxcImZpbHRlclxcXFxiZW0uanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEZpbHRlciBmb3IgYWlkaW5nIG9mIHdyaXRpbmcgZWxlbWVudHMgd2l0aCBjb21wbGV4IGNsYXNzIG5hbWVzIGFzIGRlc2NyaWJlZFxuICogaW4gWWFuZGV4J3MgQkVNIChCbG9jaywgRWxlbWVudCwgTW9kaWZpZXIpIG1ldGhvZG9sb2d5LiBUaGlzIGZpbHRlciB3aWxsXG4gKiBhdXRvbWF0aWNhbGx5IGluaGVyaXQgYmxvY2sgYW5kIGVsZW1lbnQgbmFtZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgYW5kIGluc2VydFxuICogdGhlbSBpbnRvIGNoaWxkIGVsZW1lbnQgY2xhc3Nlc1xuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgaHRtbEZpbHRlciA9IHJlcXVpcmUoJy4vaHRtbCcpO1xuXHR2YXIgcHJlZnMgPSByZXF1aXJlKCcuLi9hc3NldHMvcHJlZmVyZW5jZXMnKTtcblx0dmFyIGFiYnJldmlhdGlvblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvYWJicmV2aWF0aW9uJyk7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG5cdHByZWZzLmRlZmluZSgnYmVtLmVsZW1lbnRTZXBhcmF0b3InLCAnX18nLCAnQ2xhc3MgbmFtZeKAmXMgZWxlbWVudCBzZXBhcmF0b3IuJyk7XG5cdHByZWZzLmRlZmluZSgnYmVtLm1vZGlmaWVyU2VwYXJhdG9yJywgJ18nLCAnQ2xhc3MgbmFtZeKAmXMgbW9kaWZpZXIgc2VwYXJhdG9yLicpO1xuXHRwcmVmcy5kZWZpbmUoJ2JlbS5zaG9ydEVsZW1lbnRQcmVmaXgnLCAnLScsIFxuXHRcdFx0J1N5bWJvbCBmb3IgZGVzY3JpYmluZyBzaG9ydCDigJxibG9jay1lbGVtZW504oCdIG5vdGF0aW9uLiBDbGFzcyBuYW1lcyAnXG5cdFx0XHQrICdwcmVmaXhlZCB3aXRoIHRoaXMgc3ltYm9sIHdpbGwgYmUgdHJlYXRlZCBhcyBlbGVtZW50IG5hbWUgZm9yIHBhcmVudOKAmHMgJ1xuXHRcdFx0KyAnYmxvY2sgbmFtZS4gRWFjaCBzeW1ib2wgaW5zdGFuY2UgdHJhdmVyc2VzIG9uZSBsZXZlbCB1cCBpbiBwYXJzZWQgJyBcblx0XHRcdCsgJ3RyZWUgZm9yIGJsb2NrIG5hbWUgbG9va3VwLiBFbXB0eSB2YWx1ZSB3aWxsIGRpc2FibGUgc2hvcnQgbm90YXRpb24uJyk7XG5cdFxuXHR2YXIgc2hvdWxkUnVuSHRtbEZpbHRlciA9IGZhbHNlO1xuXHRcblx0ZnVuY3Rpb24gZ2V0U2VwYXJhdG9ycygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudDogcHJlZnMuZ2V0KCdiZW0uZWxlbWVudFNlcGFyYXRvcicpLFxuXHRcdFx0bW9kaWZpZXI6IHByZWZzLmdldCgnYmVtLm1vZGlmaWVyU2VwYXJhdG9yJylcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gaXRlbVxuXHQgKi9cblx0ZnVuY3Rpb24gYmVtUGFyc2UoaXRlbSkge1xuXHRcdGlmIChhYmJyZXZpYXRpb25VdGlscy5pc1NuaXBwZXQoaXRlbSkpXG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcblx0XHQvLyBzYXZlIEJFTSBzdHVmZiBpbiBjYWNoZSBmb3IgZmFzdGVyIGxvb2t1cHNcblx0XHRpdGVtLl9fYmVtID0ge1xuXHRcdFx0YmxvY2s6ICcnLFxuXHRcdFx0ZWxlbWVudDogJycsXG5cdFx0XHRtb2RpZmllcjogJydcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBjbGFzc05hbWVzID0gbm9ybWFsaXplQ2xhc3NOYW1lKGl0ZW0uYXR0cmlidXRlKCdjbGFzcycpKS5zcGxpdCgnICcpO1xuXHRcdFxuXHRcdC8vIGd1ZXNzIGJlc3QgbWF0Y2ggZm9yIGJsb2NrIG5hbWVcblx0XHR2YXIgcmVCbG9ja05hbWUgPSAvXlthLXpdXFwtL2k7XG5cdFx0aXRlbS5fX2JlbS5ibG9jayA9IHV0aWxzLmZpbmQoY2xhc3NOYW1lcywgZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuIHJlQmxvY2tOYW1lLnRlc3QobmFtZSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0Ly8gZ3Vlc3NpbmcgZG9lc24ndCB3b3JrZWQsIHBpY2sgZmlyc3QgY2xhc3MgbmFtZSBhcyBibG9jayBuYW1lXG5cdFx0aWYgKCFpdGVtLl9fYmVtLmJsb2NrKSB7XG5cdFx0XHRyZUJsb2NrTmFtZSA9IC9eW2Etel0vaTtcblx0XHRcdGl0ZW0uX19iZW0uYmxvY2sgPSB1dGlscy5maW5kKGNsYXNzTmFtZXMsIGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIHJlQmxvY2tOYW1lLnRlc3QobmFtZSk7XG5cdFx0XHR9KSB8fCAnJztcblx0XHR9XG5cblx0XHRjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5tYXAoZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuIHByb2Nlc3NDbGFzc05hbWUobmFtZSwgaXRlbSk7XG5cdFx0fSk7XG5cblx0XHRjbGFzc05hbWVzID0gdXRpbHMudW5pcXVlKHV0aWxzLmZsYXR0ZW4oY2xhc3NOYW1lcykpLmpvaW4oJyAnKTtcblx0XHRpZiAoY2xhc3NOYW1lcykge1xuXHRcdFx0aXRlbS5hdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lcyk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NOYW1lKGNsYXNzTmFtZSkge1xuXHRcdGNsYXNzTmFtZSA9ICgnICcgKyAoY2xhc3NOYW1lIHx8ICcnKSArICcgJykucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuXHRcdFxuXHRcdHZhciBzaG9ydFN5bWJvbCA9IHByZWZzLmdldCgnYmVtLnNob3J0RWxlbWVudFByZWZpeCcpO1xuXHRcdGlmIChzaG9ydFN5bWJvbCkge1xuXHRcdFx0dmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXHMoJyArIHV0aWxzLmVzY2FwZUZvclJlZ2V4cChzaG9ydFN5bWJvbCkgKyAnKyknLCAnZycpO1xuXHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lLnJlcGxhY2UocmUsIGZ1bmN0aW9uKHN0ciwgcDEpIHtcblx0XHRcdFx0cmV0dXJuICcgJyArIHV0aWxzLnJlcGVhdFN0cmluZyhnZXRTZXBhcmF0b3JzKCkuZWxlbWVudCwgcDEubGVuZ3RoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gdXRpbHMudHJpbShjbGFzc05hbWUpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUHJvY2Vzc2VzIGNsYXNzIG5hbWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQ2xhc3MgbmFtZSBpdGVtIHRvIHByb2Nlc3Ncblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBpdGVtIEhvc3Qgbm9kZSBmb3IgcHJvdmlkZWQgY2xhc3MgbmFtZVxuXHQgKiBAcmV0dXJucyBQcm9jZXNzZWQgY2xhc3MgbmFtZS4gTWF5IHJldHVybiA8Y29kZT5BcnJheTwvY29kZT4gb2Zcblx0ICogY2xhc3MgbmFtZXMgXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9jZXNzQ2xhc3NOYW1lKG5hbWUsIGl0ZW0pIHtcblx0XHRuYW1lID0gdHJhbnNmb3JtQ2xhc3NOYW1lKG5hbWUsIGl0ZW0sICdlbGVtZW50Jyk7XG5cdFx0bmFtZSA9IHRyYW5zZm9ybUNsYXNzTmFtZShuYW1lLCBpdGVtLCAnbW9kaWZpZXInKTtcblx0XHRcblx0XHQvLyBleHBhbmQgY2xhc3MgbmFtZVxuXHRcdC8vIHBvc3NpYmxlIHZhbHVlczpcblx0XHQvLyAqIGJsb2NrX19lbGVtZW50XG5cdFx0Ly8gKiBibG9ja19fZWxlbWVudF9tb2RpZmllclxuXHRcdC8vICogYmxvY2tfX2VsZW1lbnRfbW9kaWZpZXIxX21vZGlmaWVyMlxuXHRcdC8vICogYmxvY2tfbW9kaWZpZXJcblx0XHR2YXIgYmxvY2sgPSAnJywgZWxlbWVudCA9ICcnLCBtb2RpZmllciA9ICcnO1xuXHRcdHZhciBzZXBhcmF0b3JzID0gZ2V0U2VwYXJhdG9ycygpO1xuXHRcdGlmICh+bmFtZS5pbmRleE9mKHNlcGFyYXRvcnMuZWxlbWVudCkpIHtcblx0XHRcdHZhciBlbGVtZW50cyA9IG5hbWUuc3BsaXQoc2VwYXJhdG9ycy5lbGVtZW50KTtcblx0XHRcdGJsb2NrID0gZWxlbWVudHMuc2hpZnQoKTtcblxuXHRcdFx0dmFyIG1vZGlmaWVycyA9IGVsZW1lbnRzLnBvcCgpLnNwbGl0KHNlcGFyYXRvcnMubW9kaWZpZXIpO1xuXHRcdFx0ZWxlbWVudHMucHVzaChtb2RpZmllcnMuc2hpZnQoKSk7XG5cdFx0XHRlbGVtZW50ID0gZWxlbWVudHMuam9pbihzZXBhcmF0b3JzLmVsZW1lbnQpO1xuXHRcdFx0bW9kaWZpZXIgPSBtb2RpZmllcnMuam9pbihzZXBhcmF0b3JzLm1vZGlmaWVyKTtcblx0XHR9IGVsc2UgaWYgKH5uYW1lLmluZGV4T2Yoc2VwYXJhdG9ycy5tb2RpZmllcikpIHtcblx0XHRcdHZhciBibG9ja01vZGlmaWVycyA9IG5hbWUuc3BsaXQoc2VwYXJhdG9ycy5tb2RpZmllcik7XG5cdFx0XHRcblx0XHRcdGJsb2NrID0gYmxvY2tNb2RpZmllcnMuc2hpZnQoKTtcblx0XHRcdG1vZGlmaWVyID0gYmxvY2tNb2RpZmllcnMuam9pbihzZXBhcmF0b3JzLm1vZGlmaWVyKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKGJsb2NrIHx8IGVsZW1lbnQgfHwgbW9kaWZpZXIpIHtcblx0XHRcdGlmICghYmxvY2spIHtcblx0XHRcdFx0YmxvY2sgPSBpdGVtLl9fYmVtLmJsb2NrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBpbmhlcml0IHBhcmVudCBiZW0gZWxlbWVudCwgaWYgZXhpc3RzXG4vL1x0XHRcdGlmIChpdGVtLnBhcmVudCAmJiBpdGVtLnBhcmVudC5fX2JlbSAmJiBpdGVtLnBhcmVudC5fX2JlbS5lbGVtZW50KVxuLy9cdFx0XHRcdGVsZW1lbnQgPSBpdGVtLnBhcmVudC5fX2JlbS5lbGVtZW50ICsgc2VwYXJhdG9ycy5lbGVtZW50ICsgZWxlbWVudDtcblx0XHRcdFxuXHRcdFx0Ly8gcHJvZHVjZSBtdWx0aXBsZSBjbGFzc2VzXG5cdFx0XHR2YXIgcHJlZml4ID0gYmxvY2s7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHRcblx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdHByZWZpeCArPSBzZXBhcmF0b3JzLmVsZW1lbnQgKyBlbGVtZW50O1xuXHRcdFx0XHRyZXN1bHQucHVzaChwcmVmaXgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0LnB1c2gocHJlZml4KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKG1vZGlmaWVyKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKHByZWZpeCArIHNlcGFyYXRvcnMubW9kaWZpZXIgKyBtb2RpZmllcik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICghaXRlbS5fX2JlbS5ibG9jayB8fCBtb2RpZmllcikge1xuXHRcdFx0XHRpdGVtLl9fYmVtLmJsb2NrID0gYmxvY2s7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGl0ZW0uX19iZW0uZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHRpdGVtLl9fYmVtLm1vZGlmaWVyID0gbW9kaWZpZXI7XG5cdFx0XHRcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIC4uLm90aGVyd2lzZSwgcmV0dXJuIHByb2Nlc3NlZCBvciBvcmlnaW5hbCBjbGFzcyBuYW1lXG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBMb3ctbGV2ZWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHVzZXItdHlwZWQgY2xhc3MgbmFtZSBpbnRvIGZ1bGwgQkVNIGNsYXNzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIENsYXNzIG5hbWUgaXRlbSB0byBwcm9jZXNzXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gaXRlbSBIb3N0IG5vZGUgZm9yIHByb3ZpZGVkIGNsYXNzIG5hbWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGVudGl0eVR5cGUgVHlwZSBvZiBlbnRpdHkgdG8gYmUgdHJpZWQgdG8gdHJhbnNmb3JtIFxuXHQgKiAoJ2VsZW1lbnQnIG9yICdtb2RpZmllcicpXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFByb2Nlc3NlZCBjbGFzcyBuYW1lIG9yIG9yaWdpbmFsIG9uZSBpZiBpdCBjYW4ndCBiZVxuXHQgKiB0cmFuc2Zvcm1lZFxuXHQgKi9cblx0ZnVuY3Rpb24gdHJhbnNmb3JtQ2xhc3NOYW1lKG5hbWUsIGl0ZW0sIGVudGl0eVR5cGUpIHtcblx0XHR2YXIgc2VwYXJhdG9ycyA9IGdldFNlcGFyYXRvcnMoKTtcblx0XHR2YXIgcmVTZXAgPSBuZXcgUmVnRXhwKCdeKCcgKyBzZXBhcmF0b3JzW2VudGl0eVR5cGVdICsgJykrJywgJ2cnKTtcblx0XHRpZiAocmVTZXAudGVzdChuYW1lKSkge1xuXHRcdFx0dmFyIGRlcHRoID0gMDsgLy8gcGFyZW50IGxvb2t1cCBkZXB0aFxuXHRcdFx0dmFyIGNsZWFuTmFtZSA9IG5hbWUucmVwbGFjZShyZVNlcCwgZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRcdGRlcHRoID0gc3RyLmxlbmd0aCAvIHNlcGFyYXRvcnNbZW50aXR5VHlwZV0ubGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gZmluZCBkb25vciBlbGVtZW50XG5cdFx0XHR2YXIgZG9ub3IgPSBpdGVtO1xuXHRcdFx0d2hpbGUgKGRvbm9yLnBhcmVudCAmJiBkZXB0aC0tKSB7XG5cdFx0XHRcdGRvbm9yID0gZG9ub3IucGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoIWRvbm9yIHx8ICFkb25vci5fX2JlbSlcblx0XHRcdFx0ZG9ub3IgPSBpdGVtO1xuXHRcdFx0XG5cdFx0XHRpZiAoZG9ub3IgJiYgZG9ub3IuX19iZW0pIHtcblx0XHRcdFx0dmFyIHByZWZpeCA9IGRvbm9yLl9fYmVtLmJsb2NrO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gZGVjaWRlIGlmIHdlIHNob3VsZCBpbmhlcml0IGVsZW1lbnQgbmFtZVxuLy9cdFx0XHRcdGlmIChlbnRpdHlUeXBlID09ICdlbGVtZW50Jykge1xuLy9cdFx0XHRcdFx0dmFyIGN1ckVsZW0gPSBjbGVhbk5hbWUuc3BsaXQoc2VwYXJhdG9ycy5tb2RpZmllciwgMSlbMF07XG4vL1x0XHRcdFx0XHRpZiAoZG9ub3IuX19iZW0uZWxlbWVudCAmJiBkb25vci5fX2JlbS5lbGVtZW50ICE9IGN1ckVsZW0pXG4vL1x0XHRcdFx0XHRcdHByZWZpeCArPSBzZXBhcmF0b3JzLmVsZW1lbnQgKyBkb25vci5fX2JlbS5lbGVtZW50O1xuLy9cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChlbnRpdHlUeXBlID09ICdtb2RpZmllcicgJiYgIGRvbm9yLl9fYmVtLmVsZW1lbnQpXG5cdFx0XHRcdFx0cHJlZml4ICs9IHNlcGFyYXRvcnMuZWxlbWVudCArIGRvbm9yLl9fYmVtLmVsZW1lbnQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gcHJlZml4ICsgc2VwYXJhdG9yc1tlbnRpdHlUeXBlXSArIGNsZWFuTmFtZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZWN1cnNpdmUgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgdGFncywgd2hpY2ggZXh0ZW5kcyBjbGFzcyBuYW1lcyBcblx0ICogYWNjb3JkaW5nIHRvIEJFTSBzcGVjczogaHR0cDovL2JlbS5naXRodWIuY29tL2JlbS1tZXRob2QvcGFnZXMvYmVnaW5uaW5nL2JlZ2lubmluZy5ydS5odG1sXG5cdCAqIDxicj48YnI+XG5cdCAqIEl0IGRvZXMgc2V2ZXJhbCB0aGluZ3M6PGJyPlxuXHQgKiA8dWw+XG5cdCAqIDxsaT5FeHBhbmRzIGNvbXBsZXggY2xhc3MgbmFtZSAoYWNjb3JkaW5nIHRvIEJFTSBzeW1ib2wgc2VtYW50aWNzKTpcblx0ICogLmJsb2NrX19lbGVtX21vZGlmaWVyIOKGkiAuYmxvY2suYmxvY2tfX2VsZW0uYmxvY2tfX2VsZW1fbW9kaWZpZXJcblx0ICogPC9saT5cblx0ICogPGxpPkluaGVyaXRzIGJsb2NrIG5hbWUgb24gY2hpbGQgZWxlbWVudHM6IFxuXHQgKiAuYi1ibG9jayA+IC5fX2VsID4gLl9fZWwg4oaSIC5iLWJsb2NrID4gLmItYmxvY2tfX2VsID4gLmItYmxvY2tfX2VsX19lbFxuXHQgKiA8L2xpPlxuXHQgKiA8bGk+VHJlYXRzIGZpcnN0IGRhc2ggc3ltYm9sIGFzICdfXyc8L2xpPlxuXHQgKiA8bGk+RG91YmxlIHVuZGVyc2NvcmUgKG9yIHR5cG9ncmFwaGljICfigJMnKSBpcyBhbHNvIHRyZWF0ZWQgYXMgYW4gZWxlbWVudCBcblx0ICogbGV2ZWwgbG9va3VwLCBlLmcuIF9fX19lbCB3aWxsIHNlYXJjaCBmb3IgZWxlbWVudCBkZWZpbml0aW9uIGluIHBhcmVudOKAmXMgXG5cdCAqIHBhcmVudCBlbGVtZW50OlxuXHQgKiAuYi1ibG9jayA+IC5fX2VsMSA+IC5fX19fZWwyIOKGkiAuYi1ibG9jayA+IC5iLWJsb2NrX19lbDEgPiAuYi1ibG9ja19fZWwyXG5cdCAqIDwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIFxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IHRyZWVcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb2ZpbGVcblx0ICovXG5cdGZ1bmN0aW9uIHByb2Nlc3ModHJlZSwgcHJvZmlsZSkge1xuXHRcdGlmICh0cmVlLm5hbWUpIHtcblx0XHRcdGJlbVBhcnNlKHRyZWUsIHByb2ZpbGUpO1xuXHRcdH1cblx0XHRcblx0XHR0cmVlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cHJvY2VzcyhpdGVtLCBwcm9maWxlKTtcblx0XHRcdGlmICghYWJicmV2aWF0aW9uVXRpbHMuaXNTbmlwcGV0KGl0ZW0pICYmIGl0ZW0uc3RhcnQpIHtcblx0XHRcdFx0c2hvdWxkUnVuSHRtbEZpbHRlciA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRyZWU7XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24odHJlZSwgcHJvZmlsZSkge1xuXHRcdHNob3VsZFJ1bkh0bWxGaWx0ZXIgPSBmYWxzZTtcblx0XHR0cmVlID0gcHJvY2Vzcyh0cmVlLCBwcm9maWxlKTtcblx0XHQvLyBpbiBjYXNlICdiZW0nIGZpbHRlciBpcyBhcHBsaWVkIGFmdGVyICdodG1sJyBmaWx0ZXI6IHJ1biBpdCBhZ2FpblxuXHRcdC8vIHRvIHVwZGF0ZSBvdXRwdXRcblx0XHRpZiAoc2hvdWxkUnVuSHRtbEZpbHRlcikge1xuXHRcdFx0dHJlZSA9IGh0bWxGaWx0ZXIodHJlZSwgcHJvZmlsZSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0cmVlO1xuXHR9O1xufSk7XG5cbn0se1wiLi4vYXNzZXRzL3ByZWZlcmVuY2VzXCI6XCJhc3NldHNcXFxccHJlZmVyZW5jZXMuanNcIixcIi4uL3V0aWxzL2FiYnJldmlhdGlvblwiOlwidXRpbHNcXFxcYWJicmV2aWF0aW9uLmpzXCIsXCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi9odG1sXCI6XCJmaWx0ZXJcXFxcaHRtbC5qc1wifV0sXCJmaWx0ZXJcXFxcY29tbWVudC5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQ29tbWVudCBpbXBvcnRhbnQgdGFncyAod2l0aCAnaWQnIGFuZCAnY2xhc3MnIGF0dHJpYnV0ZXMpXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBwcmVmcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9wcmVmZXJlbmNlcycpO1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblx0dmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdXRpbHMvdGVtcGxhdGUnKTtcblx0dmFyIGFiYnJVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2FiYnJldmlhdGlvbicpO1xuXHR2YXIgZmlsdGVyQ29yZSA9IHJlcXVpcmUoJy4vbWFpbicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdmaWx0ZXIuY29tbWVudEFmdGVyJywgXG5cdFx0XHQnXFxuPCEtLSAvPCU9IGF0dHIoXCJpZFwiLCBcIiNcIikgJT48JT0gYXR0cihcImNsYXNzXCIsIFwiLlwiKSAlPiAtLT4nLFxuXHRcdFx0J0EgZGVmaW5pdGlvbiBvZiBjb21tZW50IHRoYXQgc2hvdWxkIGJlIHBsYWNlZCA8aT5hZnRlcjwvaT4gbWF0Y2hlZCAnXG5cdFx0XHQrICdlbGVtZW50IHdoZW4gPGNvZGU+Y29tbWVudDwvY29kZT4gZmlsdGVyIGlzIGFwcGxpZWQuIFRoaXMgZGVmaW5pdGlvbiAnXG5cdFx0XHQrICdpcyBhbiBFUkItc3R5bGUgdGVtcGxhdGUgcGFzc2VkIHRvIDxjb2RlPl8udGVtcGxhdGUoKTwvY29kZT4gJ1xuXHRcdFx0KyAnZnVuY3Rpb24gKHNlZSBVbmRlcnNjb3JlLmpzIGRvY3MgZm9yIGRldGFpbHMpLiBJbiB0ZW1wbGF0ZSBjb250ZXh0LCAnXG5cdFx0XHQrICd0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYW5kIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmU6XFxuJ1xuXHRcdFx0KyAnPHVsPidcblx0XHRcdFxuXHRcdFx0KyAnPGxpPjxjb2RlPmF0dHIobmFtZSwgYmVmb3JlLCBhZnRlcik8L2NvZGU+IOKAkyBhIGZ1bmN0aW9uIHRoYXQgb3V0cHV0cycgXG5cdFx0XHQrICdzcGVjaWZpZWQgYXR0cmlidXRlIHZhbHVlIGNvbmNhdGVuYXRlZCB3aXRoIDxjb2RlPmJlZm9yZTwvY29kZT4gJyBcblx0XHRcdCsgJ2FuZCA8Y29kZT5hZnRlcjwvY29kZT4gc3RyaW5ncy4gSWYgYXR0cmlidXRlIGRvZXNuXFwndCBleGlzdHMsIHRoZSAnIFxuXHRcdFx0KyAnZW1wdHkgc3RyaW5nIHdpbGwgYmUgcmV0dXJuZWQuPC9saT4nXG5cdFx0XHRcblx0XHRcdCsgJzxsaT48Y29kZT5ub2RlPC9jb2RlPiDigJMgY3VycmVudCBub2RlIChpbnN0YW5jZSBvZiA8Y29kZT5BYmJyZXZpYXRpb25Ob2RlPC9jb2RlPik8L2xpPidcblx0XHRcdFxuXHRcdFx0KyAnPGxpPjxjb2RlPm5hbWU8L2NvZGU+IOKAkyBuYW1lIG9mIGN1cnJlbnQgdGFnPC9saT4nXG5cdFx0XHRcblx0XHRcdCsgJzxsaT48Y29kZT5wYWRkaW5nPC9jb2RlPiDigJMgY3VycmVudCBzdHJpbmcgcGFkZGluZywgY2FuIGJlIHVzZWQgJyBcblx0XHRcdCsgJ2ZvciBmb3JtYXR0aW5nPC9saT4nXG5cdFx0XHRcblx0XHRcdCsnPC91bD4nKTtcblx0XG5cdHByZWZzLmRlZmluZSgnZmlsdGVyLmNvbW1lbnRCZWZvcmUnLCBcblx0XHRcdCcnLFxuXHRcdFx0J0EgZGVmaW5pdGlvbiBvZiBjb21tZW50IHRoYXQgc2hvdWxkIGJlIHBsYWNlZCA8aT5iZWZvcmU8L2k+IG1hdGNoZWQgJ1xuXHRcdFx0KyAnZWxlbWVudCB3aGVuIDxjb2RlPmNvbW1lbnQ8L2NvZGU+IGZpbHRlciBpcyBhcHBsaWVkLiAnXG5cdFx0XHQrICdGb3IgbW9yZSBpbmZvLCByZWFkIGRlc2NyaXB0aW9uIG9mIDxjb2RlPmZpbHRlci5jb21tZW50QWZ0ZXI8L2NvZGU+ICdcblx0XHRcdCsgJ3Byb3BlcnR5Jyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2ZpbHRlci5jb21tZW50VHJpZ2dlcicsICdpZCwgY2xhc3MnLFxuXHRcdFx0J0EgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRoYXQgc2hvdWxkIGV4aXN0IGluIGFiYnJldmlhdG9pbiAnXG5cdFx0XHQrICd3aGVyZSBjb21tZW50IHNob3VsZCBiZSBhZGRlZC4gSWYgeW91IHdpc2ggdG8gYWRkIGNvbW1lbnQgZm9yICdcblx0XHRcdCsgJ2V2ZXJ5IGVsZW1lbnQsIHNldCB0aGlzIG9wdGlvbiB0byA8Y29kZT4qPC9jb2RlPicpO1xuXHRcblx0LyoqXG5cdCAqIEFkZCBjb21tZW50cyB0byB0YWdcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRDb21tZW50cyhub2RlLCB0ZW1wbGF0ZUJlZm9yZSwgdGVtcGxhdGVBZnRlcikge1xuXHRcdC8vIGNoZWNrIGlmIGNvbW1lbnRzIHNob3VsZCBiZSBhZGRlZFxuXHRcdHZhciB0cmlnZ2VyID0gcHJlZnMuZ2V0KCdmaWx0ZXIuY29tbWVudFRyaWdnZXInKTtcblx0XHRpZiAodHJpZ2dlciAhPSAnKicpIHtcblx0XHRcdHZhciBzaG91bGRBZGQgPSB1dGlscy5maW5kKHRyaWdnZXIuc3BsaXQoJywnKSwgZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gISFub2RlLmF0dHJpYnV0ZSh1dGlscy50cmltKG5hbWUpKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIXNob3VsZEFkZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBjdHggPSB7XG5cdFx0XHRub2RlOiBub2RlLFxuXHRcdFx0bmFtZTogbm9kZS5uYW1lKCksXG5cdFx0XHRwYWRkaW5nOiBub2RlLnBhcmVudCA/IG5vZGUucGFyZW50LnBhZGRpbmcgOiAnJyxcblx0XHRcdGF0dHI6IGZ1bmN0aW9uKG5hbWUsIGJlZm9yZSwgYWZ0ZXIpIHtcblx0XHRcdFx0dmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZShuYW1lKTtcblx0XHRcdFx0aWYgKGF0dHIpIHtcblx0XHRcdFx0XHRyZXR1cm4gKGJlZm9yZSB8fCAnJykgKyBhdHRyICsgKGFmdGVyIHx8ICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0dmFyIG5vZGVCZWZvcmUgPSB0ZW1wbGF0ZUJlZm9yZSA/IHRlbXBsYXRlQmVmb3JlKGN0eCkgOiAnJztcblx0XHR2YXIgbm9kZUFmdGVyID0gdGVtcGxhdGVBZnRlciA/IHRlbXBsYXRlQWZ0ZXIoY3R4KSA6ICcnO1xuXHRcdFxuXHRcdG5vZGUuc3RhcnQgPSBub2RlLnN0YXJ0LnJlcGxhY2UoLzwvLCBub2RlQmVmb3JlICsgJzwnKTtcblx0XHRub2RlLmVuZCA9IG5vZGUuZW5kLnJlcGxhY2UoLz4vLCAnPicgKyBub2RlQWZ0ZXIpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBwcm9jZXNzKHRyZWUsIGJlZm9yZSwgYWZ0ZXIpIHtcblx0XHR0cmVlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKGFiYnJVdGlscy5pc0Jsb2NrKGl0ZW0pKSB7XG5cdFx0XHRcdGFkZENvbW1lbnRzKGl0ZW0sIGJlZm9yZSwgYWZ0ZXIpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRwcm9jZXNzKGl0ZW0sIGJlZm9yZSwgYWZ0ZXIpO1xuXHRcdH0pO1xuXHRcdFx0XG5cdFx0cmV0dXJuIHRyZWU7XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24odHJlZSkge1xuXHRcdHZhciB0ZW1wbGF0ZUJlZm9yZSA9IHRlbXBsYXRlKHByZWZzLmdldCgnZmlsdGVyLmNvbW1lbnRCZWZvcmUnKSk7XG5cdFx0dmFyIHRlbXBsYXRlQWZ0ZXIgPSB0ZW1wbGF0ZShwcmVmcy5nZXQoJ2ZpbHRlci5jb21tZW50QWZ0ZXInKSk7XG5cdFx0XG5cdFx0cmV0dXJuIHByb2Nlc3ModHJlZSwgdGVtcGxhdGVCZWZvcmUsIHRlbXBsYXRlQWZ0ZXIpO1xuXHR9O1xufSk7XG5cbn0se1wiLi4vYXNzZXRzL3ByZWZlcmVuY2VzXCI6XCJhc3NldHNcXFxccHJlZmVyZW5jZXMuanNcIixcIi4uL3V0aWxzL2FiYnJldmlhdGlvblwiOlwidXRpbHNcXFxcYWJicmV2aWF0aW9uLmpzXCIsXCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi4vdXRpbHMvdGVtcGxhdGVcIjpcInV0aWxzXFxcXHRlbXBsYXRlLmpzXCIsXCIuL21haW5cIjpcImZpbHRlclxcXFxtYWluLmpzXCJ9XSxcImZpbHRlclxcXFxjc3MuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEZpbHRlciBmb3Igb3V0cHV0dGluZyBDU1MgYW5kIGFsaWtlXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdC8qKlxuXHQgKiBUZXN0IGlmIHBhc3NlZCBpdGVtIGlzIHZlcnkgZmlyc3QgY2hpbGQgaW4gcGFyc2VkIHRyZWVcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBpdGVtXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1ZlcnlGaXJzdENoaWxkKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS5wYXJlbnQgJiYgIWl0ZW0ucGFyZW50LnBhcmVudCAmJiAhaXRlbS5pbmRleCgpO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHByb2Nlc3ModHJlZSwgcHJvZmlsZSwgbGV2ZWwpIHtcblx0XHRsZXZlbCA9IGxldmVsIHx8IDA7XG5cdFx0XG5cdFx0dHJlZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmICghaXNWZXJ5Rmlyc3RDaGlsZChpdGVtKSAmJiBwcm9maWxlLnRhZ19ubCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0aXRlbS5zdGFydCA9ICdcXG4nICsgaXRlbS5zdGFydDtcblx0XHRcdH1cblx0XHRcdHByb2Nlc3MoaXRlbSwgcHJvZmlsZSwgbGV2ZWwgKyAxKTtcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gdHJlZTtcblx0fTtcbn0pO1xufSx7fV0sXCJmaWx0ZXJcXFxcZXNjYXBlLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBGaWx0ZXIgZm9yIGVzY2FwaW5nIHVuc2FmZSBYTUwgY2hhcmFjdGVyczogPCwgPiwgJlxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgY2hhck1hcCA9IHtcblx0XHQnPCc6ICcmbHQ7Jyxcblx0XHQnPic6ICcmZ3Q7Jyxcblx0XHQnJic6ICcmYW1wOydcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGVzY2FwZUNoYXJzKHN0cikge1xuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvKFs8PiZdKS9nLCBmdW5jdGlvbihzdHIsIHAxKXtcblx0XHRcdHJldHVybiBjaGFyTWFwW3AxXTtcblx0XHR9KTtcblx0fVxuXHRcblx0cmV0dXJuIGZ1bmN0aW9uIHByb2Nlc3ModHJlZSkge1xuXHRcdHRyZWUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpdGVtLnN0YXJ0ID0gZXNjYXBlQ2hhcnMoaXRlbS5zdGFydCk7XG5cdFx0XHRpdGVtLmVuZCA9IGVzY2FwZUNoYXJzKGl0ZW0uZW5kKTtcblx0XHRcdGl0ZW0uY29udGVudCA9IGVzY2FwZUNoYXJzKGl0ZW0uY29udGVudCk7XG5cdFx0XHRwcm9jZXNzKGl0ZW0pO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiB0cmVlO1xuXHR9O1xufSk7XG59LHt9XSxcImZpbHRlclxcXFxmb3JtYXQuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEdlbmVyaWMgZm9ybWF0dGluZyBmaWx0ZXI6IGNyZWF0ZXMgcHJvcGVyIGluZGVudGF0aW9uIGZvciBlYWNoIHRyZWUgbm9kZSxcbiAqIHBsYWNpbmcgXCIlc1wiIHBsYWNlaG9sZGVyIHdoZXJlIHRoZSBhY3R1YWwgb3V0cHV0IHNob3VsZCBiZS4gWW91IGNhbiB1c2VcbiAqIHRoaXMgZmlsdGVyIHRvIHByZWZvcm1hdCB0cmVlIGFuZCB0aGVuIHJlcGxhY2UgJXMgcGxhY2Vob2xkZXIgdG8gd2hhdGV2ZXIgeW91XG4gKiBuZWVkLiBUaGlzIGZpbHRlciBzaG91bGQndCBiZSBjYWxsZWQgZGlyZWN0bHkgZnJvbSBlZGl0b3IgYXMgYSBwYXJ0IFxuICogb2YgYWJicmV2aWF0aW9uLlxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblx0dmFyIGFiYnJVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2FiYnJldmlhdGlvbicpO1xuXHR2YXIgcHJlZnMgPSByZXF1aXJlKCcuLi9hc3NldHMvcHJlZmVyZW5jZXMnKTtcblx0dmFyIHJlc291cmNlcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9yZXNvdXJjZXMnKTtcblxuXHRwcmVmcy5kZWZpbmUoJ2Zvcm1hdC5ub0luZGVudFRhZ3MnLCAnaHRtbCcsIFxuXHRcdFx0J0EgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdGFnIG5hbWVzIHRoYXQgc2hvdWxkIG5vdCBnZXQgaW5uZXIgaW5kZW50YXRpb24uJyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2Zvcm1hdC5mb3JjZUluZGVudGF0aW9uRm9yVGFncycsICdib2R5JywgXG5cdFx0J0EgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdGFnIG5hbWVzIHRoYXQgc2hvdWxkIDxlbT5hbHdheXM8L2VtPiBnZXQgaW5uZXIgaW5kZW50YXRpb24uJyk7XG5cblx0dmFyIHBsYWNlaG9sZGVyID0gJyVzJztcblx0XG5cdC8qKlxuXHQgKiBHZXQgaW5kZW50YXRpb24gZm9yIGdpdmVuIG5vZGVcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRJbmRlbnRhdGlvbihub2RlKSB7XG5cdFx0dmFyIGl0ZW1zID0gcHJlZnMuZ2V0QXJyYXkoJ2Zvcm1hdC5ub0luZGVudFRhZ3MnKSB8fCBbXTtcblx0XHRpZiAofml0ZW1zLmluZGV4T2Yobm9kZS5uYW1lKCkpKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiAnXFx0Jztcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRlc3QgaWYgcGFzc2VkIG5vZGUgaGFzIGJsb2NrLWxldmVsIHNpYmxpbmcgZWxlbWVudFxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IGl0ZW1cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGhhc0Jsb2NrU2libGluZyhpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0ucGFyZW50ICYmIGFiYnJVdGlscy5oYXNCbG9ja0NoaWxkcmVuKGl0ZW0ucGFyZW50KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRlc3QgaWYgcGFzc2VkIGl0ZW0gaXMgdmVyeSBmaXJzdCBjaGlsZCBpbiBwYXJzZWQgdHJlZVxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IGl0ZW1cblx0ICovXG5cdGZ1bmN0aW9uIGlzVmVyeUZpcnN0Q2hpbGQoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnBhcmVudCAmJiAhaXRlbS5wYXJlbnQucGFyZW50ICYmICFpdGVtLmluZGV4KCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhIG5ld2xpbmUgc2hvdWxkIGJlIGFkZGVkIGJlZm9yZSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHQgKiBAcGFyYW0ge091dHB1dFByb2ZpbGV9IHByb2ZpbGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIHNob3VsZEFkZExpbmVCcmVhayhub2RlLCBwcm9maWxlKSB7XG5cdFx0aWYgKHByb2ZpbGUudGFnX25sID09PSB0cnVlIHx8IGFiYnJVdGlscy5pc0Jsb2NrKG5vZGUpKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XG5cdFx0aWYgKCFub2RlLnBhcmVudCB8fCAhcHJvZmlsZS5pbmxpbmVfYnJlYWspXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XG5cdFx0Ly8gY2hlY2sgaWYgdGhlcmUgYXJlIHJlcXVpcmVkIGFtb3VudCBvZiBhZGphY2VudCBpbmxpbmUgZWxlbWVudFxuXHRcdHJldHVybiBzaG91bGRGb3JtYXRJbmxpbmUobm9kZS5wYXJlbnQsIHByb2ZpbGUpO1xufVxuXHRcblx0LyoqXG5cdCAqIE5lZWQgdG8gYWRkIG5ld2xpbmUgYmVjYXVzZSA8Y29kZT5pdGVtPC9jb2RlPiBoYXMgdG9vIG1hbnkgaW5saW5lIGNoaWxkcmVuXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHQgKiBAcGFyYW0ge091dHB1dFByb2ZpbGV9IHByb2ZpbGVcblx0ICovXG5cdGZ1bmN0aW9uIHNob3VsZEJyZWFrQ2hpbGQobm9kZSwgcHJvZmlsZSkge1xuXHRcdC8vIHdlIG5lZWQgdG8gdGVzdCBvbmx5IG9uZSBjaGlsZCBlbGVtZW50LCBiZWNhdXNlIFxuXHRcdC8vIGhhc0Jsb2NrQ2hpbGRyZW4oKSBtZXRob2Qgd2lsbCBkbyB0aGUgcmVzdFxuXHRcdHJldHVybiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiBzaG91bGRBZGRMaW5lQnJlYWsobm9kZS5jaGlsZHJlblswXSwgcHJvZmlsZSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHNob3VsZEZvcm1hdElubGluZShub2RlLCBwcm9maWxlKSB7XG5cdFx0dmFyIG5vZGVDb3VudCA9IDA7XG5cdFx0cmV0dXJuICEhdXRpbHMuZmluZChub2RlLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0aWYgKGNoaWxkLmlzVGV4dE5vZGUoKSB8fCAhYWJiclV0aWxzLmlzSW5saW5lKGNoaWxkKSlcblx0XHRcdFx0bm9kZUNvdW50ID0gMDtcblx0XHRcdGVsc2UgaWYgKGFiYnJVdGlscy5pc0lubGluZShjaGlsZCkpXG5cdFx0XHRcdG5vZGVDb3VudCsrO1xuXHRcdFx0XG5cdFx0XHRpZiAobm9kZUNvdW50ID49IHByb2ZpbGUuaW5saW5lX2JyZWFrKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9KTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gaXNSb290KGl0ZW0pIHtcblx0XHRyZXR1cm4gIWl0ZW0ucGFyZW50O1xuXHR9XG5cdFxuXHQvKipcblx0ICogUHJvY2Vzc2VzIGVsZW1lbnQgd2l0aCBtYXRjaGVkIHJlc291cmNlIG9mIHR5cGUgPGNvZGU+c25pcHBldDwvY29kZT5cblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBpdGVtXG5cdCAqIEBwYXJhbSB7T3V0cHV0UHJvZmlsZX0gcHJvZmlsZVxuXHQgKi9cblx0ZnVuY3Rpb24gcHJvY2Vzc1NuaXBwZXQoaXRlbSwgcHJvZmlsZSkge1xuXHRcdGl0ZW0uc3RhcnQgPSBpdGVtLmVuZCA9ICcnO1xuXHRcdGlmICghaXNWZXJ5Rmlyc3RDaGlsZChpdGVtKSAmJiBwcm9maWxlLnRhZ19ubCAhPT0gZmFsc2UgJiYgc2hvdWxkQWRkTGluZUJyZWFrKGl0ZW0sIHByb2ZpbGUpKSB7XG5cdFx0XHQvLyBjaGVjayBpZiB3ZeKAmXJlIG5vdCBpbnNpZGUgaW5saW5lIGVsZW1lbnRcblx0XHRcdGlmIChpc1Jvb3QoaXRlbS5wYXJlbnQpIHx8ICFhYmJyVXRpbHMuaXNJbmxpbmUoaXRlbS5wYXJlbnQpKSB7XG5cdFx0XHRcdGl0ZW0uc3RhcnQgPSAnXFxuJyArIGl0ZW0uc3RhcnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgd2Ugc2hvdWxkIGFkZCBsaW5lIGJyZWFrcyBpbnNpZGUgaW5saW5lIGVsZW1lbnRcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdCAqIEBwYXJhbSB7T3V0cHV0UHJvZmlsZX0gcHJvZmlsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gc2hvdWxkQnJlYWtJbnNpZGVJbmxpbmUobm9kZSwgcHJvZmlsZSkge1xuXHRcdHZhciBoYXNCbG9ja0VsZW1zID0gbm9kZS5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0XHRpZiAoYWJiclV0aWxzLmlzU25pcHBldChjaGlsZCkpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuICFhYmJyVXRpbHMuaXNJbmxpbmUoY2hpbGQpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdGlmICghaGFzQmxvY2tFbGVtcykge1xuXHRcdFx0cmV0dXJuIHNob3VsZEZvcm1hdElubGluZShub2RlLCBwcm9maWxlKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBQcm9jZXNzZXMgZWxlbWVudCB3aXRoIDxjb2RlPnRhZzwvY29kZT4gdHlwZVxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IGl0ZW1cblx0ICogQHBhcmFtIHtPdXRwdXRQcm9maWxlfSBwcm9maWxlXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9jZXNzVGFnKGl0ZW0sIHByb2ZpbGUpIHtcblx0XHRpdGVtLnN0YXJ0ID0gaXRlbS5lbmQgPSBwbGFjZWhvbGRlcjtcblx0XHR2YXIgaXNVbmFyeSA9IGFiYnJVdGlscy5pc1VuYXJ5KGl0ZW0pO1xuXHRcdHZhciBubCA9ICdcXG4nO1xuXHRcdHZhciBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihpdGVtKTtcblx0XHRcdFxuXHRcdC8vIGZvcm1hdHRpbmcgb3V0cHV0XG5cdFx0aWYgKHByb2ZpbGUudGFnX25sICE9PSBmYWxzZSkge1xuXHRcdFx0dmFyIGZvcmNlTmwgPSBwcm9maWxlLnRhZ19ubCA9PT0gdHJ1ZSAmJiAocHJvZmlsZS50YWdfbmxfbGVhZiB8fCBpdGVtLmNoaWxkcmVuLmxlbmd0aCk7XG5cdFx0XHRpZiAoIWZvcmNlTmwpIHtcblx0XHRcdFx0dmFyIGZvcmNlSW5kZW50VGFncyA9IHByZWZzLmdldEFycmF5KCdmb3JtYXQuZm9yY2VJbmRlbnRhdGlvbkZvclRhZ3MnKSB8fCBbXTtcblx0XHRcdFx0Zm9yY2VObCA9IH5mb3JjZUluZGVudFRhZ3MuaW5kZXhPZihpdGVtLm5hbWUoKSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGZvcm1hdHRpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHNcblx0XHRcdGlmICghaXRlbS5pc1RleHROb2RlKCkpIHtcblx0XHRcdFx0aWYgKHNob3VsZEFkZExpbmVCcmVhayhpdGVtLCBwcm9maWxlKSkge1xuXHRcdFx0XHRcdC8vIC0gZG8gbm90IGluZGVudCB0aGUgdmVyeSBmaXJzdCBlbGVtZW50XG5cdFx0XHRcdFx0Ly8gLSBkbyBub3QgaW5kZW50IGZpcnN0IGNoaWxkIG9mIGEgc25pcHBldFxuXHRcdFx0XHRcdGlmICghaXNWZXJ5Rmlyc3RDaGlsZChpdGVtKSAmJiAoIWFiYnJVdGlscy5pc1NuaXBwZXQoaXRlbS5wYXJlbnQpIHx8IGl0ZW0uaW5kZXgoKSkpXG5cdFx0XHRcdFx0XHRpdGVtLnN0YXJ0ID0gbmwgKyBpdGVtLnN0YXJ0O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGFiYnJVdGlscy5oYXNCbG9ja0NoaWxkcmVuKGl0ZW0pIHx8IHNob3VsZEJyZWFrQ2hpbGQoaXRlbSwgcHJvZmlsZSkgfHwgKGZvcmNlTmwgJiYgIWlzVW5hcnkpKVxuXHRcdFx0XHRcdFx0aXRlbS5lbmQgPSBubCArIGl0ZW0uZW5kO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGFiYnJVdGlscy5oYXNUYWdzSW5Db250ZW50KGl0ZW0pIHx8IChmb3JjZU5sICYmICFpdGVtLmNoaWxkcmVuLmxlbmd0aCAmJiAhaXNVbmFyeSkpXG5cdFx0XHRcdFx0XHRpdGVtLnN0YXJ0ICs9IG5sICsgaW5kZW50O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFiYnJVdGlscy5pc0lubGluZShpdGVtKSAmJiBoYXNCbG9ja1NpYmxpbmcoaXRlbSkgJiYgIWlzVmVyeUZpcnN0Q2hpbGQoaXRlbSkpIHtcblx0XHRcdFx0XHRpdGVtLnN0YXJ0ID0gbmwgKyBpdGVtLnN0YXJ0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFiYnJVdGlscy5pc0lubGluZShpdGVtKSAmJiBzaG91bGRCcmVha0luc2lkZUlubGluZShpdGVtLCBwcm9maWxlKSkge1xuXHRcdFx0XHRcdGl0ZW0uZW5kID0gbmwgKyBpdGVtLmVuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aXRlbS5wYWRkaW5nID0gaW5kZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9jZXNzZXMgc2ltcGxpZmllZCB0cmVlLCBtYWtpbmcgaXQgc3VpdGFibGUgZm9yIG91dHB1dCBhcyBIVE1MIHN0cnVjdHVyZVxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IHRyZWVcblx0ICogQHBhcmFtIHtPdXRwdXRQcm9maWxlfSBwcm9maWxlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBEZXB0aCBsZXZlbFxuXHQgKi9cblx0cmV0dXJuIGZ1bmN0aW9uIHByb2Nlc3ModHJlZSwgcHJvZmlsZSwgbGV2ZWwpIHtcblx0XHRsZXZlbCA9IGxldmVsIHx8IDA7XG5cdFxuXHRcdHRyZWUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoYWJiclV0aWxzLmlzU25pcHBldChpdGVtKSkge1xuXHRcdFx0XHRwcm9jZXNzU25pcHBldChpdGVtLCBwcm9maWxlLCBsZXZlbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcm9jZXNzVGFnKGl0ZW0sIHByb2ZpbGUsIGxldmVsKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cHJvY2VzcyhpdGVtLCBwcm9maWxlLCBsZXZlbCArIDEpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiB0cmVlO1xuXHR9O1xufSk7XG59LHtcIi4uL2Fzc2V0cy9wcmVmZXJlbmNlc1wiOlwiYXNzZXRzXFxcXHByZWZlcmVuY2VzLmpzXCIsXCIuLi9hc3NldHMvcmVzb3VyY2VzXCI6XCJhc3NldHNcXFxccmVzb3VyY2VzLmpzXCIsXCIuLi91dGlscy9hYmJyZXZpYXRpb25cIjpcInV0aWxzXFxcXGFiYnJldmlhdGlvbi5qc1wiLFwiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIn1dLFwiZmlsdGVyXFxcXGhhbWwuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEZpbHRlciBmb3IgcHJvZHVjaW5nIEhBTUwgY29kZSBmcm9tIGFiYnJldmlhdGlvbi5cbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciBhYmJyVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9hYmJyZXZpYXRpb24nKTtcblx0dmFyIGZvcm1hdEZpbHRlciA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtQ2xhc3NOYW1lKGNsYXNzTmFtZSkge1xuXHRcdHJldHVybiB1dGlscy50cmltKGNsYXNzTmFtZSkucmVwbGFjZSgvXFxzKy9nLCAnLicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbmRlbnNlcyBhbGwgXCJkYXRhLVwiIGF0dHJpYnV0ZXMgaW50byBhIHNpbmdsZSBlbnRyeS5cblx0ICogSEFNTCBhbGxvd3MgZGF0YSBhdHRyaWJ1dGVzIHRvIGJlIG91cHV0dGVkIGFzIGEgc3ViLWhhc2hcblx0ICogb2YgYDpkYXRhYCBrZXlcblx0ICogQHBhcmFtICB7QXJyYXl9IGF0dHJzXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gY29uZGVuc2VEYXRhQXR0cnMoYXR0cnMpIHtcblx0XHR2YXIgb3V0ID0gW10sIGRhdGEgPSBudWxsO1xuXHRcdHZhciByZURhdGEgPSAvXmRhdGEtL2k7XG5cdFx0YXR0cnMuZm9yRWFjaChmdW5jdGlvbihhdHRyKSB7XG5cdFx0XHRpZiAocmVEYXRhLnRlc3QoYXR0ci5uYW1lKSkge1xuXHRcdFx0XHRpZiAoIWRhdGEpIHtcblx0XHRcdFx0XHRkYXRhID0gW107XG5cdFx0XHRcdFx0b3V0LnB1c2goe1xuXHRcdFx0XHRcdFx0bmFtZTogJ2RhdGEnLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGRhdGFcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRhdGEucHVzaCh1dGlscy5leHRlbmQoe30sIGF0dHIsIHtuYW1lOiBhdHRyLm5hbWUucmVwbGFjZShyZURhdGEsICcnKX0pKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dC5wdXNoKGF0dHIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdGZ1bmN0aW9uIHN0cmluZ2lmeUF0dHJzKGF0dHJzLCBwcm9maWxlKSB7XG5cdFx0dmFyIGF0dHJRdW90ZSA9IHByb2ZpbGUuYXR0cmlidXRlUXVvdGUoKTtcblx0XHRyZXR1cm4gJ3snICsgYXR0cnMubWFwKGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGF0dHJRdW90ZSArIGF0dHIudmFsdWUgKyBhdHRyUXVvdGU7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhdHRyLnZhbHVlKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHN0cmluZ2lmeUF0dHJzKGF0dHIudmFsdWUsIHByb2ZpbGUpO1xuXHRcdFx0fSBlbHNlIGlmIChhdHRyLmlzQm9vbGVhbikge1xuXHRcdFx0XHR2YWx1ZSA9ICd0cnVlJztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICc6JyArIGF0dHIubmFtZSArICcgPT4gJyArIHZhbHVlXG5cdFx0fSkuam9pbignLCAnKSArICd9Jztcblx0fVxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZXMgSEFNTCBhdHRyaWJ1dGVzIHN0cmluZyBmcm9tIHRhZyBhY2NvcmRpbmcgdG8gcHJvZmlsZSBzZXR0aW5nc1xuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IHRhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvZmlsZVxuXHQgKi9cblx0ZnVuY3Rpb24gbWFrZUF0dHJpYnV0ZXNTdHJpbmcodGFnLCBwcm9maWxlKSB7XG5cdFx0dmFyIGF0dHJzID0gJyc7XG5cdFx0dmFyIG90aGVyQXR0cnMgPSBbXTtcblx0XHR2YXIgYXR0clF1b3RlID0gcHJvZmlsZS5hdHRyaWJ1dGVRdW90ZSgpO1xuXHRcdHZhciBjdXJzb3IgPSBwcm9maWxlLmN1cnNvcigpO1xuXHRcdFxuXHRcdHRhZy5hdHRyaWJ1dGVMaXN0KCkuZm9yRWFjaChmdW5jdGlvbihhKSB7XG5cdFx0XHR2YXIgYXR0ck5hbWUgPSBwcm9maWxlLmF0dHJpYnV0ZU5hbWUoYS5uYW1lKTtcblx0XHRcdHN3aXRjaCAoYXR0ck5hbWUudG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0XHQvLyB1c2Ugc2hvcnQgbm90YXRpb24gZm9yIElEIGFuZCBDTEFTUyBhdHRyaWJ1dGVzXG5cdFx0XHRcdGNhc2UgJ2lkJzpcblx0XHRcdFx0XHRhdHRycyArPSAnIycgKyAoYS52YWx1ZSB8fCBjdXJzb3IpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdjbGFzcyc6XG5cdFx0XHRcdFx0YXR0cnMgKz0gJy4nICsgdHJhbnNmb3JtQ2xhc3NOYW1lKGEudmFsdWUgfHwgY3Vyc29yKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Ly8gcHJvY2VzcyBvdGhlciBhdHRyaWJ1dGVzXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0b3RoZXJBdHRycy5wdXNoKHtcblx0XHRcdFx0XHRcdG5hbWU6IGF0dHJOYW1lLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGEudmFsdWUgfHwgY3Vyc29yLFxuXHRcdFx0XHRcdFx0aXNCb29sZWFuOiBwcm9maWxlLmlzQm9vbGVhbihhLm5hbWUsIGEudmFsdWUpXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0XG5cdFx0aWYgKG90aGVyQXR0cnMubGVuZ3RoKSB7XG5cdFx0XHRhdHRycyArPSBzdHJpbmdpZnlBdHRycyhjb25kZW5zZURhdGFBdHRycyhvdGhlckF0dHJzKSwgcHJvZmlsZSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBhdHRycztcblx0fVxuXHRcblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBlbGVtZW50IHdpdGggPGNvZGU+dGFnPC9jb2RlPiB0eXBlXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gaXRlbVxuXHQgKiBAcGFyYW0ge091dHB1dFByb2ZpbGV9IHByb2ZpbGVcblx0ICovXG5cdGZ1bmN0aW9uIHByb2Nlc3NUYWcoaXRlbSwgcHJvZmlsZSkge1xuXHRcdGlmICghaXRlbS5wYXJlbnQpXG5cdFx0XHQvLyBsb29rcyBsaWtlIGl0J3Mgcm9vdCBlbGVtZW50XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcblx0XHR2YXIgYXR0cnMgPSBtYWtlQXR0cmlidXRlc1N0cmluZyhpdGVtLCBwcm9maWxlKTtcblx0XHR2YXIgY3Vyc29yID0gcHJvZmlsZS5jdXJzb3IoKTtcblx0XHR2YXIgaXNVbmFyeSA9IGFiYnJVdGlscy5pc1VuYXJ5KGl0ZW0pO1xuXHRcdHZhciBzZWxmQ2xvc2luZyA9IHByb2ZpbGUuc2VsZl9jbG9zaW5nX3RhZyAmJiBpc1VuYXJ5ID8gJy8nIDogJyc7XG5cdFx0dmFyIHN0YXJ0PSAnJztcblx0XHRcdFxuXHRcdC8vIGRlZmluZSB0YWcgbmFtZVxuXHRcdHZhciB0YWdOYW1lID0gJyUnICsgcHJvZmlsZS50YWdOYW1lKGl0ZW0ubmFtZSgpKTtcblx0XHRpZiAodGFnTmFtZS50b0xvd2VyQ2FzZSgpID09ICclZGl2JyAmJiBhdHRycyAmJiBhdHRycy5pbmRleE9mKCd7JykgPT0gLTEpXG5cdFx0XHQvLyBvbWl0IGRpdiB0YWdcblx0XHRcdHRhZ05hbWUgPSAnJztcblx0XHRcdFxuXHRcdGl0ZW0uZW5kID0gJyc7XG5cdFx0c3RhcnQgPSB0YWdOYW1lICsgYXR0cnMgKyBzZWxmQ2xvc2luZztcblx0XHRpZiAoaXRlbS5jb250ZW50ICYmICEvXlxccy8udGVzdChpdGVtLmNvbnRlbnQpKSB7XG5cdFx0XHRpdGVtLmNvbnRlbnQgPSAnICcgKyBpdGVtLmNvbnRlbnQ7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBwbGFjZWhvbGRlciA9ICclcyc7XG5cdFx0Ly8gV2UgY2FuJ3QganVzdCByZXBsYWNlIHBsYWNlaG9sZGVyIHdpdGggbmV3IHZhbHVlIGJlY2F1c2Vcblx0XHQvLyBKYXZhU2NyaXB0IHdpbGwgdHJlYXQgZG91YmxlICQgY2hhcmFjdGVyIGFzIGEgc2luZ2xlIG9uZSwgYXNzdW1pbmdcblx0XHQvLyB3ZSdyZSB1c2luZyBSZWdFeHAgbGl0ZXJhbC5cblx0XHRpdGVtLnN0YXJ0ID0gdXRpbHMucmVwbGFjZVN1YnN0cmluZyhpdGVtLnN0YXJ0LCBzdGFydCwgaXRlbS5zdGFydC5pbmRleE9mKHBsYWNlaG9sZGVyKSwgcGxhY2Vob2xkZXIpO1xuXHRcdFxuXHRcdGlmICghaXRlbS5jaGlsZHJlbi5sZW5ndGggJiYgIWlzVW5hcnkpXG5cdFx0XHRpdGVtLnN0YXJ0ICs9IGN1cnNvcjtcblx0XHRcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiBwcm9jZXNzKHRyZWUsIHByb2ZpbGUsIGxldmVsKSB7XG5cdFx0bGV2ZWwgPSBsZXZlbCB8fCAwO1xuXHRcdFxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdHRyZWUgPSBmb3JtYXRGaWx0ZXIodHJlZSwgJ19mb3JtYXQnLCBwcm9maWxlKTtcblx0XHR9XG5cdFx0XG5cdFx0dHJlZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmICghYWJiclV0aWxzLmlzU25pcHBldChpdGVtKSkge1xuXHRcdFx0XHRwcm9jZXNzVGFnKGl0ZW0sIHByb2ZpbGUsIGxldmVsKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cHJvY2VzcyhpdGVtLCBwcm9maWxlLCBsZXZlbCArIDEpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiB0cmVlO1xuXHR9O1xufSk7XG59LHtcIi4uL3V0aWxzL2FiYnJldmlhdGlvblwiOlwidXRpbHNcXFxcYWJicmV2aWF0aW9uLmpzXCIsXCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi9mb3JtYXRcIjpcImZpbHRlclxcXFxmb3JtYXQuanNcIn1dLFwiZmlsdGVyXFxcXGh0bWwuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEZpbHRlciB0aGF0IHByb2R1Y2VzIEhUTUwgdHJlZVxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgYWJiclV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvYWJicmV2aWF0aW9uJyk7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgdGFiU3RvcHMgPSByZXF1aXJlKCcuLi9hc3NldHMvdGFiU3RvcHMnKTtcblx0dmFyIGZvcm1hdEZpbHRlciA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgSFRNTCBhdHRyaWJ1dGVzIHN0cmluZyBmcm9tIHRhZyBhY2NvcmRpbmcgdG8gcHJvZmlsZSBzZXR0aW5nc1xuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0ICogQHBhcmFtIHtPdXRwdXRQcm9maWxlfSBwcm9maWxlXG5cdCAqL1xuXHRmdW5jdGlvbiBtYWtlQXR0cmlidXRlc1N0cmluZyhub2RlLCBwcm9maWxlKSB7XG5cdFx0dmFyIGF0dHJRdW90ZSA9IHByb2ZpbGUuYXR0cmlidXRlUXVvdGUoKTtcblx0XHR2YXIgY3Vyc29yID0gcHJvZmlsZS5jdXJzb3IoKTtcblx0XHRcblx0XHRyZXR1cm4gbm9kZS5hdHRyaWJ1dGVMaXN0KCkubWFwKGZ1bmN0aW9uKGEpIHtcblx0XHRcdHZhciBpc0Jvb2xlYW4gPSBwcm9maWxlLmlzQm9vbGVhbihhLm5hbWUsIGEudmFsdWUpO1xuXHRcdFx0dmFyIGF0dHJOYW1lID0gcHJvZmlsZS5hdHRyaWJ1dGVOYW1lKGEubmFtZSk7XG5cdFx0XHR2YXIgYXR0clZhbHVlID0gaXNCb29sZWFuID8gYXR0ck5hbWUgOiBhLnZhbHVlO1xuXHRcdFx0aWYgKGlzQm9vbGVhbiAmJiBwcm9maWxlLmFsbG93Q29tcGFjdEJvb2xlYW4oKSkge1xuXHRcdFx0XHRyZXR1cm4gJyAnICsgYXR0ck5hbWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJyAnICsgYXR0ck5hbWUgKyAnPScgKyBhdHRyUXVvdGUgKyAoYXR0clZhbHVlIHx8IGN1cnNvcikgKyBhdHRyUXVvdGU7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBQcm9jZXNzZXMgZWxlbWVudCB3aXRoIDxjb2RlPnRhZzwvY29kZT4gdHlwZVxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IGl0ZW1cblx0ICogQHBhcmFtIHtPdXRwdXRQcm9maWxlfSBwcm9maWxlXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9jZXNzVGFnKGl0ZW0sIHByb2ZpbGUpIHtcblx0XHRpZiAoIWl0ZW0ucGFyZW50KSB7IC8vIGxvb2tzIGxpa2UgaXQncyByb290IGVsZW1lbnRcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH1cblx0XHRcblx0XHR2YXIgYXR0cnMgPSBtYWtlQXR0cmlidXRlc1N0cmluZyhpdGVtLCBwcm9maWxlKTsgXG5cdFx0dmFyIGN1cnNvciA9IHByb2ZpbGUuY3Vyc29yKCk7XG5cdFx0dmFyIGlzVW5hcnkgPSBhYmJyVXRpbHMuaXNVbmFyeShpdGVtKTtcblx0XHR2YXIgc3RhcnQgPSAnJztcblx0XHR2YXIgZW5kID0gJyc7XG5cdFx0XHRcblx0XHQvLyBkZWZpbmUgb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzXG5cdFx0aWYgKCFpdGVtLmlzVGV4dE5vZGUoKSkge1xuXHRcdFx0dmFyIHRhZ05hbWUgPSBwcm9maWxlLnRhZ05hbWUoaXRlbS5uYW1lKCkpO1xuXHRcdFx0aWYgKGlzVW5hcnkpIHtcblx0XHRcdFx0c3RhcnQgPSAnPCcgKyB0YWdOYW1lICsgYXR0cnMgKyBwcm9maWxlLnNlbGZDbG9zaW5nKCkgKyAnPic7XG5cdFx0XHRcdGl0ZW0uZW5kID0gJyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdGFydCA9ICc8JyArIHRhZ05hbWUgKyBhdHRycyArICc+Jztcblx0XHRcdFx0ZW5kID0gJzwvJyArIHRhZ05hbWUgKyAnPic7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBwbGFjZWhvbGRlciA9ICclcyc7XG5cdFx0Ly8gV2UgY2FuJ3QganVzdCByZXBsYWNlIHBsYWNlaG9sZGVyIHdpdGggbmV3IHZhbHVlIGJlY2F1c2Vcblx0XHQvLyBKYXZhU2NyaXB0IHdpbGwgdHJlYXQgZG91YmxlICQgY2hhcmFjdGVyIGFzIGEgc2luZ2xlIG9uZSwgYXNzdW1pbmdcblx0XHQvLyB3ZSdyZSB1c2luZyBSZWdFeHAgbGl0ZXJhbC5cblx0XHRpdGVtLnN0YXJ0ID0gdXRpbHMucmVwbGFjZVN1YnN0cmluZyhpdGVtLnN0YXJ0LCBzdGFydCwgaXRlbS5zdGFydC5pbmRleE9mKHBsYWNlaG9sZGVyKSwgcGxhY2Vob2xkZXIpO1xuXHRcdGl0ZW0uZW5kID0gdXRpbHMucmVwbGFjZVN1YnN0cmluZyhpdGVtLmVuZCwgZW5kLCBpdGVtLmVuZC5pbmRleE9mKHBsYWNlaG9sZGVyKSwgcGxhY2Vob2xkZXIpO1xuXHRcdFxuXHRcdC8vIHNob3VsZCB3ZSBwdXQgY2FyZXQgcGxhY2Vob2xkZXIgYWZ0ZXIgb3BlbmluZyB0YWc/XG5cdFx0aWYgKFxuXHRcdFx0XHQhaXRlbS5jaGlsZHJlbi5sZW5ndGggXG5cdFx0XHRcdCYmICFpc1VuYXJ5IFxuXHRcdFx0XHQmJiAhfml0ZW0uY29udGVudC5pbmRleE9mKGN1cnNvcilcblx0XHRcdFx0JiYgIXRhYlN0b3BzLmV4dHJhY3QoaXRlbS5jb250ZW50KS50YWJzdG9wcy5sZW5ndGhcblx0XHRcdCkge1xuXHRcdFx0aXRlbS5zdGFydCArPSBjdXJzb3I7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHByb2Nlc3ModHJlZSwgcHJvZmlsZSwgbGV2ZWwpIHtcblx0XHRsZXZlbCA9IGxldmVsIHx8IDA7XG5cdFx0XG5cdFx0aWYgKCFsZXZlbCkge1xuXHRcdFx0dHJlZSA9IGZvcm1hdEZpbHRlcih0cmVlLCBwcm9maWxlLCBsZXZlbClcblx0XHR9XG5cdFx0XG5cdFx0dHJlZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmICghYWJiclV0aWxzLmlzU25pcHBldChpdGVtKSkge1xuXHRcdFx0XHRwcm9jZXNzVGFnKGl0ZW0sIHByb2ZpbGUsIGxldmVsKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cHJvY2VzcyhpdGVtLCBwcm9maWxlLCBsZXZlbCArIDEpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiB0cmVlO1xuXHR9O1xufSk7XG59LHtcIi4uL2Fzc2V0cy90YWJTdG9wc1wiOlwiYXNzZXRzXFxcXHRhYlN0b3BzLmpzXCIsXCIuLi91dGlscy9hYmJyZXZpYXRpb25cIjpcInV0aWxzXFxcXGFiYnJldmlhdGlvbi5qc1wiLFwiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4vZm9ybWF0XCI6XCJmaWx0ZXJcXFxcZm9ybWF0LmpzXCJ9XSxcImZpbHRlclxcXFxqYWRlLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBGaWx0ZXIgZm9yIHByb2R1Y2luZyBKYWRlIGNvZGUgZnJvbSBhYmJyZXZpYXRpb24uXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgYWJiclV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvYWJicmV2aWF0aW9uJyk7XG5cdHZhciBmb3JtYXRGaWx0ZXIgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuXHR2YXIgdGFiU3RvcHMgPSByZXF1aXJlKCcuLi9hc3NldHMvdGFiU3RvcHMnKTtcblx0dmFyIHByb2ZpbGUgPSByZXF1aXJlKCcuLi9hc3NldHMvcHJvZmlsZScpO1xuXG5cdHZhciByZU5sID0gL1tcXG5cXHJdLztcblx0dmFyIHJlSW5kZW50ZWRUZXh0ID0gL15cXHMqXFx8Lztcblx0dmFyIHJlU3BhY2UgPSAvXlxccy87XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtQ2xhc3NOYW1lKGNsYXNzTmFtZSkge1xuXHRcdHJldHVybiB1dGlscy50cmltKGNsYXNzTmFtZSkucmVwbGFjZSgvXFxzKy9nLCAnLicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc3RyaW5naWZ5QXR0cnMoYXR0cnMsIHByb2ZpbGUpIHtcblx0XHR2YXIgYXR0clF1b3RlID0gcHJvZmlsZS5hdHRyaWJ1dGVRdW90ZSgpO1xuXHRcdHJldHVybiAnKCcgKyBhdHRycy5tYXAoZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0aWYgKGF0dHIuaXNCb29sZWFuKSB7XG5cdFx0XHRcdHJldHVybiBhdHRyLm5hbWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhdHRyLm5hbWUgKyAnPScgKyBhdHRyUXVvdGUgKyBhdHRyLnZhbHVlICsgYXR0clF1b3RlO1xuXHRcdH0pLmpvaW4oJywgJykgKyAnKSc7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDcmVhdGVzIEhBTUwgYXR0cmlidXRlcyBzdHJpbmcgZnJvbSB0YWcgYWNjb3JkaW5nIHRvIHByb2ZpbGUgc2V0dGluZ3Ncblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSB0YWdcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb2ZpbGVcblx0ICovXG5cdGZ1bmN0aW9uIG1ha2VBdHRyaWJ1dGVzU3RyaW5nKHRhZywgcHJvZmlsZSkge1xuXHRcdHZhciBhdHRycyA9ICcnO1xuXHRcdHZhciBvdGhlckF0dHJzID0gW107XG5cdFx0dmFyIGF0dHJRdW90ZSA9IHByb2ZpbGUuYXR0cmlidXRlUXVvdGUoKTtcblx0XHR2YXIgY3Vyc29yID0gcHJvZmlsZS5jdXJzb3IoKTtcblx0XHRcblx0XHR0YWcuYXR0cmlidXRlTGlzdCgpLmZvckVhY2goZnVuY3Rpb24oYSkge1xuXHRcdFx0dmFyIGF0dHJOYW1lID0gcHJvZmlsZS5hdHRyaWJ1dGVOYW1lKGEubmFtZSk7XG5cdFx0XHRzd2l0Y2ggKGF0dHJOYW1lLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0Ly8gdXNlIHNob3J0IG5vdGF0aW9uIGZvciBJRCBhbmQgQ0xBU1MgYXR0cmlidXRlc1xuXHRcdFx0XHRjYXNlICdpZCc6XG5cdFx0XHRcdFx0YXR0cnMgKz0gJyMnICsgKGEudmFsdWUgfHwgY3Vyc29yKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnY2xhc3MnOlxuXHRcdFx0XHRcdGF0dHJzICs9ICcuJyArIHRyYW5zZm9ybUNsYXNzTmFtZShhLnZhbHVlIHx8IGN1cnNvcik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdC8vIHByb2Nlc3Mgb3RoZXIgYXR0cmlidXRlc1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdG90aGVyQXR0cnMucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiBhdHRyTmFtZSxcblx0XHRcdFx0XHRcdHZhbHVlOiBhLnZhbHVlIHx8IGN1cnNvcixcblx0XHRcdFx0XHRcdGlzQm9vbGVhbjogcHJvZmlsZS5pc0Jvb2xlYW4oYS5uYW1lLCBhLnZhbHVlKVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdFxuXHRcdGlmIChvdGhlckF0dHJzLmxlbmd0aCkge1xuXHRcdFx0YXR0cnMgKz0gc3RyaW5naWZ5QXR0cnMob3RoZXJBdHRycywgcHJvZmlsZSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBhdHRycztcblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NUYWdDb250ZW50KGl0ZW0pIHtcblx0XHRpZiAoIWl0ZW0uY29udGVudCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjb250ZW50ID0gdGFiU3RvcHMucmVwbGFjZVZhcmlhYmxlcyhpdGVtLmNvbnRlbnQsIGZ1bmN0aW9uKHN0ciwgbmFtZSkge1xuXHRcdFx0aWYgKG5hbWUgPT09ICdubCcgfHwgbmFtZSA9PT0gJ25ld2xpbmUnKSB7XG5cdFx0XHRcdHJldHVybiAnXFxuJztcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fSk7XG5cblx0XHRpZiAocmVObC50ZXN0KGNvbnRlbnQpICYmICFyZUluZGVudGVkVGV4dC50ZXN0KGNvbnRlbnQpKSB7XG5cdFx0XHQvLyBtdWx0aWxpbmUgY29udGVudDogcGFkIGl0IHdpdGggaW5kZW50YXRpb24gYW5kIHBpcGVcblx0XHRcdHZhciBwYWQgPSAnfCAnO1xuXHRcdFx0aXRlbS5jb250ZW50ID0gJ1xcbicgKyBwYWQgKyB1dGlscy5wYWRTdHJpbmcoY29udGVudCwgcGFkKTtcblx0XHR9IGVsc2UgaWYgKCFyZVNwYWNlLnRlc3QoY29udGVudCkpIHtcblx0XHRcdGl0ZW0uY29udGVudCA9ICcgJyArIGNvbnRlbnQ7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogUHJvY2Vzc2VzIGVsZW1lbnQgd2l0aCA8Y29kZT50YWc8L2NvZGU+IHR5cGVcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBpdGVtXG5cdCAqIEBwYXJhbSB7T3V0cHV0UHJvZmlsZX0gcHJvZmlsZVxuXHQgKi9cblx0ZnVuY3Rpb24gcHJvY2Vzc1RhZyhpdGVtLCBwcm9maWxlKSB7XG5cdFx0aWYgKCFpdGVtLnBhcmVudClcblx0XHRcdC8vIGxvb2tzIGxpa2UgaXQncyBhIHJvb3QgKGVtcHR5KSBlbGVtZW50XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcblx0XHR2YXIgYXR0cnMgPSBtYWtlQXR0cmlidXRlc1N0cmluZyhpdGVtLCBwcm9maWxlKTtcblx0XHR2YXIgY3Vyc29yID0gcHJvZmlsZS5jdXJzb3IoKTtcblx0XHR2YXIgaXNVbmFyeSA9IGFiYnJVdGlscy5pc1VuYXJ5KGl0ZW0pO1xuXHRcdFx0XG5cdFx0Ly8gZGVmaW5lIHRhZyBuYW1lXG5cdFx0dmFyIHRhZ05hbWUgPSBwcm9maWxlLnRhZ05hbWUoaXRlbS5uYW1lKCkpO1xuXHRcdGlmICh0YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2RpdicgJiYgYXR0cnMgJiYgYXR0cnMuY2hhckF0KDApICE9ICcoJylcblx0XHRcdC8vIG9taXQgZGl2IHRhZ1xuXHRcdFx0dGFnTmFtZSA9ICcnO1xuXHRcdFx0XG5cdFx0aXRlbS5lbmQgPSAnJztcblx0XHR2YXIgc3RhcnQgPSB0YWdOYW1lICsgYXR0cnM7XG5cdFx0cHJvY2Vzc1RhZ0NvbnRlbnQoaXRlbSk7XG5cblx0XHR2YXIgcGxhY2Vob2xkZXIgPSAnJXMnO1xuXHRcdC8vIFdlIGNhbid0IGp1c3QgcmVwbGFjZSBwbGFjZWhvbGRlciB3aXRoIG5ldyB2YWx1ZSBiZWNhdXNlXG5cdFx0Ly8gSmF2YVNjcmlwdCB3aWxsIHRyZWF0IGRvdWJsZSAkIGNoYXJhY3RlciBhcyBhIHNpbmdsZSBvbmUsIGFzc3VtaW5nXG5cdFx0Ly8gd2UncmUgdXNpbmcgUmVnRXhwIGxpdGVyYWwuXG5cdFx0aXRlbS5zdGFydCA9IHV0aWxzLnJlcGxhY2VTdWJzdHJpbmcoaXRlbS5zdGFydCwgc3RhcnQsIGl0ZW0uc3RhcnQuaW5kZXhPZihwbGFjZWhvbGRlciksIHBsYWNlaG9sZGVyKTtcblx0XHRcblx0XHRpZiAoIWl0ZW0uY2hpbGRyZW4ubGVuZ3RoICYmICFpc1VuYXJ5KVxuXHRcdFx0aXRlbS5zdGFydCArPSBjdXJzb3I7XG5cdFx0XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24gcHJvY2Vzcyh0cmVlLCBjdXJQcm9maWxlLCBsZXZlbCkge1xuXHRcdGxldmVsID0gbGV2ZWwgfHwgMDtcblx0XHRcblx0XHRpZiAoIWxldmVsKSB7XG5cdFx0XHQvLyBhbHdheXMgZm9ybWF0IHdpdGggYHhtbGAgcHJvZmlsZSBzaW5jZVxuXHRcdFx0Ly8gSmFkZSByZXF1aXJlcyBhbGwgdGFncyB0byBiZSBvbiBzZXBhcmF0ZSBsaW5lc1xuXHRcdFx0dHJlZSA9IGZvcm1hdEZpbHRlcih0cmVlLCBwcm9maWxlLmdldCgneG1sJykpO1xuXHRcdH1cblx0XHRcblx0XHR0cmVlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKCFhYmJyVXRpbHMuaXNTbmlwcGV0KGl0ZW0pKSB7XG5cdFx0XHRcdHByb2Nlc3NUYWcoaXRlbSwgY3VyUHJvZmlsZSwgbGV2ZWwpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRwcm9jZXNzKGl0ZW0sIGN1clByb2ZpbGUsIGxldmVsICsgMSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRyZWU7XG5cdH07XG59KTtcbn0se1wiLi4vYXNzZXRzL3Byb2ZpbGVcIjpcImFzc2V0c1xcXFxwcm9maWxlLmpzXCIsXCIuLi9hc3NldHMvdGFiU3RvcHNcIjpcImFzc2V0c1xcXFx0YWJTdG9wcy5qc1wiLFwiLi4vdXRpbHMvYWJicmV2aWF0aW9uXCI6XCJ1dGlsc1xcXFxhYmJyZXZpYXRpb24uanNcIixcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCIsXCIuL2Zvcm1hdFwiOlwiZmlsdGVyXFxcXGZvcm1hdC5qc1wifV0sXCJmaWx0ZXJcXFxcanN4LmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBBIGZpbHRlciBmb3IgUmVhY3QuanMgKEpTWCk6XG4gKiByYW5hbWVzIGF0dHJpYnV0ZXMgbGlrZSBgY2xhc3NgIGFuZCBgZm9yYFxuICogZm9yIHByb3BlciByZXByZXNlbnRhdGlvbiBpbiBKU1hcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIGF0dHJNYXAgPSB7XG5cdFx0J2NsYXNzJzogJ2NsYXNzTmFtZScsXG5cdFx0J2Zvcic6ICdodG1sRm9yJ1xuXHR9O1xuXG5cdHJldHVybiBmdW5jdGlvbiBwcm9jZXNzKHRyZWUpIHtcblx0XHR0cmVlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aXRlbS5fYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdFx0aWYgKGF0dHIubmFtZSBpbiBhdHRyTWFwKSB7XG5cdFx0XHRcdFx0YXR0ci5uYW1lID0gYXR0ck1hcFthdHRyLm5hbWVdXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cHJvY2VzcyhpdGVtKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiB0cmVlO1xuXHR9O1xufSk7XG59LHt9XSxcImZpbHRlclxcXFxtYWluLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBNb2R1bGUgZm9yIGhhbmRsaW5nIGZpbHRlcnNcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciBwcm9maWxlID0gcmVxdWlyZSgnLi4vYXNzZXRzL3Byb2ZpbGUnKTtcblx0dmFyIHJlc291cmNlcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9yZXNvdXJjZXMnKTtcblxuXHQvKiogTGlzdCBvZiByZWdpc3RlcmVkIGZpbHRlcnMgKi9cblx0dmFyIHJlZ2lzdGVyZWRGaWx0ZXJzID0ge1xuXHRcdGh0bWw6IHJlcXVpcmUoJy4vaHRtbCcpLFxuXHRcdGhhbWw6IHJlcXVpcmUoJy4vaGFtbCcpLFxuXHRcdGphZGU6IHJlcXVpcmUoJy4vamFkZScpLFxuXHRcdGpzeDogcmVxdWlyZSgnLi9qc3gnKSxcblx0XHRzbGltOiByZXF1aXJlKCcuL3NsaW0nKSxcblx0XHR4c2w6IHJlcXVpcmUoJy4veHNsJyksXG5cdFx0Y3NzOiByZXF1aXJlKCcuL2NzcycpLFxuXHRcdGJlbTogcmVxdWlyZSgnLi9iZW0nKSxcblx0XHRjOiByZXF1aXJlKCcuL2NvbW1lbnQnKSxcblx0XHRlOiByZXF1aXJlKCcuL2VzY2FwZScpLFxuXHRcdHM6IHJlcXVpcmUoJy4vc2luZ2xlTGluZScpLFxuXHRcdHQ6IHJlcXVpcmUoJy4vdHJpbScpXG5cdH07XG5cdFxuXHQvKiogRmlsdGVycyB0aGF0IHdpbGwgYmUgYXBwbGllZCBmb3IgdW5rbm93biBzeW50YXggKi9cblx0dmFyIGJhc2ljRmlsdGVycyA9ICdodG1sJztcblx0XG5cdGZ1bmN0aW9uIGxpc3QoZmlsdGVycykge1xuXHRcdGlmICghZmlsdGVycylcblx0XHRcdHJldHVybiBbXTtcblx0XHRcblx0XHRpZiAodHlwZW9mIGZpbHRlcnMgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gZmlsdGVycy5zcGxpdCgvW1xcfCxdL2cpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmlsdGVycztcblx0fVxuXHRcblx0cmV0dXJuICB7XG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXIgbmV3IGZpbHRlclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEZpbHRlciBuYW1lXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRmlsdGVyIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0YWRkOiBmdW5jdGlvbihuYW1lLCBmbikge1xuXHRcdFx0cmVnaXN0ZXJlZEZpbHRlcnNbbmFtZV0gPSBmbjtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFwcGx5IGZpbHRlcnMgZm9yIGZpbmFsIG91dHB1dCB0cmVlXG5cdFx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSB0cmVlIE91dHB1dCB0cmVlXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gZmlsdGVycyBMaXN0IG9mIGZpbHRlcnMgdG8gYXBwbHkuIE1pZ2h0IGJlIGEgXG5cdFx0ICogPGNvZGU+U3RyaW5nPC9jb2RlPlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9maWxlIE91dHB1dCBwcm9maWxlLCBkZWZpbmVkIGluIDxpPnByb2ZpbGU8L2k+IFxuXHRcdCAqIG1vZHVsZS4gRmlsdGVycyBkZWZpbmVkIGl0IHByb2ZpbGUgYXJlIG5vdCB1c2VkLCA8Y29kZT5wcm9maWxlPC9jb2RlPlxuXHRcdCAqIGlzIHBhc3NlZCB0byBmaWx0ZXIgZnVuY3Rpb25cblx0XHQgKiBAbWVtYmVyT2YgZW1tZXQuZmlsdGVyc1xuXHRcdCAqIEByZXR1cm5zIHtBYmJyZXZpYXRpb25Ob2RlfVxuXHRcdCAqL1xuXHRcdGFwcGx5OiBmdW5jdGlvbih0cmVlLCBmaWx0ZXJzLCBwcm9maWxlTmFtZSkge1xuXHRcdFx0cHJvZmlsZU5hbWUgPSBwcm9maWxlLmdldChwcm9maWxlTmFtZSk7XG5cdFx0XHRcblx0XHRcdGxpc3QoZmlsdGVycykuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHtcblx0XHRcdFx0dmFyIG5hbWUgPSB1dGlscy50cmltKGZpbHRlci50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdFx0aWYgKG5hbWUgJiYgbmFtZSBpbiByZWdpc3RlcmVkRmlsdGVycykge1xuXHRcdFx0XHRcdHRyZWUgPSByZWdpc3RlcmVkRmlsdGVyc1tuYW1lXSh0cmVlLCBwcm9maWxlTmFtZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJlZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbXBvc2VzIGxpc3Qgb2YgZmlsdGVycyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGEgdHJlZSwgYmFzZWQgb24gXG5cdFx0ICogcGFzc2VkIGRhdGFcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4IFN5bnRheCBuYW1lICgnaHRtbCcsICdjc3MnLCBldGMuKVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9maWxlIE91dHB1dCBwcm9maWxlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFkZGl0aW9uYWxGaWx0ZXJzIExpc3Qgb3IgcGlwZS1zZXBhcmF0ZWRcblx0XHQgKiBzdHJpbmcgb2YgYWRkaXRpb25hbCBmaWx0ZXJzIHRvIGFwcGx5XG5cdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdCAqL1xuXHRcdGNvbXBvc2VMaXN0OiBmdW5jdGlvbihzeW50YXgsIHByb2ZpbGVOYW1lLCBhZGRpdGlvbmFsRmlsdGVycykge1xuXHRcdFx0cHJvZmlsZU5hbWUgPSBwcm9maWxlLmdldChwcm9maWxlTmFtZSk7XG5cdFx0XHR2YXIgZmlsdGVycyA9IGxpc3QocHJvZmlsZU5hbWUuZmlsdGVycyB8fCByZXNvdXJjZXMuZmluZEl0ZW0oc3ludGF4LCAnZmlsdGVycycpIHx8IGJhc2ljRmlsdGVycyk7XG5cdFx0XHRcblx0XHRcdGlmIChwcm9maWxlTmFtZS5leHRyYUZpbHRlcnMpIHtcblx0XHRcdFx0ZmlsdGVycyA9IGZpbHRlcnMuY29uY2F0KGxpc3QocHJvZmlsZU5hbWUuZXh0cmFGaWx0ZXJzKSk7XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0aWYgKGFkZGl0aW9uYWxGaWx0ZXJzKSB7XG5cdFx0XHRcdGZpbHRlcnMgPSBmaWx0ZXJzLmNvbmNhdChsaXN0KGFkZGl0aW9uYWxGaWx0ZXJzKSk7XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0aWYgKCFmaWx0ZXJzIHx8ICFmaWx0ZXJzLmxlbmd0aCkge1xuXHRcdFx0XHQvLyBsb29rcyBsaWtlIHVua25vd24gc3ludGF4LCBhcHBseSBiYXNpYyBmaWx0ZXJzXG5cdFx0XHRcdGZpbHRlcnMgPSBsaXN0KGJhc2ljRmlsdGVycyk7XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0cmV0dXJuIGZpbHRlcnM7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBFeHRyYWN0cyBmaWx0ZXIgbGlzdCBmcm9tIGFiYnJldmlhdGlvblxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBhYmJyXG5cdFx0ICogQHJldHVybnMge0FycmF5fSBBcnJheSB3aXRoIGNsZWFuZWQgYWJicmV2aWF0aW9uIGFuZCBsaXN0IG9mIFxuXHRcdCAqIGV4dHJhY3RlZCBmaWx0ZXJzXG5cdFx0ICovXG5cdFx0ZXh0cmFjdDogZnVuY3Rpb24oYWJicikge1xuXHRcdFx0dmFyIGZpbHRlcnMgPSAnJztcblx0XHRcdGFiYnIgPSBhYmJyLnJlcGxhY2UoL1xcfChbXFx3XFx8XFwtXSspJC8sIGZ1bmN0aW9uKHN0ciwgcDEpe1xuXHRcdFx0XHRmaWx0ZXJzID0gcDE7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gW2FiYnIsIGxpc3QoZmlsdGVycyldO1xuXHRcdH1cblx0fTtcbn0pO1xufSx7XCIuLi9hc3NldHMvcHJvZmlsZVwiOlwiYXNzZXRzXFxcXHByb2ZpbGUuanNcIixcIi4uL2Fzc2V0cy9yZXNvdXJjZXNcIjpcImFzc2V0c1xcXFxyZXNvdXJjZXMuanNcIixcIi4uL3V0aWxzL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCIsXCIuL2JlbVwiOlwiZmlsdGVyXFxcXGJlbS5qc1wiLFwiLi9jb21tZW50XCI6XCJmaWx0ZXJcXFxcY29tbWVudC5qc1wiLFwiLi9jc3NcIjpcImZpbHRlclxcXFxjc3MuanNcIixcIi4vZXNjYXBlXCI6XCJmaWx0ZXJcXFxcZXNjYXBlLmpzXCIsXCIuL2hhbWxcIjpcImZpbHRlclxcXFxoYW1sLmpzXCIsXCIuL2h0bWxcIjpcImZpbHRlclxcXFxodG1sLmpzXCIsXCIuL2phZGVcIjpcImZpbHRlclxcXFxqYWRlLmpzXCIsXCIuL2pzeFwiOlwiZmlsdGVyXFxcXGpzeC5qc1wiLFwiLi9zaW5nbGVMaW5lXCI6XCJmaWx0ZXJcXFxcc2luZ2xlTGluZS5qc1wiLFwiLi9zbGltXCI6XCJmaWx0ZXJcXFxcc2xpbS5qc1wiLFwiLi90cmltXCI6XCJmaWx0ZXJcXFxcdHJpbS5qc1wiLFwiLi94c2xcIjpcImZpbHRlclxcXFx4c2wuanNcIn1dLFwiZmlsdGVyXFxcXHNpbmdsZUxpbmUuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIE91dHB1dCBhYmJyZXZpYXRpb24gb24gYSBzaW5nbGUgbGluZSAoaS5lLiBubyBsaW5lIGJyZWFrcylcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIGFiYnJVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2FiYnJldmlhdGlvbicpO1xuXHR2YXIgcmVQYWQgPSAvXlxccysvO1xuXHR2YXIgcmVObCA9IC9bXFxuXFxyXS9nO1xuXG5cdHJldHVybiBmdW5jdGlvbiBwcm9jZXNzKHRyZWUpIHtcblx0XHR0cmVlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKCFhYmJyVXRpbHMuaXNTbmlwcGV0KGl0ZW0pKSB7XG5cdFx0XHRcdC8vIHJlbW92ZSBwYWRkaW5nIGZyb20gaXRlbSBcblx0XHRcdFx0aXRlbS5zdGFydCA9IGl0ZW0uc3RhcnQucmVwbGFjZShyZVBhZCwgJycpO1xuXHRcdFx0XHRpdGVtLmVuZCA9IGl0ZW0uZW5kLnJlcGxhY2UocmVQYWQsICcnKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gcmVtb3ZlIG5ld2xpbmVzIFxuXHRcdFx0aXRlbS5zdGFydCA9IGl0ZW0uc3RhcnQucmVwbGFjZShyZU5sLCAnJyk7XG5cdFx0XHRpdGVtLmVuZCA9IGl0ZW0uZW5kLnJlcGxhY2UocmVObCwgJycpO1xuXHRcdFx0aXRlbS5jb250ZW50ID0gaXRlbS5jb250ZW50LnJlcGxhY2UocmVObCwgJycpO1xuXHRcdFx0XG5cdFx0XHRwcm9jZXNzKGl0ZW0pO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiB0cmVlO1xuXHR9O1xufSk7XG5cbn0se1wiLi4vdXRpbHMvYWJicmV2aWF0aW9uXCI6XCJ1dGlsc1xcXFxhYmJyZXZpYXRpb24uanNcIn1dLFwiZmlsdGVyXFxcXHNsaW0uanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEZpbHRlciBmb3IgcHJvZHVjaW5nIEphZGUgY29kZSBmcm9tIGFiYnJldmlhdGlvbi5cbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciBhYmJyVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9hYmJyZXZpYXRpb24nKTtcblx0dmFyIGZvcm1hdEZpbHRlciA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5cdHZhciB0YWJTdG9wcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy90YWJTdG9wcycpO1xuXHR2YXIgcHJlZnMgPSByZXF1aXJlKCcuLi9hc3NldHMvcHJlZmVyZW5jZXMnKTtcblx0dmFyIHByb2ZpbGUgPSByZXF1aXJlKCcuLi9hc3NldHMvcHJvZmlsZScpO1xuXG5cdHZhciByZU5sID0gL1tcXG5cXHJdLztcblx0dmFyIHJlSW5kZW50ZWRUZXh0ID0gL15cXHMqXFx8Lztcblx0dmFyIHJlU3BhY2UgPSAvXlxccy87XG5cblx0cHJlZnMuZGVmaW5lKCdzbGltLmF0dHJpYnV0ZXNXcmFwcGVyJywgJ25vbmUnLCBcblx0XHQnRGVmaW5lcyBob3cgYXR0cmlidXRlcyB3aWxsIGJlIHdyYXBwZWQ6JyArXG5cdFx0Jzx1bD4nICtcblx0XHQnPGxpPjxjb2RlPm5vbmU8L2NvZGU+IOKAkyBubyB3cmFwcGluZzs8L2xpPicgK1xuXHRcdCc8bGk+PGNvZGU+cm91bmQ8L2NvZGU+IOKAlCB3cmFwIGF0dHJpYnV0ZXMgd2l0aCByb3VuZCBicmFjZXM7PC9saT4nICtcblx0XHQnPGxpPjxjb2RlPnNxdWFyZTwvY29kZT4g4oCUIHdyYXAgYXR0cmlidXRlcyB3aXRoIHJvdW5kIGJyYWNlczs8L2xpPicgK1xuXHRcdCc8bGk+PGNvZGU+Y3VybHk8L2NvZGU+IOKAlCB3cmFwIGF0dHJpYnV0ZXMgd2l0aCBjdXJseSBicmFjZXMuPC9saT4nICtcblx0XHQnPC91bD4nKTtcblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1DbGFzc05hbWUoY2xhc3NOYW1lKSB7XG5cdFx0cmV0dXJuIHV0aWxzLnRyaW0oY2xhc3NOYW1lKS5yZXBsYWNlKC9cXHMrL2csICcuJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRBdHRyV3JhcHBlcigpIHtcblx0XHR2YXIgc3RhcnQgPSAnICcsIGVuZCA9ICcnO1xuXHRcdHN3aXRjaCAocHJlZnMuZ2V0KCdzbGltLmF0dHJpYnV0ZXNXcmFwcGVyJykpIHtcblx0XHRcdGNhc2UgJ3JvdW5kJzpcblx0XHRcdFx0c3RhcnQgPSAnKCc7XG5cdFx0XHRcdGVuZCA9ICcpJztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzcXVhcmUnOlxuXHRcdFx0XHRzdGFydCA9ICdbJztcblx0XHRcdFx0ZW5kID0gJ10nO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2N1cmx5Jzpcblx0XHRcdFx0c3RhcnQgPSAneyc7XG5cdFx0XHRcdGVuZCA9ICd9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGVuZDogZW5kXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHN0cmluZ2lmeUF0dHJzKGF0dHJzLCBwcm9maWxlKSB7XG5cdFx0dmFyIGF0dHJRdW90ZSA9IHByb2ZpbGUuYXR0cmlidXRlUXVvdGUoKTtcblx0XHR2YXIgYXR0cldyYXAgPSBnZXRBdHRyV3JhcHBlcigpO1xuXHRcdHJldHVybiBhdHRyV3JhcC5zdGFydCArIGF0dHJzLm1hcChmdW5jdGlvbihhdHRyKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBhdHRyUXVvdGUgKyBhdHRyLnZhbHVlICsgYXR0clF1b3RlO1xuXHRcdFx0aWYgKGF0dHIuaXNCb29sZWFuKSB7XG5cdFx0XHRcdGlmICghYXR0cldyYXAuZW5kKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSAndHJ1ZSc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGF0dHIubmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXR0ci5uYW1lICsgJz0nICsgdmFsdWU7XG5cdFx0fSkuam9pbignICcpICsgYXR0cldyYXAuZW5kO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBIQU1MIGF0dHJpYnV0ZXMgc3RyaW5nIGZyb20gdGFnIGFjY29yZGluZyB0byBwcm9maWxlIHNldHRpbmdzXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gdGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9maWxlXG5cdCAqL1xuXHRmdW5jdGlvbiBtYWtlQXR0cmlidXRlc1N0cmluZyh0YWcsIHByb2ZpbGUpIHtcblx0XHR2YXIgYXR0cnMgPSAnJztcblx0XHR2YXIgb3RoZXJBdHRycyA9IFtdO1xuXHRcdHZhciBhdHRyUXVvdGUgPSBwcm9maWxlLmF0dHJpYnV0ZVF1b3RlKCk7XG5cdFx0dmFyIGN1cnNvciA9IHByb2ZpbGUuY3Vyc29yKCk7XG5cdFx0XG5cdFx0dGFnLmF0dHJpYnV0ZUxpc3QoKS5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcblx0XHRcdHZhciBhdHRyTmFtZSA9IHByb2ZpbGUuYXR0cmlidXRlTmFtZShhLm5hbWUpO1xuXHRcdFx0c3dpdGNoIChhdHRyTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRcdC8vIHVzZSBzaG9ydCBub3RhdGlvbiBmb3IgSUQgYW5kIENMQVNTIGF0dHJpYnV0ZXNcblx0XHRcdFx0Y2FzZSAnaWQnOlxuXHRcdFx0XHRcdGF0dHJzICs9ICcjJyArIChhLnZhbHVlIHx8IGN1cnNvcik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2NsYXNzJzpcblx0XHRcdFx0XHRhdHRycyArPSAnLicgKyB0cmFuc2Zvcm1DbGFzc05hbWUoYS52YWx1ZSB8fCBjdXJzb3IpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHQvLyBwcm9jZXNzIG90aGVyIGF0dHJpYnV0ZXNcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRvdGhlckF0dHJzLnB1c2goe1xuXHRcdFx0XHRcdFx0bmFtZTogYXR0ck5hbWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogYS52YWx1ZSB8fCBjdXJzb3IsXG5cdFx0XHRcdFx0XHRpc0Jvb2xlYW46IHByb2ZpbGUuaXNCb29sZWFuKGEubmFtZSwgYS52YWx1ZSlcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRcblx0XHRpZiAob3RoZXJBdHRycy5sZW5ndGgpIHtcblx0XHRcdGF0dHJzICs9IHN0cmluZ2lmeUF0dHJzKG90aGVyQXR0cnMsIHByb2ZpbGUpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gYXR0cnM7XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzVGFnQ29udGVudChpdGVtKSB7XG5cdFx0aWYgKCFpdGVtLmNvbnRlbnQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY29udGVudCA9IHRhYlN0b3BzLnJlcGxhY2VWYXJpYWJsZXMoaXRlbS5jb250ZW50LCBmdW5jdGlvbihzdHIsIG5hbWUpIHtcblx0XHRcdGlmIChuYW1lID09PSAnbmwnIHx8IG5hbWUgPT09ICduZXdsaW5lJykge1xuXHRcdFx0XHRyZXR1cm4gJ1xcbic7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHJlTmwudGVzdChjb250ZW50KSAmJiAhcmVJbmRlbnRlZFRleHQudGVzdChjb250ZW50KSkge1xuXHRcdFx0Ly8gbXVsdGlsaW5lIGNvbnRlbnQ6IHBhZCBpdCB3aXRoIGluZGVudGF0aW9uIGFuZCBwaXBlXG5cdFx0XHR2YXIgcGFkID0gJyAgJztcblx0XHRcdGl0ZW0uY29udGVudCA9ICdcXG58ICcgKyB1dGlscy5wYWRTdHJpbmcoY29udGVudCwgcGFkKTtcblx0XHR9IGVsc2UgaWYgKCFyZVNwYWNlLnRlc3QoY29udGVudCkpIHtcblx0XHRcdGl0ZW0uY29udGVudCA9ICcgJyArIGNvbnRlbnQ7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogUHJvY2Vzc2VzIGVsZW1lbnQgd2l0aCA8Y29kZT50YWc8L2NvZGU+IHR5cGVcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBpdGVtXG5cdCAqIEBwYXJhbSB7T3V0cHV0UHJvZmlsZX0gcHJvZmlsZVxuXHQgKi9cblx0ZnVuY3Rpb24gcHJvY2Vzc1RhZyhpdGVtLCBwcm9maWxlKSB7XG5cdFx0aWYgKCFpdGVtLnBhcmVudClcblx0XHRcdC8vIGxvb2tzIGxpa2UgaXQncyBhIHJvb3QgKGVtcHR5KSBlbGVtZW50XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcblx0XHR2YXIgYXR0cnMgPSBtYWtlQXR0cmlidXRlc1N0cmluZyhpdGVtLCBwcm9maWxlKTtcblx0XHR2YXIgY3Vyc29yID0gcHJvZmlsZS5jdXJzb3IoKTtcblx0XHR2YXIgaXNVbmFyeSA9IGFiYnJVdGlscy5pc1VuYXJ5KGl0ZW0pO1xuXHRcdHZhciBzZWxmQ2xvc2luZyA9IHByb2ZpbGUuc2VsZl9jbG9zaW5nX3RhZyAmJiBpc1VuYXJ5ID8gJy8nIDogJyc7XG5cdFx0XHRcblx0XHQvLyBkZWZpbmUgdGFnIG5hbWVcblx0XHR2YXIgdGFnTmFtZSA9IHByb2ZpbGUudGFnTmFtZShpdGVtLm5hbWUoKSk7XG5cdFx0aWYgKHRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSAnZGl2JyAmJiBhdHRycyAmJiAnKFt7Jy5pbmRleE9mKGF0dHJzLmNoYXJBdCgwKSkgPT0gLTEpXG5cdFx0XHQvLyBvbWl0IGRpdiB0YWdcblx0XHRcdHRhZ05hbWUgPSAnJztcblx0XHRcdFxuXHRcdGl0ZW0uZW5kID0gJyc7XG5cdFx0dmFyIHN0YXJ0ID0gdGFnTmFtZSArIGF0dHJzICsgc2VsZkNsb3Npbmc7XG5cdFx0cHJvY2Vzc1RhZ0NvbnRlbnQoaXRlbSk7XG5cblx0XHR2YXIgcGxhY2Vob2xkZXIgPSAnJXMnO1xuXHRcdC8vIFdlIGNhbid0IGp1c3QgcmVwbGFjZSBwbGFjZWhvbGRlciB3aXRoIG5ldyB2YWx1ZSBiZWNhdXNlXG5cdFx0Ly8gSmF2YVNjcmlwdCB3aWxsIHRyZWF0IGRvdWJsZSAkIGNoYXJhY3RlciBhcyBhIHNpbmdsZSBvbmUsIGFzc3VtaW5nXG5cdFx0Ly8gd2UncmUgdXNpbmcgUmVnRXhwIGxpdGVyYWwuXG5cdFx0aXRlbS5zdGFydCA9IHV0aWxzLnJlcGxhY2VTdWJzdHJpbmcoaXRlbS5zdGFydCwgc3RhcnQsIGl0ZW0uc3RhcnQuaW5kZXhPZihwbGFjZWhvbGRlciksIHBsYWNlaG9sZGVyKTtcblx0XHRcblx0XHRpZiAoIWl0ZW0uY2hpbGRyZW4ubGVuZ3RoICYmICFpc1VuYXJ5KVxuXHRcdFx0aXRlbS5zdGFydCArPSBjdXJzb3I7XG5cdFx0XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24gcHJvY2Vzcyh0cmVlLCBjdXJQcm9maWxlLCBsZXZlbCkge1xuXHRcdGxldmVsID0gbGV2ZWwgfHwgMDtcblx0XHRcblx0XHRpZiAoIWxldmVsKSB7XG5cdFx0XHQvLyBhbHdheXMgZm9ybWF0IHdpdGggYHhtbGAgcHJvZmlsZSBzaW5jZVxuXHRcdFx0Ly8gU2xpbSByZXF1aXJlcyBhbGwgdGFncyB0byBiZSBvbiBzZXBhcmF0ZSBsaW5lc1xuXHRcdFx0dHJlZSA9IGZvcm1hdEZpbHRlcih0cmVlLCBwcm9maWxlLmdldCgneG1sJykpO1xuXHRcdH1cblx0XHRcblx0XHR0cmVlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKCFhYmJyVXRpbHMuaXNTbmlwcGV0KGl0ZW0pKSB7XG5cdFx0XHRcdHByb2Nlc3NUYWcoaXRlbSwgY3VyUHJvZmlsZSwgbGV2ZWwpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRwcm9jZXNzKGl0ZW0sIGN1clByb2ZpbGUsIGxldmVsICsgMSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRyZWU7XG5cdH07XG59KTtcbn0se1wiLi4vYXNzZXRzL3ByZWZlcmVuY2VzXCI6XCJhc3NldHNcXFxccHJlZmVyZW5jZXMuanNcIixcIi4uL2Fzc2V0cy9wcm9maWxlXCI6XCJhc3NldHNcXFxccHJvZmlsZS5qc1wiLFwiLi4vYXNzZXRzL3RhYlN0b3BzXCI6XCJhc3NldHNcXFxcdGFiU3RvcHMuanNcIixcIi4uL3V0aWxzL2FiYnJldmlhdGlvblwiOlwidXRpbHNcXFxcYWJicmV2aWF0aW9uLmpzXCIsXCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi9mb3JtYXRcIjpcImZpbHRlclxcXFxmb3JtYXQuanNcIn1dLFwiZmlsdGVyXFxcXHRyaW0uanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFRyaW0gZmlsdGVyOiByZW1vdmVzIGNoYXJhY3RlcnMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dFxuICogY29udGVudCB0aGF0IGluZGljYXRlcyBsaXN0czogbnVtYmVycywgIywgKiwgLSwgZXRjLlxuICogXG4gKiBVc2VmdWwgZm9yIHdyYXBwaW5nIGxpc3RzIHdpdGggYWJicmV2aWF0aW9uLlxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgcHJlZnMgPSByZXF1aXJlKCcuLi9hc3NldHMvcHJlZmVyZW5jZXMnKTtcblx0cHJlZnMuZGVmaW5lKCdmaWx0ZXIudHJpbVJlZ2V4cCcsIFxuXHRcdCdbXFxcXHN8XFxcXHUwMGEwXSpbXFxcXGR8I3xcXFxcLXxcXCp8XFxcXHUyMDIyXStcXFxcLj9cXFxccyonLFxuXHRcdCdSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byByZW1vdmUgbGlzdCBtYXJrZXJzIChudW1iZXJzLCBkYXNoZXMsICcgXG5cdFx0KyAnYnVsbGV0cywgZXRjLikgaW4gPGNvZGU+dDwvY29kZT4gKHRyaW0pIGZpbHRlci4gVGhlIHRyaW0gZmlsdGVyICdcblx0XHQrICdpcyB1c2VmdWwgZm9yIHdyYXBwaW5nIHdpdGggYWJicmV2aWF0aW9uIGxpc3RzLCBwYXNlZCBmcm9tIG90aGVyICcgXG5cdFx0KyAnZG9jdW1lbnRzIChmb3IgZXhhbXBsZSwgV29yZCBkb2N1bWVudHMpLicpO1xuXHRcblx0ZnVuY3Rpb24gcHJvY2Vzcyh0cmVlLCByZSkge1xuXHRcdHRyZWUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoaXRlbS5jb250ZW50KSB7XG5cdFx0XHRcdGl0ZW0uY29udGVudCA9IGl0ZW0uY29udGVudC5yZXBsYWNlKHJlLCAnJyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHByb2Nlc3MoaXRlbSwgcmUpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiB0cmVlO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRyZWUpIHtcblx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKHByZWZzLmdldCgnZmlsdGVyLnRyaW1SZWdleHAnKSk7XG5cdFx0cmV0dXJuIHByb2Nlc3ModHJlZSwgcmUpO1xuXHR9O1xufSk7XG5cbn0se1wiLi4vYXNzZXRzL3ByZWZlcmVuY2VzXCI6XCJhc3NldHNcXFxccHJlZmVyZW5jZXMuanNcIn1dLFwiZmlsdGVyXFxcXHhzbC5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogRmlsdGVyIGZvciB0cmltbWluZyBcInNlbGVjdFwiIGF0dHJpYnV0ZXMgZnJvbSBzb21lIHRhZ3MgdGhhdCBjb250YWluc1xuICogY2hpbGQgZWxlbWVudHNcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIGFiYnJVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2FiYnJldmlhdGlvbicpO1xuXG5cdHZhciB0YWdzID0ge1xuXHRcdCd4c2w6dmFyaWFibGUnOiAxLFxuXHRcdCd4c2w6d2l0aC1wYXJhbSc6IDFcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZW1vdmVzIFwic2VsZWN0XCIgYXR0cmlidXRlIGZyb20gbm9kZVxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0ICovXG5cdGZ1bmN0aW9uIHRyaW1BdHRyaWJ1dGUobm9kZSkge1xuXHRcdG5vZGUuc3RhcnQgPSBub2RlLnN0YXJ0LnJlcGxhY2UoL1xccytzZWxlY3RcXHMqPVxccyooWydcIl0pLio/XFwxLywgJycpO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHByb2Nlc3ModHJlZSkge1xuXHRcdHRyZWUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoIWFiYnJVdGlscy5pc1NuaXBwZXQoaXRlbSlcblx0XHRcdFx0XHQmJiAoaXRlbS5uYW1lKCkgfHwgJycpLnRvTG93ZXJDYXNlKCkgaW4gdGFncyBcblx0XHRcdFx0XHQmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aClcblx0XHRcdFx0dHJpbUF0dHJpYnV0ZShpdGVtKTtcblx0XHRcdHByb2Nlc3MoaXRlbSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRyZWU7XG5cdH07XG59KTtcbn0se1wiLi4vdXRpbHMvYWJicmV2aWF0aW9uXCI6XCJ1dGlsc1xcXFxhYmJyZXZpYXRpb24uanNcIn1dLFwiZ2VuZXJhdG9yXFxcXGxvcmVtLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBcIkxvcmVtIGlwc3VtXCIgdGV4dCBnZW5lcmF0b3IuIE1hdGNoZXMgPGNvZGU+bGlwc3VtKG51bSk/PC9jb2RlPiBvciBcbiAqIDxjb2RlPmxvcmVtKG51bSk/PC9jb2RlPiBhYmJyZXZpYXRpb24uXG4gKiBUaGlzIGNvZGUgaXMgYmFzZWQgb24gRGphbmdvJ3MgY29udHJpYnV0aW9uOiBcbiAqIGh0dHBzOi8vY29kZS5kamFuZ29wcm9qZWN0LmNvbS9icm93c2VyL2RqYW5nby90cnVuay9kamFuZ28vY29udHJpYi93ZWJkZXNpZ24vbG9yZW1faXBzdW0ucHlcbiAqIDxicj48YnI+XG4gKiBFeGFtcGxlcyB0byB0ZXN0Ojxicj5cbiAqIDxjb2RlPmxpcHN1bTwvY29kZT4g4oCTIGdlbmVyYXRlcyAzMCB3b3JkcyB0ZXh0Ljxicj5cbiAqIDxjb2RlPmxpcHN1bSo2PC9jb2RlPiDigJMgZ2VuZXJhdGVzIDYgcGFyYWdyYXBocyAoYXV0b3dyYXBwZWQgd2l0aCAmbHQ7cCZndDsgZWxlbWVudCkgb2YgdGV4dC48YnI+XG4gKiA8Y29kZT5vbD5saXBzdW0xMCo1PC9jb2RlPiDigJQgZ2VuZXJhdGVzIG9yZGVyZWQgbGlzdCB3aXRoIDUgbGlzdCBpdGVtcyAoYXV0b3dyYXBwZWQgd2l0aCAmbHQ7bGkmZ3Q7IHRhZylcbiAqIHdpdGggdGV4dCBvZiAxMCB3b3JkcyBvbiBlYWNoIGxpbmUuPGJyPlxuICogPGNvZGU+c3BhbiozPmxpcHN1bTIwPC9jb2RlPiDigJMgZ2VuZXJhdGVzIDMgcGFyYWdyYXBocyBvZiAyMC13b3JkcyB0ZXh0LCBlYWNoIHdyYXBwZWQgd2l0aCAmbHQ7c3BhbiZndDsgZWxlbWVudC5cbiAqIEVhY2ggcGFyYWdyYXBoIHBocmFzZSBpcyB1bmlxdWUuICAgXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBwcmVmcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9wcmVmZXJlbmNlcycpO1xuXG5cdHZhciBsYW5ncyA9IHtcblx0XHRlbjoge1xuXHRcdFx0Y29tbW9uOiBbJ2xvcmVtJywgJ2lwc3VtJywgJ2RvbG9yJywgJ3NpdCcsICdhbWV0JywgJ2NvbnNlY3RldHVyJywgJ2FkaXBpc2ljaW5nJywgJ2VsaXQnXSxcblx0XHRcdHdvcmRzOiBbJ2V4ZXJjaXRhdGlvbmVtJywgJ3BlcmZlcmVuZGlzJywgJ3BlcnNwaWNpYXRpcycsICdsYWJvcnVtJywgJ2V2ZW5pZXQnLFxuXHRcdFx0XHQnc3VudCcsICdpdXJlJywgJ25hbScsICdub2JpcycsICdldW0nLCAnY3VtJywgJ29mZmljaWlzJywgJ2V4Y2VwdHVyaScsXG5cdFx0XHRcdCdvZGlvJywgJ2NvbnNlY3RldHVyJywgJ3F1YXNpJywgJ2F1dCcsICdxdWlzcXVhbScsICd2ZWwnLCAnZWxpZ2VuZGknLFxuXHRcdFx0XHQnaXRhcXVlJywgJ25vbicsICdvZGl0JywgJ3RlbXBvcmUnLCAncXVhZXJhdCcsICdkaWduaXNzaW1vcycsXG5cdFx0XHRcdCdmYWNpbGlzJywgJ25lcXVlJywgJ25paGlsJywgJ2V4cGVkaXRhJywgJ3ZpdGFlJywgJ3Zlcm8nLCAnaXBzdW0nLFxuXHRcdFx0XHQnbmlzaScsICdhbmltaScsICdjdW1xdWUnLCAncGFyaWF0dXInLCAndmVsaXQnLCAnbW9kaScsICduYXR1cycsXG5cdFx0XHRcdCdpdXN0bycsICdlYXF1ZScsICdzZXF1aScsICdpbGxvJywgJ3NlZCcsICdleCcsICdldCcsICd2b2x1cHRhdGlidXMnLFxuXHRcdFx0XHQndGVtcG9yYScsICd2ZXJpdGF0aXMnLCAncmF0aW9uZScsICdhc3N1bWVuZGEnLCAnaW5jaWR1bnQnLCAnbm9zdHJ1bScsXG5cdFx0XHRcdCdwbGFjZWF0JywgJ2FsaXF1aWQnLCAnZnVnYScsICdwcm92aWRlbnQnLCAncHJhZXNlbnRpdW0nLCAncmVtJyxcblx0XHRcdFx0J25lY2Vzc2l0YXRpYnVzJywgJ3N1c2NpcGl0JywgJ2FkaXBpc2NpJywgJ3F1aWRlbScsICdwb3NzaW11cycsXG5cdFx0XHRcdCd2b2x1cHRhcycsICdkZWJpdGlzJywgJ3NpbnQnLCAnYWNjdXNhbnRpdW0nLCAndW5kZScsICdzYXBpZW50ZScsXG5cdFx0XHRcdCd2b2x1cHRhdGUnLCAncXVpJywgJ2FzcGVybmF0dXInLCAnbGF1ZGFudGl1bScsICdzb2x1dGEnLCAnYW1ldCcsXG5cdFx0XHRcdCdxdW8nLCAnYWxpcXVhbScsICdzYWVwZScsICdjdWxwYScsICdsaWJlcm8nLCAnaXBzYScsICdkaWN0YScsXG5cdFx0XHRcdCdyZWljaWVuZGlzJywgJ25lc2NpdW50JywgJ2RvbG9yaWJ1cycsICdhdXRlbScsICdpbXBlZGl0JywgJ21pbmltYScsXG5cdFx0XHRcdCdtYWlvcmVzJywgJ3JlcHVkaWFuZGFlJywgJ2lwc2FtJywgJ29iY2FlY2F0aScsICd1bGxhbScsICdlbmltJyxcblx0XHRcdFx0J3RvdGFtJywgJ2RlbGVjdHVzJywgJ2R1Y2ltdXMnLCAncXVpcycsICd2b2x1cHRhdGVzJywgJ2RvbG9yZXMnLFxuXHRcdFx0XHQnbW9sZXN0aWFlJywgJ2hhcnVtJywgJ2RvbG9yZW0nLCAncXVpYScsICd2b2x1cHRhdGVtJywgJ21vbGVzdGlhcycsXG5cdFx0XHRcdCdtYWduaScsICdkaXN0aW5jdGlvJywgJ29tbmlzJywgJ2lsbHVtJywgJ2RvbG9ydW0nLCAndm9sdXB0YXR1bScsICdlYScsXG5cdFx0XHRcdCdxdWFzJywgJ3F1YW0nLCAnY29ycG9yaXMnLCAncXVhZScsICdibGFuZGl0aWlzJywgJ2F0cXVlJywgJ2Rlc2VydW50Jyxcblx0XHRcdFx0J2xhYm9yaW9zYW0nLCAnZWFydW0nLCAnY29uc2VxdXVudHVyJywgJ2hpYycsICdjdXBpZGl0YXRlJyxcblx0XHRcdFx0J3F1aWJ1c2RhbScsICdhY2N1c2FtdXMnLCAndXQnLCAncmVydW0nLCAnZXJyb3InLCAnbWludXMnLCAnZWl1cycsXG5cdFx0XHRcdCdhYicsICdhZCcsICduZW1vJywgJ2Z1Z2l0JywgJ29mZmljaWEnLCAnYXQnLCAnaW4nLCAnaWQnLCAncXVvcycsXG5cdFx0XHRcdCdyZXByZWhlbmRlcml0JywgJ251bXF1YW0nLCAnaXN0ZScsICdmdWdpYXQnLCAnc2l0JywgJ2ludmVudG9yZScsXG5cdFx0XHRcdCdiZWF0YWUnLCAncmVwZWxsZW5kdXMnLCAnbWFnbmFtJywgJ3JlY3VzYW5kYWUnLCAncXVvZCcsICdleHBsaWNhYm8nLFxuXHRcdFx0XHQnZG9sb3JlbXF1ZScsICdhcGVyaWFtJywgJ2NvbnNlcXVhdHVyJywgJ2FzcGVyaW9yZXMnLCAnY29tbW9kaScsXG5cdFx0XHRcdCdvcHRpbycsICdkb2xvcicsICdsYWJvcmUnLCAndGVtcG9yaWJ1cycsICdyZXBlbGxhdCcsICd2ZW5pYW0nLFxuXHRcdFx0XHQnYXJjaGl0ZWN0bycsICdlc3QnLCAnZXNzZScsICdtb2xsaXRpYScsICdudWxsYScsICdhJywgJ3NpbWlsaXF1ZScsXG5cdFx0XHRcdCdlb3MnLCAnYWxpYXMnLCAnZG9sb3JlJywgJ3RlbmV0dXInLCAnZGVsZW5pdGknLCAncG9ycm8nLCAnZmFjZXJlJyxcblx0XHRcdFx0J21heGltZScsICdjb3JydXB0aSddXG5cdFx0fSxcblx0XHRzcDoge1xuXHRcdFx0Y29tbW9uOiBbJ211amVyJywgJ3VubycsICdkb2xvcicsICdtw6FzJywgJ2RlJywgJ3BvZGVyJywgJ21pc21vJywgJ3NpJ10sXG5cdFx0XHR3b3JkczogWydlamVyY2ljaW8nLCAncHJlZmVyZW5jaWEnLCAncGVyc3BpY2FjaWEnLCAnbGFib3JhbCcsICdwYcOxbycsXG5cdFx0XHRcdCdzdW50dW9zbycsICdtb2xkZScsICduYW1pYmlhJywgJ3BsYW5lYWRvcicsICdtaXJhcicsICdkZW3DoXMnLCAnb2ZpY2luaXN0YScsICdleGNlcGNpw7NuJyxcblx0XHRcdFx0J29kaW8nLCAnY29uc2VjdWVuY2lhJywgJ2Nhc2knLCAnYXV0bycsICdjaGljaGFycmEnLCAndmVsbycsICdlbGl4aXInLFxuXHRcdFx0XHQnYXRhcXVlJywgJ25vJywgJ29kaW8nLCAndGVtcG9yYWwnLCAnY3XDs3J1bScsICdkaWduw61zaW1vJyxcblx0XHRcdFx0J2ZhY2lsaXNtbycsICdsZXRyYScsICduaWhpbGlzdGEnLCAnZXhwZWRpY2nDs24nLCAnYWxtYScsICdhbHZlb2xhcicsICdhcGFydGUnLFxuXHRcdFx0XHQnbGXDs24nLCAnYW5pbWFsJywgJ2NvbW8nLCAncGFyaWEnLCAnYmVsbGV6YScsICdtb2RvJywgJ25hdGl2aWRhZCcsXG5cdFx0XHRcdCdqdXN0bycsICdhdGFxdWUnLCAnc8OpcXVpdG8nLCAncGlsbG8nLCAnc2VkJywgJ2V4JywgJ3knLCAndm9sdW1pbm9zbycsXG5cdFx0XHRcdCd0ZW1wb3JhbGlkYWQnLCAndmVyZGFkZXMnLCAncmFjaW9uYWwnLCAnYXN1bmNpw7NuJywgJ2luY2lkZW50ZScsICdtYXJlamFkYScsXG5cdFx0XHRcdCdwbGFjZW50YScsICdhbWFuZWNlcicsICdmdWdhJywgJ3ByZXZpc29yJywgJ3ByZXNlbnRhY2nDs24nLCAnbGVqb3MnLFxuXHRcdFx0XHQnbmVjZXNhcmlhbWVudGUnLCAnc29zcGVjaG9zbycsICdhZGlwb3NpZGFkJywgJ3F1aW5kw61vJywgJ3DDs2NpbWEnLFxuXHRcdFx0XHQndm9sdWJsZScsICdkw6liaXRvJywgJ3NpbnRpw7MnLCAnYWNjZXNvcmlvJywgJ2ZhbGRhJywgJ3NhcGllbmNpYScsXG5cdFx0XHRcdCd2b2x1dGFzJywgJ3F1ZXNvJywgJ3Blcm1hY3VsdHVyYScsICdsYXVkbycsICdzb2x1Y2lvbmVzJywgJ2VudGVybycsXG5cdFx0XHRcdCdwYW4nLCAnbGl0cm8nLCAndG9uZWxhZGEnLCAnY3VscGEnLCAnbGliZXJ0YXJpbycsICdtb3NjYScsICdkaWN0YWRvJyxcblx0XHRcdFx0J3JlaW5jaWRlbnRlJywgJ25hc2NpbWllbnRvJywgJ2RvbG9yJywgJ2VzY29sYXInLCAnaW1wZWRpbWVudG8nLCAnbcOtbmltYScsXG5cdFx0XHRcdCdtYXlvcmVzJywgJ3JlcHVnbmFudGUnLCAnZHVsY2UnLCAnb2JjZWNhZG8nLCAnbW9udGHDsWEnLCAnZW5pZ21hJyxcblx0XHRcdFx0J3RvdGFsJywgJ2RlbGV0w6lyZW8nLCAnZMOpY2ltYScsICdjw6FiYWxhJywgJ2ZvdG9ncmFmw61hJywgJ2RvbG9yZXMnLFxuXHRcdFx0XHQnbW9sZXN0bycsICdvbHZpZG8nLCAncGFjaWVuY2lhJywgJ3Jlc2lsaWVuY2lhJywgJ3ZvbHVudGFkJywgJ21vbGVzdGlhcycsXG5cdFx0XHRcdCdtYWduw61maWNvJywgJ2Rpc3RpbmNpw7NuJywgJ292bmknLCAnbWFyZWphZGEnLCAnY2Vycm8nLCAndG9ycmUnLCAneScsXG5cdFx0XHRcdCdhYm9nYWRhJywgJ21hbmFudGlhbCcsICdjb3Jwb3JhbCcsICdhZ3VhJywgJ2NyZXDDunNjdWxvJywgJ2F0YXF1ZScsICdkZXNpZXJ0bycsXG5cdFx0XHRcdCdsYWJvcmlvc2FtZW50ZScsICdhbmd1c3RpYScsICdhZm9ydHVuYWRvJywgJ2FsbWEnLCAnZW5jZWZhbG9ncmFtYScsXG5cdFx0XHRcdCdtYXRlcmlhbGlkYWQnLCAnY29zYXMnLCAnbycsICdyZW51bmNpYScsICdlcnJvcicsICdtZW5vcycsICdjb25lam8nLFxuXHRcdFx0XHQnYWJhZMOtYScsICdhbmFsZmFiZXRvJywgJ3JlbW8nLCAnZnVnYWNpZGFkJywgJ29maWNpbycsICdlbicsICdhbG3DoWNpZ28nLCAndm9zJywgJ3BhbicsXG5cdFx0XHRcdCdyZXByZXNpw7NuJywgJ27Dum1lcm9zJywgJ3RyaXN0ZScsICdyZWZ1Z2lhZG8nLCAndHJvdGUnLCAnaW52ZW50b3InLFxuXHRcdFx0XHQnY29yY2hlYScsICdyZXBlbGVudGUnLCAnbWFnbWEnLCAncmVjdXNhZG8nLCAncGF0csOzbicsICdleHBsw61jaXRvJyxcblx0XHRcdFx0J3BhbG9tYScsICdzw61uZHJvbWUnLCAnaW5tdW5lJywgJ2F1dG9pbm11bmUnLCAnY29tb2RpZGFkJyxcblx0XHRcdFx0J2xleScsICd2aWV0bmFtaXRhJywgJ2RlbW9uaW8nLCAndGFzbWFuaWEnLCAncmVwZWxlcicsICdhcMOpbmRpY2UnLFxuXHRcdFx0XHQnYXJxdWl0ZWN0bycsICdjb2x1bW5hJywgJ3l1Z28nLCAnY29tcHV0YWRvcicsICdtdWxhJywgJ2EnLCAncHJvcMOzc2l0bycsXG5cdFx0XHRcdCdmYW50YXPDrWEnLCAnYWxpYXMnLCAncmF5bycsICd0ZW5lZG9yJywgJ2RlbGV6bmFibGUnLCAndmVudGFuYScsICdjYXJhJyxcblx0XHRcdFx0J2FuZW1pYScsICdjb3JydXB0byddXG5cdFx0fSxcblx0XHRydToge1xuXHRcdFx0Y29tbW9uOiBbJ9C00LDQu9C10LrQvi3QtNCw0LvQtdC60L4nLCAn0LfQsCcsICfRgdC70L7QstC10YHQvdGL0LzQuCcsICfQs9C+0YDQsNC80LgnLCAn0LIg0YHRgtGA0LDQvdC1JywgJ9Cz0LvQsNGB0L3Ri9GFJywgJ9C4INGB0L7Qs9C70LDRgdC90YvRhScsICfQttC40LLRg9GCJywgJ9GA0YvQsdC90YvQtScsICfRgtC10LrRgdGC0YsnXSxcblx0XHRcdHdvcmRzOiBbJ9Cy0LTQsNC70LgnLCAn0L7RgiDQstGB0LXRhScsICfQvtC90LgnLCAn0LHRg9C60LLQtdC90L3Ri9GFJywgJ9C00L7QvNCw0YUnLCAn0L3QsCDQsdC10YDQtdCz0YMnLCAn0YHQtdC80LDQvdGC0LjQutCwJywgXG5cdFx0XHRcdCfQsdC+0LvRjNGI0L7Qs9C+JywgJ9GP0LfRi9C60L7QstC+0LPQvicsICfQvtC60LXQsNC90LAnLCAn0LzQsNC70LXQvdGM0LrQuNC5JywgJ9GA0YPRh9C10LXQuicsICfQtNCw0LvRjCcsIFxuXHRcdFx0XHQn0LbRg9GA0YfQuNGCJywgJ9C/0L4g0LLRgdC10LknLCAn0L7QsdC10YHQv9C10YfQuNCy0LDQtdGCJywgJ9C10LUnLCfQstGB0LXQvNC4JywgJ9C90LXQvtCx0YXQvtC00LjQvNGL0LzQuCcsIFxuXHRcdFx0XHQn0L/RgNCw0LLQuNC70LDQvNC4JywgJ9GN0YLQsCcsICfQv9Cw0YDQsNC00LjQs9C80LDRgtC40YfQtdGB0LrQsNGPJywgJ9GB0YLRgNCw0L3QsCcsICfQutC+0YLQvtGA0L7QuScsICfQttCw0YDQtdC90L3Ri9C1JywgXG5cdFx0XHRcdCfQv9GA0LXQtNC70L7QttC10L3QuNGPJywgJ9C30LDQu9C10YLQsNGO0YInLCAn0L/RgNGP0LzQvicsICfRgNC+0YInLCAn0LTQsNC20LUnLCAn0LLRgdC10LzQvtCz0YPRidCw0Y8nLCBcblx0XHRcdFx0J9C/0YPQvdC60YLRg9Cw0YbQuNGPJywgJ9C90LUnLCAn0LjQvNC10LXRgicsICfQstC70LDRgdGC0LgnLCAn0L3QsNC0JywgJ9GA0YvQsdC90YvQvNC4JywgJ9GC0LXQutGB0YLQsNC80LgnLCBcblx0XHRcdFx0J9Cy0LXQtNGD0YnQuNC80LgnLCAn0LHQtdC30L7RgNGE0L7Qs9GA0LDRhNC40YfQvdGL0LknLCAn0L7QsdGA0LDQtycsICfQttC40LfQvdC4JywgJ9C+0LTQvdCw0LbQtNGLJywgJ9C+0LTQvdCwJywgXG5cdFx0XHRcdCfQvNCw0LvQtdC90YzQutCw0Y8nLCAn0YHRgtGA0L7Rh9C60LAnLCfRgNGL0LHQvdC+0LPQvicsICfRgtC10LrRgdGC0LAnLCAn0LjQvNC10L3QuCcsICdsb3JlbScsICdpcHN1bScsIFxuXHRcdFx0XHQn0YDQtdGI0LjQu9CwJywgJ9Cy0YvQudGC0LgnLCAn0LHQvtC70YzRiNC+0LknLCAn0LzQuNGAJywgJ9Cz0YDQsNC80LzQsNGC0LjQutC4JywgJ9Cy0LXQu9C40LrQuNC5JywgJ9C+0LrRgdC80L7QutGBJywgXG5cdFx0XHRcdCfQv9GA0LXQtNGD0L/RgNC10LbQtNCw0LsnLCAn0L4nLCAn0LfQu9GL0YUnLCAn0LfQsNC/0Y/RgtGL0YUnLCAn0LTQuNC60LjRhScsICfQt9C90LDQutCw0YUnLCAn0LLQvtC/0YDQvtGB0LAnLCBcblx0XHRcdFx0J9C60L7QstCw0YDQvdGL0YUnLCAn0YLQvtGH0LrQsNGFJywgJ9C30LDQv9GP0YLQvtC5JywgJ9C90L4nLCAn0YLQtdC60YHRgicsICfQtNCw0LsnLCAn0YHQsdC40YLRjCcsIFxuXHRcdFx0XHQn0YHQtdCx0Y8nLCAn0YLQvtC70LrRgycsICfQvtC9JywgJ9GB0L7QsdGA0LDQuycsICfRgdC10LzRjCcsICfRgdCy0L7QuNGFJywgJ9C30LDQs9C70LDQstC90YvRhScsICfQsdGD0LrQsicsIFxuXHRcdFx0XHQn0L/QvtC00L/QvtGP0YHQsNC7JywgJ9C40L3QuNGG0LjQsNC7JywgJ9C30LAnLCAn0L/QvtGP0YEnLCAn0L/Rg9GB0YLQuNC70YHRjycsICfQtNC+0YDQvtCz0YMnLCBcblx0XHRcdFx0J9Cy0LfQvtCx0YDQsNCy0YjQuNGB0YwnLCAn0L/QtdGA0LLRg9GOJywgJ9Cy0LXRgNGI0LjQvdGDJywgJ9C60YPRgNGB0LjQstC90YvRhScsICfQs9C+0YAnLCAn0LHRgNC+0YHQuNC7JywgXG5cdFx0XHRcdCfQv9C+0YHQu9C10LTQvdC40LknLCAn0LLQt9Cz0LvRj9C0JywgJ9C90LDQt9Cw0LQnLCAn0YHQuNC70YPRjdGCJywgJ9GB0LLQvtC10LPQvicsICfRgNC+0LTQvdC+0LPQvicsICfQs9C+0YDQvtC00LAnLCBcblx0XHRcdFx0J9Cx0YPQutCy0L7Qs9GA0LDQtCcsICfQt9Cw0LPQvtC70L7QstC+0LonLCAn0LTQtdGA0LXQstC90LgnLCAn0LDQu9GE0LDQstC40YInLCAn0L/QvtC00LfQsNCz0L7Qu9C+0LLQvtC6JywgJ9GB0LLQvtC10LPQvicsIFxuXHRcdFx0XHQn0L/QtdGA0LXRg9C70LrQsCcsICfQs9GA0YPRgdGC0L3Ri9C5JywgJ9GA0LXRgtC+0YDQuNGH0LXRgdC60LjQuScsICfQstC+0L/RgNC+0YEnLCAn0YHQutCw0YLQuNC70YHRjycsICfQtdCz0L4nLCBcblx0XHRcdFx0J9GJ0LXQutC1JywgJ9C/0YDQvtC00L7Qu9C20LjQuycsICfRgdCy0L7QuScsICfQv9GD0YLRjCcsICfQtNC+0YDQvtCz0LUnLCAn0LLRgdGC0YDQtdGC0LjQuycsICfRgNGD0LrQvtC/0LjRgdGMJywgXG5cdFx0XHRcdCfQvtC90LAnLCAn0L/RgNC10LTRg9C/0YDQtdC00LjQu9CwJywgICfQvNC+0LXQuScsICfQstGB0LUnLCAn0L/QtdGA0LXQv9C40YHRi9Cy0LDQtdGC0YHRjycsICfQvdC10YHQutC+0LvRjNC60L4nLCBcblx0XHRcdFx0J9GA0LDQtycsICfQtdC00LjQvdGB0YLQstC10L3QvdC+0LUnLCAn0YfRgtC+JywgJ9C80LXQvdGPJywgJ9C+0YHRgtCw0LvQvtGB0YwnLCAn0Y3RgtC+JywgJ9C/0YDQuNGB0YLQsNCy0LrQsCcsIFxuXHRcdFx0XHQn0LLQvtC30LLRgNCw0YnQsNC50YHRjycsICfRgtGLJywgJ9C70YPRh9GI0LUnLCAn0YHQstC+0Y4nLCAn0LHQtdC30L7Qv9Cw0YHQvdGD0Y4nLCAn0YHRgtGA0LDQvdGDJywgJ9C/0L7RgdC70YPRiNCw0LLRiNC40YHRjCcsIFxuXHRcdFx0XHQn0YDRg9C60L7Qv9C40YHQuCcsICfQvdCw0YgnLCAn0L/RgNC+0LTQvtC70LbQuNC7JywgJ9GB0LLQvtC5JywgJ9C/0YPRgtGMJywgJ9Cy0YHQutC+0YDQtScsICfQtdC80YMnLCBcblx0XHRcdFx0J9C/0L7QstGB0YLRgNC10YfQsNC70YHRjycsICfQutC+0LLQsNGA0L3Ri9C5JywgJ9GB0L7RgdGC0LDQstC40YLQtdC70YwnLCAn0YDQtdC60LvQsNC80L3Ri9GFJywgJ9GC0LXQutGB0YLQvtCyJywgXG5cdFx0XHRcdCfQvdCw0L/QvtC40LLRiNC40LknLCAn0Y/Qt9GL0LrQvtC8JywgJ9GA0LXRh9GM0Y4nLCAn0LfQsNC80LDQvdC40LLRiNC40LknLCAn0YHQstC+0LUnLCAn0LDQs9C10L3RgtGB0YLQstC+JywgXG5cdFx0XHRcdCfQutC+0YLQvtGA0L7QtScsICfQuNGB0L/QvtC70YzQt9C+0LLQsNC70L4nLCAn0YHQvdC+0LLQsCcsICfRgdC90L7QstCwJywgJ9GB0LLQvtC40YUnLCAn0L/RgNC+0LXQutGC0LDRhScsIFxuXHRcdFx0XHQn0LXRgdC70LgnLCAn0L/QtdGA0LXQv9C40YHQsNC70LgnLCAn0YLQvicsICfQttC40LLQtdGCJywgJ9GC0LDQvCcsICfQtNC+JywgJ9GB0LjRhScsICfQv9C+0YAnXVxuXHRcdH1cblx0fTtcblxuXHRcblx0cHJlZnMuZGVmaW5lKCdsb3JlbS5kZWZhdWx0TGFuZycsICdlbicsIFxuXHRcdCdEZWZhdWx0IGxhbmd1YWdlIG9mIGdlbmVyYXRlZCBkdW1teSB0ZXh0LiBDdXJyZW50bHksIDxjb2RlPmVuPC9jb2RlPlxcXG5cdFx0YW5kIDxjb2RlPnJ1PC9jb2RlPiBhcmUgc3VwcG9ydGVkLCBidXQgdXNlcnMgY2FuIGFkZCB0aGVpciBvd24gc3ludGF4ZXNcXFxuXHRcdHNlZSA8YSBocmVmPVwiaHR0cDovL2RvY3MuZW1tZXQuaW8vYWJicmV2aWF0aW9ucy9sb3JlbS1pcHN1bS9cIj5kb2NzPC9hPi4nKTtcblx0cHJlZnMuZGVmaW5lKCdsb3JlbS5vbWl0Q29tbW9uUGFydCcsIGZhbHNlLFxuXHRcdCdPbWl0IGNvbW1vbmx5IHVzZWQgcGFydCAoZS5nLiDigJxMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldOKAnCkgZnJvbSBnZW5lcmF0ZWQgdGV4dC4nKTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gPGNvZGU+ZnJvbTwvY29kZT4gYW5kIDxjb2RlPnRvPC9jb2RlPiB2YWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZyb21cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRvXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9XG5cdCAqL1xuXHRmdW5jdGlvbiByYW5kaW50KGZyb20sIHRvKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqICh0byAtIGZyb20pICsgZnJvbSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIHNhbXBsZShhcnIsIGNvdW50KSB7XG5cdFx0dmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0dmFyIGl0ZXJhdGlvbnMgPSBNYXRoLm1pbihsZW4sIGNvdW50KTtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKHJlc3VsdC5sZW5ndGggPCBpdGVyYXRpb25zKSB7XG5cdFx0XHR2YXIgcmFuZEl4ID0gcmFuZGludCgwLCBsZW4gLSAxKTtcblx0XHRcdGlmICghfnJlc3VsdC5pbmRleE9mKHJhbmRJeCkpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2gocmFuZEl4KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHJlc3VsdC5tYXAoZnVuY3Rpb24oaXgpIHtcblx0XHRcdHJldHVybiBhcnJbaXhdO1xuXHRcdH0pO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjaG9pY2UodmFsKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKVxuXHRcdFx0cmV0dXJuIHZhbC5jaGFyQXQocmFuZGludCgwLCB2YWwubGVuZ3RoIC0gMSkpO1xuXHRcdFxuXHRcdHJldHVybiB2YWxbcmFuZGludCgwLCB2YWwubGVuZ3RoIC0gMSldO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBzZW50ZW5jZSh3b3JkcywgZW5kKSB7XG5cdFx0aWYgKHdvcmRzLmxlbmd0aCkge1xuXHRcdFx0d29yZHNbMF0gPSB3b3Jkc1swXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmRzWzBdLnN1YnN0cmluZygxKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHdvcmRzLmpvaW4oJyAnKSArIChlbmQgfHwgY2hvaWNlKCc/IS4uLicpKTsgLy8gbW9yZSBkb3RzIHRoYW4gcXVlc3Rpb24gbWFya3Ncblx0fVxuXHRcblx0LyoqXG5cdCAqIEluc2VydCBjb21tYXMgYXQgcmFuZG9tbHkgc2VsZWN0ZWQgd29yZHMuIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdmFsdWVzXG5cdCAqIGluc2lkZSA8Y29kZT53b3JkczwvY29kZT4gYXJyYXkgXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzXG5cdCAqL1xuXHRmdW5jdGlvbiBpbnNlcnRDb21tYXMod29yZHMpIHtcblx0XHR2YXIgbGVuID0gd29yZHMubGVuZ3RoO1xuXG5cdFx0aWYgKGxlbiA8IDIpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdG90YWxDb21tYXMgPSAwO1xuXHRcdGlmIChsZW4gPiAzICYmIGxlbiA8PSA2KSB7XG5cdFx0XHR0b3RhbENvbW1hcyA9IHJhbmRpbnQoMCwgMSk7XG5cdFx0fSBlbHNlIGlmIChsZW4gPiA2ICYmIGxlbiA8PSAxMikge1xuXHRcdFx0dG90YWxDb21tYXMgPSByYW5kaW50KDAsIDIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0b3RhbENvbW1hcyA9IHJhbmRpbnQoMSwgNCk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIHBvcywgd29yZDsgaSA8IHRvdGFsQ29tbWFzOyBpKyspIHtcblx0XHRcdHBvcyA9IHJhbmRpbnQoMCwgd29yZHMubGVuZ3RoIC0gMik7XG5cdFx0XHR3b3JkID0gd29yZHNbcG9zXTtcblx0XHRcdGlmICh3b3JkLmNoYXJBdCh3b3JkLmxlbmd0aCAtIDEpICE9PSAnLCcpIHtcblx0XHRcdFx0d29yZHNbcG9zXSArPSAnLCc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGUgYSBwYXJhZ3JhcGggb2YgXCJMb3JlbSBpcHN1bVwiIHRleHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdvcmRDb3VudCBXb3JkcyBjb3VudCBpbiBwYXJhZ3JhcGhcblx0ICogQHBhcmFtIHtCb29sZWFufSBzdGFydFdpdGhDb21tb24gU2hvdWxkIHBhcmFncmFwaCBzdGFydCB3aXRoIGNvbW1vbiBcblx0ICogXCJsb3JlbSBpcHN1bVwiIHNlbnRlbmNlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyYWdyYXBoKGxhbmcsIHdvcmRDb3VudCwgc3RhcnRXaXRoQ29tbW9uKSB7XG5cdFx0dmFyIGRhdGEgPSBsYW5nc1tsYW5nXTtcblx0XHRpZiAoIWRhdGEpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0dmFyIHRvdGFsV29yZHMgPSAwO1xuXHRcdHZhciB3b3Jkcztcblx0XHRcblx0XHR3b3JkQ291bnQgPSBwYXJzZUludCh3b3JkQ291bnQsIDEwKTtcblx0XHRcblx0XHRpZiAoc3RhcnRXaXRoQ29tbW9uICYmIGRhdGEuY29tbW9uKSB7XG5cdFx0XHR3b3JkcyA9IGRhdGEuY29tbW9uLnNsaWNlKDAsIHdvcmRDb3VudCk7XG5cdFx0XHRpZiAod29yZHMubGVuZ3RoID4gNSkge1xuXHRcdFx0XHR3b3Jkc1s0XSArPSAnLCc7XG5cdFx0XHR9XG5cdFx0XHR0b3RhbFdvcmRzICs9IHdvcmRzLmxlbmd0aDtcblx0XHRcdHJlc3VsdC5wdXNoKHNlbnRlbmNlKHdvcmRzLCAnLicpKTtcblx0XHR9XG5cdFx0XG5cdFx0d2hpbGUgKHRvdGFsV29yZHMgPCB3b3JkQ291bnQpIHtcblx0XHRcdHdvcmRzID0gc2FtcGxlKGRhdGEud29yZHMsIE1hdGgubWluKHJhbmRpbnQoMiwgMzApLCB3b3JkQ291bnQgLSB0b3RhbFdvcmRzKSk7XG5cdFx0XHR0b3RhbFdvcmRzICs9IHdvcmRzLmxlbmd0aDtcblx0XHRcdGluc2VydENvbW1hcyh3b3Jkcyk7XG5cdFx0XHRyZXN1bHQucHVzaChzZW50ZW5jZSh3b3JkcykpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oJyAnKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogQWRkcyBuZXcgbGFuZ3VhZ2Ugd29yZHMgZm9yIExvcmVtIElwc3VtIGdlbmVyYXRvclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBsYW5nIFR3by1sZXR0ZXIgbGFuZyBkZWZpbml0aW9uXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgV29yZHMgZm9yIGxhbmd1YWdlLiBNYWlnaHQgYmUgZWl0aGVyIGEgc3BhY2Utc2VwYXJhdGVkIFxuXHRcdCAqIGxpc3Qgb2Ygd29yZHMgKFN0cmluZyksIEFycmF5IG9mIHdvcmRzIG9yIG9iamVjdCB3aXRoIDxjb2RlPnRleHQ8L2NvZGU+IGFuZFxuXHRcdCAqIDxjb2RlPmNvbW1vbjwvY29kZT4gcHJvcGVydGllc1xuXHRcdCAqL1xuXHRcdGFkZExhbmc6IGZ1bmN0aW9uKGxhbmcsIGRhdGEpIHtcblx0XHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0ZGF0YSA9IHtcblx0XHRcdFx0XHR3b3JkczogZGF0YS5zcGxpdCgnICcpLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gISFpdGVtO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdFx0ZGF0YSA9IHt3b3JkczogZGF0YX07XG5cdFx0XHR9XG5cblx0XHRcdGxhbmdzW2xhbmddID0gZGF0YTtcblx0XHR9LFxuXHRcdHByZXByb2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuXHRcdFx0dmFyIHJlID0gL14oPzpsb3JlbXxsaXBzdW0pKFthLXpdezJ9KT8oXFxkKikkL2ksIG1hdGNoO1xuXHRcdFx0dmFyIGFsbG93Q29tbW9uID0gIXByZWZzLmdldCgnbG9yZW0ub21pdENvbW1vblBhcnQnKTtcblx0XHRcdFxuXHRcdFx0LyoqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZSAqL1xuXHRcdFx0dHJlZS5maW5kQWxsKGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0aWYgKG5vZGUuX25hbWUgJiYgKG1hdGNoID0gbm9kZS5fbmFtZS5tYXRjaChyZSkpKSB7XG5cdFx0XHRcdFx0dmFyIHdvcmRDb3VuZCA9IG1hdGNoWzJdIHx8IDMwO1xuXHRcdFx0XHRcdHZhciBsYW5nID0gbWF0Y2hbMV0gfHwgcHJlZnMuZ2V0KCdsb3JlbS5kZWZhdWx0TGFuZycpIHx8ICdlbic7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gZm9yY2Ugbm9kZSBuYW1lIHJlc29sdmluZyBpZiBub2RlIHNob3VsZCBiZSByZXBlYXRlZFxuXHRcdFx0XHRcdC8vIG9yIGNvbnRhaW5zIGF0dHJpYnV0ZXMuIEluIHRoaXMgY2FzZSwgbm9kZSBzaG91bGQgYmUgb3V0cHV0ZWRcblx0XHRcdFx0XHQvLyBhcyB0YWcsIG90aGVyd2lzZSBhcyB0ZXh0LW9ubHkgbm9kZVxuXHRcdFx0XHRcdG5vZGUuX25hbWUgPSAnJztcblx0XHRcdFx0XHRub2RlLmRhdGEoJ2ZvcmNlTmFtZVJlc29sdmluZycsIG5vZGUuaXNSZXBlYXRpbmcoKSB8fCBub2RlLmF0dHJpYnV0ZUxpc3QoKS5sZW5ndGgpO1xuXHRcdFx0XHRcdG5vZGUuZGF0YSgncGFzdGVPdmVyd3JpdGVzJywgdHJ1ZSk7XG5cdFx0XHRcdFx0bm9kZS5kYXRhKCdwYXN0ZScsIGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBwYXJhZ3JhcGgobGFuZywgd29yZENvdW5kLCAhaSAmJiBhbGxvd0NvbW1vbik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn0pO1xuXG59LHtcIi4uL2Fzc2V0cy9wcmVmZXJlbmNlc1wiOlwiYXNzZXRzXFxcXHByZWZlcmVuY2VzLmpzXCJ9XSxcInBhcnNlclxcXFxhYmJyZXZpYXRpb24uanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEVtbWV0IGFiYnJldmlhdGlvbiBwYXJzZXIuXG4gKiBUYWtlcyBzdHJpbmcgYWJicmV2aWF0aW9uIGFuZCByZWN1cnNpdmVseSBwYXJzZXMgaXQgaW50byBhIHRyZWUuIFRoZSBwYXJzZWQgXG4gKiB0cmVlIGNhbiBiZSB0cmFuc2Zvcm1lZCBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHdpdGggXG4gKiA8Y29kZT50b1N0cmluZygpPC9jb2RlPiBtZXRob2QuIE5vdGUgdGhhdCBzdHJpbmcgcmVwcmVzZW50YXRpb24gaXMgZGVmaW5lZFxuICogYnkgY3VzdG9tIHByb2Nlc3NvcnMgKGNhbGxlZCA8aT5maWx0ZXJzPC9pPiksIG5vdCBieSBhYmJyZXZpYXRpb24gcGFyc2VyIFxuICogaXRzZWxmLlxuICogXG4gKiBUaGlzIG1vZHVsZSBjYW4gYmUgZXh0ZW5kZWQgd2l0aCBjdXN0b20gcHJlLS9wb3N0LXByb2Nlc3NvcnMgdG8gc2hhcGUtdXBcbiAqIGZpbmFsIHRyZWUgb3IgaXRzIHJlcHJlc2VudGF0aW9uLiBBY3R1YWxseSwgbWFueSBmZWF0dXJlcyBvZiBhYmJyZXZpYXRpb24gXG4gKiBlbmdpbmUgYXJlIGRlZmluZWQgaW4gb3RoZXIgbW9kdWxlcyBhcyB0cmVlIHByb2Nlc3NvcnNcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHRhYlN0b3BzID0gcmVxdWlyZSgnLi4vYXNzZXRzL3RhYlN0b3BzJyk7XG5cdHZhciBwcm9maWxlID0gcmVxdWlyZSgnLi4vYXNzZXRzL3Byb2ZpbGUnKTtcblx0dmFyIGZpbHRlcnMgPSByZXF1aXJlKCcuLi9maWx0ZXIvbWFpbicpO1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblx0dmFyIGFiYnJldmlhdGlvblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvYWJicmV2aWF0aW9uJyk7XG5cdHZhciBzdHJpbmdTdHJlYW0gPSByZXF1aXJlKCcuLi9hc3NldHMvc3RyaW5nU3RyZWFtJyk7XG5cblx0Ly8gcHJlLSBhbmQgcG9zdC1wcm9jZXNzb3Jjc1xuXHR2YXIgbG9yZW0gPSByZXF1aXJlKCcuLi9nZW5lcmF0b3IvbG9yZW0nKTtcblx0dmFyIHByb2NQYXN0ZWRDb250ZW50ID0gcmVxdWlyZSgnLi9wcm9jZXNzb3IvcGFzdGVkQ29udGVudCcpO1xuXHR2YXIgcHJvY1RhZ05hbWUgPSByZXF1aXJlKCcuL3Byb2Nlc3Nvci90YWdOYW1lJyk7XG5cdHZhciBwcm9jUmVzb3VyY2VNYXRjaGVyID0gcmVxdWlyZSgnLi9wcm9jZXNzb3IvcmVzb3VyY2VNYXRjaGVyJyk7XG5cdHZhciBwcm9jQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vcHJvY2Vzc29yL2F0dHJpYnV0ZXMnKTtcblx0dmFyIHByb2NIcmVmID0gcmVxdWlyZSgnLi9wcm9jZXNzb3IvaHJlZicpO1xuXG5cdHZhciByZVZhbGlkTmFtZSA9IC9eW1xcd1xcLVxcJFxcOkBcXCElXStcXCs/JC9pO1xuXHR2YXIgcmVXb3JkID0gL1tcXHdcXC06XFwkQF0vO1xuXHR2YXIgREVGQVVMVF9BVFRSX05BTUUgPSAnJWRlZmF1bHQnO1xuXHRcblx0dmFyIHBhaXJzID0ge1xuXHRcdCdbJzogJ10nLFxuXHRcdCcoJzogJyknLFxuXHRcdCd7JzogJ30nXG5cdH07XG5cdFxuXHR2YXIgc3BsaWNlRm4gPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xuXHRcblx0dmFyIHByZXByb2Nlc3NvcnMgPSBbXTtcblx0dmFyIHBvc3Rwcm9jZXNzb3JzID0gW107XG5cdHZhciBvdXRwdXRQcm9jZXNzb3JzID0gW107XG5cdFxuXHQvKipcblx0ICogQHR5cGUgQWJicmV2aWF0aW9uTm9kZVxuXHQgKi9cblx0ZnVuY3Rpb24gQWJicmV2aWF0aW9uTm9kZShwYXJlbnQpIHtcblx0XHQvKiogQHR5cGUgQWJicmV2aWF0aW9uTm9kZSAqL1xuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fYXR0cmlidXRlcyA9IFtdO1xuXHRcdFxuXHRcdC8qKiBAdHlwZSBTdHJpbmcgUmF3IGFiYnJldmlhdGlvbiBmb3IgY3VycmVudCBub2RlICovXG5cdFx0dGhpcy5hYmJyZXZpYXRpb24gPSAnJztcblx0XHR0aGlzLmNvdW50ZXIgPSAxO1xuXHRcdHRoaXMuX25hbWUgPSBudWxsO1xuXHRcdHRoaXMuX3RleHQgPSAnJztcblx0XHR0aGlzLnJlcGVhdENvdW50ID0gMTtcblx0XHR0aGlzLmhhc0ltcGxpY2l0UmVwZWF0ID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqIEN1c3RvbSBkYXRhIGRpY3Rpb25hcnkgKi9cblx0XHR0aGlzLl9kYXRhID0ge307XG5cdFx0XG5cdFx0Ly8gb3V0cHV0IHByb3BlcnRpZXNcblx0XHR0aGlzLnN0YXJ0ID0gJyc7XG5cdFx0dGhpcy5lbmQgPSAnJztcblx0XHR0aGlzLmNvbnRlbnQgPSAnJztcblx0XHR0aGlzLnBhZGRpbmcgPSAnJztcblx0fVxuXHRcblx0QWJicmV2aWF0aW9uTm9kZS5wcm90b3R5cGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQWRkcyBwYXNzZWQgbm9kZSBhcyBjaGlsZCBvciBjcmVhdGVzIG5ldyBjaGlsZFxuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gY2hpbGRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gSW5kZXggaW4gY2hpbGRyZW4gYXJyYXkgd2hlcmUgY2hpbGQgc2hvdWxkIFxuXHRcdCAqIGJlIGluc2VydGVkXG5cdFx0ICogQHJldHVybiB7QWJicmV2aWF0aW9uTm9kZX1cblx0XHQgKi9cblx0XHRhZGRDaGlsZDogZnVuY3Rpb24oY2hpbGQsIHBvc2l0aW9uKSB7XG5cdFx0XHRjaGlsZCA9IGNoaWxkIHx8IG5ldyBBYmJyZXZpYXRpb25Ob2RlKCk7XG5cdFx0XHRjaGlsZC5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZW9mIHBvc2l0aW9uID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UocG9zaXRpb24sIDAsIGNoaWxkKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiBjdXJyZW50IG5vZGVcblx0XHQgKiBAcmV0dXJucyB7QWJicmV2aWF0aW9uTm9kZX1cblx0XHQgKi9cblx0XHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbm9kZSA9IG5ldyBBYmJyZXZpYXRpb25Ob2RlKCk7XG5cdFx0XHR2YXIgYXR0cnMgPSBbJ2FiYnJldmlhdGlvbicsICdjb3VudGVyJywgJ19uYW1lJywgJ190ZXh0JywgJ3JlcGVhdENvdW50JywgJ2hhc0ltcGxpY2l0UmVwZWF0JywgJ3N0YXJ0JywgJ2VuZCcsICdjb250ZW50JywgJ3BhZGRpbmcnXTtcblx0XHRcdGF0dHJzLmZvckVhY2goZnVuY3Rpb24oYSkge1xuXHRcdFx0XHRub2RlW2FdID0gdGhpc1thXTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0XG5cdFx0XHQvLyBjbG9uZSBhdHRyaWJ1dGVzXG5cdFx0XHRub2RlLl9hdHRyaWJ1dGVzID0gdGhpcy5fYXR0cmlidXRlcy5tYXAoZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHMuZXh0ZW5kKHt9LCBhdHRyKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRub2RlLl9kYXRhID0gdXRpbHMuZXh0ZW5kKHt9LCB0aGlzLl9kYXRhKTtcblx0XHRcdFxuXHRcdFx0Ly8gY2xvbmUgY2hpbGRyZW5cblx0XHRcdG5vZGUuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0XHRjaGlsZCA9IGNoaWxkLmNsb25lKCk7XG5cdFx0XHRcdGNoaWxkLnBhcmVudCA9IG5vZGU7XG5cdFx0XHRcdHJldHVybiBjaGlsZDtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgY3VycmVudCBub2RlIGZyb20gcGFyZW504oCYcyBjaGlsZCBsaXN0XG5cdFx0ICogQHJldHVybnMge0FiYnJldmlhdGlvbk5vZGV9IEN1cnJlbnQgbm9kZSBpdHNlbGZcblx0XHQgKi9cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMucGFyZW50KSB7XG5cdFx0XHRcdHZhciBpeCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG5cdFx0XHRcdGlmICh+aXgpIHtcblx0XHRcdFx0XHR0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaXgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVwbGFjZXMgY3VycmVudCBub2RlIGluIHBhcmVudOKAmHMgY2hpbGRyZW4gbGlzdCB3aXRoIHBhc3NlZCBub2Rlc1xuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZSBSZXBsYWNlbWVudCBub2RlIG9yIGFycmF5IG9mIG5vZGVzXG5cdFx0ICovXG5cdFx0cmVwbGFjZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cdFx0XHR2YXIgaXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcblx0XHRcdHZhciBpdGVtcyA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0XHRcdHNwbGljZUZuLmFwcGx5KHBhcmVudC5jaGlsZHJlbiwgW2l4LCAxXS5jb25jYXQoaXRlbXMpKTtcblx0XHRcdFxuXHRcdFx0Ly8gdXBkYXRlIHBhcmVudFxuXHRcdFx0aXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdGl0ZW0ucGFyZW50ID0gcGFyZW50O1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWN1cnNpdmVseSBzZXRzIDxjb2RlPnByb3BlcnR5PC9jb2RlPiB0byA8Y29kZT52YWx1ZTwvY29kZT4gb2YgY3VycmVudFxuXHRcdCAqIG5vZGUgYW5kIGl0cyBjaGlsZHJlbiBcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcm9wZXJ0eSB0byB1cGRhdGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG5cdFx0ICovXG5cdFx0dXBkYXRlUHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHR0aGlzW25hbWVdID0gdmFsdWU7XG5cdFx0XHR0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRcdFx0Y2hpbGQudXBkYXRlUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRmluZHMgZmlyc3QgY2hpbGQgbm9kZSB0aGF0IG1hdGNoZXMgdHJ1dGggdGVzdCBmb3IgcGFzc2VkIFxuXHRcdCAqIDxjb2RlPmZuPC9jb2RlPiBmdW5jdGlvblxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdFx0ICogQHJldHVybnMge0FiYnJldmlhdGlvbk5vZGV9XG5cdFx0ICovXG5cdFx0ZmluZDogZnVuY3Rpb24oZm4pIHtcblx0XHRcdHJldHVybiB0aGlzLmZpbmRBbGwoZm4sIHthbW91bnQ6IDF9KVswXTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEZpbmRzIGFsbCBjaGlsZCBub2RlcyB0aGF0IG1hdGNoZXMgdHJ1dGggdGVzdCBmb3IgcGFzc2VkIFxuXHRcdCAqIDxjb2RlPmZuPC9jb2RlPiBmdW5jdGlvblxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdCAqL1xuXHRcdGZpbmRBbGw6IGZ1bmN0aW9uKGZuLCBzdGF0ZSkge1xuXHRcdFx0c3RhdGUgPSB1dGlscy5leHRlbmQoe2Ftb3VudDogMCwgZm91bmQ6IDB9LCBzdGF0ZSB8fCB7fSk7XG5cblx0XHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dmFyIGVsZW1OYW1lID0gZm4udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0ubmFtZSgpLnRvTG93ZXJDYXNlKCkgPT0gZWxlbU5hbWU7fTtcblx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHR0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRcdFx0aWYgKGZuKGNoaWxkKSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRzdGF0ZS5mb3VuZCsrO1xuXHRcdFx0XHRcdGlmIChzdGF0ZS5hbW91bnQgJiYgc3RhdGUuZm91bmQgPj0gc3RhdGUuYW1vdW50KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQuY29uY2F0KGNoaWxkLmZpbmRBbGwoZm4pKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0LmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiAhIWl0ZW07XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNldHMvZ2V0cyBjdXN0b20gZGF0YVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRkYXRhOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuXHRcdFx0XHR0aGlzLl9kYXRhW25hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBuYW1lIG9mIGN1cnJlbnQgbm9kZVxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0bmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbmFtZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbGlzdCBvZiBhdHRyaWJ1dGVzIGZvciBjdXJyZW50IG5vZGVcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0YXR0cmlidXRlTGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW1pemVBdHRyaWJ1dGVzKHRoaXMuX2F0dHJpYnV0ZXMuc2xpY2UoMCkpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBvciBzZXRzIGF0dHJpYnV0ZSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEF0dHJpYnV0ZSBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIE5ldyBhdHRyaWJ1dGUgdmFsdWUuIGBOdWxsYCB2YWx1ZSBcblx0XHQgKiB3aWxsIHJlbW92ZSBhdHRyaWJ1dGVcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGF0dHJpYnV0ZTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcblx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdHZhciB2YWxzID0gdGhpcy5fYXR0cmlidXRlcy5maWx0ZXIoZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGF0dHIubmFtZSA9PT0gbmFtZTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdFx0XHR2YWxzLmZvckVhY2goZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0XHRcdFx0dmFyIGl4ID0gdGhhdC5fYXR0cmlidXRlcy5pbmRleE9mKGF0dHIpO1xuXHRcdFx0XHRcdFx0aWYgKH5peCkge1xuXHRcdFx0XHRcdFx0XHR0aGF0Ll9hdHRyaWJ1dGVzLnNwbGljZShpeCwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBtb2RpZnkgYXR0cmlidXRlXG5cdFx0XHRcdHZhciBhdHRyTmFtZXMgPSB0aGlzLl9hdHRyaWJ1dGVzLm1hcChmdW5jdGlvbihhdHRyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGF0dHIubmFtZTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHZhciBpeCA9IGF0dHJOYW1lcy5pbmRleE9mKG5hbWUudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdGlmICh+aXgpIHtcblx0XHRcdFx0XHR0aGlzLl9hdHRyaWJ1dGVzW2l4XS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2F0dHJpYnV0ZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuICh1dGlscy5maW5kKHRoaXMuYXR0cmlidXRlTGlzdCgpLCBmdW5jdGlvbihhdHRyKSB7XG5cdFx0XHRcdHJldHVybiBhdHRyLm5hbWUgPT0gbmFtZTtcblx0XHRcdH0pIHx8IHt9KS52YWx1ZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgaW5kZXggb2YgY3VycmVudCBub2RlIGluIHBhcmVudOKAmHMgY2hpbGRyZW4gbGlzdFxuXHRcdCAqIEByZXR1cm5zIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0aW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKSA6IC0xO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2V0cyBob3cgbWFueSB0aW1lcyBjdXJyZW50IGVsZW1lbnQgc2hvdWxkIGJlIHJlcGVhdGVkXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfc2V0UmVwZWF0OiBmdW5jdGlvbihjb3VudCkge1xuXHRcdFx0aWYgKGNvdW50KSB7XG5cdFx0XHRcdHRoaXMucmVwZWF0Q291bnQgPSBwYXJzZUludChjb3VudCwgMTApIHx8IDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmhhc0ltcGxpY2l0UmVwZWF0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNldHMgYWJicmV2aWF0aW9uIHRoYXQgYmVsb25ncyB0byBjdXJyZW50IG5vZGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiclxuXHRcdCAqL1xuXHRcdHNldEFiYnJldmlhdGlvbjogZnVuY3Rpb24oYWJicikge1xuXHRcdFx0YWJiciA9IGFiYnIgfHwgJyc7XG5cdFx0XHRcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdFxuXHRcdFx0Ly8gZmluZCBtdWx0aXBsaWVyXG5cdFx0XHRhYmJyID0gYWJici5yZXBsYWNlKC9cXCooXFxkKyk/JC8sIGZ1bmN0aW9uKHN0ciwgcmVwZWF0Q291bnQpIHtcblx0XHRcdFx0dGhhdC5fc2V0UmVwZWF0KHJlcGVhdENvdW50KTtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuYWJicmV2aWF0aW9uID0gYWJicjtcblx0XHRcdFxuXHRcdFx0dmFyIGFiYnJUZXh0ID0gZXh0cmFjdFRleHQoYWJicik7XG5cdFx0XHRpZiAoYWJiclRleHQpIHtcblx0XHRcdFx0YWJiciA9IGFiYnJUZXh0LmVsZW1lbnQ7XG5cdFx0XHRcdHRoaXMuY29udGVudCA9IHRoaXMuX3RleHQgPSBhYmJyVGV4dC50ZXh0O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgYWJickF0dHJzID0gcGFyc2VBdHRyaWJ1dGVzKGFiYnIpO1xuXHRcdFx0aWYgKGFiYnJBdHRycykge1xuXHRcdFx0XHRhYmJyID0gYWJickF0dHJzLmVsZW1lbnQ7XG5cdFx0XHRcdHRoaXMuX2F0dHJpYnV0ZXMgPSBhYmJyQXR0cnMuYXR0cmlidXRlcztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5fbmFtZSA9IGFiYnI7XG5cdFx0XHRcblx0XHRcdC8vIHZhbGlkYXRlIG5hbWVcblx0XHRcdGlmICh0aGlzLl9uYW1lICYmICFyZVZhbGlkTmFtZS50ZXN0KHRoaXMuX25hbWUpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhYmJyZXZpYXRpb24nKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGN1cnJlbnQgbm9kZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHR2YWx1ZU9mOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG5cdFx0XHR2YXIgZW5kID0gdGhpcy5lbmQ7XG5cdFx0XHR2YXIgY29udGVudCA9IHRoaXMuY29udGVudDtcblx0XHRcdFxuXHRcdFx0Ly8gYXBwbHkgb3V0cHV0IHByb2Nlc3NvcnNcblx0XHRcdHZhciBub2RlID0gdGhpcztcblx0XHRcdG91dHB1dFByb2Nlc3NvcnMuZm9yRWFjaChmdW5jdGlvbihmbikge1xuXHRcdFx0XHRzdGFydCA9IGZuKHN0YXJ0LCBub2RlLCAnc3RhcnQnKTtcblx0XHRcdFx0Y29udGVudCA9IGZuKGNvbnRlbnQsIG5vZGUsICdjb250ZW50Jyk7XG5cdFx0XHRcdGVuZCA9IGZuKGVuZCwgbm9kZSwgJ2VuZCcpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0dmFyIGlubmVyQ29udGVudCA9IHRoaXMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0XHRcdHJldHVybiBjaGlsZC52YWx1ZU9mKCk7XG5cdFx0XHR9KS5qb2luKCcnKTtcblx0XHRcdFxuXHRcdFx0Y29udGVudCA9IGFiYnJldmlhdGlvblV0aWxzLmluc2VydENoaWxkQ29udGVudChjb250ZW50LCBpbm5lckNvbnRlbnQsIHtcblx0XHRcdFx0a2VlcFZhcmlhYmxlOiBmYWxzZVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzdGFydCArIHV0aWxzLnBhZFN0cmluZyhjb250ZW50LCB0aGlzLnBhZGRpbmcpICsgZW5kO1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBjdXJyZW50IG5vZGUgY29udGFpbnMgY2hpbGRyZW4gd2l0aCBlbXB0eSA8Y29kZT5leHByPC9jb2RlPlxuXHRcdCAqIHByb3BlcnR5XG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRoYXNFbXB0eUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhIXV0aWxzLmZpbmQodGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRcdFx0cmV0dXJuIGNoaWxkLmlzRW1wdHkoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgY3VycmVudCBub2RlIGhhcyBpbXBsaWVkIG5hbWUgdGhhdCBzaG91bGQgYmUgcmVzb2x2ZWRcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRoYXNJbXBsaWNpdE5hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICF0aGlzLl9uYW1lICYmICF0aGlzLmlzVGV4dE5vZGUoKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGF0IGN1cnJlbnQgZWxlbWVudCBpcyBhIGdyb3VwaW5nIG9uZSwgZS5nLiBoYXMgbm8gXG5cdFx0ICogcmVwcmVzZW50YXRpb24gYnV0IHNlcnZlcyBhcyBhIGNvbnRhaW5lciBmb3Igb3RoZXIgbm9kZXNcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0dyb3VwOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhdGhpcy5hYmJyZXZpYXRpb247XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgZW1wdHkgbm9kZSAoaS5lLiB3aXRob3V0IGFiYnJldmlhdGlvbikuIEl0IG1heSBiZSBhIFxuXHRcdCAqIGdyb3VwaW5nIG5vZGUgYW5kIHNob3VsZCBub3QgYmUgb3V0cHV0dGVkXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhdGhpcy5hYmJyZXZpYXRpb24gJiYgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoYXQgY3VycmVudCBub2RlIHNob3VsZCBiZSByZXBlYXRlZFxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzUmVwZWF0aW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnJlcGVhdENvdW50ID4gMSB8fCB0aGlzLmhhc0ltcGxpY2l0UmVwZWF0O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgY3VycmVudCBub2RlIGlzIGEgdGV4dC1vbmx5IG5vZGVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzVGV4dE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICF0aGlzLm5hbWUoKSAmJiAhdGhpcy5hdHRyaWJ1dGVMaXN0KCkubGVuZ3RoO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBub2RlIG1heSBiZSB1c2VkIHRvIGJ1aWxkIGVsZW1lbnRzIG9yIHNuaXBwZXRzXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhdGhpcy5pc0VtcHR5KCkgJiYgIXRoaXMuaXNUZXh0Tm9kZSgpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBsYXRlc3QgYW5kIGRlZXBlc3QgY2hpbGQgb2YgY3VycmVudCB0cmVlXG5cdFx0ICogQHJldHVybnMge0FiYnJldmlhdGlvbk5vZGV9XG5cdFx0ICovXG5cdFx0ZGVlcGVzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdHZhciBkZWVwZXN0Q2hpbGQgPSB0aGlzO1xuXHRcdFx0d2hpbGUgKGRlZXBlc3RDaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0ZGVlcGVzdENoaWxkID0gZGVlcGVzdENoaWxkLmNoaWxkcmVuW2RlZXBlc3RDaGlsZC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGRlZXBlc3RDaGlsZDtcblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBzdHJpcHBlZCBzdHJpbmc6IGEgc3RyaW5nIHdpdGhvdXQgZmlyc3QgYW5kIGxhc3QgY2hhcmFjdGVyLlxuXHQgKiBVc2VkIGZvciDigJx1bnF1b3RpbmfigJ0gc3RyaW5nc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBzdHJpcHBlZChzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnN1YnN0cmluZygxLCBzdHIubGVuZ3RoIC0gMSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNvbnN1bWVRdW90ZWRWYWx1ZShzdHJlYW0sIHF1b3RlKSB7XG5cdFx0dmFyIGNoO1xuXHRcdHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSkge1xuXHRcdFx0aWYgKGNoID09PSBxdW90ZSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdGlmIChjaCA9PSAnXFxcXCcpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBQYXJzZXMgYWJicmV2aWF0aW9uIGludG8gYSB0cmVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhYmJyXG5cdCAqIEByZXR1cm5zIHtBYmJyZXZpYXRpb25Ob2RlfVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VBYmJyZXZpYXRpb24oYWJicikge1xuXHRcdGFiYnIgPSB1dGlscy50cmltKGFiYnIpO1xuXHRcdFxuXHRcdHZhciByb290ID0gbmV3IEFiYnJldmlhdGlvbk5vZGUoKTtcblx0XHR2YXIgY29udGV4dCA9IHJvb3QuYWRkQ2hpbGQoKSwgY2g7XG5cdFx0XG5cdFx0LyoqIEB0eXBlIFN0cmluZ1N0cmVhbSAqL1xuXHRcdHZhciBzdHJlYW0gPSBzdHJpbmdTdHJlYW0uY3JlYXRlKGFiYnIpO1xuXHRcdHZhciBsb29wUHJvdGVjdG9yID0gMTAwMCwgbXVsdGlwbGllcjtcblx0XHR2YXIgYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0Y29udGV4dC5hZGRDaGlsZChjaGlsZCk7XG5cdFx0fTtcblxuXHRcdHZhciBjb25zdW1lQWJiciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdHN0cmVhbS5lYXRXaGlsZShmdW5jdGlvbihjKSB7XG5cdFx0XHRcdGlmIChjID09ICdbJyB8fCBjID09ICd7Jykge1xuXHRcdFx0XHRcdGlmIChzdHJlYW0uc2tpcFRvUGFpcihjLCBwYWlyc1tjXSkpIHtcblx0XHRcdFx0XHRcdHN0cmVhbS5iYWNrVXAoMSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFiYnJldmlhdGlvbjogbW8gbWF0Y2hpbmcgXCInICsgcGFpcnNbY10gKyAnXCIgZm91bmQgZm9yIGNoYXJhY3RlciBhdCAnICsgc3RyZWFtLnBvcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjID09ICcrJykge1xuXHRcdFx0XHRcdC8vIGxldCdzIHNlZSBpZiB0aGlzIGlzIGFuIGV4cGFuZG8gbWFya2VyXG5cdFx0XHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdFx0XHR2YXIgaXNNYXJrZXIgPSBzdHJlYW0uZW9sKCkgfHwgIH4nKz5eKicuaW5kZXhPZihzdHJlYW0ucGVlaygpKTtcblx0XHRcdFx0XHRzdHJlYW0uYmFja1VwKDEpO1xuXHRcdFx0XHRcdHJldHVybiBpc01hcmtlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGMgIT0gJygnICYmIGlzQWxsb3dlZENoYXIoYyk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdFxuXHRcdHdoaWxlICghc3RyZWFtLmVvbCgpICYmIC0tbG9vcFByb3RlY3RvciA+IDApIHtcblx0XHRcdGNoID0gc3RyZWFtLnBlZWsoKTtcblx0XHRcdFxuXHRcdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0XHRjYXNlICcoJzogLy8gYWJicmV2aWF0aW9uIGdyb3VwXG5cdFx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdFx0XHRpZiAoc3RyZWFtLnNraXBUb1BhaXIoJygnLCAnKScpKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5uZXIgPSBwYXJzZUFiYnJldmlhdGlvbihzdHJpcHBlZChzdHJlYW0uY3VycmVudCgpKSk7XG5cdFx0XHRcdFx0XHRpZiAoKG11bHRpcGxpZXIgPSBzdHJlYW0ubWF0Y2goL15cXCooXFxkKyk/LywgdHJ1ZSkpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuX3NldFJlcGVhdChtdWx0aXBsaWVyWzFdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aW5uZXIuY2hpbGRyZW4uZm9yRWFjaChhZGRDaGlsZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhYmJyZXZpYXRpb246IG1vIG1hdGNoaW5nIFwiKVwiIGZvdW5kIGZvciBjaGFyYWN0ZXIgYXQgJyArIHN0cmVhbS5wb3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0Y2FzZSAnPic6IC8vIGNoaWxkIG9wZXJhdG9yXG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQuYWRkQ2hpbGQoKTtcblx0XHRcdFx0XHRzdHJlYW0ubmV4dCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRjYXNlICcrJzogLy8gc2libGluZyBvcGVyYXRvclxuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudC5hZGRDaGlsZCgpO1xuXHRcdFx0XHRcdHN0cmVhbS5uZXh0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdGNhc2UgJ14nOiAvLyBjbGltYiB1cCBvcGVyYXRvclxuXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBjb250ZXh0LnBhcmVudCB8fCBjb250ZXh0O1xuXHRcdFx0XHRcdGNvbnRleHQgPSAocGFyZW50LnBhcmVudCB8fCBwYXJlbnQpLmFkZENoaWxkKCk7XG5cdFx0XHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0ZGVmYXVsdDogLy8gY29uc3VtZSBhYmJyZXZpYXRpb25cblx0XHRcdFx0XHRjb25zdW1lQWJicigpO1xuXHRcdFx0XHRcdGNvbnRleHQuc2V0QWJicmV2aWF0aW9uKHN0cmVhbS5jdXJyZW50KCkpO1xuXHRcdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChsb29wUHJvdGVjdG9yIDwgMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFbmRsZXNzIGxvb3AgZGV0ZWN0ZWQnKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHJvb3Q7XG5cdH1cblxuXHQvKipcblx0ICogU3BsaXRzIGF0dHJpYnV0ZSBzZXQgaW50byBhIGxpc3Qgb2YgYXR0cmlidXRlcyBzdHJpbmdcblx0ICogQHBhcmFtICB7U3RyaW5nfSBhdHRyU2V0IFxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIHNwbGl0QXR0cmlidXRlcyhhdHRyU2V0KSB7XG5cdFx0YXR0clNldCA9IHV0aWxzLnRyaW0oYXR0clNldCk7XG5cdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHQvLyBzcGxpdCBhdHRyaWJ1dGUgc2V0IGJ5IHNwYWNlc1xuXHRcdHZhciBzdHJlYW0gPSBzdHJpbmdTdHJlYW0oYXR0clNldCksIGNoO1xuXHRcdHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSkge1xuXHRcdFx0aWYgKGNoID09ICcgJykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKHV0aWxzLnRyaW0oc3RyZWFtLmN1cnJlbnQoKSkpO1xuXHRcdFx0XHQvLyBza2lwIHNwYWNlc1xuXHRcdFx0XHR3aGlsZSAoc3RyZWFtLnBlZWsoKSA9PSAnICcpIHtcblx0XHRcdFx0XHRzdHJlYW0ubmV4dCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdH0gZWxzZSBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuXHRcdFx0XHQvLyBza2lwIHZhbHVlcyBpbiBzdHJpbmdzXG5cdFx0XHRcdGlmICghc3RyZWFtLnNraXBTdHJpbmcoY2gpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBzZXQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHBhcnRzLnB1c2godXRpbHMudHJpbShzdHJlYW0uY3VycmVudCgpKSk7XG5cdFx0cmV0dXJuIHBhcnRzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgb3BlbmluZyBhbmQgY2xvc2luZyBxdW90ZXMgZnJvbSBnaXZlbiBzdHJpbmdcblx0ICogQHBhcmFtICB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gdW5xdW90ZShzdHIpIHtcblx0XHR2YXIgY2ggPSBzdHIuY2hhckF0KDApO1xuXHRcdGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKSB7XG5cdFx0XHRzdHIgPSBzdHIuc3Vic3RyKDEpO1xuXHRcdFx0dmFyIGxhc3QgPSBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKTtcblx0XHRcdGlmIChsYXN0ID09PSBjaCkge1xuXHRcdFx0XHRzdHIgPSBzdHIuc3Vic3RyKDAsIHN0ci5sZW5ndGggLSAxKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4dHJhY3QgYXR0cmlidXRlcyBhbmQgdGhlaXIgdmFsdWVzIGZyb20gYXR0cmlidXRlIHNldDogXG5cdCAqIDxjb2RlPlthdHRyIGNvbD0zIHRpdGxlPVwiUXVvdGVkIHN0cmluZ1wiXTwvY29kZT4gKHdpdGhvdXQgc3F1YXJlIGJyYWNlcylcblx0ICogQHBhcmFtIHtTdHJpbmd9IGF0dHJTZXRcblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gZXh0cmFjdEF0dHJpYnV0ZXMoYXR0clNldCkge1xuXHRcdHZhciByZUF0dHJOYW1lID0gL15bXFx3XFwtOlxcJEBdK1xcLj8kLztcblx0XHRyZXR1cm4gc3BsaXRBdHRyaWJ1dGVzKGF0dHJTZXQpLm1hcChmdW5jdGlvbihhdHRyKSB7XG5cdFx0XHQvLyBhdHRyaWJ1dGUgbmFtZTogW2F0dHJdXG5cdFx0XHRpZiAocmVBdHRyTmFtZS50ZXN0KGF0dHIpKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICcnO1xuXHRcdFx0XHRpZiAoYXR0ci5jaGFyQXQoYXR0ci5sZW5ndGggLSAxKSA9PSAnLicpIHtcblx0XHRcdFx0XHQvLyBhIGJvb2xlYW4gYXR0cmlidXRlXG5cdFx0XHRcdFx0YXR0ciA9IGF0dHIuc3Vic3RyKDAsIGF0dHIubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdFx0dmFsdWUgPSBhdHRyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bmFtZTogYXR0cixcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXR0cmlidXRlIHdpdGggdmFsdWU6IFtuYW1lPXZhbF0sIFtuYW1lPVwidmFsXCJdXG5cdFx0XHRpZiAofmF0dHIuaW5kZXhPZignPScpKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IGF0dHIuc3BsaXQoJz0nKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRuYW1lOiBwYXJ0cy5zaGlmdCgpLFxuXHRcdFx0XHRcdHZhbHVlOiB1bnF1b3RlKHBhcnRzLmpvaW4oJz0nKSlcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9va3MgbGlrZSBpdOKAmXMgaW1wbGllZCBhdHRyaWJ1dGVcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG5hbWU6IERFRkFVTFRfQVRUUl9OQU1FLFxuXHRcdFx0XHR2YWx1ZTogdW5xdW90ZShhdHRyKVxuXHRcdFx0fTtcblx0XHR9KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFBhcnNlcyB0YWcgYXR0cmlidXRlcyBleHRyYWN0ZWQgZnJvbSBhYmJyZXZpYXRpb24uIElmIGF0dHJpYnV0ZXMgZm91bmQsIFxuXHQgKiByZXR1cm5zIG9iamVjdCB3aXRoIDxjb2RlPmVsZW1lbnQ8L2NvZGU+IGFuZCA8Y29kZT5hdHRyaWJ1dGVzPC9jb2RlPlxuXHQgKiBwcm9wZXJ0aWVzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhYmJyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgPGNvZGU+bnVsbDwvY29kZT4gaWYgbm8gYXR0cmlidXRlcyBmb3VuZCBpbiBcblx0ICogYWJicmV2aWF0aW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoYWJicikge1xuXHRcdC8qXG5cdFx0ICogRXhhbXBsZSBvZiBpbmNvbWluZyBkYXRhOlxuXHRcdCAqICNoZWFkZXJcblx0XHQgKiAuc29tZS5kYXRhXG5cdFx0ICogLnNvbWUuZGF0YSNoZWFkZXJcblx0XHQgKiBbYXR0cl1cblx0XHQgKiAjaXRlbVthdHRyPUhlbGxvIG90aGVyPVwiV29ybGRcIl0uY2xhc3Ncblx0XHQgKi9cblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0dmFyIGF0dHJNYXAgPSB7JyMnOiAnaWQnLCAnLic6ICdjbGFzcyd9O1xuXHRcdHZhciBuYW1lRW5kID0gbnVsbDtcblx0XHRcblx0XHQvKiogQHR5cGUgU3RyaW5nU3RyZWFtICovXG5cdFx0dmFyIHN0cmVhbSA9IHN0cmluZ1N0cmVhbS5jcmVhdGUoYWJicik7XG5cdFx0d2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcblx0XHRcdHN3aXRjaCAoc3RyZWFtLnBlZWsoKSkge1xuXHRcdFx0XHRjYXNlICcjJzogLy8gaWRcblx0XHRcdFx0Y2FzZSAnLic6IC8vIGNsYXNzXG5cdFx0XHRcdFx0aWYgKG5hbWVFbmQgPT09IG51bGwpXG5cdFx0XHRcdFx0XHRuYW1lRW5kID0gc3RyZWFtLnBvcztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgYXR0ck5hbWUgPSBhdHRyTWFwW3N0cmVhbS5wZWVrKCldO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHN0cmVhbS5uZXh0KCk7XG5cdFx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdFx0XHRzdHJlYW0uZWF0V2hpbGUocmVXb3JkKTtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiBhdHRyTmFtZSwgXG5cdFx0XHRcdFx0XHR2YWx1ZTogc3RyZWFtLmN1cnJlbnQoKVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdbJzogLy9iZWdpbiBhdHRyaWJ1dGUgc2V0XG5cdFx0XHRcdFx0aWYgKG5hbWVFbmQgPT09IG51bGwpXG5cdFx0XHRcdFx0XHRuYW1lRW5kID0gc3RyZWFtLnBvcztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuXHRcdFx0XHRcdGlmICghc3RyZWFtLnNraXBUb1BhaXIoJ1snLCAnXScpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIHNldCBkZWZpbml0aW9uJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoXG5cdFx0XHRcdFx0XHRleHRyYWN0QXR0cmlidXRlcyhzdHJpcHBlZChzdHJlYW0uY3VycmVudCgpKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHN0cmVhbS5uZXh0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGlmICghcmVzdWx0Lmxlbmd0aClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdFxuXHRcdHJldHVybiB7XG5cdFx0XHRlbGVtZW50OiBhYmJyLnN1YnN0cmluZygwLCBuYW1lRW5kKSxcblx0XHRcdGF0dHJpYnV0ZXM6IG9wdGltaXplQXR0cmlidXRlcyhyZXN1bHQpXG5cdFx0fTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIE9wdGltaXplIGF0dHJpYnV0ZSBzZXQ6IHJlbW92ZSBkdXBsaWNhdGVzIGFuZCBtZXJnZSBjbGFzcyBhdHRyaWJ1dGVzXG5cdCAqIEBwYXJhbSBhdHRyc1xuXHQgKi9cblx0ZnVuY3Rpb24gb3B0aW1pemVBdHRyaWJ1dGVzKGF0dHJzKSB7XG5cdFx0Ly8gY2xvbmUgYWxsIGF0dHJpYnV0ZXMgdG8gbWFrZSBzdXJlIHRoYXQgb3JpZ2luYWwgb2JqZWN0cyBhcmUgXG5cdFx0Ly8gbm90IG1vZGlmaWVkXG5cdFx0YXR0cnMgPSBhdHRycy5tYXAoZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0cmV0dXJuIHV0aWxzLmNsb25lKGF0dHIpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHZhciBsb29rdXAgPSB7fTtcblxuXHRcdHJldHVybiBhdHRycy5maWx0ZXIoZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0aWYgKCEoYXR0ci5uYW1lIGluIGxvb2t1cCkpIHtcblx0XHRcdFx0cmV0dXJuIGxvb2t1cFthdHRyLm5hbWVdID0gYXR0cjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGxhID0gbG9va3VwW2F0dHIubmFtZV07XG5cdFx0XHRcblx0XHRcdGlmIChhdHRyLm5hbWUudG9Mb3dlckNhc2UoKSA9PSAnY2xhc3MnKSB7XG5cdFx0XHRcdGxhLnZhbHVlICs9IChsYS52YWx1ZS5sZW5ndGggPyAnICcgOiAnJykgKyBhdHRyLnZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGEudmFsdWUgPSBhdHRyLnZhbHVlO1xuXHRcdFx0XHRsYS5pc0ltcGxpZWQgPSAhIWF0dHIuaXNJbXBsaWVkO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBFeHRyYWN0IHRleHQgZGF0YSBmcm9tIGFiYnJldmlhdGlvbjogaWYgPGNvZGU+YXtoZWxsb308L2NvZGU+IGFiYnJldmlhdGlvblxuXHQgKiBpcyBwYXNzZWQsIHJldHVybnMgb2JqZWN0IDxjb2RlPntlbGVtZW50OiAnYScsIHRleHQ6ICdoZWxsbyd9PC9jb2RlPi5cblx0ICogSWYgbm90aGluZyBmb3VuZCwgcmV0dXJucyA8Y29kZT5udWxsPC9jb2RlPlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiclxuXHQgKiBcblx0ICovXG5cdGZ1bmN0aW9uIGV4dHJhY3RUZXh0KGFiYnIpIHtcblx0XHRpZiAoIX5hYmJyLmluZGV4T2YoJ3snKSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdFxuXHRcdC8qKiBAdHlwZSBTdHJpbmdTdHJlYW0gKi9cblx0XHR2YXIgc3RyZWFtID0gc3RyaW5nU3RyZWFtLmNyZWF0ZShhYmJyKTtcblx0XHR3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuXHRcdFx0c3dpdGNoIChzdHJlYW0ucGVlaygpKSB7XG5cdFx0XHRcdGNhc2UgJ1snOlxuXHRcdFx0XHRjYXNlICcoJzpcblx0XHRcdFx0XHRzdHJlYW0uc2tpcFRvUGFpcihzdHJlYW0ucGVlaygpLCBwYWlyc1tzdHJlYW0ucGVlaygpXSk7IGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRjYXNlICd7Jzpcblx0XHRcdFx0XHRzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuXHRcdFx0XHRcdHN0cmVhbS5za2lwVG9QYWlyKCd7JywgJ30nKTtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogYWJici5zdWJzdHJpbmcoMCwgc3RyZWFtLnN0YXJ0KSxcblx0XHRcdFx0XHRcdHRleHQ6IHN0cmlwcGVkKHN0cmVhbS5jdXJyZW50KCkpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRzdHJlYW0ubmV4dCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIOKAnFVuLXJvbGxz4oCcIGNvbnRlbnRzIG9mIGN1cnJlbnQgbm9kZTogcmVjdXJzaXZlbHkgcmVwbGFjZXMgYWxsIHJlcGVhdGluZyBcblx0ICogY2hpbGRyZW4gd2l0aCB0aGVpciByZXBlYXRlZCBjbG9uZXNcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdCAqIEByZXR1cm5zIHtBYmJyZXZpYXRpb25Ob2RlfVxuXHQgKi9cblx0ZnVuY3Rpb24gdW5yb2xsKG5vZGUpIHtcblx0XHRmb3IgKHZhciBpID0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLCBqLCBjaGlsZCwgbWF4Q291bnQ7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG5cdFx0XHRcblx0XHRcdGlmIChjaGlsZC5pc1JlcGVhdGluZygpKSB7XG5cdFx0XHRcdG1heENvdW50ID0gaiA9IGNoaWxkLnJlcGVhdENvdW50O1xuXHRcdFx0XHRjaGlsZC5yZXBlYXRDb3VudCA9IDE7XG5cdFx0XHRcdGNoaWxkLnVwZGF0ZVByb3BlcnR5KCdjb3VudGVyJywgMSk7XG5cdFx0XHRcdGNoaWxkLnVwZGF0ZVByb3BlcnR5KCdtYXhDb3VudCcsIG1heENvdW50KTtcblx0XHRcdFx0d2hpbGUgKC0taiA+IDApIHtcblx0XHRcdFx0XHRjaGlsZC5wYXJlbnQuYWRkQ2hpbGQoY2hpbGQuY2xvbmUoKSwgaSArIDEpXG5cdFx0XHRcdFx0XHQudXBkYXRlUHJvcGVydHkoJ2NvdW50ZXInLCBqICsgMSlcblx0XHRcdFx0XHRcdC51cGRhdGVQcm9wZXJ0eSgnbWF4Q291bnQnLCBtYXhDb3VudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gdG8ga2VlcCBwcm9wZXIgJ2NvdW50ZXInIHByb3BlcnR5LCB3ZSBuZWVkIHRvIHdhbGtcblx0XHQvLyBvbiBjaGlsZHJlbiBvbmNlIGFnYWluXG5cdFx0bm9kZS5jaGlsZHJlbi5mb3JFYWNoKHVucm9sbCk7XG5cdFx0XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBPcHRpbWl6ZXMgdHJlZSBub2RlOiByZXBsYWNlcyBlbXB0eSBub2RlcyB3aXRoIHRoZWlyIGNoaWxkcmVuXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHQgKiBAcmV0dXJuIHtBYmJyZXZpYXRpb25Ob2RlfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3F1YXNoKG5vZGUpIHtcblx0XHRmb3IgKHZhciBpID0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0LyoqIEB0eXBlIEFiYnJldmlhdGlvbk5vZGUgKi9cblx0XHRcdHZhciBuID0gbm9kZS5jaGlsZHJlbltpXTtcblx0XHRcdGlmIChuLmlzR3JvdXAoKSkge1xuXHRcdFx0XHRuLnJlcGxhY2Uoc3F1YXNoKG4pLmNoaWxkcmVuKTtcblx0XHRcdH0gZWxzZSBpZiAobi5pc0VtcHR5KCkpIHtcblx0XHRcdFx0bi5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0bm9kZS5jaGlsZHJlbi5mb3JFYWNoKHNxdWFzaCk7XG5cdFx0XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGlzQWxsb3dlZENoYXIoY2gpIHtcblx0XHR2YXIgY2hhckNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuXHRcdHZhciBzcGVjaWFsQ2hhcnMgPSAnIy4qOiQtXyFAfCUnO1xuXHRcdFxuXHRcdHJldHVybiAoY2hhckNvZGUgPiA2NCAmJiBjaGFyQ29kZSA8IDkxKSAgICAgICAvLyB1cHBlcmNhc2UgbGV0dGVyXG5cdFx0XHRcdHx8IChjaGFyQ29kZSA+IDk2ICYmIGNoYXJDb2RlIDwgMTIzKSAgLy8gbG93ZXJjYXNlIGxldHRlclxuXHRcdFx0XHR8fCAoY2hhckNvZGUgPiA0NyAmJiBjaGFyQ29kZSA8IDU4KSAgIC8vIG51bWJlclxuXHRcdFx0XHR8fCBzcGVjaWFsQ2hhcnMuaW5kZXhPZihjaCkgIT0gLTE7ICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVyXG5cdH1cblxuXHQvLyBYWFggYWRkIGNvdW50ZXIgcmVwbGFjZXIgZnVuY3Rpb24gYXMgb3V0cHV0IHByb2Nlc3NvclxuXHRvdXRwdXRQcm9jZXNzb3JzLnB1c2goZnVuY3Rpb24odGV4dCwgbm9kZSkge1xuXHRcdHJldHVybiB1dGlscy5yZXBsYWNlQ291bnRlcih0ZXh0LCBub2RlLmNvdW50ZXIsIG5vZGUubWF4Q291bnQpO1xuXHR9KTtcblxuXHQvLyBYWFggYWRkIHRhYnN0b3AgdXBkYXRlclxuXHRvdXRwdXRQcm9jZXNzb3JzLnB1c2godGFiU3RvcHMuYWJick91dHB1dFByb2Nlc3Nvci5iaW5kKHRhYlN0b3BzKSk7XG5cblx0Ly8gaW5jbHVkZSBkZWZhdWx0IHByZS0gYW5kIHBvc3Rwcm9jZXNzb3JzXG5cdFtsb3JlbSwgcHJvY1Jlc291cmNlTWF0Y2hlciwgcHJvY0F0dHJpYnV0ZXMsIHByb2NQYXN0ZWRDb250ZW50LCBwcm9jVGFnTmFtZSwgcHJvY0hyZWZdLmZvckVhY2goZnVuY3Rpb24obW9kKSB7XG5cdFx0aWYgKG1vZC5wcmVwcm9jZXNzb3IpIHtcblx0XHRcdHByZXByb2Nlc3NvcnMucHVzaChtb2QucHJlcHJvY2Vzc29yLmJpbmQobW9kKSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1vZC5wb3N0cHJvY2Vzc29yKSB7XG5cdFx0XHRwb3N0cHJvY2Vzc29ycy5wdXNoKG1vZC5wb3N0cHJvY2Vzc29yLmJpbmQobW9kKSk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4ge1xuXHRcdERFRkFVTFRfQVRUUl9OQU1FOiBERUZBVUxUX0FUVFJfTkFNRSxcblxuXHRcdC8qKlxuXHRcdCAqIFBhcnNlcyBhYmJyZXZpYXRpb24gaW50byB0cmVlIHdpdGggcmVzcGVjdCBvZiBncm91cHMsIFxuXHRcdCAqIHRleHQgbm9kZXMgYW5kIGF0dHJpYnV0ZXMuIEVhY2ggbm9kZSBvZiB0aGUgdHJlZSBpcyBhIHNpbmdsZSBcblx0XHQgKiBhYmJyZXZpYXRpb24uIFRyZWUgcmVwcmVzZW50cyBhY3R1YWwgc3RydWN0dXJlIG9mIHRoZSBvdXRwdXR0ZWQgXG5cdFx0ICogcmVzdWx0XG5cdFx0ICogQG1lbWJlck9mIGFiYnJldmlhdGlvblBhcnNlclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBhYmJyIEFiYnJldmlhdGlvbiB0byBwYXJzZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgcGFyc2VyIGFuZCBwcm9jZXNzb3JzXG5cdFx0ICogXG5cdFx0ICogQHJldHVybiB7QWJicmV2aWF0aW9uTm9kZX1cblx0XHQgKi9cblx0XHRwYXJzZTogZnVuY3Rpb24oYWJiciwgb3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRcblx0XHRcdHZhciB0cmVlID0gcGFyc2VBYmJyZXZpYXRpb24oYWJicik7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRcblx0XHRcdGlmIChvcHRpb25zLmNvbnRleHROb2RlKSB7XG5cdFx0XHRcdC8vIGFkZCBpbmZvIGFib3V0IGNvbnRleHQgbm9kZSDigJNcblx0XHRcdFx0Ly8gYSBwYXJlbnQgWEhUTUwgbm9kZSBpbiBlZGl0b3IgaW5zaWRlIHdoaWNoIGFiYnJldmlhdGlvbiBpcyBcblx0XHRcdFx0Ly8gZXhwYW5kZWRcblx0XHRcdFx0dHJlZS5fbmFtZSA9IG9wdGlvbnMuY29udGV4dE5vZGUubmFtZTtcblx0XHRcdFx0dmFyIGF0dHJMb29rdXAgPSB7fTtcblx0XHRcdFx0dHJlZS5fYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdFx0XHRhdHRyTG9va3VwW2F0dHIubmFtZV0gPSBhdHRyO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdG9wdGlvbnMuY29udGV4dE5vZGUuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdFx0XHRpZiAoYXR0ci5uYW1lIGluIGF0dHJMb29rdXApIHtcblx0XHRcdFx0XHRcdGF0dHJMb29rdXBbYXR0ci5uYW1lXS52YWx1ZSA9IGF0dHIudmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGF0dHIgPSB1dGlscy5jbG9uZShhdHRyKTtcblx0XHRcdFx0XHRcdHRyZWUuX2F0dHJpYnV0ZXMucHVzaChhdHRyKTtcblx0XHRcdFx0XHRcdGF0dHJMb29rdXBbYXR0ci5uYW1lXSA9IGF0dHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gYXBwbHkgcHJlcHJvY2Vzc29yc1xuXHRcdFx0cHJlcHJvY2Vzc29ycy5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHRcdGZuKHRyZWUsIG9wdGlvbnMsIHRoYXQpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmICgnY291bnRlcicgaW4gb3B0aW9ucykge1xuXHRcdFx0XHR0cmVlLnVwZGF0ZVByb3BlcnR5KCdjb3VudGVyJywgb3B0aW9ucy5jb3VudGVyKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dHJlZSA9IHNxdWFzaCh1bnJvbGwodHJlZSkpO1xuXHRcdFx0XG5cdFx0XHQvLyBhcHBseSBwb3N0cHJvY2Vzc29yc1xuXHRcdFx0cG9zdHByb2Nlc3NvcnMuZm9yRWFjaChmdW5jdGlvbihmbikge1xuXHRcdFx0XHRmbih0cmVlLCBvcHRpb25zLCB0aGF0KTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJlZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRXhwYW5kcyBnaXZlbiBhYmJyZXZpYXRpb24gaW50byBhIGZvcm1hdHRlZCBjb2RlIHN0cnVjdHVyZS5cblx0XHQgKiBUaGlzIGlzIHRoZSBtYWluIG1ldGhvZCB0aGF0IGlzIHVzZWQgZm9yIGV4cGFuZGluZyBhYmJyZXZpYXRpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiciBBYmJyZXZpYXRpb24gdG8gZXhwYW5kXG5cdFx0ICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgYWJicmV2aWF0aW9uXG5cdFx0ICogZXhwYW5kaW5nIGFuZCB0cmFuc2Zvcm1hdGlvbjogYHN5bnRheGAsIGBwcm9maWxlYCwgYGNvbnRleHROb2RlYCBldGMuXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oYWJiciwgb3B0aW9ucykge1xuXHRcdFx0aWYgKCFhYmJyKSByZXR1cm4gJyc7XG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdEZXByZWNhdGVkIHVzZSBvZiBgZXhwYW5kYCBtZXRob2Q6IGBvcHRpb25zYCBtdXN0IGJlIG9iamVjdCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdFx0aWYgKCFvcHRpb25zLnN5bnRheCkge1xuXHRcdFx0XHRvcHRpb25zLnN5bnRheCA9IHV0aWxzLmRlZmF1bHRTeW50YXgoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHAgPSBwcm9maWxlLmdldChvcHRpb25zLnByb2ZpbGUsIG9wdGlvbnMuc3ludGF4KTtcblx0XHRcdHRhYlN0b3BzLnJlc2V0VGFic3RvcEluZGV4KCk7XG5cdFx0XHRcblx0XHRcdHZhciBkYXRhID0gZmlsdGVycy5leHRyYWN0KGFiYnIpO1xuXHRcdFx0dmFyIG91dHB1dFRyZWUgPSB0aGlzLnBhcnNlKGRhdGFbMF0sIG9wdGlvbnMpO1xuXG5cdFx0XHR2YXIgZmlsdGVyc0xpc3QgPSBmaWx0ZXJzLmNvbXBvc2VMaXN0KG9wdGlvbnMuc3ludGF4LCBwLCBkYXRhWzFdKTtcblx0XHRcdGZpbHRlcnMuYXBwbHkob3V0cHV0VHJlZSwgZmlsdGVyc0xpc3QsIHApO1xuXG5cdFx0XHRyZXR1cm4gb3V0cHV0VHJlZS52YWx1ZU9mKCk7XG5cdFx0fSxcblx0XHRcblx0XHRBYmJyZXZpYXRpb25Ob2RlOiBBYmJyZXZpYXRpb25Ob2RlLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZCBuZXcgYWJicmV2aWF0aW9uIHByZXByb2Nlc3Nvci4gPGk+UHJlcHJvY2Vzc29yPC9pPiBpcyBhIGZ1bmN0aW9uXG5cdFx0ICogdGhhdCBhcHBsaWVzIHRvIGEgcGFyc2VkIGFiYnJldmlhdGlvbiB0cmVlIHJpZ2h0IGFmdGVyIGl0IGdldCBwYXJzZWQuXG5cdFx0ICogVGhlIHBhc3NlZCB0cmVlIGlzIGluIHVub3B0aW1pemVkIHN0YXRlLlxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFByZXByb2Nlc3NvciBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiByZWNlaXZlc1xuXHRcdCAqIHR3byBhcmd1bWVudHM6IHBhcnNlZCBhYmJyZXZpYXRpb24gdHJlZSAoPGNvZGU+QWJicmV2aWF0aW9uTm9kZTwvY29kZT4pXG5cdFx0ICogYW5kIDxjb2RlPm9wdGlvbnM8L2NvZGU+IGhhc2ggdGhhdCB3YXMgcGFzc2VkIHRvIDxjb2RlPnBhcnNlPC9jb2RlPlxuXHRcdCAqIG1ldGhvZFxuXHRcdCAqL1xuXHRcdGFkZFByZXByb2Nlc3NvcjogZnVuY3Rpb24oZm4pIHtcblx0XHRcdGlmICghfnByZXByb2Nlc3NvcnMuaW5kZXhPZihmbikpIHtcblx0XHRcdFx0cHJlcHJvY2Vzc29ycy5wdXNoKGZuKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgcmVnaXN0ZXJlZCBwcmVwcm9jZXNzb3Jcblx0XHQgKi9cblx0XHRyZW1vdmVGaWx0ZXI6IGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHR2YXIgaXggPSBwcmVwcm9jZXNzb3JzLmluZGV4T2YoZm4pO1xuXHRcdFx0aWYgKH5peCkge1xuXHRcdFx0XHRwcmVwcm9jZXNzb3JzLnNwbGljZShpeCwgMSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBBZGRzIG5ldyBhYmJyZXZpYXRpb24gcG9zdHByb2Nlc3Nvci4gPGk+UG9zdHByb2Nlc3NvcjwvaT4gaXMgYSBcblx0XHQgKiBmdW5jdGlub24gdGhhdCBhcHBsaWVzIHRvIDxpPm9wdGltaXplZDwvaT4gcGFyc2VkIGFiYnJldmlhdGlvbiB0cmVlXG5cdFx0ICogcmlnaHQgYmVmb3JlIGl0IHJldHVybnMgZnJvbSA8Y29kZT5wYXJzZSgpPC9jb2RlPiBtZXRob2Rcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQb3N0cHJvY2Vzc29yIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uIHJlY2VpdmVzXG5cdFx0ICogdHdvIGFyZ3VtZW50czogcGFyc2VkIGFiYnJldmlhdGlvbiB0cmVlICg8Y29kZT5BYmJyZXZpYXRpb25Ob2RlPC9jb2RlPilcblx0XHQgKiBhbmQgPGNvZGU+b3B0aW9uczwvY29kZT4gaGFzaCB0aGF0IHdhcyBwYXNzZWQgdG8gPGNvZGU+cGFyc2U8L2NvZGU+XG5cdFx0ICogbWV0aG9kXG5cdFx0ICovXG5cdFx0YWRkUG9zdHByb2Nlc3NvcjogZnVuY3Rpb24oZm4pIHtcblx0XHRcdGlmICghfnBvc3Rwcm9jZXNzb3JzLmluZGV4T2YoZm4pKSB7XG5cdFx0XHRcdHBvc3Rwcm9jZXNzb3JzLnB1c2goZm4pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyByZWdpc3RlcmVkIHBvc3Rwcm9jZXNzb3IgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRyZW1vdmVQb3N0cHJvY2Vzc29yOiBmdW5jdGlvbihmbikge1xuXHRcdFx0dmFyIGl4ID0gcG9zdHByb2Nlc3NvcnMuaW5kZXhPZihmbik7XG5cdFx0XHRpZiAofml4KSB7XG5cdFx0XHRcdHBvc3Rwcm9jZXNzb3JzLnNwbGljZShpeCwgMSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWdpc3RlcnMgb3V0cHV0IHBvc3Rwcm9jZXNzb3IuIDxpPk91dHB1dCBwcm9jZXNzb3I8L2k+IGlzIGEgXG5cdFx0ICogZnVuY3Rpb24gdGhhdCBhcHBsaWVzIHRvIG91dHB1dCBwYXJ0ICg8Y29kZT5zdGFydDwvY29kZT4sIFxuXHRcdCAqIDxjb2RlPmVuZDwvY29kZT4gYW5kIDxjb2RlPmNvbnRlbnQ8L2NvZGU+KSB3aGVuIFxuXHRcdCAqIDxjb2RlPkFiYnJldmlhdGlvbk5vZGUudG9TdHJpbmcoKTwvY29kZT4gbWV0aG9kIGlzIGNhbGxlZFxuXHRcdCAqL1xuXHRcdGFkZE91dHB1dFByb2Nlc3NvcjogZnVuY3Rpb24oZm4pIHtcblx0XHRcdGlmICghfm91dHB1dFByb2Nlc3NvcnMuaW5kZXhPZihmbikpIHtcblx0XHRcdFx0b3V0cHV0UHJvY2Vzc29ycy5wdXNoKGZuKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgcmVnaXN0ZXJlZCBvdXRwdXQgcHJvY2Vzc29yXG5cdFx0ICovXG5cdFx0cmVtb3ZlT3V0cHV0UHJvY2Vzc29yOiBmdW5jdGlvbihmbikge1xuXHRcdFx0dmFyIGl4ID0gb3V0cHV0UHJvY2Vzc29ycy5pbmRleE9mKGZuKTtcblx0XHRcdGlmICh+aXgpIHtcblx0XHRcdFx0b3V0cHV0UHJvY2Vzc29ycy5zcGxpY2UoaXgsIDEpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgcGFzc2VkIHN5bWJvbCBpcyB2YWxpZCBzeW1ib2wgZm9yIGFiYnJldmlhdGlvbiBleHByZXNzaW9uXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNoXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0FsbG93ZWRDaGFyOiBmdW5jdGlvbihjaCkge1xuXHRcdFx0Y2ggPSBTdHJpbmcoY2gpOyAvLyBjb252ZXJ0IEphdmEgb2JqZWN0IHRvIEpTXG5cdFx0XHRyZXR1cm4gaXNBbGxvd2VkQ2hhcihjaCkgfHwgfic+K15bXSgpe30nLmluZGV4T2YoY2gpO1xuXHRcdH1cblx0fTtcbn0pO1xufSx7XCIuLi9hc3NldHMvcHJvZmlsZVwiOlwiYXNzZXRzXFxcXHByb2ZpbGUuanNcIixcIi4uL2Fzc2V0cy9zdHJpbmdTdHJlYW1cIjpcImFzc2V0c1xcXFxzdHJpbmdTdHJlYW0uanNcIixcIi4uL2Fzc2V0cy90YWJTdG9wc1wiOlwiYXNzZXRzXFxcXHRhYlN0b3BzLmpzXCIsXCIuLi9maWx0ZXIvbWFpblwiOlwiZmlsdGVyXFxcXG1haW4uanNcIixcIi4uL2dlbmVyYXRvci9sb3JlbVwiOlwiZ2VuZXJhdG9yXFxcXGxvcmVtLmpzXCIsXCIuLi91dGlscy9hYmJyZXZpYXRpb25cIjpcInV0aWxzXFxcXGFiYnJldmlhdGlvbi5qc1wiLFwiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4vcHJvY2Vzc29yL2F0dHJpYnV0ZXNcIjpcInBhcnNlclxcXFxwcm9jZXNzb3JcXFxcYXR0cmlidXRlcy5qc1wiLFwiLi9wcm9jZXNzb3IvaHJlZlwiOlwicGFyc2VyXFxcXHByb2Nlc3NvclxcXFxocmVmLmpzXCIsXCIuL3Byb2Nlc3Nvci9wYXN0ZWRDb250ZW50XCI6XCJwYXJzZXJcXFxccHJvY2Vzc29yXFxcXHBhc3RlZENvbnRlbnQuanNcIixcIi4vcHJvY2Vzc29yL3Jlc291cmNlTWF0Y2hlclwiOlwicGFyc2VyXFxcXHByb2Nlc3NvclxcXFxyZXNvdXJjZU1hdGNoZXIuanNcIixcIi4vcHJvY2Vzc29yL3RhZ05hbWVcIjpcInBhcnNlclxcXFxwcm9jZXNzb3JcXFxcdGFnTmFtZS5qc1wifV0sXCJwYXJzZXJcXFxcY3NzLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHNlc3Npb24gPSB7dG9rZW5zOiBudWxsfTtcblx0XG5cdC8vIHdhbGtzIGFyb3VuZCB0aGUgc291cmNlXG5cdHZhciB3YWxrZXIgPSB7XG5cdFx0aW5pdDogZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0Ly8gdGhpcy5zb3VyY2UgPSBzb3VyY2UucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJyk7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblx0XHRcdHRoaXMuY2ggPSAnJztcblx0XHRcdHRoaXMuY2hudW0gPSAtMTtcblx0XHRcblx0XHRcdC8vIGFkdmFuY2Vcblx0XHRcdHRoaXMubmV4dENoYXIoKTtcblx0XHR9LFxuXHRcdG5leHRDaGFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jaCA9IHRoaXMuc291cmNlLmNoYXJBdCgrK3RoaXMuY2hudW0pO1xuXHRcdH0sXG5cdFx0cGVlazogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zb3VyY2UuY2hhckF0KHRoaXMuY2hudW0gKyAxKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gdXRpbGl0eSBoZWxwZXJzXG5cdGZ1bmN0aW9uIGlzTmFtZUNoYXIoYywgY2MpIHtcblx0XHRjYyA9IGNjIHx8IGMuY2hhckNvZGVBdCgwKTtcblx0XHRyZXR1cm4gKFxuXHRcdFx0KGNjID49IDk3ICYmIGNjIDw9IDEyMiAvKiBhLXogKi8pIHx8IFxuXHRcdFx0KGNjID49IDY1ICYmIGNjIDw9IDkwIC8qIEEtWiAqLykgfHwgXG5cdFx0XHQvKiBcblx0XHRcdEV4cGVyaW1lbnRhbDogaW5jbHVkZSBjeXJpbGxpYyByYW5nZXMgXG5cdFx0XHRzaW5jZSBzb21lIGxldHRlcnMsIHNpbWlsYXIgdG8gbGF0aW4gb25lcywgY2FuIFxuXHRcdFx0YWNjaWRlbnRhbGx5IGFwcGVhciBpbiBDU1MgdG9rZW5zXG5cdFx0XHQqL1xuXHRcdFx0KGNjID49IDEwMjQgJiYgY2MgPD0gMTI3OSkgfHwgXG5cdFx0XHRjID09PSAnJicgfHwgLyogc2VsZWN0b3IgcGxhY2Vob2xkZXIgKExFU1MsIFNDU1MpICovXG5cdFx0XHRjID09PSAnXycgfHwgXG5cdFx0XHRjID09PSAnPCcgfHwgLyogY29tcGFyaXNvbnMgKExFU1MsIFNDU1MpICovXG5cdFx0XHRjID09PSAnPicgfHwgXG5cdFx0XHRjID09PSAnPScgfHwgXG5cdFx0XHRjID09PSAnLSdcblx0XHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNEaWdpdChjLCBjYykge1xuXHRcdGNjID0gY2MgfHwgYy5jaGFyQ29kZUF0KDApO1xuXHRcdHJldHVybiAoY2MgPj0gNDggJiYgY2MgPD0gNTcpO1xuXHR9XG5cblx0dmFyIGlzT3AgPSAoZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvcHNhID0gXCJ7fVtdKCkrKj0uLDs6Pn58XFxcXCUkI0BeIVwiLnNwbGl0KCcnKSxcblx0XHRcdG9wc21hdGNoYSA9IFwiKl58JH5cIi5zcGxpdCgnJyksXG5cdFx0XHRvcHMgPSB7fSxcblx0XHRcdG9wc21hdGNoID0ge30sXG5cdFx0XHRpID0gMDtcblx0XHRmb3IgKDsgaSA8IG9wc2EubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdG9wc1tvcHNhW2ldXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDA7IGkgPCBvcHNtYXRjaGEubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdG9wc21hdGNoW29wc21hdGNoYVtpXV0gPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNoLCBtYXRjaGF0dHIpIHtcblx0XHRcdGlmIChtYXRjaGF0dHIpIHtcblx0XHRcdFx0cmV0dXJuIGNoIGluIG9wc21hdGNoO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoIGluIG9wcztcblx0XHR9O1xuXHR9KCkpO1xuXHRcblx0Ly8gY3JlYXRlcyB0b2tlbiBvYmplY3RzIGFuZCBwdXNoZXMgdGhlbSB0byBhIGxpc3Rcblx0ZnVuY3Rpb24gdG9rZW5lcih2YWx1ZSwgdHlwZSkge1xuXHRcdHNlc3Npb24udG9rZW5zLnB1c2goe1xuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0dHlwZTogIHR5cGUgfHwgdmFsdWUsXG5cdFx0XHRzdGFydDogbnVsbCxcblx0XHRcdGVuZDogICBudWxsXG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQb3NJbmZvKHcpIHtcblx0XHR2YXIgZXJyUG9zID0gdy5jaG51bTtcblx0XHR2YXIgc291cmNlID0gdy5zb3VyY2UucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJyk7XG5cdFx0dmFyIHBhcnQgPSB3LnNvdXJjZS5zdWJzdHJpbmcoMCwgZXJyUG9zICsgMSkucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJyk7XG5cdFx0dmFyIGxpbmVzID0gcGFydC5zcGxpdCgnXFxuJyk7XG5cdFx0dmFyIGNoID0gKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdIHx8ICcnKS5sZW5ndGg7XG5cdFx0dmFyIGZ1bGxMaW5lID0gc291cmNlLnNwbGl0KCdcXG4nKVtsaW5lcy5sZW5ndGggLSAxXSB8fCAnJztcblx0XHRcblx0XHR2YXIgY2h1bmtTaXplID0gMTAwO1xuXHRcdHZhciBvZmZzZXQgPSBNYXRoLm1heCgwLCBjaCAtIGNodW5rU2l6ZSk7XG5cdFx0dmFyIGZvcm1hdHRlZExpbmUgPSBmdWxsTGluZS5zdWJzdHIob2Zmc2V0LCBjaHVua1NpemUgKiAyKSArICdcXG4nO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2ggLSBvZmZzZXQgLSAxOyBpKyspIHtcblx0XHRcdGZvcm1hdHRlZExpbmUgKz0gJy0nO1xuXHRcdH1cblx0XHRmb3JtYXR0ZWRMaW5lICs9ICdeJztcblxuXHRcdHJldHVybiB7XG5cdFx0XHRsaW5lOiBsaW5lcy5sZW5ndGgsXG5cdFx0XHRjaDogY2gsXG5cdFx0XHR0ZXh0OiBmdWxsTGluZSxcblx0XHRcdGhpbnQ6IGZvcm1hdHRlZExpbmVcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gcmFpc2VFcnJvcihtZXNzYWdlKSB7XG5cdFx0dmFyIGVyciA9IGVycm9yKG1lc3NhZ2UpO1xuXHRcdHZhciBlcnJPYmogPSBuZXcgRXJyb3IoZXJyLm1lc3NhZ2UsICcnLCBlcnIubGluZSk7XG5cdFx0ZXJyT2JqLmxpbmUgPSBlcnIubGluZTtcblx0XHRlcnJPYmouY2ggPSBlcnIuY2g7XG5cdFx0ZXJyT2JqLm5hbWUgPSBlcnIubmFtZTtcblx0XHRlcnJPYmouaGludCA9IGVyci5oaW50O1xuXG5cdFx0dGhyb3cgZXJyT2JqO1xuXHR9XG5cdFxuXHQvLyBvb3BzXG5cdGZ1bmN0aW9uIGVycm9yKG0pIHsgXG5cdFx0dmFyIHcgPSB3YWxrZXI7XG5cdFx0dmFyIGluZm8gPSBnZXRQb3NJbmZvKHdhbGtlcik7XG5cdFx0dmFyIHRva2VucyA9IHNlc3Npb24udG9rZW5zO1xuXHRcdHNlc3Npb24udG9rZW5zID0gbnVsbDtcblxuXHRcdHZhciBtZXNzYWdlID0gJ0NTUyBwYXJzaW5nIGVycm9yIGF0IGxpbmUgJyArIGluZm8ubGluZSArICcsIGNoYXIgJyArIGluZm8uY2ggKyAnOiAnICsgbTtcblx0XHRtZXNzYWdlICs9ICdcXG4nICsgIGluZm8uaGludDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogXCJQYXJzZUVycm9yXCIsXG5cdFx0XHRtZXNzYWdlOiBtZXNzYWdlLFxuXHRcdFx0aGludDogaW5mby5oaW50LFxuXHRcdFx0bGluZTogaW5mby5saW5lLFxuXHRcdFx0Y2g6IGluZm8uY2hcblx0XHR9O1xuXHR9XG5cblxuXHQvLyB0b2tlbiBoYW5kbGVycyBmb2xsb3cgZm9yOlxuXHQvLyB3aGl0ZSBzcGFjZSwgY29tbWVudCwgc3RyaW5nLCBpZGVudGlmaWVyLCBudW1iZXIsIG9wZXJhdG9yXG5cdGZ1bmN0aW9uIHdoaXRlKCkge1xuXHRcdHZhciBjID0gd2Fsa2VyLmNoLFxuXHRcdFx0dG9rZW4gPSAnJztcblx0XG5cdFx0d2hpbGUgKGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFx0XCIpIHtcblx0XHRcdHRva2VuICs9IGM7XG5cdFx0XHRjID0gd2Fsa2VyLm5leHRDaGFyKCk7XG5cdFx0fVxuXHRcblx0XHR0b2tlbmVyKHRva2VuLCAnd2hpdGUnKTtcblx0XG5cdH1cblxuXHRmdW5jdGlvbiBjb21tZW50KCkge1xuXHRcdHZhciB3ID0gd2Fsa2VyLFxuXHRcdFx0YyA9IHcuY2gsXG5cdFx0XHR0b2tlbiA9IGMsXG5cdFx0XHRjbmV4dDtcblx0IFxuXHRcdGNuZXh0ID0gdy5uZXh0Q2hhcigpO1xuXG5cdFx0aWYgKGNuZXh0ID09PSAnLycpIHtcblx0XHRcdC8vIGlubGluZSBjb21tZW50IGluIFNDU1MgYW5kIExFU1Ncblx0XHRcdHdoaWxlIChjICYmICEoY25leHQgPT09IFwiXFxuXCIgfHwgY25leHQgPT09IFwiXFxyXCIpKSB7XG5cdFx0XHRcdHRva2VuICs9IGNuZXh0O1xuXHRcdFx0XHRjID0gY25leHQ7XG5cdFx0XHRcdGNuZXh0ID0gdy5uZXh0Q2hhcigpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY25leHQgPT09ICcqJykge1xuXHRcdFx0Ly8gbXVsdGlsaW5lIENTUyBjb21tbWVudFxuXHRcdFx0d2hpbGUgKGMgJiYgIShjID09PSBcIipcIiAmJiBjbmV4dCA9PT0gXCIvXCIpKSB7XG5cdFx0XHRcdHRva2VuICs9IGNuZXh0O1xuXHRcdFx0XHRjID0gY25leHQ7XG5cdFx0XHRcdGNuZXh0ID0gdy5uZXh0Q2hhcigpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBvb3BzLCBub3QgYSBjb21tZW50LCBqdXN0IGEgL1xuXHRcdFx0cmV0dXJuIHRva2VuZXIodG9rZW4sIHRva2VuKTtcblx0XHR9XG5cdFx0XG5cdFx0dG9rZW4gKz0gY25leHQ7XG5cdFx0dy5uZXh0Q2hhcigpO1xuXHRcdHRva2VuZXIodG9rZW4sICdjb21tZW50Jyk7XG5cdH1cblxuXHRmdW5jdGlvbiBlYXRTdHJpbmcoKSB7XG5cdFx0dmFyIHcgPSB3YWxrZXIsXG5cdFx0XHRjID0gdy5jaCxcblx0XHRcdHEgPSBjLFxuXHRcdFx0dG9rZW4gPSBjLFxuXHRcdFx0Y25leHQ7XG5cdFxuXHRcdGMgPSB3Lm5leHRDaGFyKCk7XG5cblx0XHR3aGlsZSAoYyAhPT0gcSkge1xuXHRcdFx0aWYgKGMgPT09ICdcXG4nKSB7XG5cdFx0XHRcdGNuZXh0ID0gdy5uZXh0Q2hhcigpO1xuXHRcdFx0XHRpZiAoY25leHQgPT09IFwiXFxcXFwiKSB7XG5cdFx0XHRcdFx0dG9rZW4gKz0gYyArIGNuZXh0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGVuZCBvZiBsaW5lIHdpdGggbm8gXFwgZXNjYXBlID0gYmFkXG5cdFx0XHRcdFx0cmFpc2VFcnJvcihcIlVudGVybWluYXRlZCBzdHJpbmdcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gJycpIHtcblx0XHRcdFx0cmFpc2VFcnJvcihcIlVudGVybWluYXRlZCBzdHJpbmdcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoYyA9PT0gXCJcXFxcXCIpIHtcblx0XHRcdFx0XHR0b2tlbiArPSBjICsgdy5uZXh0Q2hhcigpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRva2VuICs9IGM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcblx0XHRcdGMgPSB3Lm5leHRDaGFyKCk7XG5cdFx0fVxuXG5cdFx0dG9rZW4gKz0gYztcblxuXHRcdHJldHVybiB0b2tlbjtcblx0fVxuXG5cdGZ1bmN0aW9uIHN0cigpIHtcblx0XHR2YXIgdG9rZW4gPSBlYXRTdHJpbmcoKTtcblx0XHR3YWxrZXIubmV4dENoYXIoKTtcblx0XHR0b2tlbmVyKHRva2VuLCAnc3RyaW5nJyk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGJyYWNlKCkge1xuXHRcdHZhciB3ID0gd2Fsa2VyLFxuXHRcdFx0YyA9IHcuY2gsXG5cdFx0XHRkZXB0aCA9IDEsXG5cdFx0XHR0b2tlbiA9IGMsXG5cdFx0XHRzdG9wID0gZmFsc2U7XG5cdFxuXHRcdGMgPSB3Lm5leHRDaGFyKCk7XG5cdFxuXHRcdHdoaWxlIChjICYmICFzdG9wKSB7XG5cdFx0XHRpZiAoYyA9PT0gJygnKSB7XG5cdFx0XHRcdGRlcHRoKys7XG5cdFx0XHR9IGVsc2UgaWYgKGMgPT09ICcpJykge1xuXHRcdFx0XHRkZXB0aC0tO1xuXHRcdFx0XHRpZiAoIWRlcHRoKSB7XG5cdFx0XHRcdFx0c3RvcCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gJ1wiJyB8fCBjID09PSBcIidcIikge1xuXHRcdFx0XHRjID0gZWF0U3RyaW5nKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGMgPT09ICcnKSB7XG5cdFx0XHRcdHJhaXNlRXJyb3IoXCJVbnRlcm1pbmF0ZWQgYnJhY2VcIik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRva2VuICs9IGM7XG5cdFx0XHRjID0gdy5uZXh0Q2hhcigpO1xuXHRcdH1cblx0XHRcblx0XHR0b2tlbmVyKHRva2VuLCAnYnJhY2UnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlkZW50aWZpZXIocHJlKSB7XG5cdFx0dmFyIGMgPSB3YWxrZXIuY2g7XG5cdFx0dmFyIHRva2VuID0gcHJlID8gcHJlICsgYyA6IGM7XG5cdFx0XHRcblx0XHRjID0gd2Fsa2VyLm5leHRDaGFyKCk7XG5cdFx0dmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xuXHRcdHdoaWxlIChpc05hbWVDaGFyKGMsIGNjKSB8fCBpc0RpZ2l0KGMsIGNjKSkge1xuXHRcdFx0dG9rZW4gKz0gYztcblx0XHRcdGMgPSB3YWxrZXIubmV4dENoYXIoKTtcblx0XHRcdGNjID0gYy5jaGFyQ29kZUF0KDApO1xuXHRcdH1cblx0XG5cdFx0dG9rZW5lcih0b2tlbiwgJ2lkZW50aWZpZXInKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG51bSgpIHtcblx0XHR2YXIgdyA9IHdhbGtlcixcblx0XHRcdGMgPSB3LmNoLFxuXHRcdFx0dG9rZW4gPSBjLFxuXHRcdFx0cG9pbnQgPSB0b2tlbiA9PT0gJy4nLFxuXHRcdFx0bm9uZGlnaXQ7XG5cdFx0XG5cdFx0YyA9IHcubmV4dENoYXIoKTtcblx0XHRub25kaWdpdCA9ICFpc0RpZ2l0KGMpO1xuXHRcblx0XHQvLyAuMnB4IG9yIC5jbGFzc25hbWU/XG5cdFx0aWYgKHBvaW50ICYmIG5vbmRpZ2l0KSB7XG5cdFx0XHQvLyBtZWgsIE5hTiwgY291bGQgYmUgYSBjbGFzcyBuYW1lLCBzbyBpdCdzIGFuIG9wZXJhdG9yIGZvciBub3dcblx0XHRcdHJldHVybiB0b2tlbmVyKHRva2VuLCAnLicpOyAgICBcblx0XHR9XG5cdFx0XG5cdFx0Ly8gLTJweCBvciAtbW96LXNvbWV0aGluZ1xuXHRcdGlmICh0b2tlbiA9PT0gJy0nICYmIG5vbmRpZ2l0KSB7XG5cdFx0XHRyZXR1cm4gaWRlbnRpZmllcignLScpO1xuXHRcdH1cblx0XG5cdFx0d2hpbGUgKGMgIT09ICcnICYmIChpc0RpZ2l0KGMpIHx8ICghcG9pbnQgJiYgYyA9PT0gJy4nKSkpIHsgLy8gbm90IGVuZCBvZiBzb3VyY2UgJiYgZGlnaXQgb3IgZmlyc3QgaW5zdGFuY2Ugb2YgLlxuXHRcdFx0aWYgKGMgPT09ICcuJykge1xuXHRcdFx0XHRwb2ludCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR0b2tlbiArPSBjO1xuXHRcdFx0YyA9IHcubmV4dENoYXIoKTtcblx0XHR9XG5cblx0XHR0b2tlbmVyKHRva2VuLCAnbnVtYmVyJyk7ICAgIFxuXHRcblx0fVxuXG5cdGZ1bmN0aW9uIG9wKCkge1xuXHRcdHZhciB3ID0gd2Fsa2VyLFxuXHRcdFx0YyA9IHcuY2gsXG5cdFx0XHR0b2tlbiA9IGMsXG5cdFx0XHRuZXh0ID0gdy5uZXh0Q2hhcigpO1xuXHRcdFx0XG5cdFx0aWYgKG5leHQgPT09IFwiPVwiICYmIGlzT3AodG9rZW4sIHRydWUpKSB7XG5cdFx0XHR0b2tlbiArPSBuZXh0O1xuXHRcdFx0dG9rZW5lcih0b2tlbiwgJ21hdGNoJyk7XG5cdFx0XHR3Lm5leHRDaGFyKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSBcblx0XHRcblx0XHR0b2tlbmVyKHRva2VuLCB0b2tlbik7XG5cdH1cblxuXG5cdC8vIGNhbGwgdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXIgYmFzZWQgb24gdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHRva2VuIHN1c3BlY3Rcblx0ZnVuY3Rpb24gdG9rZW5pemUoKSB7XG5cdFx0dmFyIGNoID0gd2Fsa2VyLmNoO1xuXHRcblx0XHRpZiAoY2ggPT09IFwiIFwiIHx8IGNoID09PSBcIlxcdFwiKSB7XG5cdFx0XHRyZXR1cm4gd2hpdGUoKTtcblx0XHR9XG5cblx0XHRpZiAoY2ggPT09ICcvJykge1xuXHRcdFx0cmV0dXJuIGNvbW1lbnQoKTtcblx0XHR9IFxuXG5cdFx0aWYgKGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIikge1xuXHRcdFx0cmV0dXJuIHN0cigpO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoY2ggPT09ICcoJykge1xuXHRcdFx0cmV0dXJuIGJyYWNlKCk7XG5cdFx0fVxuXHRcblx0XHRpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nIHx8IGlzRGlnaXQoY2gpKSB7IC8vIHRyaWNreSAtIGNoYXI6IG1pbnVzICgtMXB4KSBvciBkYXNoICgtbW96LXN0dWZmKVxuXHRcdFx0cmV0dXJuIG51bSgpO1xuXHRcdH1cblx0XG5cdFx0aWYgKGlzTmFtZUNoYXIoY2gpKSB7XG5cdFx0XHRyZXR1cm4gaWRlbnRpZmllcigpO1xuXHRcdH1cblxuXHRcdGlmIChpc09wKGNoKSkge1xuXHRcdFx0cmV0dXJuIG9wKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGNoID09PSAnXFxyJykge1xuXHRcdFx0aWYgKHdhbGtlci5wZWVrKCkgPT09ICdcXG4nKSB7XG5cdFx0XHRcdGNoICs9IHdhbGtlci5uZXh0Q2hhcigpO1xuXHRcdFx0fVxuXG5cdFx0XHR0b2tlbmVyKGNoLCAnbGluZScpO1xuXHRcdFx0d2Fsa2VyLm5leHRDaGFyKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChjaCA9PT0gJ1xcbicpIHtcblx0XHRcdHRva2VuZXIoY2gsICdsaW5lJyk7XG5cdFx0XHR3YWxrZXIubmV4dENoYXIoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0cmFpc2VFcnJvcihcIlVucmVjb2duaXplZCBjaGFyYWN0ZXIgJ1wiICsgY2ggKyBcIidcIik7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIFNwcml0cyBnaXZlbiBzb3VyY2UgaW50byB0b2tlbnNcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdCAqL1xuXHRcdGxleDogZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0d2Fsa2VyLmluaXQoc291cmNlKTtcblx0XHRcdHNlc3Npb24udG9rZW5zID0gW107XG5cblx0XHRcdC8vIGZvciBlbXB0eSBzb3VyY2UsIHJldHVybiBzaW5nbGUgc3BhY2UgdG9rZW5cblx0XHRcdGlmICghc291cmNlKSB7XG5cdFx0XHRcdHNlc3Npb24udG9rZW5zLnB1c2godGhpcy53aGl0ZSgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICh3YWxrZXIuY2ggIT09ICcnKSB7XG5cdFx0XHRcdFx0dG9rZW5pemUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdG9rZW5zID0gc2Vzc2lvbi50b2tlbnM7XG5cdFx0XHRzZXNzaW9uLnRva2VucyA9IG51bGw7XG5cdFx0XHRyZXR1cm4gdG9rZW5zO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVG9rZW5pemVzIENTUyBzb3VyY2UuIEl0J3MgbGlrZSBgbGV4KClgIG1ldGhvZCxcblx0XHQgKiBidXQgYWxzbyBzdG9yZXMgcHJvcGVyIHRva2VuIGluZGV4ZXMgaW4gc291cmNlLCBcblx0XHQgKiBzbyBpdCdzIGEgYml0IHNsb3dlclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2Vcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0cGFyc2U6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0Ly8gdHJhbnNmb3JtIHRva2Vuc1xuXHRcdFx0dmFyIHRva2VucyA9IHRoaXMubGV4KHNvdXJjZSksIHBvcyA9IDAsIHRva2VuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGlsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cdFx0XHRcdHRva2VuLnN0YXJ0ID0gcG9zO1xuXHRcdFx0XHR0b2tlbi5lbmQgPSAocG9zICs9IHRva2VuLnZhbHVlLmxlbmd0aCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdG9rZW5zO1xuXHRcdH0sXG5cblx0XHR3aGl0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR2YWx1ZTogJycsXG5cdFx0XHRcdHR5cGU6ICAnd2hpdGUnLFxuXHRcdFx0XHRzdGFydDogMCxcblx0XHRcdFx0ZW5kOiAgIDBcblx0XHRcdH07XG5cdFx0fSxcblx0XHRcblx0XHR0b1NvdXJjZTogZnVuY3Rpb24odG9rcykge1xuXHRcdFx0dmFyIGkgPSAwLCBtYXggPSB0b2tzLmxlbmd0aCwgc3JjID0gJyc7XG5cdFx0XHRmb3IgKDsgaSA8IG1heDsgaSsrKSB7XG5cdFx0XHRcdHNyYyArPSB0b2tzW2ldLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNyYztcblx0XHR9XG5cdH07XG59KTtcbn0se31dLFwicGFyc2VyXFxcXHByb2Nlc3NvclxcXFxhdHRyaWJ1dGVzLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBSZXNvbHZlcyBub2RlIGF0dHJpYnV0ZSBuYW1lczogbW92ZXMgYGRlZmF1bHRgIGF0dHJpYnV0ZSB2YWx1ZVxuICogZnJvbSBzdHViIHRvIHJlYWwgYXR0cmlidXRlLlxuICpcbiAqIFRoaXMgcmVzb2x2ZXIgc2hvdWxkIGJlIGFwcGxpZWQgKmFmdGVyKiByZXNvdXJjZSBtYXRjaGVyXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbW1vbicpO1xuXG5cdHZhciBmaW5kRGVmYXVsdCA9IGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ci5pc0RlZmF1bHQ7XG5cdH07XG5cblx0dmFyIGZpbmRJbXBsaWVkID0gZnVuY3Rpb24oYXR0cikge1xuXHRcdHJldHVybiBhdHRyLmlzSW1wbGllZDtcblx0fTtcblxuXHR2YXIgZmluZEVtcHR5ID0gZnVuY3Rpb24oYXR0cikge1xuXHRcdHJldHVybiAhYXR0ci52YWx1ZTtcblx0fTtcblxuXHRmdW5jdGlvbiByZXNvbHZlRGVmYXVsdEF0dHJzKG5vZGUsIHBhcnNlcikge1xuXHRcdG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgYXR0ckxpc3QgPSBpdGVtLmF0dHJpYnV0ZUxpc3QoKTtcblx0XHRcdHZhciBkZWZhdWx0QXR0clZhbHVlID0gaXRlbS5hdHRyaWJ1dGUocGFyc2VyLkRFRkFVTFRfQVRUUl9OQU1FKTtcblx0XHRcdGlmICh0eXBlb2YgZGVmYXVsdEF0dHJWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0Ly8gcmVtb3ZlIHN0dWIgYXR0cmlidXRlXG5cdFx0XHRcdGl0ZW0uYXR0cmlidXRlKHBhcnNlci5ERUZBVUxUX0FUVFJfTkFNRSwgbnVsbCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYXR0ckxpc3QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly8gdGFyZ2V0IGZvciBkZWZhdWx0IHZhbHVlOlxuXHRcdFx0XHRcdC8vIDEuIGRlZmF1bHQgYXR0cmlidXRlXG5cdFx0XHRcdFx0Ly8gMi4gaW1wbGllZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHQvLyAzLiBmaXJzdCBlbXB0eSBhdHRyaWJ1dGVcblx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gZmluZCBhdHRyaWJ1dGUgbWFya2VkIGFzIGRlZmF1bHRcblx0XHRcdFx0XHR2YXIgZGVmYXVsdEF0dHIgPSB1dGlscy5maW5kKGF0dHJMaXN0LCBmaW5kRGVmYXVsdCkgXG5cdFx0XHRcdFx0XHR8fCB1dGlscy5maW5kKGF0dHJMaXN0LCBmaW5kSW1wbGllZCkgXG5cdFx0XHRcdFx0XHR8fCB1dGlscy5maW5kKGF0dHJMaXN0LCBmaW5kRW1wdHkpO1xuXG5cdFx0XHRcdFx0aWYgKGRlZmF1bHRBdHRyKSB7XG5cdFx0XHRcdFx0XHR2YXIgb2xkVmFsID0gaXRlbS5hdHRyaWJ1dGUoZGVmYXVsdEF0dHIubmFtZSk7XG5cdFx0XHRcdFx0XHR2YXIgbmV3VmFsID0gdXRpbHMucmVwbGFjZVVuZXNjYXBlZFN5bWJvbChvbGRWYWwsICd8JywgZGVmYXVsdEF0dHJWYWx1ZSk7XG5cdFx0XHRcdFx0XHQvLyBubyByZXBsYWNlbWVudCwgZS5nLiBkZWZhdWx0IHZhbHVlIGRvZXMgbm90IGNvbnRhaW5zIHwgc3ltYm9sXG5cdFx0XHRcdFx0XHRpZiAob2xkVmFsID09IG5ld1ZhbCkge1xuXHRcdFx0XHRcdFx0XHRuZXdWYWwgPSBkZWZhdWx0QXR0clZhbHVlXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGl0ZW0uYXR0cmlidXRlKGRlZmF1bHRBdHRyLm5hbWUsIG5ld1ZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBpZiBubyBkZWZhdWx0IGF0dHJpYnV0ZSB2YWx1ZSwgcmVtb3ZlIGltcGxpZWQgYXR0cmlidXRlc1xuXHRcdFx0XHRhdHRyTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdFx0XHRpZiAoYXR0ci5pc0ltcGxpZWQpIHtcblx0XHRcdFx0XHRcdGl0ZW0uYXR0cmlidXRlKGF0dHIubmFtZSwgbnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cmVzb2x2ZURlZmF1bHRBdHRycyhpdGVtLCBwYXJzZXIpO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBAcGFyYW0gIHtBYmJyZXZpYXRpb25Ob2RlfSB0cmVlXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG5cdFx0ICogQHBhcmFtICB7YWJicmV2aWF0aW9ufSBwYXJzZXJcblx0XHQgKi9cblx0XHRwcmVwcm9jZXNzb3I6IGZ1bmN0aW9uKHRyZWUsIG9wdGlvbnMsIHBhcnNlcikge1xuXHRcdFx0cmVzb2x2ZURlZmF1bHRBdHRycyh0cmVlLCBwYXJzZXIpO1xuXHRcdH1cblx0fTtcbn0pO1xufSx7XCIuLi8uLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wifV0sXCJwYXJzZXJcXFxccHJvY2Vzc29yXFxcXGhyZWYuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEEgcHJlcHRvY2Vzc29yIGZvciAmbHQ7YSZndDsgdGFnOiB0ZXN0cyB3cmFwcGVkIGNvbnRlbnRcbiAqIGZvciBjb21tb24gVVJMIHBhdHRlcm5zIGFuZCwgaWYgbWF0Y2hlZCwgaW5zZXJ0cyBpdCBhcyBcbiAqIGBocmVmYCBhdHRyaWJ1dGVcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHByZWZzID0gcmVxdWlyZSgnLi4vLi4vYXNzZXRzL3ByZWZlcmVuY2VzJyk7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgcGMgPSByZXF1aXJlKCcuL3Bhc3RlZENvbnRlbnQnKTtcblxuXHRwcmVmcy5kZWZpbmUoJ2hyZWYuYXV0b2RldGVjdCcsIHRydWUsIFxuXHRcdCdFbmFibGVzIG9yIGRpc2FibGVzIGF1dG9tYXRpYyBVUkwgcmVjb2duaXRpb24gd2hlbiB3cmFwcGluZ1xcXG5cdFx0dGV4dCB3aXRoIDxjb2RlPiZsdDthJmd0OzwvY29kZT4gdGFnLiBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsXFxcblx0XHRpZiB3cmFwcGVkIHRleHQgbWF0Y2hlcyBVUkwgb3IgZS1tYWlsIHBhdHRlcm4gaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5XFxcblx0XHRpbnNlcnRlZCBpbnRvIDxjb2RlPmhyZWY8L2NvZGU+IGF0dHJpYnV0ZS4nKTtcblx0cHJlZnMuZGVmaW5lKCdocmVmLnVybFBhdHRlcm4nLCAnXig/Oig/Omh0dHBzP3xmdHB8ZmlsZSk6Ly98d3d3XFxcXC58ZnRwXFxcXC4pKD86XFxcXChbLUEtWjAtOSsmQCMvJT1+X3wkPyE6LC5dKlxcXFwpfFstQS1aMC05KyZAIy8lPX5ffCQ/ITosLl0pKig/OlxcXFwoWy1BLVowLTkrJkAjLyU9fl98JD8hOiwuXSpcXFxcKXxbQS1aMC05KyZAIy8lPX5ffCRdKScsIFxuXHRcdCdSZWdFeHAgcGF0dGVybiB0byBtYXRjaCB3cmFwcGVkIFVSTHMuIE1hdGNoZWQgY29udGVudCB3aWxsIGJlIGluc2VydHNcXFxuXHRcdGFzLWlzIGludG8gPGNvZGU+aHJlZjwvY29kZT4gYXR0cmlidXRlLCBvbmx5IHdoaXRlc3BhY2Ugd2lsbCBiZSB0cmltbWVkLicpO1xuXG5cdHByZWZzLmRlZmluZSgnaHJlZi5lbWFpbFBhdHRlcm4nLCAnXlthLXowLTkuXyUrLV0rQFthLXowLTkuLV0rXFxcXC5bYS16XXsyLDV9JCcsIFxuXHRcdCdSZWdFeHAgcGF0dGVybiB0byBtYXRjaCB3cmFwcGVkIGUtbWFpbHMuIFVubGlrZSA8Y29kZT5ocmVmLnVybFBhdHRlcm48L2NvZGU+LFxcXG5cdFx0d3JhcHBlZCBjb250ZW50IHdpbGwgYmUgcHJlZml4ZWQgd2l0aCA8Y29kZT5tYWlsdG86PC9jb2RlPiBpbiA8Y29kZT5ocmVmPC9jb2RlPlxcXG5cdFx0YXR0cmlidXRlJyk7XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IHRyZWVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqL1xuXHRcdHBvc3Rwcm9jZXNzb3I6IGZ1bmN0aW9uKHRyZWUsIG9wdGlvbnMpIHtcblx0XHRcdGlmICghcHJlZnMuZ2V0KCdocmVmLmF1dG9kZXRlY3QnKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciByZVVybCA9IG5ldyBSZWdFeHAocHJlZnMuZ2V0KCdocmVmLnVybFBhdHRlcm4nKSwgJ2knKTtcblx0XHRcdHZhciByZUVtYWlsID0gbmV3IFJlZ0V4cChwcmVmcy5nZXQoJ2hyZWYuZW1haWxQYXR0ZXJuJyksICdpJyk7XG5cdFx0XHR2YXIgcmVQcm90byA9IC9eKFthLXpdKzopP1xcL1xcLy9pO1xuXG5cdFx0XHR0cmVlLmZpbmRBbGwoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRpZiAoaXRlbS5uYW1lKCkudG9Mb3dlckNhc2UoKSAhPSAnYScgfHwgaXRlbS5hdHRyaWJ1dGUoJ2hyZWYnKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwYXN0ZWRDb250ZW50ID0gdXRpbHMudHJpbShwYy5wYXN0ZWRDb250ZW50KGl0ZW0pIHx8IG9wdGlvbnMucGFzdGVkQ29udGVudCk7XG5cdFx0XHRcdGlmIChwYXN0ZWRDb250ZW50KSB7XG5cdFx0XHRcdFx0aWYgKHJlVXJsLnRlc3QocGFzdGVkQ29udGVudCkpIHtcblx0XHRcdFx0XHRcdC8vIGRvIHdlIGhhdmUgcHJvdG9jb2w/XG5cdFx0XHRcdFx0XHRpZiAoIXJlUHJvdG8udGVzdChwYXN0ZWRDb250ZW50KSkge1xuXHRcdFx0XHRcdFx0XHRwYXN0ZWRDb250ZW50ID0gJ2h0dHA6Ly8nICsgcGFzdGVkQ29udGVudDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aXRlbS5hdHRyaWJ1dGUoJ2hyZWYnLCBwYXN0ZWRDb250ZW50KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJlRW1haWwudGVzdChwYXN0ZWRDb250ZW50KSkge1xuXHRcdFx0XHRcdFx0aXRlbS5hdHRyaWJ1dGUoJ2hyZWYnLCAnbWFpbHRvOicgKyBwYXN0ZWRDb250ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn0pO1xufSx7XCIuLi8uLi9hc3NldHMvcHJlZmVyZW5jZXNcIjpcImFzc2V0c1xcXFxwcmVmZXJlbmNlcy5qc1wiLFwiLi4vLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4vcGFzdGVkQ29udGVudFwiOlwicGFyc2VyXFxcXHByb2Nlc3NvclxcXFxwYXN0ZWRDb250ZW50LmpzXCJ9XSxcInBhcnNlclxcXFxwcm9jZXNzb3JcXFxccGFzdGVkQ29udGVudC5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogUGFzdGVkIGNvbnRlbnQgYWJicmV2aWF0aW9uIHByb2Nlc3Nvci4gQSBwYXN0ZWQgY29udGVudCBpcyBhIGNvbnRlbnQgdGhhdFxuICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gaW1wbGljaXRseSByZXBlYXRlZCBhYmJyZXZpYXRpb24gbm9kZXMuXG4gKiBUaGlzIHByb2Nlc3NvciBwb3dlcnMg4oCcV3JhcCBXaXRoIEFiYnJldmlhdGlvbuKAnSBhY3Rpb25cbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciBhYmJyVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9hYmJyZXZpYXRpb24nKTtcblx0dmFyIHN0cmluZ1N0cmVhbSA9IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy9zdHJpbmdTdHJlYW0nKTtcblx0dmFyIHJhbmdlID0gcmVxdWlyZSgnLi4vLi4vYXNzZXRzL3JhbmdlJyk7XG5cblx0dmFyIG91dHB1dFBsYWNlaG9sZGVyID0gJyQjJztcblx0XG5cdC8qKlxuXHQgKiBMb2NhdGVzIG91dHB1dCBwbGFjZWhvbGRlcnMgaW5zaWRlIHRleHRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0ICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiByYW5nZXMgb2Ygb3V0cHV0IHBsYWNlaG9sZGVyIGluIHRleHRcblx0ICovXG5cdGZ1bmN0aW9uIGxvY2F0ZU91dHB1dFBsYWNlaG9sZGVyKHRleHQpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XG5cdFx0dmFyIHN0cmVhbSA9IHN0cmluZ1N0cmVhbS5jcmVhdGUodGV4dCk7XG5cdFx0XG5cdFx0d2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcblx0XHRcdGlmIChzdHJlYW0ucGVlaygpID09ICdcXFxcJykge1xuXHRcdFx0XHRzdHJlYW0ubmV4dCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdFx0aWYgKHN0cmVhbS5tYXRjaChvdXRwdXRQbGFjZWhvbGRlciwgdHJ1ZSkpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChyYW5nZS5jcmVhdGUoc3RyZWFtLnN0YXJ0LCBvdXRwdXRQbGFjZWhvbGRlcikpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzdHJlYW0ubmV4dCgpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmVwbGFjZXMgb3V0cHV0IHBsYWNlaG9sZGVycyBpbnNpZGUgPGNvZGU+c291cmNlPC9jb2RlPiB3aXRoIFxuXHQgKiA8Y29kZT52YWx1ZTwvY29kZT5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcblx0ICogQHJldHVybnMge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIHJlcGxhY2VPdXRwdXRQbGFjZWhvbGRlcnMoc291cmNlLCB2YWx1ZSkge1xuXHRcdHZhciByYW5nZXMgPSBsb2NhdGVPdXRwdXRQbGFjZWhvbGRlcihzb3VyY2UpO1xuXHRcdFxuXHRcdHJhbmdlcy5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG5cdFx0XHRzb3VyY2UgPSB1dGlscy5yZXBsYWNlU3Vic3RyaW5nKHNvdXJjZSwgdmFsdWUsIHIpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiBzb3VyY2U7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBwYXJzZWQgbm9kZSBjb250YWlucyBvdXRwdXQgcGxhY2Vob2xkZXIg4oCTIGEgdGFyZ2V0IHdoZXJlXG5cdCAqIHBhc3RlZCBjb250ZW50IHNob3VsZCBiZSBpbnNlcnRlZFxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNPdXRwdXRQbGFjZWhvbGRlcihub2RlKSB7XG5cdFx0aWYgKGxvY2F0ZU91dHB1dFBsYWNlaG9sZGVyKG5vZGUuY29udGVudCkubGVuZ3RoKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XG5cdFx0Ly8gY2hlY2sgaWYgYXR0cmlidXRlcyBjb250YWlucyBwbGFjZWhvbGRlclxuXHRcdHJldHVybiAhIXV0aWxzLmZpbmQobm9kZS5hdHRyaWJ1dGVMaXN0KCksIGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdHJldHVybiAhIWxvY2F0ZU91dHB1dFBsYWNlaG9sZGVyKGF0dHIudmFsdWUpLmxlbmd0aDtcblx0XHR9KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEluc2VydCBwYXN0ZWQgY29udGVudCBpbnRvIGNvcnJlY3QgcG9zaXRpb25zIG9mIHBhcnNlZCBub2RlXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IG92ZXJ3cml0ZSBPdmVyd3JpdGUgbm9kZSBjb250ZW50IGlmIG5vIHZhbHVlIHBsYWNlaG9sZGVyc1xuXHQgKiBmb3VuZCBpbnN0ZWFkIG9mIGFwcGVuZGluZyB0byBleGlzdGluZyBjb250ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBpbnNlcnRQYXN0ZWRDb250ZW50KG5vZGUsIGNvbnRlbnQsIG92ZXJ3cml0ZSkge1xuXHRcdHZhciBub2Rlc1dpdGhQbGFjZWhvbGRlcnMgPSBub2RlLmZpbmRBbGwoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuIGhhc091dHB1dFBsYWNlaG9sZGVyKGl0ZW0pO1xuXHRcdH0pO1xuXHRcdFxuXHRcdGlmIChoYXNPdXRwdXRQbGFjZWhvbGRlcihub2RlKSlcblx0XHRcdG5vZGVzV2l0aFBsYWNlaG9sZGVycy51bnNoaWZ0KG5vZGUpO1xuXHRcdFxuXHRcdGlmIChub2Rlc1dpdGhQbGFjZWhvbGRlcnMubGVuZ3RoKSB7XG5cdFx0XHRub2Rlc1dpdGhQbGFjZWhvbGRlcnMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdGl0ZW0uY29udGVudCA9IHJlcGxhY2VPdXRwdXRQbGFjZWhvbGRlcnMoaXRlbS5jb250ZW50LCBjb250ZW50KTtcblx0XHRcdFx0aXRlbS5fYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdFx0XHRhdHRyLnZhbHVlID0gcmVwbGFjZU91dHB1dFBsYWNlaG9sZGVycyhhdHRyLnZhbHVlLCBjb250ZW50KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gb24gb3V0cHV0IHBsYWNlaG9sZGVycyBpbiBzdWJ0cmVlLCBpbnNlcnQgY29udGVudCBpbiB0aGUgZGVlcGVzdFxuXHRcdFx0Ly8gY2hpbGQgbm9kZVxuXHRcdFx0dmFyIGRlZXBlc3QgPSBub2RlLmRlZXBlc3RDaGlsZCgpIHx8IG5vZGU7XG5cdFx0XHRpZiAob3ZlcndyaXRlKSB7XG5cdFx0XHRcdGRlZXBlc3QuY29udGVudCA9IGNvbnRlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWVwZXN0LmNvbnRlbnQgPSBhYmJyVXRpbHMuaW5zZXJ0Q2hpbGRDb250ZW50KGRlZXBlc3QuY29udGVudCwgY29udGVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRwYXN0ZWRDb250ZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGl0ZW0uZGF0YSgncGFzdGUnKTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50W2l0ZW0uY291bnRlciAtIDFdO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudChpdGVtLmNvdW50ZXIgLSAxLCBpdGVtLmNvbnRlbnQpO1xuXHRcdFx0fSBlbHNlIGlmIChjb250ZW50KSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IHRyZWVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqL1xuXHRcdHByZXByb2Nlc3NvcjogZnVuY3Rpb24odHJlZSwgb3B0aW9ucykge1xuXHRcdFx0aWYgKG9wdGlvbnMucGFzdGVkQ29udGVudCkge1xuXHRcdFx0XHR2YXIgbGluZXMgPSB1dGlscy5zcGxpdEJ5TGluZXMob3B0aW9ucy5wYXN0ZWRDb250ZW50LCB0cnVlKS5tYXAodXRpbHMudHJpbSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBzZXQgcmVwZWF0IGNvdW50IGZvciBpbXBsaWNpdGx5IHJlcGVhdGVkIGVsZW1lbnRzIGJlZm9yZVxuXHRcdFx0XHQvLyB0cmVlIGlzIHVucm9sbGVkXG5cdFx0XHRcdHRyZWUuZmluZEFsbChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdFx0aWYgKGl0ZW0uaGFzSW1wbGljaXRSZXBlYXQpIHtcblx0XHRcdFx0XHRcdGl0ZW0uZGF0YSgncGFzdGUnLCBsaW5lcyk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaXRlbS5yZXBlYXRDb3VudCA9IGxpbmVzLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IHRyZWVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqL1xuXHRcdHBvc3Rwcm9jZXNzb3I6IGZ1bmN0aW9uKHRyZWUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdC8vIGZvciBlYWNoIG5vZGUgd2l0aCBwYXN0ZWQgY29udGVudCwgdXBkYXRlIHRleHQgZGF0YVxuXHRcdFx0dmFyIHRhcmdldHMgPSB0cmVlLmZpbmRBbGwoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHR2YXIgcGFzdGVkQ29udGVudCA9IHRoYXQucGFzdGVkQ29udGVudChpdGVtKTtcblx0XHRcdFx0aWYgKHBhc3RlZENvbnRlbnQpIHtcblx0XHRcdFx0XHRpbnNlcnRQYXN0ZWRDb250ZW50KGl0ZW0sIHBhc3RlZENvbnRlbnQsICEhaXRlbS5kYXRhKCdwYXN0ZU92ZXJ3cml0ZXMnKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiAhIXBhc3RlZENvbnRlbnQ7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiBvcHRpb25zLnBhc3RlZENvbnRlbnQpIHtcblx0XHRcdFx0Ly8gbm8gaW1wbGljaXRseSByZXBlYXRlZCBlbGVtZW50cywgcHV0IHBhc3RlZCBjb250ZW50IGluXG5cdFx0XHRcdC8vIHRoZSBkZWVwZXN0IGNoaWxkXG5cdFx0XHRcdGluc2VydFBhc3RlZENvbnRlbnQodHJlZSwgb3B0aW9ucy5wYXN0ZWRDb250ZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vLi4vYXNzZXRzL3JhbmdlXCI6XCJhc3NldHNcXFxccmFuZ2UuanNcIixcIi4uLy4uL2Fzc2V0cy9zdHJpbmdTdHJlYW1cIjpcImFzc2V0c1xcXFxzdHJpbmdTdHJlYW0uanNcIixcIi4uLy4uL3V0aWxzL2FiYnJldmlhdGlvblwiOlwidXRpbHNcXFxcYWJicmV2aWF0aW9uLmpzXCIsXCIuLi8uLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wifV0sXCJwYXJzZXJcXFxccHJvY2Vzc29yXFxcXHJlc291cmNlTWF0Y2hlci5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogUHJvY2Vzc29yIGZ1bmN0aW9uIHRoYXQgbWF0Y2hlcyBwYXJzZWQgPGNvZGU+QWJicmV2aWF0aW9uTm9kZTwvY29kZT5cbiAqIGFnYWluc3QgcmVzb3VyY2VzIGRlZmluZWQgaW4gPGNvZGU+cmVzb3VyY2U8L2NvZGU+IG1vZHVsZVxuICovIFxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHJlc291cmNlcyA9IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy9yZXNvdXJjZXMnKTtcblx0dmFyIGVsZW1lbnRzID0gcmVxdWlyZSgnLi4vLi4vYXNzZXRzL2VsZW1lbnRzJyk7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgYWJicmV2aWF0aW9uVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9hYmJyZXZpYXRpb24nKTtcblxuXHQvKipcblx0ICogRmluZHMgbWF0Y2hlZCByZXNvdXJjZXMgZm9yIGNoaWxkIG5vZGVzIG9mIHBhc3NlZCA8Y29kZT5ub2RlPC9jb2RlPiBcblx0ICogZWxlbWVudC4gQSBtYXRjaGVkIHJlc291cmNlIGlzIGEgcmVmZXJlbmNlIHRvIDxpPnNuaXBwZXRzLmpzb248L2k+IGVudHJ5XG5cdCAqIHRoYXQgZGVzY3JpYmVzIG91dHB1dCBvZiBwYXJzZWQgbm9kZSBcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXhcblx0ICovXG5cdGZ1bmN0aW9uIG1hdGNoUmVzb3VyY2VzKG5vZGUsIHN5bnRheCwgcGFyc2VyKSB7XG5cdFx0Ly8gZG8gYSBzaGFsbG93IGNvcHkgYmVjYXVzZSB0aGUgY2hpbGRyZW4gbGlzdCBjYW4gYmUgbW9kaWZpZWQgZHVyaW5nXG5cdFx0Ly8gcmVzb3VyY2UgbWF0Y2hpbmdcblx0XHRub2RlLmNoaWxkcmVuLnNsaWNlKDApLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRcdHZhciByID0gcmVzb3VyY2VzLmdldE1hdGNoZWRSZXNvdXJjZShjaGlsZCwgc3ludGF4KTtcblx0XHRcdGlmICh0eXBlb2YgciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0ciA9IGVsZW1lbnRzLmNyZWF0ZSgnc25pcHBldCcsIHIpO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGlsZC5kYXRhKCdyZXNvdXJjZScsIHIpO1xuXHRcdFx0dmFyIGVsZW1UeXBlID0gZWxlbWVudHMudHlwZShyKTtcblxuXHRcdFx0aWYgKGVsZW1UeXBlID09ICdzbmlwcGV0Jykge1xuXHRcdFx0XHR2YXIgY29udGVudCA9IHIuZGF0YTtcblx0XHRcdFx0dmFyIGN1ckNvbnRlbnQgPSBjaGlsZC5fdGV4dCB8fCBjaGlsZC5jb250ZW50O1xuXHRcdFx0XHRpZiAoY3VyQ29udGVudCkge1xuXHRcdFx0XHRcdGNvbnRlbnQgPSBhYmJyZXZpYXRpb25VdGlscy5pbnNlcnRDaGlsZENvbnRlbnQoY29udGVudCwgY3VyQ29udGVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjaGlsZC5jb250ZW50ID0gY29udGVudDtcblx0XHRcdH0gZWxzZSBpZiAoZWxlbVR5cGUgPT0gJ2VsZW1lbnQnKSB7XG5cdFx0XHRcdGNoaWxkLl9uYW1lID0gci5uYW1lO1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShyLmF0dHJpYnV0ZXMpKSB7XG5cdFx0XHRcdFx0Y2hpbGQuX2F0dHJpYnV0ZXMgPSBbXS5jb25jYXQoci5hdHRyaWJ1dGVzLCBjaGlsZC5fYXR0cmlidXRlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZWxlbVR5cGUgPT0gJ3JlZmVyZW5jZScpIHtcblx0XHRcdFx0Ly8gaXTigJlzIGEgcmVmZXJlbmNlIHRvIGFub3RoZXIgYWJicmV2aWF0aW9uOlxuXHRcdFx0XHQvLyBwYXJzZSBpdCBhbmQgaW5zZXJ0IGluc3RlYWQgb2YgY3VycmVudCBjaGlsZFxuXHRcdFx0XHQvKiogQHR5cGUgQWJicmV2aWF0aW9uTm9kZSAqL1xuXHRcdFx0XHR2YXIgc3VidHJlZSA9IHBhcnNlci5wYXJzZShyLmRhdGEsIHtcblx0XHRcdFx0XHRzeW50YXg6IHN5bnRheFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBpZiBjb250ZXh0IGVsZW1lbnQgc2hvdWxkIGJlIHJlcGVhdGVkLCBjaGVjayBpZiB3ZSBuZWVkIHRvIFxuXHRcdFx0XHQvLyB0cmFuc2ZlciByZXBlYXRlZCBlbGVtZW50IHRvIHNwZWNpZmljIGNoaWxkIG5vZGVcblx0XHRcdFx0aWYgKGNoaWxkLnJlcGVhdENvdW50ID4gMSkge1xuXHRcdFx0XHRcdHZhciByZXBlYXRlZENoaWxkcmVuID0gc3VidHJlZS5maW5kQWxsKGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiBub2RlLmhhc0ltcGxpY2l0UmVwZWF0O1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0aWYgKCFyZXBlYXRlZENoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0cmVwZWF0ZWRDaGlsZHJlbiA9IHN1YnRyZWUuY2hpbGRyZW5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmVwZWF0ZWRDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0XHRcdG5vZGUucmVwZWF0Q291bnQgPSBjaGlsZC5yZXBlYXRDb3VudDtcblx0XHRcdFx0XHRcdG5vZGUuaGFzSW1wbGljaXRSZXBlYXQgPSBmYWxzZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG1vdmUgY2hpbGTigJhzIGNoaWxkcmVuIGludG8gdGhlIGRlZXBlc3QgY2hpbGQgb2YgbmV3IHN1YnRyZWVcblx0XHRcdFx0dmFyIGRlZXBlc3RDaGlsZCA9IHN1YnRyZWUuZGVlcGVzdENoaWxkKCk7XG5cdFx0XHRcdGlmIChkZWVwZXN0Q2hpbGQpIHtcblx0XHRcdFx0XHRjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcblx0XHRcdFx0XHRcdGRlZXBlc3RDaGlsZC5hZGRDaGlsZChjKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRkZWVwZXN0Q2hpbGQuY29udGVudCA9IGNoaWxkLmNvbnRlbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjb3B5IGN1cnJlbnQgYXR0cmlidXRlcyB0byBjaGlsZHJlblxuXHRcdFx0XHRzdWJ0cmVlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0XHRcdGNoaWxkLmF0dHJpYnV0ZUxpc3QoKS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdFx0XHRcdG5vZGUuYXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2hpbGQucmVwbGFjZShzdWJ0cmVlLmNoaWxkcmVuKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0bWF0Y2hSZXNvdXJjZXMoY2hpbGQsIHN5bnRheCwgcGFyc2VyKTtcblx0XHR9KTtcblx0fVxuXHRcblx0cmV0dXJuIHtcblx0XHRwcmVwcm9jZXNzb3I6IGZ1bmN0aW9uKHRyZWUsIG9wdGlvbnMsIHBhcnNlcikge1xuXHRcdFx0dmFyIHN5bnRheCA9IG9wdGlvbnMuc3ludGF4IHx8IHV0aWxzLmRlZmF1bHRTeW50YXgoKTtcblx0XHRcdG1hdGNoUmVzb3VyY2VzKHRyZWUsIHN5bnRheCwgcGFyc2VyKTtcblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vLi4vYXNzZXRzL2VsZW1lbnRzXCI6XCJhc3NldHNcXFxcZWxlbWVudHMuanNcIixcIi4uLy4uL2Fzc2V0cy9yZXNvdXJjZXNcIjpcImFzc2V0c1xcXFxyZXNvdXJjZXMuanNcIixcIi4uLy4uL3V0aWxzL2FiYnJldmlhdGlvblwiOlwidXRpbHNcXFxcYWJicmV2aWF0aW9uLmpzXCIsXCIuLi8uLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wifV0sXCJwYXJzZXJcXFxccHJvY2Vzc29yXFxcXHRhZ05hbWUuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFJlc29sdmVzIHRhZyBuYW1lcyBpbiBhYmJyZXZpYXRpb25zIHdpdGggaW1wbGllZCBuYW1lXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciB0YWdOYW1lID0gcmVxdWlyZSgnLi4vLi4vcmVzb2x2ZXIvdGFnTmFtZScpO1xuXG5cdC8qKlxuXHQgKiBSZXNvbHZlcyBpbXBsaWNpdCBub2RlIG5hbWVzIGluIHBhcnNlZCB0cmVlXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gdHJlZVxuXHQgKi9cblx0ZnVuY3Rpb24gcmVzb2x2ZU5vZGVOYW1lcyh0cmVlKSB7XG5cdFx0dHJlZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdGlmIChub2RlLmhhc0ltcGxpY2l0TmFtZSgpIHx8IG5vZGUuZGF0YSgnZm9yY2VOYW1lUmVzb2x2aW5nJykpIHtcblx0XHRcdFx0bm9kZS5fbmFtZSA9IHRhZ05hbWUucmVzb2x2ZShub2RlLnBhcmVudC5uYW1lKCkpO1xuXHRcdFx0XHRub2RlLmRhdGEoJ25hbWVSZXNvbHZlZCcsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmVzb2x2ZU5vZGVOYW1lcyhub2RlKTtcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gdHJlZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0cG9zdHByb2Nlc3NvcjogcmVzb2x2ZU5vZGVOYW1lc1xuXHR9O1xufSk7XG59LHtcIi4uLy4uL3Jlc29sdmVyL3RhZ05hbWVcIjpcInJlc29sdmVyXFxcXHRhZ05hbWUuanNcIn1dLFwicGFyc2VyXFxcXHhtbC5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSFRNTCB0b2tlbml6ZXIgYnkgTWFyaWpuIEhhdmVyYmVrZVxuICogaHR0cDovL2NvZGVtaXJyb3IubmV0L1xuICogQGNvbnN0cnVjdG9yXG4gKiBAbWVtYmVyT2YgX194bWxQYXJzZURlZmluZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBzdHJpbmdTdHJlYW0gPSByZXF1aXJlKCcuLi9hc3NldHMvc3RyaW5nU3RyZWFtJyk7XG5cblx0dmFyIEtsdWRnZXMgPSB7XG5cdFx0YXV0b1NlbGZDbG9zZXJzIDoge30sXG5cdFx0aW1wbGljaXRseUNsb3NlZCA6IHt9LFxuXHRcdGNvbnRleHRHcmFiYmVycyA6IHt9LFxuXHRcdGRvTm90SW5kZW50IDoge30sXG5cdFx0YWxsb3dVbnF1b3RlZCA6IHRydWUsXG5cdFx0YWxsb3dNaXNzaW5nIDogdHJ1ZVxuXHR9O1xuXG5cdC8vIFJldHVybiB2YXJpYWJsZXMgZm9yIHRva2VuaXplcnNcblx0dmFyIHRhZ05hbWUgPSBudWxsLCB0eXBlID0gbnVsbDtcblxuXHRmdW5jdGlvbiBpblRleHQoc3RyZWFtLCBzdGF0ZSkge1xuXHRcdGZ1bmN0aW9uIGNoYWluKHBhcnNlcikge1xuXHRcdFx0c3RhdGUudG9rZW5pemUgPSBwYXJzZXI7XG5cdFx0XHRyZXR1cm4gcGFyc2VyKHN0cmVhbSwgc3RhdGUpO1xuXHRcdH1cblxuXHRcdHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cdFx0aWYgKGNoID09IFwiPFwiKSB7XG5cdFx0XHRpZiAoc3RyZWFtLmVhdChcIiFcIikpIHtcblx0XHRcdFx0aWYgKHN0cmVhbS5lYXQoXCJbXCIpKSB7XG5cdFx0XHRcdFx0aWYgKHN0cmVhbS5tYXRjaChcIkNEQVRBW1wiKSlcblx0XHRcdFx0XHRcdHJldHVybiBjaGFpbihpbkJsb2NrKFwiYXRvbVwiLCBcIl1dPlwiKSk7XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKFwiLS1cIikpXG5cdFx0XHRcdFx0cmV0dXJuIGNoYWluKGluQmxvY2soXCJjb21tZW50XCIsIFwiLS0+XCIpKTtcblx0XHRcdFx0ZWxzZSBpZiAoc3RyZWFtLm1hdGNoKFwiRE9DVFlQRVwiLCB0cnVlLCB0cnVlKSkge1xuXHRcdFx0XHRcdHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLl9cXC1dLyk7XG5cdFx0XHRcdFx0cmV0dXJuIGNoYWluKGRvY3R5cGUoMSkpO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIj9cIikpIHtcblx0XHRcdFx0c3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuX1xcLV0vKTtcblx0XHRcdFx0c3RhdGUudG9rZW5pemUgPSBpbkJsb2NrKFwibWV0YVwiLCBcIj8+XCIpO1xuXHRcdFx0XHRyZXR1cm4gXCJtZXRhXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gc3RyZWFtLmVhdChcIi9cIikgPyBcImNsb3NlVGFnXCIgOiBcIm9wZW5UYWdcIjtcblx0XHRcdFx0c3RyZWFtLmVhdFNwYWNlKCk7XG5cdFx0XHRcdHRhZ05hbWUgPSBcIlwiO1xuXHRcdFx0XHR2YXIgYztcblx0XHRcdFx0d2hpbGUgKChjID0gc3RyZWFtLmVhdCgvW15cXHNcXHUwMGEwPTw+XFxcIlxcJ1xcLz9dLykpKVxuXHRcdFx0XHRcdHRhZ05hbWUgKz0gYztcblx0XHRcdFx0c3RhdGUudG9rZW5pemUgPSBpblRhZztcblx0XHRcdFx0cmV0dXJuIFwidGFnXCI7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjaCA9PSBcIiZcIikge1xuXHRcdFx0dmFyIG9rO1xuXHRcdFx0aWYgKHN0cmVhbS5lYXQoXCIjXCIpKSB7XG5cdFx0XHRcdGlmIChzdHJlYW0uZWF0KFwieFwiKSkge1xuXHRcdFx0XHRcdG9rID0gc3RyZWFtLmVhdFdoaWxlKC9bYS1mQS1GXFxkXS8pICYmIHN0cmVhbS5lYXQoXCI7XCIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9rID0gc3RyZWFtLmVhdFdoaWxlKC9bXFxkXS8pICYmIHN0cmVhbS5lYXQoXCI7XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvayA9IHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLlxcLTpdLykgJiYgc3RyZWFtLmVhdChcIjtcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2sgPyBcImF0b21cIiA6IFwiZXJyb3JcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RyZWFtLmVhdFdoaWxlKC9bXiY8XS8pO1xuXHRcdFx0cmV0dXJuIFwidGV4dFwiO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGluVGFnKHN0cmVhbSwgc3RhdGUpIHtcblx0XHR2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXHRcdGlmIChjaCA9PSBcIj5cIiB8fCAoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIj5cIikpKSB7XG5cdFx0XHRzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcblx0XHRcdHR5cGUgPSBjaCA9PSBcIj5cIiA/IFwiZW5kVGFnXCIgOiBcInNlbGZjbG9zZVRhZ1wiO1xuXHRcdFx0cmV0dXJuIFwidGFnXCI7XG5cdFx0fSBlbHNlIGlmIChjaCA9PSBcIj1cIikge1xuXHRcdFx0dHlwZSA9IFwiZXF1YWxzXCI7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2UgaWYgKC9bXFwnXFxcIl0vLnRlc3QoY2gpKSB7XG5cdFx0XHRzdGF0ZS50b2tlbml6ZSA9IGluQXR0cmlidXRlKGNoKTtcblx0XHRcdHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RyZWFtLmVhdFdoaWxlKC9bXlxcc1xcdTAwYTA9PD5cXFwiXFwnXFwvP10vKTtcblx0XHRcdHJldHVybiBcIndvcmRcIjtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpbkF0dHJpYnV0ZShxdW90ZSkge1xuXHRcdHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG5cdFx0XHR3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuXHRcdFx0XHRpZiAoc3RyZWFtLm5leHQoKSA9PSBxdW90ZSkge1xuXHRcdFx0XHRcdHN0YXRlLnRva2VuaXplID0gaW5UYWc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBcInN0cmluZ1wiO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBpbkJsb2NrKHN0eWxlLCB0ZXJtaW5hdG9yKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcblx0XHRcdHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG5cdFx0XHRcdGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcblx0XHRcdFx0XHRzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdHJlYW0ubmV4dCgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0eWxlO1xuXHRcdH07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGRvY3R5cGUoZGVwdGgpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuXHRcdFx0dmFyIGNoO1xuXHRcdFx0d2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChjaCA9PSBcIjxcIikge1xuXHRcdFx0XHRcdHN0YXRlLnRva2VuaXplID0gZG9jdHlwZShkZXB0aCArIDEpO1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSBcIj5cIikge1xuXHRcdFx0XHRcdGlmIChkZXB0aCA9PSAxKSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggLSAxKTtcblx0XHRcdFx0XHRcdHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBcIm1ldGFcIjtcblx0XHR9O1xuXHR9XG5cblx0dmFyIGN1clN0YXRlID0gbnVsbCwgc2V0U3R5bGU7XG5cdGZ1bmN0aW9uIHBhc3MoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdGN1clN0YXRlLmNjLnB1c2goYXJndW1lbnRzW2ldKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gY29udCgpIHtcblx0XHRwYXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiBwdXNoQ29udGV4dCh0YWdOYW1lLCBzdGFydE9mTGluZSkge1xuXHRcdHZhciBub0luZGVudCA9IEtsdWRnZXMuZG9Ob3RJbmRlbnQuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgXG5cdFx0XHR8fCAoY3VyU3RhdGUuY29udGV4dCAmJiBjdXJTdGF0ZS5jb250ZXh0Lm5vSW5kZW50KTtcblx0XHRjdXJTdGF0ZS5jb250ZXh0ID0ge1xuXHRcdFx0cHJldiA6IGN1clN0YXRlLmNvbnRleHQsXG5cdFx0XHR0YWdOYW1lIDogdGFnTmFtZSxcblx0XHRcdGluZGVudCA6IGN1clN0YXRlLmluZGVudGVkLFxuXHRcdFx0c3RhcnRPZkxpbmUgOiBzdGFydE9mTGluZSxcblx0XHRcdG5vSW5kZW50IDogbm9JbmRlbnRcblx0XHR9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBwb3BDb250ZXh0KCkge1xuXHRcdGlmIChjdXJTdGF0ZS5jb250ZXh0KVxuXHRcdFx0Y3VyU3RhdGUuY29udGV4dCA9IGN1clN0YXRlLmNvbnRleHQucHJldjtcblx0fVxuXG5cdGZ1bmN0aW9uIGVsZW1lbnQodHlwZSkge1xuXHRcdGlmICh0eXBlID09IFwib3BlblRhZ1wiKSB7XG5cdFx0XHRjdXJTdGF0ZS50YWdOYW1lID0gdGFnTmFtZTtcblx0XHRcdHJldHVybiBjb250KGF0dHJpYnV0ZXMsIGVuZHRhZyhjdXJTdGF0ZS5zdGFydE9mTGluZSkpO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcImNsb3NlVGFnXCIpIHtcblx0XHRcdHZhciBlcnIgPSBmYWxzZTtcblx0XHRcdGlmIChjdXJTdGF0ZS5jb250ZXh0KSB7XG5cdFx0XHRcdGlmIChjdXJTdGF0ZS5jb250ZXh0LnRhZ05hbWUgIT0gdGFnTmFtZSkge1xuXHRcdFx0XHRcdGlmIChLbHVkZ2VzLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoY3VyU3RhdGUuY29udGV4dC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG5cdFx0XHRcdFx0XHRwb3BDb250ZXh0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVyciA9ICFjdXJTdGF0ZS5jb250ZXh0IHx8IGN1clN0YXRlLmNvbnRleHQudGFnTmFtZSAhPSB0YWdOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlcnIgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoZXJyKVxuXHRcdFx0XHRzZXRTdHlsZSA9IFwiZXJyb3JcIjtcblx0XHRcdHJldHVybiBjb250KGVuZGNsb3NldGFnKGVycikpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29udCgpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBlbmR0YWcoc3RhcnRPZkxpbmUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0aWYgKHR5cGUgPT0gXCJzZWxmY2xvc2VUYWdcIlxuXHRcdFx0XHRcdHx8ICh0eXBlID09IFwiZW5kVGFnXCIgJiYgS2x1ZGdlcy5hdXRvU2VsZkNsb3NlcnNcblx0XHRcdFx0XHRcdFx0Lmhhc093blByb3BlcnR5KGN1clN0YXRlLnRhZ05hbWVcblx0XHRcdFx0XHRcdFx0XHRcdC50b0xvd2VyQ2FzZSgpKSkpIHtcblx0XHRcdFx0bWF5YmVQb3BDb250ZXh0KGN1clN0YXRlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdHJldHVybiBjb250KCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZSA9PSBcImVuZFRhZ1wiKSB7XG5cdFx0XHRcdG1heWJlUG9wQ29udGV4dChjdXJTdGF0ZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHRwdXNoQ29udGV4dChjdXJTdGF0ZS50YWdOYW1lLCBzdGFydE9mTGluZSk7XG5cdFx0XHRcdHJldHVybiBjb250KCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29udCgpO1xuXHRcdH07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGVuZGNsb3NldGFnKGVycikge1xuXHRcdHJldHVybiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRpZiAoZXJyKVxuXHRcdFx0XHRzZXRTdHlsZSA9IFwiZXJyb3JcIjtcblx0XHRcdGlmICh0eXBlID09IFwiZW5kVGFnXCIpIHtcblx0XHRcdFx0cG9wQ29udGV4dCgpO1xuXHRcdFx0XHRyZXR1cm4gY29udCgpO1xuXHRcdFx0fVxuXHRcdFx0c2V0U3R5bGUgPSBcImVycm9yXCI7XG5cdFx0XHRyZXR1cm4gY29udChhcmd1bWVudHMuY2FsbGVlKTtcblx0XHR9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBtYXliZVBvcENvbnRleHQobmV4dFRhZ05hbWUpIHtcblx0XHR2YXIgcGFyZW50VGFnTmFtZTtcblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0aWYgKCFjdXJTdGF0ZS5jb250ZXh0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHBhcmVudFRhZ05hbWUgPSBjdXJTdGF0ZS5jb250ZXh0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmICghS2x1ZGdlcy5jb250ZXh0R3JhYmJlcnMuaGFzT3duUHJvcGVydHkocGFyZW50VGFnTmFtZSlcblx0XHRcdFx0XHR8fCAhS2x1ZGdlcy5jb250ZXh0R3JhYmJlcnNbcGFyZW50VGFnTmFtZV0uaGFzT3duUHJvcGVydHkobmV4dFRhZ05hbWUpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHBvcENvbnRleHQoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhdHRyaWJ1dGVzKHR5cGUpIHtcblx0XHRpZiAodHlwZSA9PSBcIndvcmRcIikge1xuXHRcdFx0c2V0U3R5bGUgPSBcImF0dHJpYnV0ZVwiO1xuXHRcdFx0cmV0dXJuIGNvbnQoYXR0cmlidXRlLCBhdHRyaWJ1dGVzKTtcblx0XHR9XG5cdFx0aWYgKHR5cGUgPT0gXCJlbmRUYWdcIiB8fCB0eXBlID09IFwic2VsZmNsb3NlVGFnXCIpXG5cdFx0XHRyZXR1cm4gcGFzcygpO1xuXHRcdHNldFN0eWxlID0gXCJlcnJvclwiO1xuXHRcdHJldHVybiBjb250KGF0dHJpYnV0ZXMpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBhdHRyaWJ1dGUodHlwZSkge1xuXHRcdGlmICh0eXBlID09IFwiZXF1YWxzXCIpXG5cdFx0XHRyZXR1cm4gY29udChhdHR2YWx1ZSwgYXR0cmlidXRlcyk7XG5cdFx0aWYgKCFLbHVkZ2VzLmFsbG93TWlzc2luZylcblx0XHRcdHNldFN0eWxlID0gXCJlcnJvclwiO1xuXHRcdHJldHVybiAodHlwZSA9PSBcImVuZFRhZ1wiIHx8IHR5cGUgPT0gXCJzZWxmY2xvc2VUYWdcIikgPyBwYXNzKClcblx0XHRcdFx0OiBjb250KCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGF0dHZhbHVlKHR5cGUpIHtcblx0XHRpZiAodHlwZSA9PSBcInN0cmluZ1wiKVxuXHRcdFx0cmV0dXJuIGNvbnQoYXR0dmFsdWVtYXliZSk7XG5cdFx0aWYgKHR5cGUgPT0gXCJ3b3JkXCIgJiYgS2x1ZGdlcy5hbGxvd1VucXVvdGVkKSB7XG5cdFx0XHRzZXRTdHlsZSA9IFwic3RyaW5nXCI7XG5cdFx0XHRyZXR1cm4gY29udCgpO1xuXHRcdH1cblx0XHRzZXRTdHlsZSA9IFwiZXJyb3JcIjtcblx0XHRyZXR1cm4gKHR5cGUgPT0gXCJlbmRUYWdcIiB8fCB0eXBlID09IFwic2VsZkNsb3NlVGFnXCIpID8gcGFzcygpXG5cdFx0XHRcdDogY29udCgpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBhdHR2YWx1ZW1heWJlKHR5cGUpIHtcblx0XHRpZiAodHlwZSA9PSBcInN0cmluZ1wiKVxuXHRcdFx0cmV0dXJuIGNvbnQoYXR0dmFsdWVtYXliZSk7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIHBhc3MoKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gc3RhcnRTdGF0ZSgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9rZW5pemUgOiBpblRleHQsXG5cdFx0XHRjYyA6IFtdLFxuXHRcdFx0aW5kZW50ZWQgOiAwLFxuXHRcdFx0c3RhcnRPZkxpbmUgOiB0cnVlLFxuXHRcdFx0dGFnTmFtZSA6IG51bGwsXG5cdFx0XHRjb250ZXh0IDogbnVsbFxuXHRcdH07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHRva2VuKHN0cmVhbSwgc3RhdGUpIHtcblx0XHRpZiAoc3RyZWFtLnNvbCgpKSB7XG5cdFx0XHRzdGF0ZS5zdGFydE9mTGluZSA9IHRydWU7XG5cdFx0XHRzdGF0ZS5pbmRlbnRlZCA9IDA7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChzdHJlYW0uZWF0U3BhY2UoKSlcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0c2V0U3R5bGUgPSB0eXBlID0gdGFnTmFtZSA9IG51bGw7XG5cdFx0dmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG5cdFx0c3RhdGUudHlwZSA9IHR5cGU7XG5cdFx0aWYgKChzdHlsZSB8fCB0eXBlKSAmJiBzdHlsZSAhPSBcImNvbW1lbnRcIikge1xuXHRcdFx0Y3VyU3RhdGUgPSBzdGF0ZTtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdHZhciBjb21iID0gc3RhdGUuY2MucG9wKCkgfHwgZWxlbWVudDtcblx0XHRcdFx0aWYgKGNvbWIodHlwZSB8fCBzdHlsZSkpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHN0YXRlLnN0YXJ0T2ZMaW5lID0gZmFsc2U7XG5cdFx0cmV0dXJuIHNldFN0eWxlIHx8IHN0eWxlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBAbWVtYmVyT2YgZW1tZXQueG1sUGFyc2VyXG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRwYXJzZTogZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KSB7XG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0XHRcdHZhciBzdGF0ZSA9IHN0YXJ0U3RhdGUoKTtcblx0XHRcdHZhciBzdHJlYW0gPSBzdHJpbmdTdHJlYW0uY3JlYXRlKGRhdGEpO1xuXHRcdFx0dmFyIHRva2VucyA9IFtdO1xuXHRcdFx0d2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHR5cGU6IHRva2VuKHN0cmVhbSwgc3RhdGUpLFxuXHRcdFx0XHRcdHN0YXJ0OiBzdHJlYW0uc3RhcnQgKyBvZmZzZXQsXG5cdFx0XHRcdFx0ZW5kOiBzdHJlYW0ucG9zICsgb2Zmc2V0XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdG9rZW5zO1xuXHRcdH1cdFx0XG5cdH07XG59KTtcblxufSx7XCIuLi9hc3NldHMvc3RyaW5nU3RyZWFtXCI6XCJhc3NldHNcXFxcc3RyaW5nU3RyZWFtLmpzXCJ9XSxcInBsdWdpblxcXFxmaWxlLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBNb2R1bGUgZm9yIHdvcmtpbmcgd2l0aCBmaWxlLiBTaGFsbCBpbXBsZW1lbnRcbiAqIElFbW1ldEZpbGUgaW50ZXJmYWNlLlxuICpcbiAqIFNpbmNlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbW9kdWxlIGRlcGVuZHNcbiAqIGdyZWF0bHkgb24gY3VycmVudCBydW50aW1lLCB0aGlzIG1vZHVsZSBtdXN0IGJlXG4gKiBpbml0aWFsaXplZCB3aXRoIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBmaXJzdFxuICogYmVmb3JlIHVzZS4gRS5nLlxuICogcmVxdWlyZSgnLi9wbHVnaW4vZmlsZScpKHtcbiAqIFx0cmVhZDogZnVuY3Rpb24oKSB7Li4ufVxuICogfSlcbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIG1vZHVsZSBwcm92aWRlcyBOb2RlLkpTIGltcGxlbWVudGF0aW9uXG4gKi9cblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciBfdHJhbnNwb3J0ID0ge307XG5cblx0Ly8gaGlkZSBpdCBmcm9tIFJlcXVpcmUuSlMgcGFyc2VyXG5cdChmdW5jdGlvbihyKSB7XG5cdFx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICd1bmRlZmluZWQnIHx8ICFkZWZpbmUuYW1kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmcyA9IHIoJ2ZzJyk7XG5cdFx0XHRcdHBhdGggPSByKCdwYXRoJyk7XG5cdFx0XHRcdF90cmFuc3BvcnQuaHR0cCA9IHIoJ2h0dHAnKTtcblx0XHRcdFx0X3RyYW5zcG9ydC5odHRwcyA9IHIoJ2h0dHBzJyk7XG5cdFx0XHR9IGNhdGNoKGUpIHsgfVxuXHRcdH1cblx0fSkocmVxdWlyZSk7XG5cblx0Ly8gbW9kdWxlIGlzIGEgZnVuY3Rpb24gdGhhdCBjYW4gZXh0ZW5kIGl0c2VsZlxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdGlmIChvYmopIHtcblx0XHRcdHV0aWxzLmV4dGVuZChtb2R1bGUuZXhwb3J0cywgb2JqKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gYnRzKGJ5dGVzKSB7XG5cdFx0dmFyIG91dCA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBpbCA9IGJ5dGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dC5qb2luKCcnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzVVJMKHBhdGgpIHtcblx0XHR2YXIgcmUgPSAvXmh0dHBzPzpcXC9cXC8vO1xuXHRcdHJldHVybiByZS50ZXN0KHBhdGgpO1xuXHR9XG5cblx0cmV0dXJuIHV0aWxzLmV4dGVuZChtb2R1bGUuZXhwb3J0cywge1xuXHRcdF9wYXJzZVBhcmFtczogZnVuY3Rpb24oYXJncykge1xuXHRcdFx0dmFyIHBhcmFtcyA9IHtcblx0XHRcdFx0cGF0aDogYXJnc1swXSxcblx0XHRcdFx0c2l6ZTogMFxuXHRcdFx0fTtcblxuXHRcdFx0YXJncyA9IHV0aWxzLnRvQXJyYXkoYXJncywgMSk7XG5cdFx0XHRwYXJhbXMuY2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG5cdFx0XHRhcmdzID0gYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpO1xuXHRcdFx0aWYgKGFyZ3MubGVuZ3RoKSB7XG5cdFx0XHRcdHBhcmFtcy5zaXplID0gYXJnc1swXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBhcmFtcztcblx0XHR9LFxuXG5cdFx0X3JlYWQ6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRcdGlmIChpc1VSTChwYXJhbXMucGF0aCkpIHtcblx0XHRcdFx0dmFyIHJlcSA9IF90cmFuc3BvcnRbL15odHRwczovLnRlc3QocGFyYW1zLnBhdGgpID8gJ2h0dHBzJyA6ICdodHRwJ10uZ2V0KHBhcmFtcy5wYXRoLCBmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0XHR2YXIgYnVmcyA9IFtdO1xuXHRcdFx0XHRcdHZhciB0b3RhbExlbmd0aCA9IDA7XG5cdFx0XHRcdFx0dmFyIGZpbmlzaGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0cmVzXG5cdFx0XHRcdFx0XHQub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuXHRcdFx0XHRcdFx0XHR0b3RhbExlbmd0aCArPSBjaHVuay5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGJ1ZnMucHVzaChjaHVuayk7XG5cdFx0XHRcdFx0XHRcdGlmIChwYXJhbXMuc2l6ZSAmJiB0b3RhbExlbmd0aCA+PSBwYXJhbXMuc2l6ZSkge1xuXHRcdFx0XHRcdFx0XHRcdGZpbmlzaGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCBCdWZmZXIuY29uY2F0KGJ1ZnMpKTtcblx0XHRcdFx0XHRcdFx0XHRyZXEuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5vbignZW5kJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghZmluaXNoZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRmaW5pc2hlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChidWZzKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KS5vbignZXJyb3InLCBjYWxsYmFjayk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAocGFyYW1zLnNpemUpIHtcblx0XHRcdFx0XHR2YXIgZmQgPSBmcy5vcGVuU3luYyhwYXJhbXMucGF0aCwgJ3InKTtcblx0XHRcdFx0XHR2YXIgYnVmID0gbmV3IEJ1ZmZlcihwYXJhbXMuc2l6ZSk7XG5cdFx0XHRcdFx0ZnMucmVhZChmZCwgYnVmLCAwLCBwYXJhbXMuc2l6ZSwgbnVsbCwgZnVuY3Rpb24oZXJyLCBieXRlc1JlYWQpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKGVyciwgYnVmKVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIGZzLnJlYWRGaWxlU3luYyhwYXJhbXMucGF0aCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlYWRzIGJpbmFyeSBmaWxlIGNvbnRlbnQgYW5kIHJldHVybiBpdFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIEZpbGUncyByZWxhdGl2ZSBvciBhYnNvbHV0ZSBwYXRoXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHJlYWQ6IGZ1bmN0aW9uKHBhdGgsIHNpemUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgcGFyYW1zID0gdGhpcy5fcGFyc2VQYXJhbXMoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX3JlYWQocGFyYW1zLCBmdW5jdGlvbihlcnIsIGJ1Zikge1xuXHRcdFx0XHRwYXJhbXMuY2FsbGJhY2soZXJyLCBlcnIgPyAnJyA6IGJ0cyhidWYpKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZWFkIGZpbGUgY29udGVudCBhbmQgcmV0dXJuIGl0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhdGggRmlsZSdzIHJlbGF0aXZlIG9yIGFic29sdXRlIHBhdGhcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cmVhZFRleHQ6IGZ1bmN0aW9uKHBhdGgsIHNpemUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgcGFyYW1zID0gdGhpcy5fcGFyc2VQYXJhbXMoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX3JlYWQocGFyYW1zLCBmdW5jdGlvbihlcnIsIGJ1Zikge1xuXHRcdFx0XHRwYXJhbXMuY2FsbGJhY2soZXJyLCBlcnIgPyAnJyA6IGJ1Zi50b1N0cmluZygpKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBMb2NhdGUgPGNvZGU+ZmlsZV9uYW1lPC9jb2RlPiBmaWxlIHRoYXQgcmVsYXRlcyB0byA8Y29kZT5lZGl0b3JfZmlsZTwvY29kZT4uXG5cdFx0ICogRmlsZSBuYW1lIG1heSBiZSBhYnNvbHV0ZSBvciByZWxhdGl2ZSBwYXRoXG5cdFx0ICpcblx0XHQgKiA8Yj5EZWFsaW5nIHdpdGggYWJzb2x1dGUgcGF0aC48L2I+XG5cdFx0ICogTWFueSBtb2Rlcm4gZWRpdG9ycyBoYXZlIGEgXCJwcm9qZWN0XCIgc3VwcG9ydCBhcyBpbmZvcm1hdGlvbiB1bml0LCBidXQgeW91XG5cdFx0ICogc2hvdWxkIG5vdCByZWx5IG9uIHByb2plY3QgcGF0aCB0byBmaW5kIGZpbGUgd2l0aCBhYnNvbHV0ZSBwYXRoLiBGaXJzdCxcblx0XHQgKiBpdCByZXF1aXJlcyB1c2VyIHRvIGNyZWF0ZSBhIHByb2plY3QgYmVmb3JlIHVzaW5nIHRoaXMgbWV0aG9kIChhbmQgdGhpc1xuXHRcdCAqIGlzIG5vdCB2ZXJ5IGNvbnZlbmllbnQpLiBTZWNvbmQsIHByb2plY3QgcGF0aCBkb2Vzbid0IGFsd2F5cyBwb2ludHMgdG9cblx0XHQgKiB0byB3ZWJzaXRlJ3MgZG9jdW1lbnQgcm9vdCBmb2xkZXI6IGl0IG1heSBwb2ludCwgZm9yIGV4YW1wbGUsIHRvIGFuXG5cdFx0ICogdXBwZXIgZm9sZGVyIHdoaWNoIGNvbnRhaW5zIHNlcnZlci1zaWRlIHNjcmlwdHMuXG5cdFx0ICpcblx0XHQgKiBGb3IgYmV0dGVyIHJlc3VsdCwgeW91IHNob3VsZCB1c2UgdGhlIGZvbGxvd2luZyBhbGdvcml0aG0gaW4gbG9jYXRpbmdcblx0XHQgKiBhYnNvbHV0ZSByZXNvdXJjZXM6XG5cdFx0ICogMSkgR2V0IHBhcmVudCBmb2xkZXIgZm9yIDxjb2RlPmVkaXRvckZpbGU8L2NvZGU+IGFzIGEgc3RhcnQgcG9pbnRcblx0XHQgKiAyKSBBcHBlbmQgcmVxdWlyZWQgPGNvZGU+ZmlsZU5hbWU8L2NvZGU+IHRvIHN0YXJ0IHBvaW50IGFuZCB0ZXN0IGlmXG5cdFx0ICogZmlsZSBleGlzdHNcblx0XHQgKiAzKSBJZiBpdCBkb2Vzbid0IGV4aXN0cywgbW92ZSBzdGFydCBwb2ludCBvbmUgbGV2ZWwgdXAgKHRvIHBhcmVudCBmb2xkZXIpXG5cdFx0ICogYW5kIHJlcGVhdCBzdGVwIDIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gZWRpdG9yRmlsZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlTmFtZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBudWxsIGlmIDxjb2RlPmZpbGVOYW1lPC9jb2RlPiBjYW5ub3QgYmUgbG9jYXRlZFxuXHRcdCAqL1xuXHRcdGxvY2F0ZUZpbGU6IGZ1bmN0aW9uKGVkaXRvckZpbGUsIGZpbGVOYW1lLCBjYWxsYmFjaykge1xuXHRcdFx0aWYgKGlzVVJMKGZpbGVOYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soZmlsZU5hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGlybmFtZSA9IGVkaXRvckZpbGVcblx0XHRcdHZhciBmaWxlcGF0aDtcblx0XHRcdGZpbGVOYW1lID0gZmlsZU5hbWUucmVwbGFjZSgvXlxcLysvLCAnJyk7XG5cdFx0XHR3aGlsZSAoZGlybmFtZSAmJiBkaXJuYW1lICE9PSBwYXRoLmRpcm5hbWUoZGlybmFtZSkpIHtcblx0XHRcdFx0ZGlybmFtZSA9IHBhdGguZGlybmFtZShkaXJuYW1lKTtcblx0XHRcdFx0ZmlsZXBhdGggPSBwYXRoLmpvaW4oZGlybmFtZSwgZmlsZU5hbWUpO1xuXHRcdFx0XHRpZiAoZnMuZXhpc3RzU3luYyhmaWxlcGF0aCkpXG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGZpbGVwYXRoKTtcblx0XHRcdH1cblxuXHRcdFx0Y2FsbGJhY2sobnVsbCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYWJzb2x1dGUgcGF0aCBieSBjb25jYXRlbmF0aW5nIDxjb2RlPnBhcmVudDwvY29kZT4gYW5kIDxjb2RlPmZpbGVOYW1lPC9jb2RlPi5cblx0XHQgKiBJZiA8Y29kZT5wYXJlbnQ8L2NvZGU+IHBvaW50cyB0byBmaWxlLCBpdHMgcGFyZW50IGRpcmVjdG9yeSBpcyB1c2VkXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlTmFtZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRjcmVhdGVQYXRoOiBmdW5jdGlvbihwYXJlbnQsIGZpbGVOYW1lLCBjYWxsYmFjaykge1xuXHRcdFx0ZnMuc3RhdChwYXJlbnQsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuXHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc3RhdC5pc0ZpbGUoKSkge1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhdGguZGlybmFtZShwYXJlbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGZpbGVwYXRoID0gcGF0aC5yZXNvbHZlKHBhcmVudCwgZmlsZU5hbWUpO1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCBmaWxlcGF0aCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2F2ZXMgPGNvZGU+Y29udGVudDwvY29kZT4gYXMgPGNvZGU+ZmlsZTwvY29kZT5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gZmlsZSBGaWxlJ3MgYWJzb2x1dGUgcGF0aFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50IEZpbGUgY29udGVudFxuXHRcdCAqL1xuXHRcdHNhdmU6IGZ1bmN0aW9uKGZpbGUsIGNvbnRlbnQsIGNhbGxiYWNrKSB7XG5cdFx0XHRmcy53cml0ZUZpbGUoZmlsZSwgY29udGVudCwgJ2FzY2lpJywgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVyciA/IGVyciA6IG51bGwpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgZmlsZSBleHRlbnNpb24gaW4gbG93ZXIgY2FzZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldEV4dDogZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0dmFyIG0gPSAoZmlsZSB8fCAnJykubWF0Y2goL1xcLihbXFx3XFwtXSspJC8pO1xuXHRcdFx0cmV0dXJuIG0gPyBtWzFdLnRvTG93ZXJDYXNlKCkgOiAnJztcblx0XHR9XG5cblx0fSk7XG59KTtcblxufSx7XCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wifV0sXCJyZXNvbHZlclxcXFxjc3MuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFJlc29sdmVyIGZvciBmYXN0IENTUyB0eXBpbmcuIEhhbmRsZXMgYWJicmV2aWF0aW9ucyB3aXRoIHRoZSBmb2xsb3dpbmcgXG4gKiBub3RhdGlvbjo8YnI+XG4gKiBcbiAqIDxjb2RlPigtdmVuZG9yIHByZWZpeCk/cHJvcGVydHkodmFsdWUpKighKT88L2NvZGU+XG4gKiBcbiAqIDxicj48YnI+XG4gKiA8Yj5BYmJyZXZpYXRpb24gaGFuZGxpbmc8L2I+PGJyPlxuICogXG4gKiBCeSBkZWZhdWx0LCBFbW1ldCBzZWFyY2hlcyBmb3IgbWF0Y2hpbmcgc25pcHBldCBkZWZpbml0aW9uIGZvciBwcm92aWRlZCBhYmJyZXZpYXRpb24uXG4gKiBJZiBzbmlwcGV0IHdhc24ndCBmb3VuZCwgRW1tZXQgYXV0b21hdGljYWxseSBnZW5lcmF0ZXMgZWxlbWVudCB3aXRoIFxuICogYWJicmV2aWF0aW9uJ3MgbmFtZS4gRm9yIGV4YW1wbGUsIDxjb2RlPmZvbzwvY29kZT4gYWJicmV2aWF0aW9uIHdpbGwgZ2VuZXJhdGVcbiAqIDxjb2RlPiZsdDtmb28mZ3Q7Jmx0Oy9mb28mZ3Q7PC9jb2RlPiBvdXRwdXQuXG4gKiA8YnI+PGJyPlxuICogVGhpcyBtb2R1bGUgd2lsbCBjYXB0dXJlIGFsbCBleHBhbmRlZCBwcm9wZXJ0aWVzIGFuZCB1cGdyYWRlIHRoZW0gd2l0aCB2YWx1ZXMsIFxuICogdmVuZG9yIHByZWZpeGVzIGFuZCAhaW1wb3J0YW50IGRlY2xhcmF0aW9ucy4gQWxsIHVubWF0Y2hlZCBhYmJyZXZpYXRpb25zIHdpbGwgXG4gKiBiZSBhdXRvbWF0aWNhbGx5IHRyYW5zZm9ybWVkIGludG8gPGNvZGU+cHJvcGVydHktbmFtZTogJHsxfTwvY29kZT4gc25pcHBldHMuIFxuICogXG4gKiA8Yj5WZW5kb3IgcHJlZml4ZXM8Yj48YnI+XG4gKiBcbiAqIElmIENTUy1wcm9wZXJ0eSBpcyBwcmVjZWRlZCB3aXRoIGRhc2gsIHJlc29sdmVyIHNob3VsZCBvdXRwdXQgcHJvcGVydHkgd2l0aFxuICogYWxsIDxpPmtub3duPC9pPiB2ZW5kb3IgcHJlZml4ZXMuIEZvciBleGFtcGxlLCBpZiA8Y29kZT5icmFkPC9jb2RlPiBcbiAqIGFiYnJldmlhdGlvbiBnZW5lcmF0ZXMgPGNvZGU+Ym9yZGVyLXJhZGl1czogJHt2YWx1ZX07PC9jb2RlPiBzbmlwcGV0LFxuICogdGhlIDxjb2RlPi1icmFkPC9jb2RlPiBhYmJyZXZpYXRpb24gc2hvdWxkIGdlbmVyYXRlOlxuICogPHByZT48Y29kZT5cbiAqIC13ZWJraXQtYm9yZGVyLXJhZGl1czogJHt2YWx1ZX07XG4gKiAtbW96LWJvcmRlci1yYWRpdXM6ICR7dmFsdWV9O1xuICogYm9yZGVyLXJhZGl1czogJHt2YWx1ZX07XG4gKiA8L2NvZGU+PC9wcmU+XG4gKiBOb3RlIHRoYXQgPGk+bzwvaT4gYW5kIDxpPm1zPC9pPiBwcmVmaXhlcyBhcmUgb21pdHRlZCBzaW5jZSBPcGVyYSBhbmQgSUUgXG4gKiBzdXBwb3J0cyB1bnByZWZpeGVkIHByb3BlcnR5Ljxicj48YnI+XG4gKiBcbiAqIFVzZXJzIGNhbiBhbHNvIHByb3ZpZGUgYW4gZXhwbGljaXQgbGlzdCBvZiBvbmUtY2hhcmFjdGVyIHByZWZpeGVzIGZvciBhbnlcbiAqIENTUyBwcm9wZXJ0eS4gRm9yIGV4YW1wbGUsIDxjb2RlPi13bS1mbG9hdDwvY29kZT4gd2lsbCBwcm9kdWNlXG4gKiBcbiAqIDxwcmU+PGNvZGU+XG4gKiAtd2Via2l0LWZsb2F0OiAkezF9O1xuICogLW1vei1mbG9hdDogJHsxfTtcbiAqIGZsb2F0OiAkezF9O1xuICogPC9jb2RlPjwvcHJlPlxuICogXG4gKiBBbHRob3VnaCB0aGlzIGV4YW1wbGUgbG9va3MgcG9pbnRsZXNzLCB1c2VycyBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byB3cml0ZVxuICogY3V0dGluZy1lZGdlIHByb3BlcnRpZXMgaW1wbGVtZW50ZWQgYnkgYnJvd3NlciB2ZW5kb3JzIHJlY2VudGx5LiAgXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBwcmVmcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9wcmVmZXJlbmNlcycpO1xuXHR2YXIgcmVzb3VyY2VzID0gcmVxdWlyZSgnLi4vYXNzZXRzL3Jlc291cmNlcycpO1xuXHR2YXIgc3RyaW5nU3RyZWFtID0gcmVxdWlyZSgnLi4vYXNzZXRzL3N0cmluZ1N0cmVhbScpO1xuXHR2YXIgY2l1ID0gcmVxdWlyZSgnLi4vYXNzZXRzL2Nhbml1c2UnKTtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdHZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL3RlbXBsYXRlJyk7XG5cdHZhciBjc3NFZGl0VHJlZSA9IHJlcXVpcmUoJy4uL2VkaXRUcmVlL2NzcycpO1xuXG5cdHZhciBwcmVmaXhPYmogPSB7XG5cdFx0LyoqIFJlYWwgdmVuZG9yIHByZWZpeCBuYW1lICovXG5cdFx0cHJlZml4OiAnZW1tZXQnLFxuXHRcdFxuXHRcdC8qKiBcblx0XHQgKiBJbmRpY2F0ZXMgdGhpcyBwcmVmaXggaXMgb2Jzb2xldGUgYW5kIHNob3VsZCd0IGJlIHVzZWQgd2hlbiB1c2VyIFxuXHRcdCAqIHdhbnRzIHRvIGdlbmVyYXRlIGFsbC1wcmVmaXhlZCBwcm9wZXJ0aWVzXG5cdFx0ICovXG5cdFx0b2Jzb2xldGU6IGZhbHNlLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgcHJlZml4ZWQgQ1NTIHByb3BlcnR5IG5hbWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBVbnByZWZpeGVkIENTUyBwcm9wZXJ0eVxuXHRcdCAqL1xuXHRcdHRyYW5zZm9ybU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiAnLScgKyB0aGlzLnByZWZpeCArICctJyArIG5hbWU7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBMaXN0IG9mIHVucHJlZml4ZWQgQ1NTIHByb3BlcnRpZXMgdGhhdCBzdXBwb3J0ZWQgYnkgXG5cdFx0ICogY3VycmVudCBwcmVmaXguIFRoaXMgbGlzdCBpcyB1c2VkIHRvIGdlbmVyYXRlIGFsbC1wcmVmaXhlZCBwcm9wZXJ0eVxuXHRcdCAqIEByZXR1cm5zIHtBcnJheX0gXG5cdFx0ICovXG5cdFx0cHJvcGVydGllczogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZ2V0UHJvcGVydGllcygnY3NzLicgKyB0aGlzLnByZWZpeCArICdQcm9wZXJ0aWVzJykgfHwgW107XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBnaXZlbiBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBwcmVmaXhcblx0XHQgKiBAcGFyYW0gbmFtZVxuXHRcdCAqL1xuXHRcdHN1cHBvcnRzOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gfnRoaXMucHJvcGVydGllcygpLmluZGV4T2YobmFtZSk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qKiBcblx0ICogTGlzdCBvZiByZWdpc3RlcmVkIG9uZS1jaGFyYWN0ZXIgcHJlZml4ZXMuIEtleSBpcyBhIG9uZS1jaGFyYWN0ZXIgcHJlZml4LCBcblx0ICogdmFsdWUgaXMgYW4gPGNvZGU+cHJlZml4T2JqPC9jb2RlPiBvYmplY3Rcblx0ICovXG5cdHZhciB2ZW5kb3JQcmVmaXhlcyA9IHt9O1xuXHRcblx0dmFyIGRlZmF1bHRWYWx1ZSA9ICckezF9Oyc7XG5cdFxuXHQvLyBYWFggbW9kdWxlIHByZWZlcmVuY2VzXG5cdHByZWZzLmRlZmluZSgnY3NzLnZhbHVlU2VwYXJhdG9yJywgJzogJyxcblx0XHRcdCdEZWZpbmVzIGEgc3ltYm9sIHRoYXQgc2hvdWxkIGJlIHBsYWNlZCBiZXR3ZWVuIENTUyBwcm9wZXJ0eSBhbmQgJyBcblx0XHRcdCsgJ3ZhbHVlIHdoZW4gZXhwYW5kaW5nIENTUyBhYmJyZXZpYXRpb25zLicpO1xuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5wcm9wZXJ0eUVuZCcsICc7Jyxcblx0XHRcdCdEZWZpbmVzIGEgc3ltYm9sIHRoYXQgc2hvdWxkIGJlIHBsYWNlZCBhdCB0aGUgZW5kIG9mIENTUyBwcm9wZXJ0eSAgJyBcblx0XHRcdCsgJ3doZW4gZXhwYW5kaW5nIENTUyBhYmJyZXZpYXRpb25zLicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdzdHlsdXMudmFsdWVTZXBhcmF0b3InLCAnICcsXG5cdFx0XHQnRGVmaW5lcyBhIHN5bWJvbCB0aGF0IHNob3VsZCBiZSBwbGFjZWQgYmV0d2VlbiBDU1MgcHJvcGVydHkgYW5kICcgXG5cdFx0XHQrICd2YWx1ZSB3aGVuIGV4cGFuZGluZyBDU1MgYWJicmV2aWF0aW9ucyBpbiBTdHlsdXMgZGlhbGVjdC4nKTtcblx0cHJlZnMuZGVmaW5lKCdzdHlsdXMucHJvcGVydHlFbmQnLCAnJyxcblx0XHRcdCdEZWZpbmVzIGEgc3ltYm9sIHRoYXQgc2hvdWxkIGJlIHBsYWNlZCBhdCB0aGUgZW5kIG9mIENTUyBwcm9wZXJ0eSAgJyBcblx0XHRcdCsgJ3doZW4gZXhwYW5kaW5nIENTUyBhYmJyZXZpYXRpb25zIGluIFN0eWx1cyBkaWFsZWN0LicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdzYXNzLnByb3BlcnR5RW5kJywgJycsXG5cdFx0XHQnRGVmaW5lcyBhIHN5bWJvbCB0aGF0IHNob3VsZCBiZSBwbGFjZWQgYXQgdGhlIGVuZCBvZiBDU1MgcHJvcGVydHkgICcgXG5cdFx0XHQrICd3aGVuIGV4cGFuZGluZyBDU1MgYWJicmV2aWF0aW9ucyBpbiBTQVNTIGRpYWxlY3QuJyk7XG5cblx0cHJlZnMuZGVmaW5lKCdjc3Muc3ludGF4ZXMnLCAnY3NzLCBsZXNzLCBzYXNzLCBzY3NzLCBzdHlsdXMsIHN0eWwnLFxuXHRcdFx0J0xpc3Qgb2Ygc3ludGF4ZXMgdGhhdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBDU1MgZGlhbGVjdHMuJyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5hdXRvSW5zZXJ0VmVuZG9yUHJlZml4ZXMnLCB0cnVlLFxuXHRcdFx0J0F1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgdmVuZG9yLXByZWZpeGVkIGNvcGllcyBvZiBleHBhbmRlZCBDU1MgJyBcblx0XHRcdCsgJ3Byb3BlcnR5LiBCeSBkZWZhdWx0LCBFbW1ldCB3aWxsIGdlbmVyYXRlIHZlbmRvci1wcmVmaXhlZCAnXG5cdFx0XHQrICdwcm9wZXJ0aWVzIG9ubHkgd2hlbiB5b3UgcHV0IGRhc2ggYmVmb3JlIGFiYnJldmlhdGlvbiAnIFxuXHRcdFx0KyAnKGUuZy4gPGNvZGU+LWJ4c2g8L2NvZGU+KS4gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB5b3UgZG9u4oCZdCAnIFxuXHRcdFx0KyAnbmVlZCBkYXNoZXMgYmVmb3JlIGFiYnJldmlhdGlvbnM6IEVtbWV0IHdpbGwgcHJvZHVjZSAnIFxuXHRcdFx0KyAndmVuZG9yLXByZWZpeGVkIHByb3BlcnRpZXMgZm9yIHlvdS4nKTtcblxuXHRwcmVmcy5kZWZpbmUoJ2xlc3MuYXV0b0luc2VydFZlbmRvclByZWZpeGVzJywgZmFsc2UsICdTYW1lIGFzIDxjb2RlPmNzcy5hdXRvSW5zZXJ0VmVuZG9yUHJlZml4ZXM8L2NvZGU+IGJ1dCBmb3IgTEVTUyBzeW50YXgnKTtcblx0cHJlZnMuZGVmaW5lKCdzY3NzLmF1dG9JbnNlcnRWZW5kb3JQcmVmaXhlcycsIGZhbHNlLCAnU2FtZSBhcyA8Y29kZT5jc3MuYXV0b0luc2VydFZlbmRvclByZWZpeGVzPC9jb2RlPiBidXQgZm9yIFNDU1Mgc3ludGF4Jyk7XG5cdHByZWZzLmRlZmluZSgnc2Fzcy5hdXRvSW5zZXJ0VmVuZG9yUHJlZml4ZXMnLCBmYWxzZSwgJ1NhbWUgYXMgPGNvZGU+Y3NzLmF1dG9JbnNlcnRWZW5kb3JQcmVmaXhlczwvY29kZT4gYnV0IGZvciBTQVNTIHN5bnRheCcpO1xuXHRwcmVmcy5kZWZpbmUoJ3N0eWx1cy5hdXRvSW5zZXJ0VmVuZG9yUHJlZml4ZXMnLCBmYWxzZSwgJ1NhbWUgYXMgPGNvZGU+Y3NzLmF1dG9JbnNlcnRWZW5kb3JQcmVmaXhlczwvY29kZT4gYnV0IGZvciBTdHlsdXMgc3ludGF4Jyk7XG5cdFxuXHR2YXIgZGVzY1RlbXBsYXRlID0gdGVtcGxhdGUoJ0EgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgQ1NTIHByb3BlcnRpZXMgdGhhdCBtYXkgaGF2ZSAnIFxuXHRcdCsgJzxjb2RlPjwlPSB2ZW5kb3IgJT48L2NvZGU+IHZlbmRvciBwcmVmaXguIFRoaXMgbGlzdCBpcyB1c2VkIHRvIGdlbmVyYXRlICdcblx0XHQrICdhIGxpc3Qgb2YgcHJlZml4ZWQgcHJvcGVydGllcyB3aGVuIGV4cGFuZGluZyA8Y29kZT4tcHJvcGVydHk8L2NvZGU+ICdcblx0XHQrICdhYmJyZXZpYXRpb25zLiBFbXB0eSBsaXN0IG1lYW5zIHRoYXQgYWxsIHBvc3NpYmxlIENTUyB2YWx1ZXMgbWF5ICcgXG5cdFx0KyAnaGF2ZSA8Y29kZT48JT0gdmVuZG9yICU+PC9jb2RlPiBwcmVmaXguJyk7XG5cdFxuXHR2YXIgZGVzY0FkZG9uVGVtcGxhdGUgPSB0ZW1wbGF0ZSgnQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiA8ZW0+YWRkaXRpb25hbDwvZW0+IENTUyBwcm9wZXJ0aWVzICcgXG5cdFx0XHQrICdmb3IgPGNvZGU+Y3NzLjwlPSB2ZW5kb3IgJT5QcmVwZXJ0aWVzPC9jb2RlPiBwcmVmZXJlbmNlLiAnIFxuXHRcdFx0KyAnWW91IHNob3VsZCB1c2UgdGhpcyBsaXN0IGlmIHlvdSB3YW50IHRvIGFkZCBvciByZW1vdmUgYSBmZXcgQ1NTICcgXG5cdFx0XHQrICdwcm9wZXJ0aWVzIHRvIG9yaWdpbmFsIHNldC4gVG8gYWRkIGEgbmV3IHByb3BlcnR5LCBzaW1wbHkgd3JpdGUgaXRzIG5hbWUsICdcblx0XHRcdCsgJ3RvIHJlbW92ZSBpdCwgcHJlY2VkZSBwcm9wZXJ0eSB3aXRoIGh5cGhlbi48YnI+J1xuXHRcdFx0KyAnRm9yIGV4YW1wbGUsIHRvIGFkZCA8ZW0+Zm9vPC9lbT4gcHJvcGVydHkgYW5kIHJlbW92ZSA8ZW0+Ym9yZGVyLXJhZGl1czwvZW0+IG9uZSwgJ1xuXHRcdFx0KyAndGhlIHByZWZlcmVuY2UgdmFsdWUgd2lsbCBsb29rIGxpa2UgdGhpczogPGNvZGU+Zm9vLCAtYm9yZGVyLXJhZGl1czwvY29kZT4uJyk7XG5cdFxuXHQvLyBwcm9wZXJ0aWVzIGxpc3QgaXMgY3JlYXRlZCBmcm9tIGNzc0ZlYXR1cmVzLmh0bWwgZmlsZVxuXHR2YXIgcHJvcHMgPSB7XG5cdFx0J3dlYmtpdCc6ICdhbmltYXRpb24sIGFuaW1hdGlvbi1kZWxheSwgYW5pbWF0aW9uLWRpcmVjdGlvbiwgYW5pbWF0aW9uLWR1cmF0aW9uLCBhbmltYXRpb24tZmlsbC1tb2RlLCBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50LCBhbmltYXRpb24tbmFtZSwgYW5pbWF0aW9uLXBsYXktc3RhdGUsIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24sIGFwcGVhcmFuY2UsIGJhY2tmYWNlLXZpc2liaWxpdHksIGJhY2tncm91bmQtY2xpcCwgYmFja2dyb3VuZC1jb21wb3NpdGUsIGJhY2tncm91bmQtb3JpZ2luLCBiYWNrZ3JvdW5kLXNpemUsIGJvcmRlci1maXQsIGJvcmRlci1ob3Jpem9udGFsLXNwYWNpbmcsIGJvcmRlci1pbWFnZSwgYm9yZGVyLXZlcnRpY2FsLXNwYWNpbmcsIGJveC1hbGlnbiwgYm94LWRpcmVjdGlvbiwgYm94LWZsZXgsIGJveC1mbGV4LWdyb3VwLCBib3gtbGluZXMsIGJveC1vcmRpbmFsLWdyb3VwLCBib3gtb3JpZW50LCBib3gtcGFjaywgYm94LXJlZmxlY3QsIGJveC1zaGFkb3csIGNvbG9yLWNvcnJlY3Rpb24sIGNvbHVtbi1icmVhay1hZnRlciwgY29sdW1uLWJyZWFrLWJlZm9yZSwgY29sdW1uLWJyZWFrLWluc2lkZSwgY29sdW1uLWNvdW50LCBjb2x1bW4tZ2FwLCBjb2x1bW4tcnVsZS1jb2xvciwgY29sdW1uLXJ1bGUtc3R5bGUsIGNvbHVtbi1ydWxlLXdpZHRoLCBjb2x1bW4tc3BhbiwgY29sdW1uLXdpZHRoLCBkYXNoYm9hcmQtcmVnaW9uLCBmb250LXNtb290aGluZywgaGlnaGxpZ2h0LCBoeXBoZW5hdGUtY2hhcmFjdGVyLCBoeXBoZW5hdGUtbGltaXQtYWZ0ZXIsIGh5cGhlbmF0ZS1saW1pdC1iZWZvcmUsIGh5cGhlbnMsIGxpbmUtYm94LWNvbnRhaW4sIGxpbmUtYnJlYWssIGxpbmUtY2xhbXAsIGxvY2FsZSwgbWFyZ2luLWJlZm9yZS1jb2xsYXBzZSwgbWFyZ2luLWFmdGVyLWNvbGxhcHNlLCBtYXJxdWVlLWRpcmVjdGlvbiwgbWFycXVlZS1pbmNyZW1lbnQsIG1hcnF1ZWUtcmVwZXRpdGlvbiwgbWFycXVlZS1zdHlsZSwgbWFzay1hdHRhY2htZW50LCBtYXNrLWJveC1pbWFnZSwgbWFzay1ib3gtaW1hZ2Utb3V0c2V0LCBtYXNrLWJveC1pbWFnZS1yZXBlYXQsIG1hc2stYm94LWltYWdlLXNsaWNlLCBtYXNrLWJveC1pbWFnZS1zb3VyY2UsIG1hc2stYm94LWltYWdlLXdpZHRoLCBtYXNrLWNsaXAsIG1hc2stY29tcG9zaXRlLCBtYXNrLWltYWdlLCBtYXNrLW9yaWdpbiwgbWFzay1wb3NpdGlvbiwgbWFzay1yZXBlYXQsIG1hc2stc2l6ZSwgbmJzcC1tb2RlLCBwZXJzcGVjdGl2ZSwgcGVyc3BlY3RpdmUtb3JpZ2luLCBydGwtb3JkZXJpbmcsIHRleHQtY29tYmluZSwgdGV4dC1kZWNvcmF0aW9ucy1pbi1lZmZlY3QsIHRleHQtZW1waGFzaXMtY29sb3IsIHRleHQtZW1waGFzaXMtcG9zaXRpb24sIHRleHQtZW1waGFzaXMtc3R5bGUsIHRleHQtZmlsbC1jb2xvciwgdGV4dC1vcmllbnRhdGlvbiwgdGV4dC1zZWN1cml0eSwgdGV4dC1zdHJva2UtY29sb3IsIHRleHQtc3Ryb2tlLXdpZHRoLCB0cmFuc2Zvcm0sIHRyYW5zaXRpb24sIHRyYW5zZm9ybS1vcmlnaW4sIHRyYW5zZm9ybS1zdHlsZSwgdHJhbnNpdGlvbi1kZWxheSwgdHJhbnNpdGlvbi1kdXJhdGlvbiwgdHJhbnNpdGlvbi1wcm9wZXJ0eSwgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24sIHVzZXItZHJhZywgdXNlci1tb2RpZnksIHVzZXItc2VsZWN0LCB3cml0aW5nLW1vZGUsIHN2Zy1zaGFkb3csIGJveC1zaXppbmcsIGJvcmRlci1yYWRpdXMnLFxuXHRcdCdtb3onOiAnYW5pbWF0aW9uLWRlbGF5LCBhbmltYXRpb24tZGlyZWN0aW9uLCBhbmltYXRpb24tZHVyYXRpb24sIGFuaW1hdGlvbi1maWxsLW1vZGUsIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsIGFuaW1hdGlvbi1uYW1lLCBhbmltYXRpb24tcGxheS1zdGF0ZSwgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbiwgYXBwZWFyYW5jZSwgYmFja2ZhY2UtdmlzaWJpbGl0eSwgYmFja2dyb3VuZC1pbmxpbmUtcG9saWN5LCBiaW5kaW5nLCBib3JkZXItYm90dG9tLWNvbG9ycywgYm9yZGVyLWltYWdlLCBib3JkZXItbGVmdC1jb2xvcnMsIGJvcmRlci1yaWdodC1jb2xvcnMsIGJvcmRlci10b3AtY29sb3JzLCBib3gtYWxpZ24sIGJveC1kaXJlY3Rpb24sIGJveC1mbGV4LCBib3gtb3JkaW5hbC1ncm91cCwgYm94LW9yaWVudCwgYm94LXBhY2ssIGJveC1zaGFkb3csIGJveC1zaXppbmcsIGNvbHVtbi1jb3VudCwgY29sdW1uLWdhcCwgY29sdW1uLXJ1bGUtY29sb3IsIGNvbHVtbi1ydWxlLXN0eWxlLCBjb2x1bW4tcnVsZS13aWR0aCwgY29sdW1uLXdpZHRoLCBmbG9hdC1lZGdlLCBmb250LWZlYXR1cmUtc2V0dGluZ3MsIGZvbnQtbGFuZ3VhZ2Utb3ZlcnJpZGUsIGZvcmNlLWJyb2tlbi1pbWFnZS1pY29uLCBoeXBoZW5zLCBpbWFnZS1yZWdpb24sIG9yaWVudCwgb3V0bGluZS1yYWRpdXMtYm90dG9tbGVmdCwgb3V0bGluZS1yYWRpdXMtYm90dG9tcmlnaHQsIG91dGxpbmUtcmFkaXVzLXRvcGxlZnQsIG91dGxpbmUtcmFkaXVzLXRvcHJpZ2h0LCBwZXJzcGVjdGl2ZSwgcGVyc3BlY3RpdmUtb3JpZ2luLCBzdGFjay1zaXppbmcsIHRhYi1zaXplLCB0ZXh0LWJsaW5rLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIHRleHQtZGVjb3JhdGlvbi1saW5lLCB0ZXh0LWRlY29yYXRpb24tc3R5bGUsIHRleHQtc2l6ZS1hZGp1c3QsIHRyYW5zZm9ybSwgdHJhbnNmb3JtLW9yaWdpbiwgdHJhbnNmb3JtLXN0eWxlLCB0cmFuc2l0aW9uLCB0cmFuc2l0aW9uLWRlbGF5LCB0cmFuc2l0aW9uLWR1cmF0aW9uLCB0cmFuc2l0aW9uLXByb3BlcnR5LCB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiwgdXNlci1mb2N1cywgdXNlci1pbnB1dCwgdXNlci1tb2RpZnksIHVzZXItc2VsZWN0LCB3aW5kb3ctc2hhZG93LCBiYWNrZ3JvdW5kLWNsaXAsIGJvcmRlci1yYWRpdXMnLFxuXHRcdCdtcyc6ICdhY2NlbGVyYXRvciwgYmFja2ZhY2UtdmlzaWJpbGl0eSwgYmFja2dyb3VuZC1wb3NpdGlvbi14LCBiYWNrZ3JvdW5kLXBvc2l0aW9uLXksIGJlaGF2aW9yLCBibG9jay1wcm9ncmVzc2lvbiwgYm94LWFsaWduLCBib3gtZGlyZWN0aW9uLCBib3gtZmxleCwgYm94LWxpbmUtcHJvZ3Jlc3Npb24sIGJveC1saW5lcywgYm94LW9yZGluYWwtZ3JvdXAsIGJveC1vcmllbnQsIGJveC1wYWNrLCBjb250ZW50LXpvb20tYm91bmRhcnksIGNvbnRlbnQtem9vbS1ib3VuZGFyeS1tYXgsIGNvbnRlbnQtem9vbS1ib3VuZGFyeS1taW4sIGNvbnRlbnQtem9vbS1jaGFpbmluZywgY29udGVudC16b29tLXNuYXAsIGNvbnRlbnQtem9vbS1zbmFwLXBvaW50cywgY29udGVudC16b29tLXNuYXAtdHlwZSwgY29udGVudC16b29taW5nLCBmaWx0ZXIsIGZsb3ctZnJvbSwgZmxvdy1pbnRvLCBmb250LWZlYXR1cmUtc2V0dGluZ3MsIGdyaWQtY29sdW1uLCBncmlkLWNvbHVtbi1hbGlnbiwgZ3JpZC1jb2x1bW4tc3BhbiwgZ3JpZC1jb2x1bW5zLCBncmlkLWxheWVyLCBncmlkLXJvdywgZ3JpZC1yb3ctYWxpZ24sIGdyaWQtcm93LXNwYW4sIGdyaWQtcm93cywgaGlnaC1jb250cmFzdC1hZGp1c3QsIGh5cGhlbmF0ZS1saW1pdC1jaGFycywgaHlwaGVuYXRlLWxpbWl0LWxpbmVzLCBoeXBoZW5hdGUtbGltaXQtem9uZSwgaHlwaGVucywgaW1lLW1vZGUsIGludGVycG9sYXRpb24tbW9kZSwgbGF5b3V0LWZsb3csIGxheW91dC1ncmlkLCBsYXlvdXQtZ3JpZC1jaGFyLCBsYXlvdXQtZ3JpZC1saW5lLCBsYXlvdXQtZ3JpZC1tb2RlLCBsYXlvdXQtZ3JpZC10eXBlLCBsaW5lLWJyZWFrLCBvdmVyZmxvdy1zdHlsZSwgcGVyc3BlY3RpdmUsIHBlcnNwZWN0aXZlLW9yaWdpbiwgcGVyc3BlY3RpdmUtb3JpZ2luLXgsIHBlcnNwZWN0aXZlLW9yaWdpbi15LCBzY3JvbGwtYm91bmRhcnksIHNjcm9sbC1ib3VuZGFyeS1ib3R0b20sIHNjcm9sbC1ib3VuZGFyeS1sZWZ0LCBzY3JvbGwtYm91bmRhcnktcmlnaHQsIHNjcm9sbC1ib3VuZGFyeS10b3AsIHNjcm9sbC1jaGFpbmluZywgc2Nyb2xsLXJhaWxzLCBzY3JvbGwtc25hcC1wb2ludHMteCwgc2Nyb2xsLXNuYXAtcG9pbnRzLXksIHNjcm9sbC1zbmFwLXR5cGUsIHNjcm9sbC1zbmFwLXgsIHNjcm9sbC1zbmFwLXksIHNjcm9sbGJhci1hcnJvdy1jb2xvciwgc2Nyb2xsYmFyLWJhc2UtY29sb3IsIHNjcm9sbGJhci1kYXJrc2hhZG93LWNvbG9yLCBzY3JvbGxiYXItZmFjZS1jb2xvciwgc2Nyb2xsYmFyLWhpZ2hsaWdodC1jb2xvciwgc2Nyb2xsYmFyLXNoYWRvdy1jb2xvciwgc2Nyb2xsYmFyLXRyYWNrLWNvbG9yLCB0ZXh0LWFsaWduLWxhc3QsIHRleHQtYXV0b3NwYWNlLCB0ZXh0LWp1c3RpZnksIHRleHQta2FzaGlkYS1zcGFjZSwgdGV4dC1vdmVyZmxvdywgdGV4dC1zaXplLWFkanVzdCwgdGV4dC11bmRlcmxpbmUtcG9zaXRpb24sIHRvdWNoLWFjdGlvbiwgdHJhbnNmb3JtLCB0cmFuc2Zvcm0tb3JpZ2luLCB0cmFuc2Zvcm0tb3JpZ2luLXgsIHRyYW5zZm9ybS1vcmlnaW4teSwgdHJhbnNmb3JtLW9yaWdpbi16LCB0cmFuc2Zvcm0tc3R5bGUsIHRyYW5zaXRpb24sIHRyYW5zaXRpb24tZGVsYXksIHRyYW5zaXRpb24tZHVyYXRpb24sIHRyYW5zaXRpb24tcHJvcGVydHksIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uLCB1c2VyLXNlbGVjdCwgd29yZC1icmVhaywgd3JhcC1mbG93LCB3cmFwLW1hcmdpbiwgd3JhcC10aHJvdWdoLCB3cml0aW5nLW1vZGUnLFxuXHRcdCdvJzogJ2Rhc2hib2FyZC1yZWdpb24sIGFuaW1hdGlvbiwgYW5pbWF0aW9uLWRlbGF5LCBhbmltYXRpb24tZGlyZWN0aW9uLCBhbmltYXRpb24tZHVyYXRpb24sIGFuaW1hdGlvbi1maWxsLW1vZGUsIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsIGFuaW1hdGlvbi1uYW1lLCBhbmltYXRpb24tcGxheS1zdGF0ZSwgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbiwgYm9yZGVyLWltYWdlLCBsaW5rLCBsaW5rLXNvdXJjZSwgb2JqZWN0LWZpdCwgb2JqZWN0LXBvc2l0aW9uLCB0YWItc2l6ZSwgdGFibGUtYmFzZWxpbmUsIHRyYW5zZm9ybSwgdHJhbnNmb3JtLW9yaWdpbiwgdHJhbnNpdGlvbiwgdHJhbnNpdGlvbi1kZWxheSwgdHJhbnNpdGlvbi1kdXJhdGlvbiwgdHJhbnNpdGlvbi1wcm9wZXJ0eSwgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24sIGFjY2Vzc2tleSwgaW5wdXQtZm9ybWF0LCBpbnB1dC1yZXF1aXJlZCwgbWFycXVlZS1kaXIsIG1hcnF1ZWUtbG9vcCwgbWFycXVlZS1zcGVlZCwgbWFycXVlZS1zdHlsZSdcblx0fTtcblx0XG5cdE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcblx0XHRwcmVmcy5kZWZpbmUoJ2Nzcy4nICsgayArICdQcm9wZXJ0aWVzJywgcHJvcHNba10sIGRlc2NUZW1wbGF0ZSh7dmVuZG9yOiBrfSkpO1xuXHRcdHByZWZzLmRlZmluZSgnY3NzLicgKyBrICsgJ1Byb3BlcnRpZXNBZGRvbicsICcnLCBkZXNjQWRkb25UZW1wbGF0ZSh7dmVuZG9yOiBrfSkpO1xuXHR9KTtcblx0XG5cdHByZWZzLmRlZmluZSgnY3NzLnVuaXRsZXNzUHJvcGVydGllcycsICd6LWluZGV4LCBsaW5lLWhlaWdodCwgb3BhY2l0eSwgZm9udC13ZWlnaHQsIHpvb20nLCBcblx0XHRcdCdUaGUgbGlzdCBvZiBwcm9wZXJ0aWVzIHdob3NlIHZhbHVlcyDigIvigIttdXN0IG5vdCBjb250YWluIHVuaXRzLicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdjc3MuaW50VW5pdCcsICdweCcsICdEZWZhdWx0IHVuaXQgZm9yIGludGVnZXIgdmFsdWVzJyk7XG5cdHByZWZzLmRlZmluZSgnY3NzLmZsb2F0VW5pdCcsICdlbScsICdEZWZhdWx0IHVuaXQgZm9yIGZsb2F0IHZhbHVlcycpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdjc3Mua2V5d29yZHMnLCAnYXV0bywgaW5oZXJpdCwgYWxsJywgXG5cdFx0XHQnQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2YWxpZCBrZXl3b3JkcyB0aGF0IGNhbiBiZSB1c2VkIGluIENTUyBhYmJyZXZpYXRpb25zLicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdjc3Mua2V5d29yZEFsaWFzZXMnLCAnYTphdXRvLCBpOmluaGVyaXQsIHM6c29saWQsIGRhOmRhc2hlZCwgZG86ZG90dGVkLCB0OnRyYW5zcGFyZW50JywgXG5cdFx0XHQnQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBrZXl3b3JkIGFsaWFzZXMsIHVzZWQgaW4gQ1NTIGFiYnJldmlhdGlvbi4gJ1xuXHRcdFx0KyAnRWFjaCBhbGlhcyBzaG91bGQgYmUgZGVmaW5lZCBhcyA8Y29kZT5hbGlhczprZXl3b3JkX25hbWU8L2NvZGU+LicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdjc3MudW5pdEFsaWFzZXMnLCAnZTplbSwgcDolLCB4OmV4LCByOnJlbScsIFxuXHRcdFx0J0EgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdW5pdCBhbGlhc2VzLCB1c2VkIGluIENTUyBhYmJyZXZpYXRpb24uICdcblx0XHRcdCsgJ0VhY2ggYWxpYXMgc2hvdWxkIGJlIGRlZmluZWQgYXMgPGNvZGU+YWxpYXM6dW5pdF92YWx1ZTwvY29kZT4uJyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5jb2xvci5zaG9ydCcsIHRydWUsIFxuXHRcdFx0J1Nob3VsZCBjb2xvciB2YWx1ZXMgbGlrZSA8Y29kZT4jZmZmZmZmPC9jb2RlPiBiZSBzaG9ydGVuZWQgdG8gJ1xuXHRcdFx0KyAnPGNvZGU+I2ZmZjwvY29kZT4gYWZ0ZXIgYWJicmV2aWF0aW9uIHdpdGggY29sb3Igd2FzIGV4cGFuZGVkLicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdjc3MuY29sb3IuY2FzZScsICdrZWVwJywgXG5cdFx0XHQnTGV0dGVyIGNhc2Ugb2YgY29sb3IgdmFsdWVzIGdlbmVyYXRlZCBieSBhYmJyZXZpYXRpb25zIHdpdGggY29sb3IgJ1xuXHRcdFx0KyAnKGxpa2UgPGNvZGU+YyMwPC9jb2RlPikuIFBvc3NpYmxlIHZhbHVlcyBhcmUgPGNvZGU+dXBwZXI8L2NvZGU+LCAnXG5cdFx0XHQrICc8Y29kZT5sb3dlcjwvY29kZT4gYW5kIDxjb2RlPmtlZXA8L2NvZGU+LicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdjc3MuZnV6enlTZWFyY2gnLCB0cnVlLCBcblx0XHRcdCdFbmFibGUgZnV6enkgc2VhcmNoIGFtb25nIENTUyBzbmlwcGV0IG5hbWVzLiBXaGVuIGVuYWJsZWQsIGV2ZXJ5ICcgXG5cdFx0XHQrICc8ZW0+dW5rbm93bjwvZW0+IHNuaXBwZXQgd2lsbCBiZSBzY29yZWQgYWdhaW5zdCBhdmFpbGFibGUgc25pcHBldCAnXG5cdFx0XHQrICduYW1lcyAobm90IHZhbHVlcyBvciBDU1MgcHJvcGVydGllcyEpLiBUaGUgbWF0Y2ggd2l0aCBiZXN0IHNjb3JlICdcblx0XHRcdCsgJ3dpbGwgYmUgdXNlZCB0byByZXNvbHZlIHNuaXBwZXQgdmFsdWUuIEZvciBleGFtcGxlLCB3aXRoIHRoaXMgJyBcblx0XHRcdCsgJ3ByZWZlcmVuY2UgZW5hYmxlZCwgdGhlIGZvbGxvd2luZyBhYmJyZXZpYXRpb25zIGFyZSBlcXVhbDogJ1xuXHRcdFx0KyAnPGNvZGU+b3Y6aDwvY29kZT4gPT0gPGNvZGU+b3YtaDwvY29kZT4gPT0gPGNvZGU+by1oPC9jb2RlPiA9PSAnXG5cdFx0XHQrICc8Y29kZT5vaDwvY29kZT4nKTtcblx0XG5cdHByZWZzLmRlZmluZSgnY3NzLmZ1enp5U2VhcmNoTWluU2NvcmUnLCAwLjMsIFxuXHRcdFx0J1RoZSBtaW5pdW0gc2NvcmUgKGZyb20gMCB0byAxKSB0aGF0IGZ1enp5LW1hdGNoZWQgYWJicmV2aWF0aW9uIHNob3VsZCAnIFxuXHRcdFx0KyAnYWNoaXZlLiBMb3dlciB2YWx1ZXMgbWF5IHByb2R1Y2UgbWFueSBmYWxzZS1wb3NpdGl2ZSBtYXRjaGVzLCAnXG5cdFx0XHQrICdoaWdoZXIgdmFsdWVzIG1heSByZWR1Y2UgcG9zc2libGUgbWF0Y2hlcy4nKTtcblx0XG5cdHByZWZzLmRlZmluZSgnY3NzLmFsaWduVmVuZG9yJywgZmFsc2UsIFxuXHRcdFx0J0lmIHNldCB0byA8Y29kZT50cnVlPC9jb2RlPiwgYWxsIGdlbmVyYXRlZCB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydGllcyAnIFxuXHRcdFx0KyAnd2lsbCBiZSBhbGlnbmVkIGJ5IHJlYWwgcHJvcGVydHkgbmFtZS4nKTtcblx0XG5cdFxuXHRmdW5jdGlvbiBpc051bWVyaWMoY2gpIHtcblx0XHR2YXIgY29kZSA9IGNoICYmIGNoLmNoYXJDb2RlQXQoMCk7XG5cdFx0cmV0dXJuIChjaCAmJiBjaCA9PSAnLicgfHwgKGNvZGUgPiA0NyAmJiBjb2RlIDwgNTgpKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIHByb3ZpZGVkIHNuaXBwZXQgY29udGFpbnMgb25seSBvbmUgQ1NTIHByb3BlcnR5IGFuZCB2YWx1ZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHNuaXBwZXRcblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBpc1NpbmdsZVByb3BlcnR5KHNuaXBwZXQpIHtcblx0XHRzbmlwcGV0ID0gdXRpbHMudHJpbShzbmlwcGV0KTtcblx0XHRcblx0XHQvLyBjaGVjayBpZiBpdCBkb2Vzbid0IGNvbnRhaW4gYSBjb21tZW50IGFuZCBhIG5ld2xpbmVcblx0XHRpZiAoL1xcL1xcKnxcXG58XFxyLy50ZXN0KHNuaXBwZXQpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIGNoZWNrIGlmIGl0J3MgYSB2YWxpZCBzbmlwcGV0IGRlZmluaXRpb25cblx0XHRpZiAoIS9eW2EtejAtOVxcLV0rXFxzKlxcOi9pLnRlc3Qoc25pcHBldCkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHNuaXBwZXQucmVwbGFjZSgvXFwkXFx7Lis/XFx9L2csICcnKS5zcGxpdCgnOicpLmxlbmd0aCA9PSAyO1xuXHR9XG5cdFxuXHQvKipcblx0ICogTm9ybWFsaXplcyBhYmJyZXZpYXRlZCB2YWx1ZSB0byBmaW5hbCBDU1Mgb25lXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcblx0XHRpZiAodmFsdWUuY2hhckF0KDApID09ICctJyAmJiAhL15cXC1bXFwuXFxkXS8udGVzdCh2YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXlxcLSsvLCAnJyk7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBjaCA9IHZhbHVlLmNoYXJBdCgwKTtcblx0XHRpZiAoY2ggPT0gJyMnKSB7XG5cdFx0XHRyZXR1cm4gbm9ybWFsaXplSGV4Q29sb3IodmFsdWUpO1xuXHRcdH1cblxuXHRcdGlmIChjaCA9PSAnJCcpIHtcblx0XHRcdHJldHVybiB1dGlscy5lc2NhcGVUZXh0KHZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZ2V0S2V5d29yZCh2YWx1ZSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZUhleENvbG9yKHZhbHVlKSB7XG5cdFx0dmFyIGhleCA9IHZhbHVlLnJlcGxhY2UoL14jKy8sICcnKSB8fCAnMCc7XG5cdFx0aWYgKGhleC50b0xvd2VyQ2FzZSgpID09ICd0Jykge1xuXHRcdFx0cmV0dXJuICd0cmFuc3BhcmVudCc7XG5cdFx0fVxuXG5cdFx0dmFyIG9wYWNpdHkgPSAnJztcblx0XHRoZXggPSBoZXgucmVwbGFjZSgvXFwuKFxcZCspJC8sIGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0b3BhY2l0eSA9ICcwJyArIHN0cjtcblx0XHRcdHJldHVybiAnJztcblx0XHR9KTtcblx0XHRcblx0XHR2YXIgcmVwZWF0ID0gdXRpbHMucmVwZWF0U3RyaW5nO1xuXHRcdHZhciBjb2xvciA9IG51bGw7XG5cdFx0c3dpdGNoIChoZXgubGVuZ3RoKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdGNvbG9yID0gcmVwZWF0KGhleCwgNik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRjb2xvciA9IHJlcGVhdChoZXgsIDMpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMzpcblx0XHRcdFx0Y29sb3IgPSBoZXguY2hhckF0KDApICsgaGV4LmNoYXJBdCgwKSArIGhleC5jaGFyQXQoMSkgKyBoZXguY2hhckF0KDEpICsgaGV4LmNoYXJBdCgyKSArIGhleC5jaGFyQXQoMik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRjb2xvciA9IGhleCArIGhleC5zdWJzdHIoMCwgMik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSA1OlxuXHRcdFx0XHRjb2xvciA9IGhleCArIGhleC5jaGFyQXQoMCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29sb3IgPSBoZXguc3Vic3RyKDAsIDYpO1xuXHRcdH1cblxuXHRcdGlmIChvcGFjaXR5KSB7XG5cdFx0XHRyZXR1cm4gdG9SZ2JhKGNvbG9yLCBvcGFjaXR5KTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gY29sb3IgbXVzdCBiZSBzaG9ydGVuZWQ/XG5cdFx0aWYgKHByZWZzLmdldCgnY3NzLmNvbG9yLnNob3J0JykpIHtcblx0XHRcdHZhciBwID0gY29sb3Iuc3BsaXQoJycpO1xuXHRcdFx0aWYgKHBbMF0gPT0gcFsxXSAmJiBwWzJdID09IHBbM10gJiYgcFs0XSA9PSBwWzVdKSB7XG5cdFx0XHRcdGNvbG9yID0gcFswXSArIHBbMl0gKyBwWzRdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBzaG91bGQgdHJhbnNmb3JtIGNhc2U/XG5cdFx0c3dpdGNoIChwcmVmcy5nZXQoJ2Nzcy5jb2xvci5jYXNlJykpIHtcblx0XHRcdGNhc2UgJ3VwcGVyJzpcblx0XHRcdFx0Y29sb3IgPSBjb2xvci50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2xvd2VyJzpcblx0XHRcdFx0Y29sb3IgPSBjb2xvci50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuICcjJyArIGNvbG9yO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgSEVYIGNvbG9yIGRlZmluaXRpb24gaW50byBSR0JBIG9uZVxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9IGNvbG9yICAgSEVYIGNvbG9yLCA2IGNoYXJhY3RlcnNcblx0ICogQHBhcmFtICB7U3RyaW5nfSBvcGFjaXR5IE9wYWNpdHkgdmFsdWVcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gdG9SZ2JhKGNvbG9yLCBvcGFjaXR5KSB7XG5cdFx0dmFyIHIgPSBwYXJzZUludChjb2xvci5zdWJzdHIoMCwgMiksIDE2KTtcblx0XHR2YXIgZyA9IHBhcnNlSW50KGNvbG9yLnN1YnN0cigyLCAyKSwgMTYpO1xuXHRcdHZhciBiID0gcGFyc2VJbnQoY29sb3Iuc3Vic3RyKDQsIDIpLCAxNik7XG5cblx0XHRyZXR1cm4gJ3JnYmEoJyArIFtyLCBnLCBiLCBvcGFjaXR5XS5qb2luKCcsICcpICsgJyknO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBnZXRLZXl3b3JkKG5hbWUpIHtcblx0XHR2YXIgYWxpYXNlcyA9IHByZWZzLmdldERpY3QoJ2Nzcy5rZXl3b3JkQWxpYXNlcycpO1xuXHRcdHJldHVybiBuYW1lIGluIGFsaWFzZXMgPyBhbGlhc2VzW25hbWVdIDogbmFtZTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZ2V0VW5pdChuYW1lKSB7XG5cdFx0dmFyIGFsaWFzZXMgPSBwcmVmcy5nZXREaWN0KCdjc3MudW5pdEFsaWFzZXMnKTtcblx0XHRyZXR1cm4gbmFtZSBpbiBhbGlhc2VzID8gYWxpYXNlc1tuYW1lXSA6IG5hbWU7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGlzVmFsaWRLZXl3b3JkKGtleXdvcmQpIHtcblx0XHRyZXR1cm4gfnByZWZzLmdldEFycmF5KCdjc3Mua2V5d29yZHMnKS5pbmRleE9mKGdldEtleXdvcmQoa2V5d29yZCkpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgcGFzc2VkIENTUyBwcm9wZXJ0eSBzdXBwb3J0IHNwZWNpZmllZCB2ZW5kb3IgcHJlZml4IFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeFxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzUHJlZml4KHByb3BlcnR5LCBwcmVmaXgpIHtcblx0XHR2YXIgaW5mbyA9IHZlbmRvclByZWZpeGVzW3ByZWZpeF07XG5cdFx0XG5cdFx0aWYgKCFpbmZvKVxuXHRcdFx0aW5mbyA9IHV0aWxzLmZpbmQodmVuZG9yUHJlZml4ZXMsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0cmV0dXJuIGRhdGEucHJlZml4ID09IHByZWZpeDtcblx0XHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiBpbmZvICYmIGluZm8uc3VwcG9ydHMocHJvcGVydHkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmRzIGF2YWlsYWJsZSB2ZW5kb3IgcHJlZml4ZXMgZm9yIGdpdmVuIENTUyBwcm9wZXJ0eS5cblx0ICogU2VhcmNoIGlzIHBlcmZvcm1lZCB3aXRoaW4gQ2FuIEkgVXNlIGRhdGFiYXNlIGFuZCBpbnRlcm5hbFxuXHQgKiBwcm9wZXJ0eSBsaXN0XG5cdCAqIEBwYXJhbSAge1N0cmluZ30gcHJvcGVydHkgQ1NTIHByb3BlcnR5IG5hbWVcblx0ICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIHJlc29sdmVkIHByZWZpeGVzIG9yIG51bGwgaWZcblx0ICogcHJlZml4ZXMgYXJlIG5vdCBhdmFpbGFibGUgZm9yIHRoaXMgcHJvcGVydHkgYXQgYWxsLlxuXHQgKiBFbXB0eSBhcnJheSBtZWFucyBwcmVmaXhlcyBhcmUgbm90IGF2YWlsYWJsZSBmb3IgY3VycmVudFxuXHQgKiB1c2VyLWRlZmluZSBlcmFcblx0ICovXG5cdGZ1bmN0aW9uIGZpbmRWZW5kb3JQcmVmaXhlcyhwcm9wZXJ0eSkge1xuXHRcdHZhciBwcmVmaXhlcyA9IGNpdS5yZXNvbHZlUHJlZml4ZXMocHJvcGVydHkpO1xuXHRcdGlmICghcHJlZml4ZXMpIHtcblx0XHRcdC8vIENhbiBJIFVzZSBkYXRhYmFzZSBpcyBkaXNhYmxlZCBvciBwcmVmaXhlcyBhcmUgbm90XG5cdFx0XHQvLyBhdmFpbGFibGUgZm9yIHRoaXMgcHJvcGVydHlcblx0XHRcdHByZWZpeGVzID0gW107XG5cdFx0XHRPYmplY3Qua2V5cyh2ZW5kb3JQcmVmaXhlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0aWYgKGhhc1ByZWZpeChwcm9wZXJ0eSwga2V5KSkge1xuXHRcdFx0XHRcdHByZWZpeGVzLnB1c2godmVuZG9yUHJlZml4ZXNba2V5XS5wcmVmaXgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCFwcmVmaXhlcy5sZW5ndGgpIHtcblx0XHRcdFx0cHJlZml4ZXMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBwcmVmaXhlcztcblx0fVxuXHRcblx0LyoqXG5cdCAqIFNlYXJjaCBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCBwcmVmaXhlcyBmb3IgQ1NTIHByb3BlcnR5LiBUaGlzIGxpc3Rcblx0ICogaXMgdXNlZCB0byBnZW5lcmF0ZSBhbGwtcHJlZml4ZWQgc25pcHBldFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgQ1NTIHByb3BlcnR5IG5hbWVcblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gZmluZEludGVybmFsUHJlZml4ZXMocHJvcGVydHksIG5vQXV0b2ZpbGwpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0dmFyIHByZWZpeGVzID0gZmluZFZlbmRvclByZWZpeGVzKHByb3BlcnR5KTtcblx0XHRcblx0XHRpZiAocHJlZml4ZXMpIHtcblx0XHRcdHZhciBwcmVmaXhNYXAgPSB7fTtcblx0XHRcdE9iamVjdC5rZXlzKHZlbmRvclByZWZpeGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRwcmVmaXhNYXBbdmVuZG9yUHJlZml4ZXNba2V5XS5wcmVmaXhdID0ga2V5O1xuXHRcdFx0fSk7XG5cblx0XHRcdHJlc3VsdCA9IHByZWZpeGVzLm1hcChmdW5jdGlvbihwcmVmaXgpIHtcblx0XHRcdFx0cmV0dXJuIHByZWZpeE1hcFtwcmVmaXhdO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmICghcmVzdWx0Lmxlbmd0aCAmJiAhbm9BdXRvZmlsbCkge1xuXHRcdFx0Ly8gYWRkIGFsbCBub24tb2Jzb2xldGUgcHJlZml4ZXNcblx0XHRcdE9iamVjdC5rZXlzKHZlbmRvclByZWZpeGVzKS5mb3JFYWNoKGZ1bmN0aW9uKHByZWZpeCkge1xuXHRcdFx0XHRpZiAoIXZlbmRvclByZWZpeGVzW3ByZWZpeF0ub2Jzb2xldGUpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChwcmVmaXgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXHRcblx0ZnVuY3Rpb24gYWRkUHJlZml4KG5hbWUsIG9iaikge1xuXHRcdGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHRcdFx0b2JqID0ge3ByZWZpeDogb2JqfTtcblx0XHR9XG5cdFx0XG5cdFx0dmVuZG9yUHJlZml4ZXNbbmFtZV0gPSB1dGlscy5leHRlbmQoe30sIHByZWZpeE9iaiwgb2JqKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZ2V0U3ludGF4UHJlZmVyZW5jZShuYW1lLCBzeW50YXgpIHtcblx0XHRpZiAoc3ludGF4KSB7XG5cdFx0XHQvLyBoYWNreSBhbGlhcyBmb3IgU3R5bHVzIGRpYWxlY3Rcblx0XHRcdGlmIChzeW50YXggPT0gJ3N0eWwnKSB7XG5cdFx0XHRcdHN5bnRheCA9ICdzdHlsdXMnO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdmFsID0gcHJlZnMuZ2V0KHN5bnRheCArICcuJyArIG5hbWUpO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBwcmVmcy5nZXQoJ2Nzcy4nICsgbmFtZSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBGb3JtYXQgQ1NTIHByb3BlcnR5IGFjY29yZGluZyB0byBjdXJyZW50IHN5bnRheCBkaWFsZWN0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4XG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShwcm9wZXJ0eSwgc3ludGF4KSB7XG5cdFx0dmFyIGl4ID0gcHJvcGVydHkuaW5kZXhPZignOicpO1xuXHRcdHByb3BlcnR5ID0gcHJvcGVydHkuc3Vic3RyaW5nKDAsIGl4KS5yZXBsYWNlKC9cXHMrJC8sICcnKSBcblx0XHRcdCsgZ2V0U3ludGF4UHJlZmVyZW5jZSgndmFsdWVTZXBhcmF0b3InLCBzeW50YXgpXG5cdFx0XHQrIHV0aWxzLnRyaW0ocHJvcGVydHkuc3Vic3RyaW5nKGl4ICsgMSkpO1xuXHRcdFxuXHRcdHJldHVybiBwcm9wZXJ0eS5yZXBsYWNlKC9cXHMqO1xccyokLywgZ2V0U3ludGF4UHJlZmVyZW5jZSgncHJvcGVydHlFbmQnLCBzeW50YXgpKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgc25pcHBldCB2YWx1ZSBpZiByZXF1aXJlZC4gRm9yIGV4YW1wbGUsIHRoaXMgdHJhbnNmb3JtYXRpb25cblx0ICogbWF5IGFkZCA8aT4haW1wb3J0YW50PC9pPiBkZWNsYXJhdGlvbiB0byBDU1MgcHJvcGVydHlcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNuaXBwZXRcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0ltcG9ydGFudFxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gdHJhbnNmb3JtU25pcHBldChzbmlwcGV0LCBpc0ltcG9ydGFudCwgc3ludGF4KSB7XG5cdFx0aWYgKHR5cGVvZiBzbmlwcGV0ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0c25pcHBldCA9IHNuaXBwZXQuZGF0YTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKCFpc1NpbmdsZVByb3BlcnR5KHNuaXBwZXQpKSB7XG5cdFx0XHRyZXR1cm4gc25pcHBldDtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKGlzSW1wb3J0YW50KSB7XG5cdFx0XHRpZiAofnNuaXBwZXQuaW5kZXhPZignOycpKSB7XG5cdFx0XHRcdHNuaXBwZXQgPSBzbmlwcGV0LnNwbGl0KCc7Jykuam9pbignICFpbXBvcnRhbnQ7Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzbmlwcGV0ICs9ICcgIWltcG9ydGFudCc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmb3JtYXRQcm9wZXJ0eShzbmlwcGV0LCBzeW50YXgpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKGtleSkge1xuXHRcdHZhciBsaXN0ID0gcHJlZnMuZ2V0QXJyYXkoa2V5KTtcblx0XHR2YXIgYWRkb24gPSBwcmVmcy5nZXRBcnJheShrZXkgKyAnQWRkb24nKTtcblx0XHRpZiAoYWRkb24pIHtcblx0XHRcdGFkZG9uLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuXHRcdFx0XHRpZiAocHJvcC5jaGFyQXQoMCkgPT0gJy0nKSB7XG5cdFx0XHRcdFx0bGlzdCA9IHV0aWxzLndpdGhvdXQobGlzdCwgcHJvcC5zdWJzdHIoMSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChwcm9wLmNoYXJBdCgwKSA9PSAnKycpXG5cdFx0XHRcdFx0XHRwcm9wID0gcHJvcC5zdWJzdHIoMSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0bGlzdC5wdXNoKHByb3ApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGxpc3Q7XG5cdH1cblxuXHQvKipcblx0ICogVHJpZXMgdG8gcHJvZHVjZSBwcm9wZXJ0aWVzIHdpdGggdmVuZG9yLXByZWZpeGVkIHZhbHVlXG5cdCAqIEBwYXJhbSAge09iamVjdH0gc25pcHBldE9iaiBQYXJzZWQgc25pcHBldCBvYmplY3Rcblx0ICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIHByb3BlcnRpZXMgd2l0aCBwcmVmaXhlZCB2YWx1ZXNcblx0ICovXG5cdGZ1bmN0aW9uIHJlc29sdmVQcmVmaXhlZFZhbHVlcyhzbmlwcGV0T2JqLCBpc0ltcG9ydGFudCwgc3ludGF4KSB7XG5cdFx0dmFyIHByZWZpeGVzID0gW107XG5cdFx0dmFyIGxvb2t1cCA9IHt9O1xuXG5cdFx0dmFyIHBhcnRzID0gY3NzRWRpdFRyZWUuZmluZFBhcnRzKHNuaXBwZXRPYmoudmFsdWUpO1xuXHRcdHBhcnRzLnJldmVyc2UoKTtcblx0XHRwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcblx0XHRcdHZhciBwYXJ0VmFsdWUgPSBwLnN1YnN0cmluZyhzbmlwcGV0T2JqLnZhbHVlKTtcblx0XHRcdChmaW5kVmVuZG9yUHJlZml4ZXMocGFydFZhbHVlKSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihwcmVmaXgpIHtcblx0XHRcdFx0aWYgKCFsb29rdXBbcHJlZml4XSkge1xuXHRcdFx0XHRcdGxvb2t1cFtwcmVmaXhdID0gc25pcHBldE9iai52YWx1ZTtcblx0XHRcdFx0XHRwcmVmaXhlcy5wdXNoKHByZWZpeCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsb29rdXBbcHJlZml4XSA9IHV0aWxzLnJlcGxhY2VTdWJzdHJpbmcobG9va3VwW3ByZWZpeF0sICctJyArIHByZWZpeCArICctJyArIHBhcnRWYWx1ZSwgcCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBwcmVmaXhlcy5tYXAoZnVuY3Rpb24ocHJlZml4KSB7XG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtU25pcHBldChzbmlwcGV0T2JqLm5hbWUgKyAnOicgKyBsb29rdXBbcHJlZml4XSwgaXNJbXBvcnRhbnQsIHN5bnRheCk7XG5cdFx0fSk7XG5cdH1cblx0XG5cdFxuXHQvLyBUT0RPIHJlZmFjdG9yLCB0aGlzIGxvb2tzIGF3a3dhcmQgbm93XG5cdGFkZFByZWZpeCgndycsIHtcblx0XHRwcmVmaXg6ICd3ZWJraXQnXG5cdH0pO1xuXHRhZGRQcmVmaXgoJ20nLCB7XG5cdFx0cHJlZml4OiAnbW96J1xuXHR9KTtcblx0YWRkUHJlZml4KCdzJywge1xuXHRcdHByZWZpeDogJ21zJ1xuXHR9KTtcblx0YWRkUHJlZml4KCdvJywge1xuXHRcdHByZWZpeDogJ28nXG5cdH0pO1xuXHRcblx0XG5cdG1vZHVsZSA9IG1vZHVsZSB8fCB7fTtcblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdFx0LyoqXG5cdFx0ICogQWRkcyB2ZW5kb3IgcHJlZml4XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgT25lLWNoYXJhY3RlciBwcmVmaXggbmFtZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IGRlc2NyaWJpbmcgdmVuZG9yIHByZWZpeFxuXHRcdCAqIEBtZW1iZXJPZiBjc3NSZXNvbHZlclxuXHRcdCAqL1xuXHRcdGFkZFByZWZpeDogYWRkUHJlZml4LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIHBhc3NlZCBDU1MgcHJvcGVydHkgc3VwcG9ydHMgc3BlY2lmaWVkIHZlbmRvciBwcmVmaXhcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG5cdFx0ICovXG5cdFx0c3VwcG9ydHNQcmVmaXg6IGhhc1ByZWZpeCxcblxuXHRcdHJlc29sdmU6IGZ1bmN0aW9uKG5vZGUsIHN5bnRheCkge1xuXHRcdFx0dmFyIGNzc1N5bnRheGVzID0gcHJlZnMuZ2V0QXJyYXkoJ2Nzcy5zeW50YXhlcycpO1xuXHRcdFx0aWYgKGNzc1N5bnRheGVzICYmIH5jc3NTeW50YXhlcy5pbmRleE9mKHN5bnRheCkgJiYgbm9kZS5pc0VsZW1lbnQoKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHBhbmRUb1NuaXBwZXQobm9kZS5hYmJyZXZpYXRpb24sIHN5bnRheCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHByZWZpeGVkIHZlcnNpb24gb2YgcGFzc2VkIENTUyBwcm9wZXJ0eSwgb25seSBpZiB0aGlzXG5cdFx0ICogcHJvcGVydHkgc3VwcG9ydHMgc3VjaCBwcmVmaXhcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRwcmVmaXhlZDogZnVuY3Rpb24ocHJvcGVydHksIHByZWZpeCkge1xuXHRcdFx0cmV0dXJuIGhhc1ByZWZpeChwcm9wZXJ0eSwgcHJlZml4KSBcblx0XHRcdFx0PyAnLScgKyBwcmVmaXggKyAnLScgKyBwcm9wZXJ0eSBcblx0XHRcdFx0OiBwcm9wZXJ0eTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbGlzdCBvZiBhbGwgcmVnaXN0ZXJlZCB2ZW5kb3IgcHJlZml4ZXNcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0bGlzdFByZWZpeGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB2ZW5kb3JQcmVmaXhlcy5tYXAoZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHJldHVybiBvYmoucHJlZml4O1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIG9iamVjdCBkZXNjcmliaW5nIHZlbmRvciBwcmVmaXhcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0UHJlZml4OiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gdmVuZG9yUHJlZml4ZXNbbmFtZV07XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHByZWZpeCBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHRcdCAqL1xuXHRcdHJlbW92ZVByZWZpeDogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0aWYgKG5hbWUgaW4gdmVuZG9yUHJlZml4ZXMpXG5cdFx0XHRcdGRlbGV0ZSB2ZW5kb3JQcmVmaXhlc1tuYW1lXTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4dHJhY3QgdmVuZG9yIHByZWZpeGVzIGZyb20gYWJicmV2aWF0aW9uXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFiYnJcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBhcnJheSBvZiBwcmVmaXhlcyBhbmQgY2xlYW4gXG5cdFx0ICogYWJicmV2aWF0aW9uIG5hbWVcblx0XHQgKi9cblx0XHRleHRyYWN0UHJlZml4ZXM6IGZ1bmN0aW9uKGFiYnIpIHtcblx0XHRcdGlmIChhYmJyLmNoYXJBdCgwKSAhPSAnLScpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRwcm9wZXJ0eTogYWJicixcblx0XHRcdFx0XHRwcmVmaXhlczogbnVsbFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBhYmJyZXZpYXRpb24gbWF5IGVpdGhlciBjb250YWluIHNlcXVlbmNlIG9mIG9uZS1jaGFyYWN0ZXIgcHJlZml4ZXNcblx0XHRcdC8vIG9yIGp1c3QgZGFzaCwgbWVhbmluZyB0aGF0IHVzZXIgd2FudHMgdG8gcHJvZHVjZSBhbGwgcG9zc2libGVcblx0XHRcdC8vIHByZWZpeGVkIHByb3BlcnRpZXNcblx0XHRcdHZhciBpID0gMSwgaWwgPSBhYmJyLmxlbmd0aCwgY2g7XG5cdFx0XHR2YXIgcHJlZml4ZXMgPSBbXTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKGkgPCBpbCkge1xuXHRcdFx0XHRjaCA9IGFiYnIuY2hhckF0KGkpO1xuXHRcdFx0XHRpZiAoY2ggPT0gJy0nKSB7XG5cdFx0XHRcdFx0Ly8gZW5kLXNlcXVlbmNlIGNoYXJhY3RlciBmb3VuZCwgc3RvcCBzZWFyY2hpbmdcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjaCBpbiB2ZW5kb3JQcmVmaXhlcykge1xuXHRcdFx0XHRcdHByZWZpeGVzLnB1c2goY2gpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG5vIHByZWZpeCBmb3VuZCwgbWVhbmluZyB1c2VyIHdhbnQgdG8gcHJvZHVjZSBhbGxcblx0XHRcdFx0XHQvLyB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydGllc1xuXHRcdFx0XHRcdHByZWZpeGVzLmxlbmd0aCA9IDA7XG5cdFx0XHRcdFx0aSA9IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGkrKztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gcmVhY2hlZCBlbmQgb2YgYWJicmV2aWF0aW9uIGFuZCBubyBwcm9wZXJ0eSBuYW1lIGxlZnRcblx0XHRcdGlmIChpID09IGlsIC0xKSB7XG5cdFx0XHRcdGkgPSAxO1xuXHRcdFx0XHRwcmVmaXhlcy5sZW5ndGggPSAxO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwcm9wZXJ0eTogYWJici5zdWJzdHJpbmcoaSksXG5cdFx0XHRcdHByZWZpeGVzOiBwcmVmaXhlcy5sZW5ndGggPyBwcmVmaXhlcyA6ICdhbGwnXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2VhcmNoIGZvciB2YWx1ZSBzdWJzdHJpbmcgaW4gYWJicmV2aWF0aW9uXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFiYnJcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfSBWYWx1ZSBzdWJzdHJpbmdcblx0XHQgKi9cblx0XHRmaW5kVmFsdWVzSW5BYmJyZXZpYXRpb246IGZ1bmN0aW9uKGFiYnIsIHN5bnRheCkge1xuXHRcdFx0c3ludGF4ID0gc3ludGF4IHx8ICdjc3MnO1xuXHRcdFx0XG5cdFx0XHR2YXIgaSA9IDAsIGlsID0gYWJici5sZW5ndGgsIHZhbHVlID0gJycsIGNoO1xuXHRcdFx0d2hpbGUgKGkgPCBpbCkge1xuXHRcdFx0XHRjaCA9IGFiYnIuY2hhckF0KGkpO1xuXHRcdFx0XHRpZiAoaXNOdW1lcmljKGNoKSB8fCBjaCA9PSAnIycgfHwgY2ggPT0gJyQnIHx8IChjaCA9PSAnLScgJiYgaXNOdW1lcmljKGFiYnIuY2hhckF0KGkgKyAxKSkpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBhYmJyLnN1YnN0cmluZyhpKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aSsrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyB0cnkgdG8gZmluZCBrZXl3b3JkcyBpbiBhYmJyZXZpYXRpb25cblx0XHRcdHZhciBwcm9wZXJ0eSA9IGFiYnIuc3Vic3RyaW5nKDAsIGFiYnIubGVuZ3RoIC0gdmFsdWUubGVuZ3RoKTtcblx0XHRcdHZhciBrZXl3b3JkcyA9IFtdO1xuXHRcdFx0Ly8gdHJ5IHRvIGV4dHJhY3Qgc29tZSBjb21tb25seS11c2VkIHByb3BlcnRpZXNcblx0XHRcdHdoaWxlICh+cHJvcGVydHkuaW5kZXhPZignLScpICYmICFyZXNvdXJjZXMuZmluZFNuaXBwZXQoc3ludGF4LCBwcm9wZXJ0eSkpIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gcHJvcGVydHkuc3BsaXQoJy0nKTtcblx0XHRcdFx0dmFyIGxhc3RQYXJ0ID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdGlmICghaXNWYWxpZEtleXdvcmQobGFzdFBhcnQpKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGtleXdvcmRzLnVuc2hpZnQobGFzdFBhcnQpO1xuXHRcdFx0XHRwcm9wZXJ0eSA9IHBhcnRzLmpvaW4oJy0nKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGtleXdvcmRzLmpvaW4oJy0nKSArIHZhbHVlO1xuXHRcdH0sXG5cdFx0XG5cdFx0cGFyc2VWYWx1ZXM6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0LyoqIEB0eXBlIFN0cmluZ1N0cmVhbSAqL1xuXHRcdFx0dmFyIHN0cmVhbSA9IHN0cmluZ1N0cmVhbS5jcmVhdGUoc3RyKTtcblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblx0XHRcdHZhciBjaCA9IG51bGw7XG5cdFx0XHRcblx0XHRcdHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSkge1xuXHRcdFx0XHRpZiAoY2ggPT0gJyQnKSB7XG5cdFx0XHRcdFx0c3RyZWFtLm1hdGNoKC9eW15cXCRdKy8sIHRydWUpO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKHN0cmVhbS5jdXJyZW50KCkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNoID09ICcjJykge1xuXHRcdFx0XHRcdHN0cmVhbS5tYXRjaCgvXnR8WzAtOWEtZl0rKFxcLlxcZCspPy9pLCB0cnVlKTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChzdHJlYW0uY3VycmVudCgpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSAnLScpIHtcblx0XHRcdFx0XHRpZiAoaXNWYWxpZEtleXdvcmQodXRpbHMubGFzdCh2YWx1ZXMpKSB8fCBcblx0XHRcdFx0XHRcdFx0KCBzdHJlYW0uc3RhcnQgJiYgaXNOdW1lcmljKHN0ci5jaGFyQXQoc3RyZWFtLnN0YXJ0IC0gMSkpIClcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0c3RyZWFtLm1hdGNoKC9eXFwtP1swLTldKihcXC5bMC05XSspP1thLXolXFwuXSovLCB0cnVlKTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChzdHJlYW0uY3VycmVudCgpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHJlYW0ubWF0Y2goL15bMC05XSooXFwuWzAtOV0qKT9bYS16JV0qLywgdHJ1ZSk7XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goc3RyZWFtLmN1cnJlbnQoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB2YWx1ZXNcblx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhaXRlbTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lm1hcChub3JtYWxpemVWYWx1ZSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBFeHRyYWN0cyB2YWx1ZXMgZnJvbSBhYmJyZXZpYXRpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiclxuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIGFycmF5IG9mIHZhbHVlcyBhbmQgY2xlYW4gXG5cdFx0ICogYWJicmV2aWF0aW9uIG5hbWVcblx0XHQgKi9cblx0XHRleHRyYWN0VmFsdWVzOiBmdW5jdGlvbihhYmJyKSB7XG5cdFx0XHQvLyBzZWFyY2ggZm9yIHZhbHVlIHN0YXJ0XG5cdFx0XHR2YXIgYWJiclZhbHVlcyA9IHRoaXMuZmluZFZhbHVlc0luQWJicmV2aWF0aW9uKGFiYnIpO1xuXHRcdFx0aWYgKCFhYmJyVmFsdWVzKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0cHJvcGVydHk6IGFiYnIsXG5cdFx0XHRcdFx0dmFsdWVzOiBudWxsXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHByb3BlcnR5OiBhYmJyLnN1YnN0cmluZygwLCBhYmJyLmxlbmd0aCAtIGFiYnJWYWx1ZXMubGVuZ3RoKS5yZXBsYWNlKC8tJC8sICcnKSxcblx0XHRcdFx0dmFsdWVzOiB0aGlzLnBhcnNlVmFsdWVzKGFiYnJWYWx1ZXMpXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogTm9ybWFsaXplcyB2YWx1ZSwgZGVmaW5lZCBpbiBhYmJyZXZpYXRpb24uXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRub3JtYWxpemVWYWx1ZTogZnVuY3Rpb24odmFsdWUsIHByb3BlcnR5KSB7XG5cdFx0XHRwcm9wZXJ0eSA9IChwcm9wZXJ0eSB8fCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciB1bml0bGVzc1Byb3BzID0gcHJlZnMuZ2V0QXJyYXkoJ2Nzcy51bml0bGVzc1Byb3BlcnRpZXMnKTtcblx0XHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKC9eKFxcLT9bMC05XFwuXSspKFthLXpdKikkLywgZnVuY3Rpb24oc3RyLCB2YWwsIHVuaXQpIHtcblx0XHRcdFx0aWYgKCF1bml0ICYmICh2YWwgPT0gJzAnIHx8IH51bml0bGVzc1Byb3BzLmluZGV4T2YocHJvcGVydHkpKSlcblx0XHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCF1bml0KVxuXHRcdFx0XHRcdHJldHVybiB2YWwucmVwbGFjZSgvXFwuJC8sICcnKSArIHByZWZzLmdldCh+dmFsLmluZGV4T2YoJy4nKSA/ICdjc3MuZmxvYXRVbml0JyA6ICdjc3MuaW50VW5pdCcpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHZhbCArIGdldFVuaXQodW5pdCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4cGFuZHMgYWJicmV2aWF0aW9uIGludG8gYSBzbmlwcGV0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFiYnIgQWJicmV2aWF0aW9uIG5hbWUgdG8gZXhwYW5kXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIEFiYnJldmlhdGlvbiB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXggQ3VycmVjdCBzeW50YXggb3IgZGlhbGVjdC4gRGVmYXVsdCBpcyAnY3NzJ1xuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9IEFycmF5IG9mIENTUyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgb3IgcHJlZGVmaW5lZFxuXHRcdCAqIHNuaXBwZXQgKHN0cmluZyBvciBlbGVtZW50KVxuXHRcdCAqL1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oYWJiciwgdmFsdWUsIHN5bnRheCkge1xuXHRcdFx0c3ludGF4ID0gc3ludGF4IHx8ICdjc3MnO1xuXHRcdFx0dmFyIGF1dG9JbnNlcnRQcmVmaXhlcyA9IHByZWZzLmdldChzeW50YXggKyAnLmF1dG9JbnNlcnRWZW5kb3JQcmVmaXhlcycpO1xuXHRcdFx0XG5cdFx0XHQvLyBjaGVjayBpZiBzbmlwcGV0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZCB0byAhaW1wb3J0YW50XG5cdFx0XHR2YXIgaXNJbXBvcnRhbnQgPSAvXiguKylcXCEkLy50ZXN0KGFiYnIpO1xuXHRcdFx0aWYgKGlzSW1wb3J0YW50KSB7XG5cdFx0XHRcdGFiYnIgPSBSZWdFeHAuJDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGlmIHdlIGhhdmUgYWJicmV2aWF0ZWQgcmVzb3VyY2Vcblx0XHRcdHZhciBzbmlwcGV0ID0gcmVzb3VyY2VzLmZpbmRTbmlwcGV0KHN5bnRheCwgYWJicik7XG5cdFx0XHRpZiAoc25pcHBldCAmJiAhYXV0b0luc2VydFByZWZpeGVzKSB7XG5cdFx0XHRcdHJldHVybiB0cmFuc2Zvcm1TbmlwcGV0KHNuaXBwZXQsIGlzSW1wb3J0YW50LCBzeW50YXgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBubyBhYmJyZXZpYXRlZCByZXNvdXJjZSwgcGFyc2UgYWJicmV2aWF0aW9uXG5cdFx0XHR2YXIgcHJlZml4RGF0YSA9IHRoaXMuZXh0cmFjdFByZWZpeGVzKGFiYnIpO1xuXHRcdFx0dmFyIHZhbHVlc0RhdGEgPSB0aGlzLmV4dHJhY3RWYWx1ZXMocHJlZml4RGF0YS5wcm9wZXJ0eSk7XG5cdFx0XHR2YXIgYWJickRhdGEgPSB1dGlscy5leHRlbmQocHJlZml4RGF0YSwgdmFsdWVzRGF0YSk7XG5cblx0XHRcdGlmICghc25pcHBldCkge1xuXHRcdFx0XHRzbmlwcGV0ID0gcmVzb3VyY2VzLmZpbmRTbmlwcGV0KHN5bnRheCwgYWJickRhdGEucHJvcGVydHkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWJickRhdGEudmFsdWVzID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFzbmlwcGV0ICYmIHByZWZzLmdldCgnY3NzLmZ1enp5U2VhcmNoJykpIHtcblx0XHRcdFx0Ly8gbGV04oCZcyB0cnkgZnV6enkgc2VhcmNoXG5cdFx0XHRcdHNuaXBwZXQgPSByZXNvdXJjZXMuZnV6enlGaW5kU25pcHBldChzeW50YXgsIGFiYnJEYXRhLnByb3BlcnR5LCBwYXJzZUZsb2F0KHByZWZzLmdldCgnY3NzLmZ1enp5U2VhcmNoTWluU2NvcmUnKSkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoIXNuaXBwZXQpIHtcblx0XHRcdFx0aWYgKCFhYmJyRGF0YS5wcm9wZXJ0eSB8fCBhYmJyRGF0YS5wcm9wZXJ0eS5lbmRzV2l0aCgnOicpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0c25pcHBldCA9IGFiYnJEYXRhLnByb3BlcnR5ICsgJzonICsgZGVmYXVsdFZhbHVlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2Ygc25pcHBldCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0c25pcHBldCA9IHNuaXBwZXQuZGF0YTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFpc1NpbmdsZVByb3BlcnR5KHNuaXBwZXQpKSB7XG5cdFx0XHRcdHJldHVybiBzbmlwcGV0O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgc25pcHBldE9iaiA9IHRoaXMuc3BsaXRTbmlwcGV0KHNuaXBwZXQpO1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdFx0aWYgKCF2YWx1ZSAmJiBhYmJyRGF0YS52YWx1ZXMpIHtcblx0XHRcdFx0dmFsdWUgPSBhYmJyRGF0YS52YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbCwgc25pcHBldE9iai5uYW1lKTtcblx0XHRcdFx0fSwgdGhpcykuam9pbignICcpICsgJzsnO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRzbmlwcGV0T2JqLnZhbHVlID0gdmFsdWUgfHwgc25pcHBldE9iai52YWx1ZTtcblxuXHRcdFx0dmFyIHByZWZpeGVzID0gYWJickRhdGEucHJlZml4ZXMgPT0gJ2FsbCcgfHwgKCFhYmJyRGF0YS5wcmVmaXhlcyAmJiBhdXRvSW5zZXJ0UHJlZml4ZXMpIFxuXHRcdFx0XHQ/IGZpbmRJbnRlcm5hbFByZWZpeGVzKHNuaXBwZXRPYmoubmFtZSwgYXV0b0luc2VydFByZWZpeGVzICYmIGFiYnJEYXRhLnByZWZpeGVzICE9ICdhbGwnKVxuXHRcdFx0XHQ6IGFiYnJEYXRhLnByZWZpeGVzO1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHR2YXIgbmFtZXMgPSBbXSwgcHJvcE5hbWU7XG5cdFx0XHQocHJlZml4ZXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAocCBpbiB2ZW5kb3JQcmVmaXhlcykge1xuXHRcdFx0XHRcdHByb3BOYW1lID0gdmVuZG9yUHJlZml4ZXNbcF0udHJhbnNmb3JtTmFtZShzbmlwcGV0T2JqLm5hbWUpO1xuXHRcdFx0XHRcdG5hbWVzLnB1c2gocHJvcE5hbWUpO1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHRyYW5zZm9ybVNuaXBwZXQocHJvcE5hbWUgKyAnOicgKyBzbmlwcGV0T2JqLnZhbHVlLFxuXHRcdFx0XHRcdFx0XHRpc0ltcG9ydGFudCwgc3ludGF4KSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBwdXQgdGhlIG9yaWdpbmFsIHByb3BlcnR5XG5cdFx0XHRyZXN1bHQucHVzaCh0cmFuc2Zvcm1TbmlwcGV0KHNuaXBwZXRPYmoubmFtZSArICc6JyArIHNuaXBwZXRPYmoudmFsdWUsIGlzSW1wb3J0YW50LCBzeW50YXgpKTtcblx0XHRcdG5hbWVzLnB1c2goc25pcHBldE9iai5uYW1lKTtcblxuXHRcdFx0cmVzdWx0ID0gcmVzb2x2ZVByZWZpeGVkVmFsdWVzKHNuaXBwZXRPYmosIGlzSW1wb3J0YW50LCBzeW50YXgpLmNvbmNhdChyZXN1bHQpO1xuXHRcdFx0XG5cdFx0XHRpZiAocHJlZnMuZ2V0KCdjc3MuYWxpZ25WZW5kb3InKSkge1xuXHRcdFx0XHR2YXIgcGFkcyA9IHV0aWxzLmdldFN0cmluZ3NQYWRzKG5hbWVzKTtcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0Lm1hcChmdW5jdGlvbihwcm9wLCBpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhZHNbaV0gKyBwcm9wO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNhbWUgYXMgPGNvZGU+ZXhwYW5kPC9jb2RlPiBtZXRob2QgYnV0IHRyYW5zZm9ybXMgb3V0cHV0IGludG8gXG5cdFx0ICogRW1tZXQgc25pcHBldFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBhYmJyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN5bnRheFxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0ZXhwYW5kVG9TbmlwcGV0OiBmdW5jdGlvbihhYmJyLCBzeW50YXgpIHtcblx0XHRcdHZhciBzbmlwcGV0ID0gdGhpcy5leHBhbmQoYWJiciwgbnVsbCwgc3ludGF4KTtcblx0XHRcdGlmIChzbmlwcGV0ID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShzbmlwcGV0KSkge1xuXHRcdFx0XHRyZXR1cm4gc25pcHBldC5qb2luKCdcXG4nKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHR5cGVvZiBzbmlwcGV0ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRyZXR1cm4gc25pcHBldC5kYXRhO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc25pcHBldCArICcnO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3BsaXQgc25pcHBldCBpbnRvIGEgQ1NTIHByb3BlcnR5LXZhbHVlIHBhaXJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc25pcHBldFxuXHRcdCAqL1xuXHRcdHNwbGl0U25pcHBldDogZnVuY3Rpb24oc25pcHBldCkge1xuXHRcdFx0c25pcHBldCA9IHV0aWxzLnRyaW0oc25pcHBldCk7XG5cdFx0XHRpZiAoc25pcHBldC5pbmRleE9mKCc6JykgPT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRuYW1lOiBzbmlwcGV0LFxuXHRcdFx0XHRcdHZhbHVlOiBkZWZhdWx0VmFsdWVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIHBhaXIgPSBzbmlwcGV0LnNwbGl0KCc6Jyk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG5hbWU6IHV0aWxzLnRyaW0ocGFpci5zaGlmdCgpKSxcblx0XHRcdFx0Ly8gcmVwbGFjZSAkezB9IHRhYnN0b3AgdG8gcHJvZHVjZSB2YWxpZCB2ZW5kb3ItcHJlZml4ZWQgdmFsdWVzXG5cdFx0XHRcdC8vIHdoZXJlIHBvc3NpYmxlXG5cdFx0XHRcdHZhbHVlOiB1dGlscy50cmltKHBhaXIuam9pbignOicpKS5yZXBsYWNlKC9eKFxcJFxcezBcXH18XFwkMCkoXFxzKjs/KSQvLCAnJHsxfSQyJylcblx0XHRcdH07XG5cdFx0fSxcblx0XHRcblx0XHRnZXRTeW50YXhQcmVmZXJlbmNlOiBnZXRTeW50YXhQcmVmZXJlbmNlLFxuXHRcdHRyYW5zZm9ybVNuaXBwZXQ6IHRyYW5zZm9ybVNuaXBwZXQsXG5cdFx0dmVuZG9yUHJlZml4ZXM6IGZpbmRWZW5kb3JQcmVmaXhlc1xuXHR9O1xuXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn0pO1xufSx7XCIuLi9hc3NldHMvY2FuaXVzZVwiOlwiYXNzZXRzXFxcXGNhbml1c2UuanNcIixcIi4uL2Fzc2V0cy9wcmVmZXJlbmNlc1wiOlwiYXNzZXRzXFxcXHByZWZlcmVuY2VzLmpzXCIsXCIuLi9hc3NldHMvcmVzb3VyY2VzXCI6XCJhc3NldHNcXFxccmVzb3VyY2VzLmpzXCIsXCIuLi9hc3NldHMvc3RyaW5nU3RyZWFtXCI6XCJhc3NldHNcXFxcc3RyaW5nU3RyZWFtLmpzXCIsXCIuLi9lZGl0VHJlZS9jc3NcIjpcImVkaXRUcmVlXFxcXGNzcy5qc1wiLFwiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4uL3V0aWxzL3RlbXBsYXRlXCI6XCJ1dGlsc1xcXFx0ZW1wbGF0ZS5qc1wifV0sXCJyZXNvbHZlclxcXFxjc3NHcmFkaWVudC5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogJ0V4cGFuZCBBYmJyZXZpYXRpb24nIGhhbmRsZXIgdGhhdCBwYXJzZXMgZ3JhZGllbnQgZGVmaW5pdGlvbiBmcm9tIHVuZGVyIFxuICogY3Vyc29yIGFuZCB1cGRhdGVzIENTUyBydWxlIHdpdGggdmVuZG9yLXByZWZpeGVkIHZhbHVlcy5cbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHByZWZzID0gcmVxdWlyZSgnLi4vYXNzZXRzL3ByZWZlcmVuY2VzJyk7XG5cdHZhciByZXNvdXJjZXMgPSByZXF1aXJlKCcuLi9hc3NldHMvcmVzb3VyY2VzJyk7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXHR2YXIgc3RyaW5nU3RyZWFtID0gcmVxdWlyZSgnLi4vYXNzZXRzL3N0cmluZ1N0cmVhbScpO1xuXHR2YXIgY3NzUmVzb2x2ZXIgPSByZXF1aXJlKCcuL2NzcycpO1xuXHR2YXIgcmFuZ2UgPSByZXF1aXJlKCcuLi9hc3NldHMvcmFuZ2UnKTtcblx0dmFyIGNzc0VkaXRUcmVlID0gcmVxdWlyZSgnLi4vZWRpdFRyZWUvY3NzJyk7XG5cdHZhciBlZGl0b3JVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2VkaXRvcicpO1xuXHR2YXIgbGluZWFyR3JhZGllbnQgPSByZXF1aXJlKCcuL2dyYWRpZW50L2xpbmVhcicpO1xuXG5cdHZhciBjc3NTeW50YXhlcyA9IFsnY3NzJywgJ2xlc3MnLCAnc2FzcycsICdzY3NzJywgJ3N0eWx1cycsICdzdHlsJ107XG5cdFxuXHQvLyBYWFggZGVmaW5lIHByZWZlcmVuY2VzXG5cdHByZWZzLmRlZmluZSgnY3NzLmdyYWRpZW50LnByZWZpeGVzJywgJ3dlYmtpdCwgbW96LCBvJyxcblx0XHRcdCdBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZlbmRvci1wcmVmaXhlcyBmb3Igd2hpY2ggdmFsdWVzIHNob3VsZCAnIFxuXHRcdFx0KyAnYmUgZ2VuZXJhdGVkLicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdjc3MuZ3JhZGllbnQub2xkV2Via2l0JywgZmFsc2UsXG5cdFx0XHQnR2VuZXJhdGUgZ3JhZGllbnQgZGVmaW5pdGlvbiBmb3Igb2xkIFdlYmtpdCBpbXBsZW1lbnRhdGlvbnMnKTtcblx0XG5cdHByZWZzLmRlZmluZSgnY3NzLmdyYWRpZW50Lm9taXREZWZhdWx0RGlyZWN0aW9uJywgdHJ1ZSxcblx0XHQnRG8gbm90IG91dHB1dCBkZWZhdWx0IGRpcmVjdGlvbiBkZWZpbml0aW9uIGluIGdlbmVyYXRlZCBncmFkaWVudHMuJyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5ncmFkaWVudC5kZWZhdWx0UHJvcGVydHknLCAnYmFja2dyb3VuZC1pbWFnZScsXG5cdFx0J1doZW4gZ3JhZGllbnQgZXhwYW5kZWQgb3V0c2lkZSBDU1MgdmFsdWUgY29udGV4dCwgaXQgd2lsbCBwcm9kdWNlICdcblx0XHRcdCsgJ3Byb3BlcnRpZXMgd2l0aCB0aGlzIG5hbWUuJyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5ncmFkaWVudC5mYWxsYmFjaycsIGZhbHNlLFxuXHRcdFx0J1dpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgQ1NTIGdyYWRpZW50IGdlbmVyYXRvciB3aWxsIHByb2R1Y2UgJ1xuXHRcdFx0KyAnPGNvZGU+YmFja2dyb3VuZC1jb2xvcjwvY29kZT4gcHJvcGVydHkgd2l0aCBncmFkaWVudCBmaXJzdCBjb2xvciAnXG5cdFx0XHQrICdhcyBmYWxsYmFjayBmb3Igb2xkIGJyb3dzZXJzLicpO1xuXG5cdC8qKlxuXHQgKiBSZXNvbHZlcyBwcm9wZXJ0eSBuYW1lIChhYmJyZXZpYXRpb24pOiBzZWFyY2hlcyBmb3Igc25pcHBldCBkZWZpbml0aW9uIGluIFxuXHQgKiAncmVzb3VyY2VzJyBhbmQgcmV0dXJucyBuZXcgbmFtZSBvZiBtYXRjaGVkIHByb3BlcnR5XG5cdCAqL1xuXHRmdW5jdGlvbiByZXNvbHZlUHJvcGVydHlOYW1lKG5hbWUsIHN5bnRheCkge1xuXHRcdHZhciBzbmlwcGV0ID0gcmVzb3VyY2VzLmZpbmRTbmlwcGV0KHN5bnRheCwgbmFtZSk7XG5cdFx0XG5cdFx0aWYgKCFzbmlwcGV0ICYmIHByZWZzLmdldCgnY3NzLmZ1enp5U2VhcmNoJykpIHtcblx0XHRcdHZhciBtaW5TY29yZSA9IHBhcnNlRmxvYXQocHJlZnMuZ2V0KCdjc3MuZnV6enlTZWFyY2hNaW5TY29yZScpKTtcblx0XHRcdHNuaXBwZXQgPSByZXNvdXJjZXMuZnV6enlGaW5kU25pcHBldChzeW50YXgsIG5hbWUsIG1pblNjb3JlKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHNuaXBwZXQpIHtcblx0XHRcdGlmICh0eXBlb2Ygc25pcHBldCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0c25pcHBldCA9IHNuaXBwZXQuZGF0YTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNzc1Jlc29sdmVyLnNwbGl0U25pcHBldChzbmlwcGV0KS5uYW1lO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHZlbmRvciBwcmVmaXhlcyBmb3IgZ2l2ZW4gZ3JhZGllbnQgdHlwZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBHcmFkaWVudCB0eXBlIChjdXJyZW50bHksICdsaW5lYXItZ3JhZGllbnQnIFxuXHQgKiBpcyB0aGUgb25seSBzdXBwb3J0ZWQgdmFsdWUpXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0R3JhZGllbnRQcmVmaXhlcyh0eXBlKSB7XG5cdFx0dmFyIHByZWZpeGVzID0gY3NzUmVzb2x2ZXIudmVuZG9yUHJlZml4ZXModHlwZSk7XG5cdFx0aWYgKCFwcmVmaXhlcykge1xuXHRcdFx0Ly8gZGlzYWJsZWQgQ2FuIEkgVXNlLCBmYWxsYmFjayB0byBwcm9wZXJ0eSBsaXN0XG5cdFx0XHRwcmVmaXhlcyA9IHByZWZzLmdldEFycmF5KCdjc3MuZ3JhZGllbnQucHJlZml4ZXMnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJlZml4ZXMgfHwgW107XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGdldFByZWZpeGVkTmFtZXModHlwZSkge1xuXHRcdHZhciBwcmVmaXhlcyA9IGdldEdyYWRpZW50UHJlZml4ZXModHlwZSk7XG5cdFx0dmFyIG5hbWVzID0gcHJlZml4ZXMgXG5cdFx0XHQ/IHByZWZpeGVzLm1hcChmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAnLScgKyBwICsgJy0nICsgdHlwZTtcblx0XHRcdH0pIFxuXHRcdFx0OiBbXTtcblx0XHRcblx0XHRuYW1lcy5wdXNoKHR5cGUpO1xuXHRcdFxuXHRcdHJldHVybiBuYW1lcztcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgbGlzdCBvZiBDU1MgcHJvcGVydGllcyB3aXRoIGdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGdyYWRpZW50IExpc3Qgb2YgZ3JhZGllbnQgb2JqZWN0c1xuXHQgKiBAcGFyYW0ge0NTU0VkaXRFbGVtZW50fSBwcm9wZXJ0eSBPcmlnaW5hbCBDU1MgcHJvcGVydHlcblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UHJvcGVydGllc0ZvckdyYWRpZW50KGdyYWRpZW50cywgcHJvcGVydHkpIHtcblx0XHR2YXIgcHJvcHMgPSBbXTtcblx0XHR2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHkubmFtZSgpO1xuXHRcdHZhciBvbWl0RGlyID0gcHJlZnMuZ2V0KCdjc3MuZ3JhZGllbnQub21pdERlZmF1bHREaXJlY3Rpb24nKTtcblx0XHRcblx0XHRpZiAocHJlZnMuZ2V0KCdjc3MuZ3JhZGllbnQuZmFsbGJhY2snKSAmJiB+cHJvcGVydHlOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYmFja2dyb3VuZCcpKSB7XG5cdFx0XHRwcm9wcy5wdXNoKHtcblx0XHRcdFx0bmFtZTogJ2JhY2tncm91bmQtY29sb3InLFxuXHRcdFx0XHR2YWx1ZTogJyR7MTonICsgZ3JhZGllbnRzWzBdLmdyYWRpZW50LmNvbG9yU3RvcHNbMF0uY29sb3IgKyAnfSdcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHR2YXIgdmFsdWUgPSBwcm9wZXJ0eS52YWx1ZSgpO1xuXHRcdGdldEdyYWRpZW50UHJlZml4ZXMoJ2xpbmVhci1ncmFkaWVudCcpLmZvckVhY2goZnVuY3Rpb24ocHJlZml4KSB7XG5cdFx0XHR2YXIgbmFtZSA9IGNzc1Jlc29sdmVyLnByZWZpeGVkKHByb3BlcnR5TmFtZSwgcHJlZml4KTtcblx0XHRcdGlmIChwcmVmaXggPT0gJ3dlYmtpdCcgJiYgcHJlZnMuZ2V0KCdjc3MuZ3JhZGllbnQub2xkV2Via2l0JykpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwcm9wcy5wdXNoKHtcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogaW5zZXJ0R3JhZGllbnRzSW50b0NTU1ZhbHVlKGdyYWRpZW50cywgdmFsdWUsIHtcblx0XHRcdFx0XHRcdFx0cHJlZml4OiBwcmVmaXgsIFxuXHRcdFx0XHRcdFx0XHRvbGRXZWJraXQ6IHRydWUsXG5cdFx0XHRcdFx0XHRcdG9taXREZWZhdWx0RGlyZWN0aW9uOiBvbWl0RGlyXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHt9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHByb3BzLnB1c2goe1xuXHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHR2YWx1ZTogaW5zZXJ0R3JhZGllbnRzSW50b0NTU1ZhbHVlKGdyYWRpZW50cywgdmFsdWUsIHtcblx0XHRcdFx0XHRwcmVmaXg6IHByZWZpeCxcblx0XHRcdFx0XHRvbWl0RGVmYXVsdERpcmVjdGlvbjogb21pdERpclxuXHRcdFx0XHR9KVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHByb3BzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGIubmFtZS5sZW5ndGggLSBhLm5hbWUubGVuZ3RoO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIG9sZCBncmFkaWVudCBkZWZpbml0aW9ucyBpbiBnaXZlbiBDU1MgcHJvcGVydHkgdmFsdWVcblx0ICogd2l0aCBuZXcgb25lcywgcHJlc2VydmluZyBvcmlnaW5hbCBmb3JtYXR0aW5nXG5cdCAqIEBwYXJhbSAge0FycmF5fSBncmFkaWVudHMgTGlzdCBvZiBDU1MgZ3JhZGllbnRzXG5cdCAqIEBwYXJhbSAge1N0cmluZ30gdmFsdWUgICAgIE9yaWdpbmFsIENTUyB2YWx1ZVxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgICBPcHRpb25zIGZvciBncmFkaWVudOKAmXMgc3RyaW5naWZ5KCkgbWV0aG9kXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGluc2VydEdyYWRpZW50c0ludG9DU1NWYWx1ZShncmFkaWVudHMsIHZhbHVlLCBvcHRpb25zKSB7XG5cdFx0Ly8gZ3JhZGllbnRzICpzaG91bGQqIHBhc3NlZCBpbiBvcmRlciB0aGV5IGFjdHVhbGx5IGFwcGVhciBpbiBDU1MgcHJvcGVydHlcblx0XHQvLyBpdGVyYXRlIG92ZXIgaXQgaW4gYmFja3dhcmQgZGlyZWN0aW9uIHRvIHByZXNlcnZlIGdyYWRpZW50IGxvY2F0aW9uc1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGdyYWRpZW50cyA9IHV0aWxzLmNsb25lKGdyYWRpZW50cyk7XG5cdFx0Z3JhZGllbnRzLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGkpIHtcblx0XHRcdHZhciBzdWZmaXggPSAhaSAmJiBvcHRpb25zLnBsYWNlaG9sZGVyID8gb3B0aW9ucy5wbGFjZWhvbGRlciA6ICcnO1xuXHRcdFx0dmFyIHN0ciA9IG9wdGlvbnMub2xkV2Via2l0ID8gaXRlbS5ncmFkaWVudC5zdHJpbmdpZnlPbGRXZWJraXQob3B0aW9ucykgOiBpdGVtLmdyYWRpZW50LnN0cmluZ2lmeShvcHRpb25zKTtcblx0XHRcdHZhbHVlID0gdXRpbHMucmVwbGFjZVN1YnN0cmluZyh2YWx1ZSwgc3RyICsgc3VmZml4LCBpdGVtLm1hdGNoZWRQYXJ0KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGxpc3Qgb2YgcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIG1lYW5pbmcgXG5cdCAqIChlLmcuIHZlbmRvci1wcmVmaXhlZCArIG9yaWdpbmFsIG5hbWUpXG5cdCAqIEBwYXJhbSAge1N0cmluZ30gcHJvcGVydHkgQ1NTIHByb3BlcnR5IG5hbWVcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqL1xuXHRmdW5jdGlvbiBzaW1pbGFyUHJvcGVydHlOYW1lcyhwcm9wZXJ0eSkge1xuXHRcdGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRwcm9wZXJ0eSA9IHByb3BlcnR5Lm5hbWUoKTtcblx0XHR9XG5cblx0XHR2YXIgc2ltaWxhclByb3BzID0gKGNzc1Jlc29sdmVyLnZlbmRvclByZWZpeGVzKHByb3BlcnR5KSB8fCBbXSkubWFwKGZ1bmN0aW9uKHByZWZpeCkge1xuXHRcdFx0cmV0dXJuICctJyArIHByZWZpeCArICctJyArIHByb3BlcnR5O1xuXHRcdH0pO1xuXHRcdHNpbWlsYXJQcm9wcy5wdXNoKHByb3BlcnR5KTtcblx0XHRyZXR1cm4gc2ltaWxhclByb3BzO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUGFzdGVzIGdyYWRpZW50IGRlZmluaXRpb24gaW50byBDU1MgcnVsZSB3aXRoIGNvcnJlY3QgdmVuZG9yLXByZWZpeGVzXG5cdCAqIEBwYXJhbSB7RWRpdEVsZW1lbnR9IHByb3BlcnR5IE1hdGNoZWQgQ1NTIHByb3BlcnR5XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGdyYWRpZW50cyBMaXN0IG9mIGdyYWRpZW50cyB0byBpbnNlcnRcblx0ICovXG5cdGZ1bmN0aW9uIHBhc3RlR3JhZGllbnQocHJvcGVydHksIGdyYWRpZW50cykge1xuXHRcdHZhciBydWxlID0gcHJvcGVydHkucGFyZW50O1xuXHRcdHZhciBhbGlnblZlbmRvciA9IHByZWZzLmdldCgnY3NzLmFsaWduVmVuZG9yJyk7XG5cdFx0dmFyIG9taXREaXIgPSBwcmVmcy5nZXQoJ2Nzcy5ncmFkaWVudC5vbWl0RGVmYXVsdERpcmVjdGlvbicpO1xuXHRcdFxuXHRcdC8vIHdlIG1heSBoYXZlIGFsaWduZWQgZ3JhZGllbnQgZGVmaW5pdGlvbnM6IGZpbmQgdGhlIHNtYWxsZXN0IHZhbHVlXG5cdFx0Ly8gc2VwYXJhdG9yXG5cdFx0dmFyIHNlcCA9IHByb3BlcnR5LnN0eWxlU2VwYXJhdG9yO1xuXHRcdHZhciBiZWZvcmUgPSBwcm9wZXJ0eS5zdHlsZUJlZm9yZTtcblx0XHRcblx0XHQvLyBmaXJzdCwgcmVtb3ZlIGFsbCBwcm9wZXJ0aWVzIHdpdGhpbiBDU1MgcnVsZSB3aXRoIHRoZSBzYW1lIG5hbWUgYW5kXG5cdFx0Ly8gZ3JhZGllbnQgZGVmaW5pdGlvblxuXHRcdHJ1bGUuZ2V0QWxsKHNpbWlsYXJQcm9wZXJ0eU5hbWVzKHByb3BlcnR5KSkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoaXRlbSAhPSBwcm9wZXJ0eSAmJiAvZ3JhZGllbnQvaS50ZXN0KGl0ZW0udmFsdWUoKSkpIHtcblx0XHRcdFx0aWYgKGl0ZW0uc3R5bGVTZXBhcmF0b3IubGVuZ3RoIDwgc2VwLmxlbmd0aCkge1xuXHRcdFx0XHRcdHNlcCA9IGl0ZW0uc3R5bGVTZXBhcmF0b3I7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGl0ZW0uc3R5bGVCZWZvcmUubGVuZ3RoIDwgYmVmb3JlLmxlbmd0aCkge1xuXHRcdFx0XHRcdGJlZm9yZSA9IGl0ZW0uc3R5bGVCZWZvcmU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cnVsZS5yZW1vdmUoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0XG5cdFx0aWYgKGFsaWduVmVuZG9yKSB7XG5cdFx0XHQvLyB1cGRhdGUgcHJlZml4XG5cdFx0XHRpZiAoYmVmb3JlICE9IHByb3BlcnR5LnN0eWxlQmVmb3JlKSB7XG5cdFx0XHRcdHZhciBmdWxsUmFuZ2UgPSBwcm9wZXJ0eS5mdWxsUmFuZ2UoKTtcblx0XHRcdFx0cnVsZS5fdXBkYXRlU291cmNlKGJlZm9yZSwgZnVsbFJhbmdlLnN0YXJ0LCBmdWxsUmFuZ2Uuc3RhcnQgKyBwcm9wZXJ0eS5zdHlsZUJlZm9yZS5sZW5ndGgpO1xuXHRcdFx0XHRwcm9wZXJ0eS5zdHlsZUJlZm9yZSA9IGJlZm9yZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gdXBkYXRlIHNlcGFyYXRvciB2YWx1ZVxuXHRcdFx0aWYgKHNlcCAhPSBwcm9wZXJ0eS5zdHlsZVNlcGFyYXRvcikge1xuXHRcdFx0XHRydWxlLl91cGRhdGVTb3VyY2Uoc2VwLCBwcm9wZXJ0eS5uYW1lUmFuZ2UoKS5lbmQsIHByb3BlcnR5LnZhbHVlUmFuZ2UoKS5zdGFydCk7XG5cdFx0XHRcdHByb3BlcnR5LnN0eWxlU2VwYXJhdG9yID0gc2VwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHR2YXIgdmFsdWUgPSBwcm9wZXJ0eS52YWx1ZSgpO1xuXG5cdFx0Ly8gY3JlYXRlIGxpc3Qgb2YgcHJvcGVydGllcyB0byBpbnNlcnRcblx0XHR2YXIgcHJvcHNUb0luc2VydCA9IGdldFByb3BlcnRpZXNGb3JHcmFkaWVudChncmFkaWVudHMsIHByb3BlcnR5KTtcblx0XHRcblx0XHQvLyBhbGlnbiBwcmVmaXhlZCB2YWx1ZXNcblx0XHRpZiAoYWxpZ25WZW5kb3IpIHtcblx0XHRcdHZhciBuYW1lcyA9IFtdLCB2YWx1ZXMgPSBbXTtcblx0XHRcdHByb3BzVG9JbnNlcnQuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdG5hbWVzLnB1c2goaXRlbS5uYW1lKTtcblx0XHRcdFx0dmFsdWVzLnB1c2goaXRlbS52YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHRcdHZhbHVlcy5wdXNoKHByb3BlcnR5LnZhbHVlKCkpO1xuXHRcdFx0bmFtZXMucHVzaChwcm9wZXJ0eS5uYW1lKCkpO1xuXHRcdFx0XG5cdFx0XHR2YXIgdmFsdWVQYWRzID0gdXRpbHMuZ2V0U3RyaW5nc1BhZHModmFsdWVzLm1hcChmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHJldHVybiB2LnN1YnN0cmluZygwLCB2LmluZGV4T2YoJygnKSk7XG5cdFx0XHR9KSk7XG5cdFx0XHRcblx0XHRcdHZhciBuYW1lUGFkcyA9IHV0aWxzLmdldFN0cmluZ3NQYWRzKG5hbWVzKTtcblx0XHRcdHByb3BlcnR5Lm5hbWUobmFtZVBhZHNbbmFtZVBhZHMubGVuZ3RoIC0gMV0gKyBwcm9wZXJ0eS5uYW1lKCkpO1xuXHRcdFx0XG5cdFx0XHRwcm9wc1RvSW5zZXJ0LmZvckVhY2goZnVuY3Rpb24ocHJvcCwgaSkge1xuXHRcdFx0XHRwcm9wLm5hbWUgPSBuYW1lUGFkc1tpXSArIHByb3AubmFtZTtcblx0XHRcdFx0cHJvcC52YWx1ZSA9IHZhbHVlUGFkc1tpXSArIHByb3AudmFsdWU7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cHJvcGVydHkudmFsdWUodmFsdWVQYWRzW3ZhbHVlUGFkcy5sZW5ndGggLSAxXSArIHByb3BlcnR5LnZhbHVlKCkpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBwdXQgdmVuZG9yLXByZWZpeGVkIGRlZmluaXRpb25zIGJlZm9yZSBjdXJyZW50IHJ1bGVcblx0XHRwcm9wc1RvSW5zZXJ0LmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuXHRcdFx0cnVsZS5hZGQocHJvcC5uYW1lLCBwcm9wLnZhbHVlLCBydWxlLmluZGV4T2YocHJvcGVydHkpKTtcblx0XHR9KTtcblxuXHRcdC8vIHB1dCB2YW5pbGxhLWNsZWFuIGdyYWRpZW50IGRlZmluaXRpb24gaW50byBjdXJyZW50IHJ1bGVcblx0XHRwcm9wZXJ0eS52YWx1ZShpbnNlcnRHcmFkaWVudHNJbnRvQ1NTVmFsdWUoZ3JhZGllbnRzLCB2YWx1ZSwge1xuXHRcdFx0cGxhY2Vob2xkZXI6ICckezJ9Jyxcblx0XHRcdG9taXREZWZhdWx0RGlyZWN0aW9uOiBvbWl0RGlyXG5cdFx0fSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFZhbGlkYXRlcyBjYXJldCBwb3NpdGlvbiByZWxhdGl2ZWx5IHRvIGxvY2F0ZWQgZ3JhZGllbnRzXG5cdCAqIGluIENTUyBydWxlLiBJbiBvdGhlciB3b3JkcywgaXQgY2hlY2tzIGlmIGl04oCZcyBzYWZlIHRvIFxuXHQgKiBleHBhbmQgZ3JhZGllbnRzIGZvciBjdXJyZW50IGNhcmV0IHBvc2l0aW9uIG9yIG5vdC5cblx0ICogXG5cdCAqIFNlZSBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vc2VyZ2VjaGUvZW1tZXQtc3VibGltZS9pc3N1ZXMvNDExXG5cdCAqIFxuXHQgKiBAcGFyYW0gIHtBcnJheX0gZ3JhZGllbnRzIExpc3Qgb2YgcGFyc2VkIGdyYWRpZW50c1xuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IGNhcmV0UG9zICBDdXJyZW50IGNhcmV0IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSAge1N0cmluZ30gc3ludGF4ICAgIEN1cnJlbnQgZG9jdW1lbnQgc3ludGF4XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBpc1ZhbGlkQ2FyZXRQb3NpdGlvbihncmFkaWVudHMsIGNhcmV0UG9zLCBzeW50YXgpIHtcblx0XHRzeW50YXggPSBzeW50YXggfHwgJ2Nzcyc7XG5cdFx0aWYgKHN5bnRheCA9PSAnY3NzJyB8fCBzeW50YXggPT0gJ2xlc3MnIHx8IHN5bnRheCA9PSAnc2NzcycpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXQgPSBncmFkaWVudHMucHJvcGVydHkudmFsdWVSYW5nZSh0cnVlKS5zdGFydDtcblx0XHR2YXIgcGFydHMgPSBncmFkaWVudHMuZ3JhZGllbnRzO1xuXG5cdFx0Ly8gaW4gY2FzZSBvZiBwcmVwcm9jZXNzb3JzIHdoZXJlIHByb3BlcnRpZXMgYXJlIHNlcGFyYXRlZCB3aXRoXG5cdFx0Ly8gbmV3bGluZXMsIG1ha2Ugc3VyZSB0aGVyZeKAmXMgbm8gZ3JhZGllbnQgZGVmaW5pdGlvbiBwYXN0XG5cdFx0Ly8gY3VycmVudCBjYXJldCBwb3NpdGlvbi4gXG5cdFx0Zm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRpZiAocGFydHNbaV0ubWF0Y2hlZFBhcnQuc3RhcnQgKyBvZmZzZXQgPj0gY2FyZXRQb3MpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdFxuXHRtb2R1bGUgPSBtb2R1bGUgfHwge307XG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IHtcblx0XHQvKipcblx0XHQgKiBTZWFyY2ggZm9yIGdyYWRpZW50IGRlZmluaXRpb25zIGluc2lkZSBDU1MgcHJvcGVydHkgdmFsdWVcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIG1hdGNoZWQgZ3JhZGllbnRzXG5cdFx0ICovXG5cdFx0ZmluZEdyYWRpZW50czogZnVuY3Rpb24oY3NzUHJvcCkge1xuXHRcdFx0dmFyIHZhbHVlID0gY3NzUHJvcC52YWx1ZSgpO1xuXHRcdFx0dmFyIGdyYWRpZW50cyA9IFtdO1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0Y3NzUHJvcC52YWx1ZVBhcnRzKCkuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XG5cdFx0XHRcdHZhciBwYXJ0VmFsdWUgPSBwYXJ0LnN1YnN0cmluZyh2YWx1ZSk7XG5cdFx0XHRcdGlmIChsaW5lYXJHcmFkaWVudC5pc0xpbmVhckdyYWRpZW50KHBhcnRWYWx1ZSkpIHtcblx0XHRcdFx0XHR2YXIgZ3JhZGllbnQgPSBsaW5lYXJHcmFkaWVudC5wYXJzZShwYXJ0VmFsdWUpO1xuXHRcdFx0XHRcdGlmIChncmFkaWVudCkge1xuXHRcdFx0XHRcdFx0Z3JhZGllbnRzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRncmFkaWVudDogZ3JhZGllbnQsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRQYXJ0OiBwYXJ0XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZ3JhZGllbnRzLmxlbmd0aCA/IGdyYWRpZW50cyA6IG51bGw7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbGlzdCBvZiBncmFkaWVudHMgZm91bmQgaW4gQ1NTIHByb3BlcnR5XG5cdFx0ICogb2YgZ2l2ZW4gQ1NTIGNvZGUgaW4gc3BlY2lmaWVkIChjYXJldCkgcG9zaXRpb25cblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGNzcyBDU1MgY29kZSBzbmlwcGV0XG5cdFx0ICogQHBhcmFtICB7TnVtYmVyfSBwb3MgQ2hhcmFjdGVyIGluZGV4IHdoZXJlIHRvIHN0YXJ0IHNlYXJjaGluZyBmb3IgQ1NTIHByb3BlcnR5XG5cdFx0ICogQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdFx0Z3JhZGllbnRzRnJvbUNTU1Byb3BlcnR5OiBmdW5jdGlvbihjc3MsIHBvcykge1xuXHRcdFx0dmFyIGNzc1Byb3AgPSBjc3NFZGl0VHJlZS5wcm9wZXJ0eUZyb21Qb3NpdGlvbihjc3MsIHBvcyk7XG5cdFx0XHRpZiAoY3NzUHJvcCkge1xuXHRcdFx0XHR2YXIgZ3JkID0gdGhpcy5maW5kR3JhZGllbnRzKGNzc1Byb3ApO1xuXHRcdFx0XHRpZiAoZ3JkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHByb3BlcnR5OiBjc3NQcm9wLFxuXHRcdFx0XHRcdFx0Z3JhZGllbnRzOiBncmRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIGZvciDigJxFeHBhbmQgQWJicmV2aWF0aW9u4oCdIGFjdGlvblxuXHRcdCAqIEBwYXJhbSAge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBzeW50YXhcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHByb2ZpbGVcblx0XHQgKiByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0ZXhwYW5kQWJicmV2aWF0aW9uSGFuZGxlcjogZnVuY3Rpb24oZWRpdG9yLCBzeW50YXgsIHByb2ZpbGUpIHtcblx0XHRcdHZhciBpbmZvID0gZWRpdG9yVXRpbHMub3V0cHV0SW5mbyhlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSk7XG5cdFx0XHRpZiAoIX5jc3NTeW50YXhlcy5pbmRleE9mKGluZm8uc3ludGF4KSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGxldCdzIHNlZSBpZiB3ZSBhcmUgZXhwYW5kaW5nIGdyYWRpZW50IGRlZmluaXRpb25cblx0XHRcdHZhciBjYXJldCA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBpbmZvLmNvbnRlbnQ7XG5cdFx0XHR2YXIgZ3JhZGllbnRzID0gdGhpcy5ncmFkaWVudHNGcm9tQ1NTUHJvcGVydHkoY29udGVudCwgY2FyZXQpO1xuXHRcdFx0aWYgKGdyYWRpZW50cykge1xuXHRcdFx0XHRpZiAoIWlzVmFsaWRDYXJldFBvc2l0aW9uKGdyYWRpZW50cywgY2FyZXQsIGluZm8uc3ludGF4KSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjc3NQcm9wZXJ0eSA9IGdyYWRpZW50cy5wcm9wZXJ0eTtcblx0XHRcdFx0dmFyIGNzc1J1bGUgPSBjc3NQcm9wZXJ0eS5wYXJlbnQ7XG5cdFx0XHRcdHZhciBydWxlU3RhcnQgPSBjc3NSdWxlLm9wdGlvbnMub2Zmc2V0IHx8IDA7XG5cdFx0XHRcdHZhciBydWxlRW5kID0gcnVsZVN0YXJ0ICsgY3NzUnVsZS50b1N0cmluZygpLmxlbmd0aDtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEhhbmRsZSBzcGVjaWFsIGNhc2U6XG5cdFx0XHRcdC8vIHVzZXIgd3JvdGUgZ3JhZGllbnQgZGVmaW5pdGlvbiBiZXR3ZWVuIGV4aXN0aW5nIENTUyBcblx0XHRcdFx0Ly8gcHJvcGVydGllcyBhbmQgZGlkIG5vdCBmaW5pc2hlZCBpdCB3aXRoIHNlbWljb2xvbi5cblx0XHRcdFx0Ly8gSW4gdGhpcyBjYXNlLCB3ZSBoYXZlIHNlbWljb2xvbiByaWdodCBhZnRlciBncmFkaWVudCBcblx0XHRcdFx0Ly8gZGVmaW5pdGlvbiBhbmQgcmUtcGFyc2UgcnVsZSBhZ2FpblxuXHRcdFx0XHRpZiAoL1tcXG5cXHJdLy50ZXN0KGNzc1Byb3BlcnR5LnZhbHVlKCkpKSB7XG5cdFx0XHRcdFx0Ly8gaW5zZXJ0IHNlbWljb2xvbiBhdCB0aGUgZW5kIG9mIGdyYWRpZW50IGRlZmluaXRpb25cblx0XHRcdFx0XHR2YXIgaW5zZXJ0UG9zID0gY3NzUHJvcGVydHkudmFsdWVSYW5nZSh0cnVlKS5zdGFydCArIHV0aWxzLmxhc3QoZ3JhZGllbnRzLmdyYWRpZW50cykubWF0Y2hlZFBhcnQuZW5kO1xuXHRcdFx0XHRcdGNvbnRlbnQgPSB1dGlscy5yZXBsYWNlU3Vic3RyaW5nKGNvbnRlbnQsICc7JywgaW5zZXJ0UG9zKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgX2dyYWRpZW50cyA9IHRoaXMuZ3JhZGllbnRzRnJvbUNTU1Byb3BlcnR5KGNvbnRlbnQsIGNhcmV0KTtcblx0XHRcdFx0XHRpZiAoX2dyYWRpZW50cykge1xuXHRcdFx0XHRcdFx0Z3JhZGllbnRzID0gX2dyYWRpZW50cztcblx0XHRcdFx0XHRcdGNzc1Byb3BlcnR5ID0gZ3JhZGllbnRzLnByb3BlcnR5O1xuXHRcdFx0XHRcdFx0Y3NzUnVsZSA9IGNzc1Byb3BlcnR5LnBhcmVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSBjdXJyZW50IHByb3BlcnR5IGhhcyB0ZXJtaW5hdGluZyBzZW1pY29sb25cblx0XHRcdFx0Y3NzUHJvcGVydHkuZW5kKCc7Jyk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyByZXNvbHZlIENTUyBwcm9wZXJ0eSBuYW1lXG5cdFx0XHRcdHZhciByZXNvbHZlZE5hbWUgPSByZXNvbHZlUHJvcGVydHlOYW1lKGNzc1Byb3BlcnR5Lm5hbWUoKSwgc3ludGF4KTtcblx0XHRcdFx0aWYgKHJlc29sdmVkTmFtZSkge1xuXHRcdFx0XHRcdGNzc1Byb3BlcnR5Lm5hbWUocmVzb2x2ZWROYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cGFzdGVHcmFkaWVudChjc3NQcm9wZXJ0eSwgZ3JhZGllbnRzLmdyYWRpZW50cyk7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlQ29udGVudChjc3NSdWxlLnRvU3RyaW5nKCksIHJ1bGVTdGFydCwgcnVsZUVuZCwgdHJ1ZSk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5leHBhbmRHcmFkaWVudE91dHNpZGVWYWx1ZShlZGl0b3IsIHN5bnRheCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyaWVzIHRvIGV4cGFuZCBncmFkaWVudCBvdXRzaWRlIENTUyB2YWx1ZSBcblx0XHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN5bnRheFxuXHRcdCAqL1xuXHRcdGV4cGFuZEdyYWRpZW50T3V0c2lkZVZhbHVlOiBmdW5jdGlvbihlZGl0b3IsIHN5bnRheCkge1xuXHRcdFx0dmFyIHByb3BlcnR5TmFtZSA9IHByZWZzLmdldCgnY3NzLmdyYWRpZW50LmRlZmF1bHRQcm9wZXJ0eScpO1xuXHRcdFx0dmFyIG9taXREaXIgPSBwcmVmcy5nZXQoJ2Nzcy5ncmFkaWVudC5vbWl0RGVmYXVsdERpcmVjdGlvbicpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXByb3BlcnR5TmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGFzc3VtaW5nIHRoYXQgZ3JhZGllbnQgZGVmaW5pdGlvbiBpcyB3cml0dGVuIG9uIG5ldyBsaW5lLFxuXHRcdFx0Ly8gZG8gYSBzaW1wbGlmaWVkIHBhcnNpbmdcblx0XHRcdHZhciBjb250ZW50ID0gU3RyaW5nKGVkaXRvci5nZXRDb250ZW50KCkpO1xuXHRcdFx0LyoqIEB0eXBlIFJhbmdlICovXG5cdFx0XHR2YXIgbGluZVJhbmdlID0gcmFuZ2UuY3JlYXRlKGVkaXRvci5nZXRDdXJyZW50TGluZVJhbmdlKCkpO1xuXHRcdFx0XG5cdFx0XHQvLyBnZXQgbGluZSBjb250ZW50IGFuZCBhZGp1c3QgcmFuZ2Ugd2l0aCBwYWRkaW5nXG5cdFx0XHR2YXIgbGluZSA9IGxpbmVSYW5nZS5zdWJzdHJpbmcoY29udGVudClcblx0XHRcdFx0LnJlcGxhY2UoL15cXHMrLywgZnVuY3Rpb24ocGFkKSB7XG5cdFx0XHRcdFx0bGluZVJhbmdlLnN0YXJ0ICs9IHBhZC5sZW5ndGg7XG5cdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQucmVwbGFjZSgvXFxzKyQvLCBmdW5jdGlvbihwYWQpIHtcblx0XHRcdFx0XHRsaW5lUmFuZ2UuZW5kIC09IHBhZC5sZW5ndGg7XG5cdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0Ly8gdHJpY2sgcGFyc2VyOiBtYWtlIGl0IHRoaW5rIHRoYXQgd2XigJlyZSBwYXJzaW5nIGFjdHVhbCBDU1MgcHJvcGVydHlcblx0XHRcdHZhciBmYWtlQ1NTID0gJ2F7JyArIHByb3BlcnR5TmFtZSArICc6ICcgKyBsaW5lICsgJzt9Jztcblx0XHRcdHZhciBncmFkaWVudHMgPSB0aGlzLmdyYWRpZW50c0Zyb21DU1NQcm9wZXJ0eShmYWtlQ1NTLCBmYWtlQ1NTLmxlbmd0aCAtIDIpO1xuXHRcdFx0aWYgKGdyYWRpZW50cykge1xuXHRcdFx0XHR2YXIgcHJvcHMgPSBnZXRQcm9wZXJ0aWVzRm9yR3JhZGllbnQoZ3JhZGllbnRzLmdyYWRpZW50cywgZ3JhZGllbnRzLnByb3BlcnR5KTtcblx0XHRcdFx0cHJvcHMucHVzaCh7XG5cdFx0XHRcdFx0bmFtZTogZ3JhZGllbnRzLnByb3BlcnR5Lm5hbWUoKSxcblx0XHRcdFx0XHR2YWx1ZTogaW5zZXJ0R3JhZGllbnRzSW50b0NTU1ZhbHVlKGdyYWRpZW50cy5ncmFkaWVudHMsIGdyYWRpZW50cy5wcm9wZXJ0eS52YWx1ZSgpLCB7XG5cdFx0XHRcdFx0XHRwbGFjZWhvbGRlcjogJyR7Mn0nLFxuXHRcdFx0XHRcdFx0b21pdERlZmF1bHREaXJlY3Rpb246IG9taXREaXJcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBzZXAgPSBjc3NSZXNvbHZlci5nZXRTeW50YXhQcmVmZXJlbmNlKCd2YWx1ZVNlcGFyYXRvcicsIHN5bnRheCk7XG5cdFx0XHRcdHZhciBlbmQgPSBjc3NSZXNvbHZlci5nZXRTeW50YXhQcmVmZXJlbmNlKCdwcm9wZXJ0eUVuZCcsIHN5bnRheCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocHJlZnMuZ2V0KCdjc3MuYWxpZ25WZW5kb3InKSkge1xuXHRcdFx0XHRcdHZhciBwYWRzID0gdXRpbHMuZ2V0U3RyaW5nc1BhZHMocHJvcHMubWFwKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9wLnZhbHVlLnN1YnN0cmluZygwLCBwcm9wLnZhbHVlLmluZGV4T2YoJygnKSk7XG5cdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdHByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCwgaSkge1xuXHRcdFx0XHRcdFx0cHJvcC52YWx1ZSA9IHBhZHNbaV0gKyBwcm9wLnZhbHVlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRwcm9wcyA9IHByb3BzLm1hcChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW0ubmFtZSArIHNlcCArIGl0ZW0udmFsdWUgKyBlbmQ7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KHByb3BzLmpvaW4oJ1xcbicpLCBsaW5lUmFuZ2Uuc3RhcnQsIGxpbmVSYW5nZS5lbmQpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIGZvciDigJxSZWZsZWN0IENTUyBWYWx1ZeKAnCBhY3Rpb25cblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHByb3BlcnR5XG5cdFx0ICovXG5cdFx0cmVmbGVjdFZhbHVlSGFuZGxlcjogZnVuY3Rpb24ocHJvcGVydHkpIHtcblx0XHRcdHZhciBvbWl0RGlyID0gcHJlZnMuZ2V0KCdjc3MuZ3JhZGllbnQub21pdERlZmF1bHREaXJlY3Rpb24nKTtcblx0XHRcdHZhciBncmFkaWVudHMgPSB0aGlzLmZpbmRHcmFkaWVudHMocHJvcGVydHkpO1xuXHRcdFx0aWYgKCFncmFkaWVudHMpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHR2YXIgdmFsdWUgPSBwcm9wZXJ0eS52YWx1ZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyByZWZsZWN0IHZhbHVlIGZvciBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgbmFtZVxuXHRcdFx0cHJvcGVydHkucGFyZW50LmdldEFsbChzaW1pbGFyUHJvcGVydHlOYW1lcyhwcm9wZXJ0eSkpLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuXHRcdFx0XHRpZiAocHJvcCA9PT0gcHJvcGVydHkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBtYWtlIHN1cmUgY3VycmVudCBwcm9wZXJ0eSBjb250YWlucyBncmFkaWVudCBkZWZpbml0aW9uLFxuXHRcdFx0XHQvLyBvdGhlcndpc2Ug4oCTIHNraXAgaXRcblx0XHRcdFx0dmFyIGxvY2FsR3JhZGllbnRzID0gdGhhdC5maW5kR3JhZGllbnRzKHByb3ApO1xuXHRcdFx0XHRpZiAobG9jYWxHcmFkaWVudHMpIHtcblx0XHRcdFx0XHQvLyBkZXRlY3QgdmVuZG9yIHByZWZpeCBmb3IgY3VycmVudCBwcm9wZXJ0eVxuXHRcdFx0XHRcdHZhciBsb2NhbFZhbHVlID0gcHJvcC52YWx1ZSgpO1xuXHRcdFx0XHRcdHZhciBkZm4gPSBsb2NhbEdyYWRpZW50c1swXS5tYXRjaGVkUGFydC5zdWJzdHJpbmcobG9jYWxWYWx1ZSk7XG5cdFx0XHRcdFx0dmFyIHByZWZpeCA9ICcnO1xuXHRcdFx0XHRcdGlmICgvXlxccypcXC0oW2Etel0rKVxcLS8udGVzdChkZm4pKSB7XG5cdFx0XHRcdFx0XHRwcmVmaXggPSBSZWdFeHAuJDE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cHJvcC52YWx1ZShpbnNlcnRHcmFkaWVudHNJbnRvQ1NTVmFsdWUoZ3JhZGllbnRzLCB2YWx1ZSwge1xuXHRcdFx0XHRcdFx0cHJlZml4OiBwcmVmaXgsXG5cdFx0XHRcdFx0XHRvbWl0RGVmYXVsdERpcmVjdGlvbjogb21pdERpclxuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fTtcbn0pO1xufSx7XCIuLi9hc3NldHMvcHJlZmVyZW5jZXNcIjpcImFzc2V0c1xcXFxwcmVmZXJlbmNlcy5qc1wiLFwiLi4vYXNzZXRzL3JhbmdlXCI6XCJhc3NldHNcXFxccmFuZ2UuanNcIixcIi4uL2Fzc2V0cy9yZXNvdXJjZXNcIjpcImFzc2V0c1xcXFxyZXNvdXJjZXMuanNcIixcIi4uL2Fzc2V0cy9zdHJpbmdTdHJlYW1cIjpcImFzc2V0c1xcXFxzdHJpbmdTdHJlYW0uanNcIixcIi4uL2VkaXRUcmVlL2Nzc1wiOlwiZWRpdFRyZWVcXFxcY3NzLmpzXCIsXCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wiLFwiLi4vdXRpbHMvZWRpdG9yXCI6XCJ1dGlsc1xcXFxlZGl0b3IuanNcIixcIi4vY3NzXCI6XCJyZXNvbHZlclxcXFxjc3MuanNcIixcIi4vZ3JhZGllbnQvbGluZWFyXCI6XCJyZXNvbHZlclxcXFxncmFkaWVudFxcXFxsaW5lYXIuanNcIn1dLFwicmVzb2x2ZXJcXFxcZ3JhZGllbnRcXFxcbGluZWFyLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBDU1MgbGluZWFyIGdyYWRpZW50IGRlZmluaXRpb25cbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHN0cmluZ1N0cmVhbSA9IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy9zdHJpbmdTdHJlYW0nKTtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29tbW9uJyk7XG5cblx0Ly8gYWxsIGRpcmVjdGlvbnMgYXJlIGV4cHJlc3NlZCBpbiDigJxuZXcgc3R5bGXigJ0gZGVncmVlc1xuXHR2YXIgZGlyZWN0aW9ucyA9IHtcblx0XHQnYm90dG9tJzogMCxcblx0XHQnYm90dG9tIGxlZnQnOiA0NSxcblx0XHQnbGVmdCc6IDkwLFxuXHRcdCd0b3AgbGVmdCc6IDEzNSxcblx0XHQndG9wJzogMTgwLFxuXHRcdCd0b3AgcmlnaHQnOiAyMjUsXG5cdFx0J3JpZ2h0JzogMjcwLFxuXHRcdCdib3R0b20gcmlnaHQnOiAzMTUsXG5cdFx0XG5cdFx0J3RvIHRvcCc6IDAsXG5cdFx0J3RvIHRvcCByaWdodCc6IDQ1LFxuXHRcdCd0byByaWdodCc6IDkwLFxuXHRcdCd0byBib3R0b20gcmlnaHQnOiAxMzUsXG5cdFx0J3RvIGJvdHRvbSc6IDE4MCxcblx0XHQndG8gYm90dG9tIGxlZnQnOiAyMjUsXG5cdFx0J3RvIGxlZnQnOiAyNzAsXG5cdFx0J3RvIHRvcCBsZWZ0JzogMzE1XG5cdH07XG5cblx0dmFyIGRlZmF1bHREaXJlY3Rpb25zID0gWyd0b3AnLCAndG8gYm90dG9tJywgJzBkZWcnXTtcblxuXG5cdHZhciByZUxpbmVhckdyYWRpZW50ID0gL15cXHMqKFxcLVthLXpdK1xcLSk/KGxnfGxpbmVhclxcLWdyYWRpZW50KVxccypcXCgvaTtcblx0dmFyIHJlRGVnID0gLyhcXGQrKWRlZy9pO1xuXHR2YXIgcmVLZXl3b3JkID0gL3RvcHxib3R0b218bGVmdHxyaWdodC9pO1xuXG5cdGZ1bmN0aW9uIExpbmVhckdyYWRpZW50KGRmbikge1xuXHRcdHRoaXMuY29sb3JTdG9wcyA9IFtdO1xuXHRcdHRoaXMuZGlyZWN0aW9uID0gMTgwO1xuXG5cdFx0Ly8gZXh0cmFjdCB0b2tlbnNcblx0XHR2YXIgc3RyZWFtID0gc3RyaW5nU3RyZWFtLmNyZWF0ZSh1dGlscy50cmltKGRmbikpO1xuXHRcdHZhciBjaCwgY3VyO1xuXHRcdHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSkge1xuXHRcdFx0aWYgKHN0cmVhbS5wZWVrKCkgPT0gJywnKSB7XG5cdFx0XHRcdC8vIElzIGl0IGEgZmlyc3QgZW50cnk/IENoZWNrIGlmIGl04oCZcyBhIGRpcmVjdGlvblxuXHRcdFx0XHRjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuXG5cdFx0XHRcdGlmICghdGhpcy5jb2xvclN0b3BzLmxlbmd0aCAmJiAocmVEZWcudGVzdChjdXIpIHx8IHJlS2V5d29yZC50ZXN0KGN1cikpKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXJlY3Rpb24gPSByZXNvbHZlRGlyZWN0aW9uKGN1cik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRDb2xvclN0b3AoY3VyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdFx0c3RyZWFtLmVhdFNwYWNlKCk7XG5cdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHR9IGVsc2UgaWYgKGNoID09ICcoJykgeyAvLyBjb2xvciBkZWZpbml0aW9uLCBsaWtlICdyZ2IoMCwwLDApJ1xuXHRcdFx0XHRzdHJlYW0uc2tpcFRvKCcpJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIGFkZCBsYXN0IHRva2VuXG5cdFx0dGhpcy5hZGRDb2xvclN0b3Aoc3RyZWFtLmN1cnJlbnQoKSk7XHRcdFxuXHR9XG5cblx0TGluZWFyR3JhZGllbnQucHJvdG90eXBlID0ge1xuXHRcdHR5cGU6ICdsaW5lYXItZ3JhZGllbnQnLFxuXHRcdGFkZENvbG9yU3RvcDogZnVuY3Rpb24oY29sb3IsIGl4KSB7XG5cdFx0XHRjb2xvciA9IG5vcm1hbGl6ZVNwYWNlKGNvbG9yIHx8ICcnKTtcblx0XHRcdGlmICghY29sb3IpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb2xvciA9IHRoaXMucGFyc2VDb2xvclN0b3AoY29sb3IpO1xuXG5cdFx0XHRpZiAodHlwZW9mIGl4ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aGlzLmNvbG9yU3RvcHMucHVzaChjb2xvcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNvbG9yU3RvcHMuc3BsaWNlKGl4LCAwLCBjb2xvcik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBhcnNlcyBjb2xvciBzdG9wIGRlZmluaXRpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JTdG9wXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRwYXJzZUNvbG9yU3RvcDogZnVuY3Rpb24oY29sb3JTdG9wKSB7XG5cdFx0XHRjb2xvclN0b3AgPSBub3JtYWxpemVTcGFjZShjb2xvclN0b3ApO1xuXHRcdFx0XG5cdFx0XHQvLyBmaW5kIGNvbG9yIGRlY2xhcmF0aW9uXG5cdFx0XHQvLyBmaXJzdCwgdHJ5IGNvbXBsZXggY29sb3IgZGVjbGFyYXRpb24sIGxpa2UgcmdiKDAsMCwwKVxuXHRcdFx0dmFyIGNvbG9yID0gbnVsbDtcblx0XHRcdGNvbG9yU3RvcCA9IGNvbG9yU3RvcC5yZXBsYWNlKC9eKFxcdytcXCguKz9cXCkpXFxzKi8sIGZ1bmN0aW9uKHN0ciwgYykge1xuXHRcdFx0XHRjb2xvciA9IGM7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoIWNvbG9yKSB7XG5cdFx0XHRcdC8vIHRyeSBzaW1wbGUgZGVjbGFyYXRpb24sIGxpa2UgeWVsbG93LCAjZmNvLCAjZmZmZmZmLCBldGMuXG5cdFx0XHRcdHZhciBwYXJ0cyA9IGNvbG9yU3RvcC5zcGxpdCgnICcpO1xuXHRcdFx0XHRjb2xvciA9IHBhcnRzWzBdO1xuXHRcdFx0XHRjb2xvclN0b3AgPSBwYXJ0c1sxXSB8fCAnJztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdFx0Y29sb3I6IGNvbG9yXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoY29sb3JTdG9wKSB7XG5cdFx0XHRcdC8vIHRoZXJlJ3MgcG9zaXRpb24gaW4gY29sb3Igc3RvcCBkZWZpbml0aW9uXG5cdFx0XHRcdGNvbG9yU3RvcC5yZXBsYWNlKC9eKFxcLT9bXFxkXFwuXSspKFthLXolXSspPyQvLCBmdW5jdGlvbihzdHIsIHBvcywgdW5pdCkge1xuXHRcdFx0XHRcdHJlc3VsdC5wb3NpdGlvbiA9IHBvcztcblx0XHRcdFx0XHRpZiAofnBvcy5pbmRleE9mKCcuJykpIHtcblx0XHRcdFx0XHRcdHVuaXQgPSAnJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCF1bml0KSB7XG5cdFx0XHRcdFx0XHR1bml0ID0gJyUnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAodW5pdCkge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnVuaXQgPSB1bml0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdHN0cmluZ2lmeTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHR2YXIgZm4gPSAnbGluZWFyLWdyYWRpZW50Jztcblx0XHRcdGlmIChvcHRpb25zLnByZWZpeCkge1xuXHRcdFx0XHRmbiA9ICctJyArIG9wdGlvbnMucHJlZml4ICsgJy0nICsgZm47XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0Ly8gdHJhbnNmb3JtIGNvbG9yLXN0b3BzXG5cdFx0XHR2YXIgcGFydHMgPSB0aGlzLmNvbG9yU3RvcHMubWFwKGZ1bmN0aW9uKGNzKSB7XG5cdFx0XHRcdHZhciBwb3MgPSBjcy5wb3NpdGlvbiA/ICcgJyArIGNzLnBvc2l0aW9uICsgKGNzLnVuaXQgfHwgJycpIDogJyc7XG5cdFx0XHRcdHJldHVybiBjcy5jb2xvciArIHBvcztcblx0XHRcdH0pO1xuXG5cdFx0XHR2YXIgZGlyID0gc3RyaW5naWZ5RGlyZWN0aW9uKHRoaXMuZGlyZWN0aW9uLCAhIW9wdGlvbnMucHJlZml4KTtcblx0XHRcdGlmICghb3B0aW9ucy5vbWl0RGVmYXVsdERpcmVjdGlvbiB8fCAhfmRlZmF1bHREaXJlY3Rpb25zLmluZGV4T2YoZGlyKSkge1xuXHRcdFx0XHRwYXJ0cy51bnNoaWZ0KGRpcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbiArICcoJyArIHBhcnRzLmpvaW4oJywgJykgKyAnKSc7XG5cdFx0fSxcblxuXHRcdHN0cmluZ2lmeU9sZFdlYmtpdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY29sb3JTdG9wcyA9IHRoaXMuY29sb3JTdG9wcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHMuY2xvbmUoaXRlbSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gbm9ybWFsaXplIGNvbG9yLXN0b3BzIHBvc2l0aW9uXG5cdFx0XHRjb2xvclN0b3BzLmZvckVhY2goZnVuY3Rpb24oY3MpIHtcblx0XHRcdFx0aWYgKCEoJ3Bvc2l0aW9uJyBpbiBjcykpIC8vIGltcGxpZWQgcG9zaXRpb25cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAofmNzLnBvc2l0aW9uLmluZGV4T2YoJy4nKSB8fCBjcy51bml0ID09ICclJykge1xuXHRcdFx0XHRcdGNzLnBvc2l0aW9uID0gcGFyc2VGbG9hdChjcy5wb3NpdGlvbikgLyAoY3MudW5pdCA9PSAnJScgPyAxMDAgOiAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBcIkNhbid0IGNvbnZlcnQgY29sb3Igc3RvcCAnXCIgKyAoY3MucG9zaXRpb24gKyAoY3MudW5pdCB8fCAnJykpICsgXCInXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9maWxsSW1wbGllZFBvc2l0aW9ucyhjb2xvclN0b3BzKTtcblx0XHRcdFxuXHRcdFx0Ly8gdHJhbnNmb3JtIGNvbG9yLXN0b3BzIGludG8gc3RyaW5nIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRjb2xvclN0b3BzID0gY29sb3JTdG9wcy5tYXAoZnVuY3Rpb24oY3MsIGkpIHtcblx0XHRcdFx0aWYgKCFjcy5wb3NpdGlvbiAmJiAhaSkge1xuXHRcdFx0XHRcdHJldHVybiAnZnJvbSgnICsgY3MuY29sb3IgKyAnKSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjcy5wb3NpdGlvbiA9PSAxICYmIGkgPT0gY29sb3JTdG9wcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0cmV0dXJuICd0bygnICsgY3MuY29sb3IgKyAnKSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiAnY29sb3Itc3RvcCgnICsgKGNzLnBvc2l0aW9uLnRvRml4ZWQoMikucmVwbGFjZSgvXFwuPzArJC8sICcnKSkgKyAnLCAnICsgY3MuY29sb3IgKyAnKSc7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuICctd2Via2l0LWdyYWRpZW50KGxpbmVhciwgJyBcblx0XHRcdFx0KyBvbGRXZWJraXREaXJlY3Rpb24oKHRoaXMuZGlyZWN0aW9uICsgMTgwKSAlIDM2MClcblx0XHRcdFx0KyAnLCAnXG5cdFx0XHRcdCsgY29sb3JTdG9wcy5qb2luKCcsICcpXG5cdFx0XHRcdCsgJyknO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGaWxscy1vdXQgaW1wbGllZCBwb3NpdGlvbnMgaW4gY29sb3Itc3RvcHMuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGZvclxuXHRcdCAqIG9sZCBXZWJraXQgZ3JhZGllbnQgZGVmaW5pdGlvbnNcblx0XHQgKi9cblx0XHRfZmlsbEltcGxpZWRQb3NpdGlvbnM6IGZ1bmN0aW9uKGNvbG9yU3RvcHMpIHtcblx0XHRcdHZhciBmcm9tID0gMDtcblx0XHRcdFxuXHRcdFx0Y29sb3JTdG9wcy5mb3JFYWNoKGZ1bmN0aW9uKGNzLCBpKSB7XG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGF0IGZpcnN0IGFuZCBsYXN0IHBvc2l0aW9ucyBhcmUgZGVmaW5lZFxuXHRcdFx0XHRpZiAoIWkpIHtcblx0XHRcdFx0XHRyZXR1cm4gY3MucG9zaXRpb24gPSBjcy5wb3NpdGlvbiB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaSA9PSBjb2xvclN0b3BzLmxlbmd0aCAtIDEgJiYgISgncG9zaXRpb24nIGluIGNzKSkge1xuXHRcdFx0XHRcdGNzLnBvc2l0aW9uID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCdwb3NpdGlvbicgaW4gY3MpIHtcblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBjb2xvclN0b3BzW2Zyb21dLnBvc2l0aW9uIHx8IDA7XG5cdFx0XHRcdFx0dmFyIHN0ZXAgPSAoY3MucG9zaXRpb24gLSBzdGFydCkgLyAoaSAtIGZyb20pO1xuXHRcdFx0XHRcdGNvbG9yU3RvcHMuc2xpY2UoZnJvbSwgaSkuZm9yRWFjaChmdW5jdGlvbihjczIsIGopIHtcblx0XHRcdFx0XHRcdGNzMi5wb3NpdGlvbiA9IHN0YXJ0ICsgc3RlcCAqIGo7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZnJvbSA9IGk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHR2YWx1ZU9mOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnN0cmluZ2lmeSgpO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBub3JtYWxpemVTcGFjZShzdHIpIHtcblx0XHRyZXR1cm4gdXRpbHMudHJpbShzdHIpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNvbHZlcyB0ZXh0dWFsIGRpcmVjdGlvbiB0byBkZWdyZWVzXG5cdCAqIEBwYXJhbSAge1N0cmluZ30gZGlyIERpcmVjdGlvbiB0byByZXNvbHZlXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICovXG5cdGZ1bmN0aW9uIHJlc29sdmVEaXJlY3Rpb24oZGlyKSB7XG5cdFx0aWYgKHR5cGVvZiBkaXIgPT0gJ251bWJlcicpIHtcblx0XHRcdHJldHVybiBkaXI7XG5cdFx0fVxuXG5cdFx0ZGlyID0gbm9ybWFsaXplU3BhY2UoZGlyKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmIChyZURlZy50ZXN0KGRpcikpIHtcblx0XHRcdHJldHVybiArUmVnRXhwLiQxO1xuXHRcdH1cblxuXHRcdHZhciBwcmVmaXggPSAvXnRvXFxzLy50ZXN0KGRpcikgPyAndG8gJyA6ICcnO1xuXHRcdHZhciBsZWZ0ICAgPSB+ZGlyLmluZGV4T2YoJ2xlZnQnKSAgICYmICdsZWZ0Jztcblx0XHR2YXIgcmlnaHQgID0gfmRpci5pbmRleE9mKCdyaWdodCcpICAmJiAncmlnaHQnO1xuXHRcdHZhciB0b3AgICAgPSB+ZGlyLmluZGV4T2YoJ3RvcCcpICAgICYmICd0b3AnO1xuXHRcdHZhciBib3R0b20gPSB+ZGlyLmluZGV4T2YoJ2JvdHRvbScpICYmICdib3R0b20nO1xuXG5cdFx0dmFyIGtleSA9IG5vcm1hbGl6ZVNwYWNlKHByZWZpeCArICh0b3AgfHwgYm90dG9tIHx8ICcnKSArICcgJyArIChsZWZ0IHx8IHJpZ2h0IHx8ICcnKSk7XG5cdFx0cmV0dXJuIGRpcmVjdGlvbnNba2V5XSB8fCAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWVzIHRvIGZpbmQga2V5d29yZCBmb3IgZ2l2ZW4gZGlyZWN0aW9uLCBleHByZXNzZWQgaW4gZGVncmVlc1xuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IGRpciBEaXJlY3Rpb24gKGRlZ3JlZXMpXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkU3R5bGUgVXNlIG9sZCBzdHlsZSBrZXl3b3JkcyAoZS5nLiBcInRvcFwiIGluc3RlYWQgb2YgXCJ0byBib3R0b21cIilcblx0ICogQHJldHVybiB7U3RyaW5nfSAgICAgS2V5d29yZCBvciA8Y29kZT5OZGVnPC9jb2RlPiBleHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBzdHJpbmdpZnlEaXJlY3Rpb24oZGlyLCBvbGRTdHlsZSkge1xuXHRcdHZhciByZU5ld1N0eWxlID0gL150b1xccy87XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhkaXJlY3Rpb25zKS5maWx0ZXIoZnVuY3Rpb24oaykge1xuXHRcdFx0dmFyIGhhc1ByZWZpeCA9IHJlTmV3U3R5bGUudGVzdChrKTtcblx0XHRcdHJldHVybiBvbGRTdHlsZSA/ICFoYXNQcmVmaXggOiBoYXNQcmVmaXg7XG5cdFx0fSk7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChkaXJlY3Rpb25zW2tleXNbaV1dID09IGRpcikge1xuXHRcdFx0XHRyZXR1cm4ga2V5c1tpXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAob2xkU3R5bGUpIHtcblx0XHRcdGRpciA9IChkaXIgKyAyNzApICUgMzYwO1xuXHRcdH1cblxuXHRcdHJldHVybiBkaXIgKyAnZGVnJztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGRpcmVjdGlvbiBkZWZpbml0aW9uIGZvciBvbGQgV2Via2l0IGdyYWRpZW50c1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBvbGRXZWJraXREaXJlY3Rpb24oZGlyKSB7XG5cdFx0ZGlyID0gc3RyaW5naWZ5RGlyZWN0aW9uKGRpciwgdHJ1ZSk7XG5cdFx0XG5cdFx0aWYocmVEZWcudGVzdChkaXIpKSB7XG5cdFx0XHR0aHJvdyBcIlRoZSBkaXJlY3Rpb24gaXMgYW4gYW5nbGUgdGhhdCBjYW7igJl0IGJlIGNvbnZlcnRlZC5cIjtcblx0XHR9XG5cdFx0XG5cdFx0dmFyIHYgPSBmdW5jdGlvbihwb3MpIHtcblx0XHRcdHJldHVybiB+ZGlyLmluZGV4T2YocG9zKSA/ICcxMDAlJyA6ICcwJztcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB2KCdsZWZ0JykgKyAnICcgKyB2KCd0b3AnKSArICcsICcgKyB2KCdyaWdodCcpICsgJyAnICsgdignYm90dG9tJyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIFBhcnNlcyBncmFkaWVudCBkZWZpbml0aW9uIGludG8gYW4gb2JqZWN0LlxuXHRcdCAqIFRoaXMgb2JqZWN0IGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBncmFkaWVudCBpbnRvIHZhcmlvdXNcblx0XHQgKiBmb3Jtc1xuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gZ3JhZGllbnQgR3JhZGllbnQgZGVmaW5pdGlvblxuXHRcdCAqIEByZXR1cm4ge0xpbmVhckdyYWRpZW50fVxuXHRcdCAqL1xuXHRcdHBhcnNlOiBmdW5jdGlvbihncmFkaWVudCkge1xuXHRcdFx0Ly8gY3V0IG91dCBhbGwgcmVkdW5kYW50IGRhdGFcblx0XHRcdGlmICh0aGlzLmlzTGluZWFyR3JhZGllbnQoZ3JhZGllbnQpKSB7XG5cdFx0XHRcdGdyYWRpZW50ID0gZ3JhZGllbnQucmVwbGFjZSgvXlxccypbXFwtYS16XStcXHMqXFwofFxcKVxccyokL2lnLCAnJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyAnSW52YWxpZCBsaW5lYXIgZ3JhZGllbnQgZGVmaW5pdGlvbjpcXG4nICsgZ3JhZGllbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgTGluZWFyR3JhZGllbnQoZ3JhZGllbnQpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBnaXZlbiBzdHJpbmcgY2FuIGJlIHBhcnNlZCBhcyBsaW5lYXIgZ3JhZGllbnRcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9ICBzdHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzTGluZWFyR3JhZGllbnQ6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHJlTGluZWFyR3JhZGllbnQudGVzdChzdHIpO1xuXHRcdH0sXG5cblx0XHRyZXNvbHZlRGlyZWN0aW9uOiByZXNvbHZlRGlyZWN0aW9uLFxuXHRcdHN0cmluZ2lmeURpcmVjdGlvbjogc3RyaW5naWZ5RGlyZWN0aW9uXG5cdH07XG59KTtcbn0se1wiLi4vLi4vYXNzZXRzL3N0cmluZ1N0cmVhbVwiOlwiYXNzZXRzXFxcXHN0cmluZ1N0cmVhbS5qc1wiLFwiLi4vLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIn1dLFwicmVzb2x2ZXJcXFxcdGFnTmFtZS5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogTW9kdWxlIGZvciByZXNvbHZpbmcgdGFnIG5hbWVzOiByZXR1cm5zIGJlc3QgbWF0Y2hlZCB0YWcgbmFtZSBmb3IgY2hpbGRcbiAqIGVsZW1lbnQgYmFzZWQgb24gcGFzc2VkIHBhcmVudCdzIHRhZyBuYW1lLiBBbHNvIHByb3ZpZGVzIHV0aWxpdHkgZnVuY3Rpb25cbiAqIGZvciBlbGVtZW50IHR5cGUgZGV0ZWN0aW9uIChpbmxpbmUsIGJsb2NrLWxldmVsLCBlbXB0eSlcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cdFxuXHR2YXIgZWxlbWVudFR5cGVzID0ge1xuLy9cdFx0ZW1wdHk6ICdhcmVhLGJhc2UsYmFzZWZvbnQsYnIsY29sLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGxpbmssbWV0YSxwYXJhbSxlbWJlZCxrZXlnZW4sY29tbWFuZCcuc3BsaXQoJywnKSxcblx0XHRlbXB0eTogW10sXG5cdFx0YmxvY2tMZXZlbDogJ2FkZHJlc3MsYXBwbGV0LGJsb2NrcXVvdGUsYnV0dG9uLGNlbnRlcixkZCxkZWwsZGlyLGRpdixkbCxkdCxmaWVsZHNldCxmb3JtLGZyYW1lc2V0LGhyLGlmcmFtZSxpbnMsaXNpbmRleCxsaSxsaW5rLG1hcCxtZW51LG5vZnJhbWVzLG5vc2NyaXB0LG9iamVjdCxvbCxwLHByZSxzY3JpcHQsdGFibGUsdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsdHIsdWwsaDEsaDIsaDMsaDQsaDUsaDYnLnNwbGl0KCcsJyksXG5cdFx0aW5saW5lTGV2ZWw6ICdhLGFiYnIsYWNyb255bSxhcHBsZXQsYixiYXNlZm9udCxiZG8sYmlnLGJyLGJ1dHRvbixjaXRlLGNvZGUsZGVsLGRmbixlbSxmb250LGksaWZyYW1lLGltZyxpbnB1dCxpbnMsa2JkLGxhYmVsLG1hcCxvYmplY3QscSxzLHNhbXAsc2VsZWN0LHNtYWxsLHNwYW4sc3RyaWtlLHN0cm9uZyxzdWIsc3VwLHRleHRhcmVhLHR0LHUsdmFyJy5zcGxpdCgnLCcpXG5cdH07XG5cdFxuXHR2YXIgZWxlbWVudE1hcCA9IHtcblx0XHQncCc6ICdzcGFuJyxcblx0XHQndWwnOiAnbGknLFxuXHRcdCdvbCc6ICdsaScsXG5cdFx0J3RhYmxlJzogJ3RyJyxcblx0XHQndHInOiAndGQnLFxuXHRcdCd0Ym9keSc6ICd0cicsXG5cdFx0J3RoZWFkJzogJ3RyJyxcblx0XHQndGZvb3QnOiAndHInLFxuXHRcdCdjb2xncm91cCc6ICdjb2wnLFxuXHRcdCdzZWxlY3QnOiAnb3B0aW9uJyxcblx0XHQnb3B0Z3JvdXAnOiAnb3B0aW9uJyxcblx0XHQnYXVkaW8nOiAnc291cmNlJyxcblx0XHQndmlkZW8nOiAnc291cmNlJyxcblx0XHQnb2JqZWN0JzogJ3BhcmFtJyxcblx0XHQnbWFwJzogJ2FyZWEnXG5cdH07XG5cdFxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYmVzdCBtYXRjaGVkIGNoaWxkIGVsZW1lbnQgbmFtZSBmb3IgcGFzc2VkIHBhcmVudCdzXG5cdFx0ICogdGFnIG5hbWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICogQG1lbWJlck9mIHRhZ05hbWVcblx0XHQgKi9cblx0XHRyZXNvbHZlOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRuYW1lID0gKG5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcblx0XHRcdGlmIChuYW1lIGluIGVsZW1lbnRNYXApXG5cdFx0XHRcdHJldHVybiB0aGlzLmdldE1hcHBpbmcobmFtZSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzSW5saW5lTGV2ZWwobmFtZSkpXG5cdFx0XHRcdHJldHVybiAnc3Bhbic7XG5cdFx0XHRcblx0XHRcdHJldHVybiAnZGl2Jztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbWFwcGVkIGNoaWxkIGVsZW1lbnQgbmFtZSBmb3IgcGFzc2VkIHBhcmVudCdzIG5hbWUgXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldE1hcHBpbmc6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiBlbGVtZW50TWFwW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBwYXNzZWQgZWxlbWVudCBuYW1lIGJlbG9uZ3MgdG8gaW5saW5lLWxldmVsIGVsZW1lbnRcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzSW5saW5lTGV2ZWw6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKG5hbWUsICdpbmxpbmVMZXZlbCcpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgcGFzc2VkIGVsZW1lbnQgYmVsb25ncyB0byBibG9jay1sZXZlbCBlbGVtZW50LlxuXHRcdCAqIEZvciBiZXR0ZXIgbWF0Y2hpbmcgb2YgdW5rbm93biBlbGVtZW50cyAoZm9yIFhNTCwgZm9yIGV4YW1wbGUpLCBcblx0XHQgKiB5b3Ugc2hvdWxkIHVzZSA8Y29kZT4hdGhpcy5pc0lubGluZUxldmVsKG5hbWUpPC9jb2RlPlxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzQmxvY2tMZXZlbDogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YobmFtZSwgJ2Jsb2NrTGV2ZWwnKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIHBhc3NlZCBlbGVtZW50IGlzIHZvaWQgKGkuZS4gc2hvdWxkIG5vdCBoYXZlIGNsb3NpbmcgdGFnKS5cblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0VtcHR5RWxlbWVudDogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YobmFtZSwgJ2VtcHR5Jyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZW5lcmljIGZ1bmN0aW9uIGZvciB0ZXN0aW5nIGlmIGVsZW1lbnQgbmFtZSBiZWxvbmdzIHRvIHNwZWNpZmllZFxuXHRcdCAqIGVsZW1lbnRzIGNvbGxlY3Rpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBFbGVtZW50IG5hbWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBDb2xsZWN0aW9uIG5hbWVcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc1R5cGVPZjogZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuXHRcdFx0cmV0dXJuIH5lbGVtZW50VHlwZXNbdHlwZV0uaW5kZXhPZihuYW1lKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgbmV3IHBhcmVudOKAk2NoaWxkIG1hcHBpbmdcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNoaWxkXG5cdFx0ICovXG5cdFx0YWRkTWFwcGluZzogZnVuY3Rpb24ocGFyZW50LCBjaGlsZCkge1xuXHRcdFx0ZWxlbWVudE1hcFtwYXJlbnRdID0gY2hpbGQ7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHBhcmVudC1jaGlsZCBtYXBwaW5nXG5cdFx0ICovXG5cdFx0cmVtb3ZlTWFwcGluZzogZnVuY3Rpb24ocGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50IGluIGVsZW1lbnRNYXApXG5cdFx0XHRcdGRlbGV0ZSBlbGVtZW50TWFwW3BhcmVudF07XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBBZGRzIG5ldyBlbGVtZW50IGludG8gY29sbGVjdGlvblxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEVsZW1lbnQgbmFtZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uIENvbGxlY3Rpb24gbmFtZVxuXHRcdCAqL1xuXHRcdGFkZEVsZW1lbnRUb0NvbGxlY3Rpb246IGZ1bmN0aW9uKG5hbWUsIGNvbGxlY3Rpb24pIHtcblx0XHRcdGlmICghZWxlbWVudFR5cGVzW2NvbGxlY3Rpb25dKVxuXHRcdFx0XHRlbGVtZW50VHlwZXNbY29sbGVjdGlvbl0gPSBbXTtcblx0XHRcdFxuXHRcdFx0dmFyIGNvbCA9IHRoaXMuZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uKTtcblx0XHRcdGlmICghfmNvbC5pbmRleE9mKG5hbWUpKSB7XG5cdFx0XHRcdGNvbC5wdXNoKG5hbWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBlbGVtZW50IG5hbWUgZnJvbSBzcGVjaWZpZWQgY29sbGVjdGlvblxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEVsZW1lbnQgbmFtZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uIENvbGxlY3Rpb24gbmFtZVxuXHRcdCAqIEByZXR1cm5zXG5cdFx0ICovXG5cdFx0cmVtb3ZlRWxlbWVudEZyb21Db2xsZWN0aW9uOiBmdW5jdGlvbihuYW1lLCBjb2xsZWN0aW9uKSB7XG5cdFx0XHRpZiAoY29sbGVjdGlvbiBpbiBlbGVtZW50VHlwZXMpIHtcblx0XHRcdFx0ZWxlbWVudFR5cGVzW2NvbGxlY3Rpb25dID0gdXRpbHMud2l0aG91dCh0aGlzLmdldENvbGxlY3Rpb24oY29sbGVjdGlvbiksIG5hbWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBlbGVtZW50cyBuYW1lIGNvbGxlY3Rpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBDb2xsZWN0aW9uIG5hbWVcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0Z2V0Q29sbGVjdGlvbjogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRUeXBlc1tuYW1lXTtcblx0XHR9XG5cdH07XG59KTtcbn0se1wiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIn1dLFwic25pcHBldHMuanNvblwiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzPXtcblx0XCJ2YXJpYWJsZXNcIjoge1xuXHRcdFwibGFuZ1wiOiBcImVuXCIsXG5cdFx0XCJsb2NhbGVcIjogXCJlbi1VU1wiLFxuXHRcdFwiY2hhcnNldFwiOiBcIlVURi04XCIsXG5cdFx0XCJpbmRlbnRhdGlvblwiOiBcIlxcdFwiLFxuXHRcdFwibmV3bGluZVwiOiBcIlxcblwiXG5cdH0sXG5cdFxuXHRcImNzc1wiOiB7XG5cdFx0XCJmaWx0ZXJzXCI6IFwiY3NzXCIsXG5cdFx0XCJwcm9maWxlXCI6IFwiY3NzXCIsXG5cdFx0XCJzbmlwcGV0c1wiOiB7XG5cdFx0XHRcIkBpXCI6IFwiQGltcG9ydCB1cmwofCk7XCIsXG5cdFx0XHRcIkBpbXBvcnRcIjogXCJAaW1wb3J0IHVybCh8KTtcIixcblx0XHRcdFwiQG1cIjogXCJAbWVkaWEgJHsxOnNjcmVlbn0ge1xcblxcdHxcXG59XCIsXG5cdFx0XHRcIkBtZWRpYVwiOiBcIkBtZWRpYSAkezE6c2NyZWVufSB7XFxuXFx0fFxcbn1cIixcblx0XHRcdFwiQGZcIjogXCJAZm9udC1mYWNlIHtcXG5cXHRmb250LWZhbWlseTp8O1xcblxcdHNyYzp1cmwofCk7XFxufVwiLFxuXHRcdFx0XCJAZitcIjogXCJAZm9udC1mYWNlIHtcXG5cXHRmb250LWZhbWlseTogJyR7MTpGb250TmFtZX0nO1xcblxcdHNyYzogdXJsKCckezI6RmlsZU5hbWV9LmVvdCcpO1xcblxcdHNyYzogdXJsKCckezI6RmlsZU5hbWV9LmVvdD8jaWVmaXgnKSBmb3JtYXQoJ2VtYmVkZGVkLW9wZW50eXBlJyksXFxuXFx0XFx0IHVybCgnJHsyOkZpbGVOYW1lfS53b2ZmJykgZm9ybWF0KCd3b2ZmJyksXFxuXFx0XFx0IHVybCgnJHsyOkZpbGVOYW1lfS50dGYnKSBmb3JtYXQoJ3RydWV0eXBlJyksXFxuXFx0XFx0IHVybCgnJHsyOkZpbGVOYW1lfS5zdmcjJHsxOkZvbnROYW1lfScpIGZvcm1hdCgnc3ZnJyk7XFxuXFx0Zm9udC1zdHlsZTogJHszOm5vcm1hbH07XFxuXFx0Zm9udC13ZWlnaHQ6ICR7NDpub3JtYWx9O1xcbn1cIixcblxuXHRcdFx0XCJAa2ZcIjogXCJALXdlYmtpdC1rZXlmcmFtZXMgJHsxOmlkZW50aWZpZXJ9IHtcXG5cXHQkezI6ZnJvbX0geyAkezN9IH0kezZ9XFxuXFx0JHs0OnRvfSB7ICR7NX0gfVxcbn1cXG5ALW8ta2V5ZnJhbWVzICR7MTppZGVudGlmaWVyfSB7XFxuXFx0JHsyOmZyb219IHsgJHszfSB9JHs2fVxcblxcdCR7NDp0b30geyAkezV9IH1cXG59XFxuQC1tb3ota2V5ZnJhbWVzICR7MTppZGVudGlmaWVyfSB7XFxuXFx0JHsyOmZyb219IHsgJHszfSB9JHs2fVxcblxcdCR7NDp0b30geyAkezV9IH1cXG59XFxuQGtleWZyYW1lcyAkezE6aWRlbnRpZmllcn0ge1xcblxcdCR7Mjpmcm9tfSB7ICR7M30gfSR7Nn1cXG5cXHQkezQ6dG99IHsgJHs1fSB9XFxufVwiLFxuXG5cdFx0XHRcImFuaW1cIjogXCJhbmltYXRpb246fDtcIixcblx0XHRcdFwiYW5pbS1cIjogXCJhbmltYXRpb246JHsxOm5hbWV9ICR7MjpkdXJhdGlvbn0gJHszOnRpbWluZy1mdW5jdGlvbn0gJHs0OmRlbGF5fSAkezU6aXRlcmF0aW9uLWNvdW50fSAkezY6ZGlyZWN0aW9ufSAkezc6ZmlsbC1tb2RlfTtcIixcblx0XHRcdFwiYW5pbWRlbFwiOiBcImFuaW1hdGlvbi1kZWxheTokezE6dGltZX07XCIsXG5cdFx0XHRcblx0XHRcdFwiYW5pbWRpclwiOiBcImFuaW1hdGlvbi1kaXJlY3Rpb246JHsxOm5vcm1hbH07XCIsXG5cdFx0XHRcImFuaW1kaXI6blwiOiBcImFuaW1hdGlvbi1kaXJlY3Rpb246bm9ybWFsO1wiLFxuXHRcdFx0XCJhbmltZGlyOnJcIjogXCJhbmltYXRpb24tZGlyZWN0aW9uOnJldmVyc2U7XCIsXG5cdFx0XHRcImFuaW1kaXI6YVwiOiBcImFuaW1hdGlvbi1kaXJlY3Rpb246YWx0ZXJuYXRlO1wiLFxuXHRcdFx0XCJhbmltZGlyOmFyXCI6IFwiYW5pbWF0aW9uLWRpcmVjdGlvbjphbHRlcm5hdGUtcmV2ZXJzZTtcIixcblx0XHRcdFxuXHRcdFx0XCJhbmltZHVyXCI6IFwiYW5pbWF0aW9uLWR1cmF0aW9uOiR7MTowfXM7XCIsXG5cdFx0XHRcblx0XHRcdFwiYW5pbWZtXCI6IFwiYW5pbWF0aW9uLWZpbGwtbW9kZTokezE6Ym90aH07XCIsXG5cdFx0XHRcImFuaW1mbTpmXCI6IFwiYW5pbWF0aW9uLWZpbGwtbW9kZTpmb3J3YXJkcztcIixcblx0XHRcdFwiYW5pbWZtOmJcIjogXCJhbmltYXRpb24tZmlsbC1tb2RlOmJhY2t3YXJkcztcIixcblx0XHRcdFwiYW5pbWZtOmJ0XCI6IFwiYW5pbWF0aW9uLWZpbGwtbW9kZTpib3RoO1wiLFxuXHRcdFx0XCJhbmltZm06YmhcIjogXCJhbmltYXRpb24tZmlsbC1tb2RlOmJvdGg7XCIsXG5cdFx0XHRcblx0XHRcdFwiYW5pbWljXCI6IFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDokezE6MX07XCIsXG5cdFx0XHRcImFuaW1pYzppXCI6IFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZTtcIixcblx0XHRcdFxuXHRcdFx0XCJhbmltblwiOiBcImFuaW1hdGlvbi1uYW1lOiR7MTpub25lfTtcIixcblxuXHRcdFx0XCJhbmltcHNcIjogXCJhbmltYXRpb24tcGxheS1zdGF0ZTokezE6cnVubmluZ307XCIsXG5cdFx0XHRcImFuaW1wczpwXCI6IFwiYW5pbWF0aW9uLXBsYXktc3RhdGU6cGF1c2VkO1wiLFxuXHRcdFx0XCJhbmltcHM6clwiOiBcImFuaW1hdGlvbi1wbGF5LXN0YXRlOnJ1bm5pbmc7XCIsXG5cblx0XHRcdFwiYW5pbXRmXCI6IFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjokezE6bGluZWFyfTtcIixcblx0XHRcdFwiYW5pbXRmOmVcIjogXCJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2U7XCIsXG5cdFx0XHRcImFuaW10ZjplaVwiOiBcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbjtcIixcblx0XHRcdFwiYW5pbXRmOmVvXCI6IFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dDtcIixcblx0XHRcdFwiYW5pbXRmOmVpb1wiOiBcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbi1vdXQ7XCIsXG5cdFx0XHRcImFuaW10ZjpsXCI6IFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7XCIsXG5cdFx0XHRcImFuaW10ZjpjYlwiOiBcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKCR7MTowLjF9LCAkezI6MC43fSwgJHszOjEuMH0sICR7MzowLjF9KTtcIixcblx0XHRcdFxuXHRcdFx0XCJhcFwiOiBcImFwcGVhcmFuY2U6JHtub25lfTtcIixcblxuXHRcdFx0XCIhXCI6IFwiIWltcG9ydGFudFwiLFxuXHRcdFx0XCJwb3NcIjogXCJwb3NpdGlvbjokezE6cmVsYXRpdmV9O1wiLFxuXHRcdFx0XCJwb3M6c1wiOiBcInBvc2l0aW9uOnN0YXRpYztcIixcblx0XHRcdFwicG9zOmFcIjogXCJwb3NpdGlvbjphYnNvbHV0ZTtcIixcblx0XHRcdFwicG9zOnJcIjogXCJwb3NpdGlvbjpyZWxhdGl2ZTtcIixcblx0XHRcdFwicG9zOmZcIjogXCJwb3NpdGlvbjpmaXhlZDtcIixcblx0XHRcdFwidFwiOiBcInRvcDp8O1wiLFxuXHRcdFx0XCJ0OmFcIjogXCJ0b3A6YXV0bztcIixcblx0XHRcdFwiclwiOiBcInJpZ2h0Onw7XCIsXG5cdFx0XHRcInI6YVwiOiBcInJpZ2h0OmF1dG87XCIsXG5cdFx0XHRcImJcIjogXCJib3R0b206fDtcIixcblx0XHRcdFwiYjphXCI6IFwiYm90dG9tOmF1dG87XCIsXG5cdFx0XHRcImxcIjogXCJsZWZ0Onw7XCIsXG5cdFx0XHRcImw6YVwiOiBcImxlZnQ6YXV0bztcIixcblx0XHRcdFwielwiOiBcInotaW5kZXg6fDtcIixcblx0XHRcdFwiejphXCI6IFwiei1pbmRleDphdXRvO1wiLFxuXHRcdFx0XCJmbFwiOiBcImZsb2F0OiR7MTpsZWZ0fTtcIixcblx0XHRcdFwiZmw6blwiOiBcImZsb2F0Om5vbmU7XCIsXG5cdFx0XHRcImZsOmxcIjogXCJmbG9hdDpsZWZ0O1wiLFxuXHRcdFx0XCJmbDpyXCI6IFwiZmxvYXQ6cmlnaHQ7XCIsXG5cdFx0XHRcImNsXCI6IFwiY2xlYXI6JHsxOmJvdGh9O1wiLFxuXHRcdFx0XCJjbDpuXCI6IFwiY2xlYXI6bm9uZTtcIixcblx0XHRcdFwiY2w6bFwiOiBcImNsZWFyOmxlZnQ7XCIsXG5cdFx0XHRcImNsOnJcIjogXCJjbGVhcjpyaWdodDtcIixcblx0XHRcdFwiY2w6YlwiOiBcImNsZWFyOmJvdGg7XCIsXG5cblx0XHRcdFwiY29sbVwiOiBcImNvbHVtbnM6fDtcIixcblx0XHRcdFwiY29sbWNcIjogXCJjb2x1bW4tY291bnQ6fDtcIixcblx0XHRcdFwiY29sbWZcIjogXCJjb2x1bW4tZmlsbDp8O1wiLFxuXHRcdFx0XCJjb2xtZ1wiOiBcImNvbHVtbi1nYXA6fDtcIixcblx0XHRcdFwiY29sbXJcIjogXCJjb2x1bW4tcnVsZTp8O1wiLFxuXHRcdFx0XCJjb2xtcmNcIjogXCJjb2x1bW4tcnVsZS1jb2xvcjp8O1wiLFxuXHRcdFx0XCJjb2xtcnNcIjogXCJjb2x1bW4tcnVsZS1zdHlsZTp8O1wiLFxuXHRcdFx0XCJjb2xtcndcIjogXCJjb2x1bW4tcnVsZS13aWR0aDp8O1wiLFxuXHRcdFx0XCJjb2xtc1wiOiBcImNvbHVtbi1zcGFuOnw7XCIsXG5cdFx0XHRcImNvbG13XCI6IFwiY29sdW1uLXdpZHRoOnw7XCIsXG5cblx0XHRcdFwiZFwiOiBcImRpc3BsYXk6JHsxOmJsb2NrfTtcIixcblx0XHRcdFwiZDpuXCI6IFwiZGlzcGxheTpub25lO1wiLFxuXHRcdFx0XCJkOmJcIjogXCJkaXNwbGF5OmJsb2NrO1wiLFxuXHRcdFx0XCJkOmZcIjogXCJkaXNwbGF5OmZsZXg7XCIsXG5cdFx0XHRcImQ6aWZcIjogXCJkaXNwbGF5OmlubGluZS1mbGV4O1wiLFxuXHRcdFx0XCJkOmlcIjogXCJkaXNwbGF5OmlubGluZTtcIixcblx0XHRcdFwiZDppYlwiOiBcImRpc3BsYXk6aW5saW5lLWJsb2NrO1wiLFxuXHRcdFx0XCJkOmliK1wiOiBcImRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4qZGlzcGxheTogaW5saW5lO1xcbip6b29tOiAxO1wiLFxuXHRcdFx0XCJkOmxpXCI6IFwiZGlzcGxheTpsaXN0LWl0ZW07XCIsXG5cdFx0XHRcImQ6cmlcIjogXCJkaXNwbGF5OnJ1bi1pbjtcIixcblx0XHRcdFwiZDpjcFwiOiBcImRpc3BsYXk6Y29tcGFjdDtcIixcblx0XHRcdFwiZDp0YlwiOiBcImRpc3BsYXk6dGFibGU7XCIsXG5cdFx0XHRcImQ6aXRiXCI6IFwiZGlzcGxheTppbmxpbmUtdGFibGU7XCIsXG5cdFx0XHRcImQ6dGJjcFwiOiBcImRpc3BsYXk6dGFibGUtY2FwdGlvbjtcIixcblx0XHRcdFwiZDp0YmNsXCI6IFwiZGlzcGxheTp0YWJsZS1jb2x1bW47XCIsXG5cdFx0XHRcImQ6dGJjbGdcIjogXCJkaXNwbGF5OnRhYmxlLWNvbHVtbi1ncm91cDtcIixcblx0XHRcdFwiZDp0YmhnXCI6IFwiZGlzcGxheTp0YWJsZS1oZWFkZXItZ3JvdXA7XCIsXG5cdFx0XHRcImQ6dGJmZ1wiOiBcImRpc3BsYXk6dGFibGUtZm9vdGVyLWdyb3VwO1wiLFxuXHRcdFx0XCJkOnRiclwiOiBcImRpc3BsYXk6dGFibGUtcm93O1wiLFxuXHRcdFx0XCJkOnRicmdcIjogXCJkaXNwbGF5OnRhYmxlLXJvdy1ncm91cDtcIixcblx0XHRcdFwiZDp0YmNcIjogXCJkaXNwbGF5OnRhYmxlLWNlbGw7XCIsXG5cdFx0XHRcImQ6cmJcIjogXCJkaXNwbGF5OnJ1Ynk7XCIsXG5cdFx0XHRcImQ6cmJiXCI6IFwiZGlzcGxheTpydWJ5LWJhc2U7XCIsXG5cdFx0XHRcImQ6cmJiZ1wiOiBcImRpc3BsYXk6cnVieS1iYXNlLWdyb3VwO1wiLFxuXHRcdFx0XCJkOnJidFwiOiBcImRpc3BsYXk6cnVieS10ZXh0O1wiLFxuXHRcdFx0XCJkOnJidGdcIjogXCJkaXNwbGF5OnJ1YnktdGV4dC1ncm91cDtcIixcblx0XHRcdFwidlwiOiBcInZpc2liaWxpdHk6JHsxOmhpZGRlbn07XCIsXG5cdFx0XHRcInY6dlwiOiBcInZpc2liaWxpdHk6dmlzaWJsZTtcIixcblx0XHRcdFwidjpoXCI6IFwidmlzaWJpbGl0eTpoaWRkZW47XCIsXG5cdFx0XHRcInY6Y1wiOiBcInZpc2liaWxpdHk6Y29sbGFwc2U7XCIsXG5cdFx0XHRcIm92XCI6IFwib3ZlcmZsb3c6JHsxOmhpZGRlbn07XCIsXG5cdFx0XHRcIm92OnZcIjogXCJvdmVyZmxvdzp2aXNpYmxlO1wiLFxuXHRcdFx0XCJvdjpoXCI6IFwib3ZlcmZsb3c6aGlkZGVuO1wiLFxuXHRcdFx0XCJvdjpzXCI6IFwib3ZlcmZsb3c6c2Nyb2xsO1wiLFxuXHRcdFx0XCJvdjphXCI6IFwib3ZlcmZsb3c6YXV0bztcIixcblx0XHRcdFwib3Z4XCI6IFwib3ZlcmZsb3cteDokezE6aGlkZGVufTtcIixcblx0XHRcdFwib3Z4OnZcIjogXCJvdmVyZmxvdy14OnZpc2libGU7XCIsXG5cdFx0XHRcIm92eDpoXCI6IFwib3ZlcmZsb3cteDpoaWRkZW47XCIsXG5cdFx0XHRcIm92eDpzXCI6IFwib3ZlcmZsb3cteDpzY3JvbGw7XCIsXG5cdFx0XHRcIm92eDphXCI6IFwib3ZlcmZsb3cteDphdXRvO1wiLFxuXHRcdFx0XCJvdnlcIjogXCJvdmVyZmxvdy15OiR7MTpoaWRkZW59O1wiLFxuXHRcdFx0XCJvdnk6dlwiOiBcIm92ZXJmbG93LXk6dmlzaWJsZTtcIixcblx0XHRcdFwib3Z5OmhcIjogXCJvdmVyZmxvdy15OmhpZGRlbjtcIixcblx0XHRcdFwib3Z5OnNcIjogXCJvdmVyZmxvdy15OnNjcm9sbDtcIixcblx0XHRcdFwib3Z5OmFcIjogXCJvdmVyZmxvdy15OmF1dG87XCIsXG5cdFx0XHRcIm92c1wiOiBcIm92ZXJmbG93LXN0eWxlOiR7MTpzY3JvbGxiYXJ9O1wiLFxuXHRcdFx0XCJvdnM6YVwiOiBcIm92ZXJmbG93LXN0eWxlOmF1dG87XCIsXG5cdFx0XHRcIm92czpzXCI6IFwib3ZlcmZsb3ctc3R5bGU6c2Nyb2xsYmFyO1wiLFxuXHRcdFx0XCJvdnM6cFwiOiBcIm92ZXJmbG93LXN0eWxlOnBhbm5lcjtcIixcblx0XHRcdFwib3ZzOm1cIjogXCJvdmVyZmxvdy1zdHlsZTptb3ZlO1wiLFxuXHRcdFx0XCJvdnM6bXFcIjogXCJvdmVyZmxvdy1zdHlsZTptYXJxdWVlO1wiLFxuXHRcdFx0XCJ6b29cIjogXCJ6b29tOjE7XCIsXG5cdFx0XHRcInptXCI6IFwiem9vbToxO1wiLFxuXHRcdFx0XCJjcFwiOiBcImNsaXA6fDtcIixcblx0XHRcdFwiY3A6YVwiOiBcImNsaXA6YXV0bztcIixcblx0XHRcdFwiY3A6clwiOiBcImNsaXA6cmVjdCgkezE6dG9wfSAkezI6cmlnaHR9ICR7Mzpib3R0b219ICR7NDpsZWZ0fSk7XCIsXG5cdFx0XHRcImJ4elwiOiBcImJveC1zaXppbmc6JHsxOmJvcmRlci1ib3h9O1wiLFxuXHRcdFx0XCJieHo6Y2JcIjogXCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiLFxuXHRcdFx0XCJieHo6YmJcIjogXCJib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIsXG5cdFx0XHRcImJ4c2hcIjogXCJib3gtc2hhZG93OiR7MTppbnNldCB9JHsyOmhvZmZ9ICR7Mzp2b2ZmfSAkezQ6Ymx1cn0gJHs1OmNvbG9yfTtcIixcblx0XHRcdFwiYnhzaDpyXCI6IFwiYm94LXNoYWRvdzokezE6aW5zZXQgfSR7Mjpob2ZmfSAkezM6dm9mZn0gJHs0OmJsdXJ9ICR7NTpzcHJlYWQgfXJnYigkezY6MH0sICR7NzowfSwgJHs4OjB9KTtcIixcblx0XHRcdFwiYnhzaDpyYVwiOiBcImJveC1zaGFkb3c6JHsxOmluc2V0IH0kezI6aH0gJHszOnZ9ICR7NDpibHVyfSAkezU6c3ByZWFkIH1yZ2JhKCR7NjowfSwgJHs3OjB9LCAkezg6MH0sIC4kezk6NX0pO1wiLFxuXHRcdFx0XCJieHNoOm5cIjogXCJib3gtc2hhZG93Om5vbmU7XCIsXG5cdFx0XHRcIm1cIjogXCJtYXJnaW46fDtcIixcblx0XHRcdFwibTphXCI6IFwibWFyZ2luOmF1dG87XCIsXG5cdFx0XHRcIm10XCI6IFwibWFyZ2luLXRvcDp8O1wiLFxuXHRcdFx0XCJtdDphXCI6IFwibWFyZ2luLXRvcDphdXRvO1wiLFxuXHRcdFx0XCJtclwiOiBcIm1hcmdpbi1yaWdodDp8O1wiLFxuXHRcdFx0XCJtcjphXCI6IFwibWFyZ2luLXJpZ2h0OmF1dG87XCIsXG5cdFx0XHRcIm1iXCI6IFwibWFyZ2luLWJvdHRvbTp8O1wiLFxuXHRcdFx0XCJtYjphXCI6IFwibWFyZ2luLWJvdHRvbTphdXRvO1wiLFxuXHRcdFx0XCJtbFwiOiBcIm1hcmdpbi1sZWZ0Onw7XCIsXG5cdFx0XHRcIm1sOmFcIjogXCJtYXJnaW4tbGVmdDphdXRvO1wiLFxuXHRcdFx0XCJwXCI6IFwicGFkZGluZzp8O1wiLFxuXHRcdFx0XCJwdFwiOiBcInBhZGRpbmctdG9wOnw7XCIsXG5cdFx0XHRcInByXCI6IFwicGFkZGluZy1yaWdodDp8O1wiLFxuXHRcdFx0XCJwYlwiOiBcInBhZGRpbmctYm90dG9tOnw7XCIsXG5cdFx0XHRcInBsXCI6IFwicGFkZGluZy1sZWZ0Onw7XCIsXG5cdFx0XHRcIndcIjogXCJ3aWR0aDp8O1wiLFxuXHRcdFx0XCJ3OmFcIjogXCJ3aWR0aDphdXRvO1wiLFxuXHRcdFx0XCJoXCI6IFwiaGVpZ2h0Onw7XCIsXG5cdFx0XHRcImg6YVwiOiBcImhlaWdodDphdXRvO1wiLFxuXHRcdFx0XCJtYXdcIjogXCJtYXgtd2lkdGg6fDtcIixcblx0XHRcdFwibWF3Om5cIjogXCJtYXgtd2lkdGg6bm9uZTtcIixcblx0XHRcdFwibWFoXCI6IFwibWF4LWhlaWdodDp8O1wiLFxuXHRcdFx0XCJtYWg6blwiOiBcIm1heC1oZWlnaHQ6bm9uZTtcIixcblx0XHRcdFwibWl3XCI6IFwibWluLXdpZHRoOnw7XCIsXG5cdFx0XHRcIm1paFwiOiBcIm1pbi1oZWlnaHQ6fDtcIixcblx0XHRcdFwibWFyXCI6IFwibWF4LXJlc29sdXRpb246JHsxOnJlc307XCIsXG5cdFx0XHRcIm1pclwiOiBcIm1pbi1yZXNvbHV0aW9uOiR7MTpyZXN9O1wiLFxuXHRcdFx0XCJvcmlcIjogXCJvcmllbnRhdGlvbjp8O1wiLFxuXHRcdFx0XCJvcmk6bFwiOiBcIm9yaWVudGF0aW9uOmxhbmRzY2FwZTtcIixcblx0XHRcdFwib3JpOnBcIjogXCJvcmllbnRhdGlvbjpwb3J0cmFpdDtcIixcblx0XHRcdFwib2xcIjogXCJvdXRsaW5lOnw7XCIsXG5cdFx0XHRcIm9sOm5cIjogXCJvdXRsaW5lOm5vbmU7XCIsXG5cdFx0XHRcIm9sb1wiOiBcIm91dGxpbmUtb2Zmc2V0Onw7XCIsXG5cdFx0XHRcIm9sd1wiOiBcIm91dGxpbmUtd2lkdGg6fDtcIixcblx0XHRcdFwib2x3OnRuXCI6IFwib3V0bGluZS13aWR0aDp0aGluO1wiLFxuXHRcdFx0XCJvbHc6bVwiOiBcIm91dGxpbmUtd2lkdGg6bWVkaXVtO1wiLFxuXHRcdFx0XCJvbHc6dGNcIjogXCJvdXRsaW5lLXdpZHRoOnRoaWNrO1wiLFxuXHRcdFx0XCJvbHNcIjogXCJvdXRsaW5lLXN0eWxlOnw7XCIsXG5cdFx0XHRcIm9sczpuXCI6IFwib3V0bGluZS1zdHlsZTpub25lO1wiLFxuXHRcdFx0XCJvbHM6ZHRcIjogXCJvdXRsaW5lLXN0eWxlOmRvdHRlZDtcIixcblx0XHRcdFwib2xzOmRzXCI6IFwib3V0bGluZS1zdHlsZTpkYXNoZWQ7XCIsXG5cdFx0XHRcIm9sczpzXCI6IFwib3V0bGluZS1zdHlsZTpzb2xpZDtcIixcblx0XHRcdFwib2xzOmRiXCI6IFwib3V0bGluZS1zdHlsZTpkb3VibGU7XCIsXG5cdFx0XHRcIm9sczpnXCI6IFwib3V0bGluZS1zdHlsZTpncm9vdmU7XCIsXG5cdFx0XHRcIm9sczpyXCI6IFwib3V0bGluZS1zdHlsZTpyaWRnZTtcIixcblx0XHRcdFwib2xzOmlcIjogXCJvdXRsaW5lLXN0eWxlOmluc2V0O1wiLFxuXHRcdFx0XCJvbHM6b1wiOiBcIm91dGxpbmUtc3R5bGU6b3V0c2V0O1wiLFxuXHRcdFx0XCJvbGNcIjogXCJvdXRsaW5lLWNvbG9yOiMkezE6MDAwfTtcIixcblx0XHRcdFwib2xjOmlcIjogXCJvdXRsaW5lLWNvbG9yOmludmVydDtcIixcblx0XHRcdFwiYmZ2XCI6IFwiYmFja2ZhY2UtdmlzaWJpbGl0eTp8O1wiLFxuXHRcdFx0XCJiZnY6aFwiOiBcImJhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO1wiLFxuXHRcdFx0XCJiZnY6dlwiOiBcImJhY2tmYWNlLXZpc2liaWxpdHk6dmlzaWJsZTtcIixcblx0XHRcdFwiYmRcIjogXCJib3JkZXI6fDtcIixcblx0XHRcdFwiYmQrXCI6IFwiYm9yZGVyOiR7MToxcHh9ICR7Mjpzb2xpZH0gJHszOiMwMDB9O1wiLFxuXHRcdFx0XCJiZDpuXCI6IFwiYm9yZGVyOm5vbmU7XCIsXG5cdFx0XHRcImJkYmtcIjogXCJib3JkZXItYnJlYWs6JHsxOmNsb3NlfTtcIixcblx0XHRcdFwiYmRiazpjXCI6IFwiYm9yZGVyLWJyZWFrOmNsb3NlO1wiLFxuXHRcdFx0XCJiZGNsXCI6IFwiYm9yZGVyLWNvbGxhcHNlOnw7XCIsXG5cdFx0XHRcImJkY2w6Y1wiOiBcImJvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTtcIixcblx0XHRcdFwiYmRjbDpzXCI6IFwiYm9yZGVyLWNvbGxhcHNlOnNlcGFyYXRlO1wiLFxuXHRcdFx0XCJiZGNcIjogXCJib3JkZXItY29sb3I6IyR7MTowMDB9O1wiLFxuXHRcdFx0XCJiZGM6dFwiOiBcImJvcmRlci1jb2xvcjp0cmFuc3BhcmVudDtcIixcblx0XHRcdFwiYmRpXCI6IFwiYm9yZGVyLWltYWdlOnVybCh8KTtcIixcblx0XHRcdFwiYmRpOm5cIjogXCJib3JkZXItaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmR0aVwiOiBcImJvcmRlci10b3AtaW1hZ2U6dXJsKHwpO1wiLFxuXHRcdFx0XCJiZHRpOm5cIjogXCJib3JkZXItdG9wLWltYWdlOm5vbmU7XCIsXG5cdFx0XHRcImJkcmlcIjogXCJib3JkZXItcmlnaHQtaW1hZ2U6dXJsKHwpO1wiLFxuXHRcdFx0XCJiZHJpOm5cIjogXCJib3JkZXItcmlnaHQtaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmRiaVwiOiBcImJvcmRlci1ib3R0b20taW1hZ2U6dXJsKHwpO1wiLFxuXHRcdFx0XCJiZGJpOm5cIjogXCJib3JkZXItYm90dG9tLWltYWdlOm5vbmU7XCIsXG5cdFx0XHRcImJkbGlcIjogXCJib3JkZXItbGVmdC1pbWFnZTp1cmwofCk7XCIsXG5cdFx0XHRcImJkbGk6blwiOiBcImJvcmRlci1sZWZ0LWltYWdlOm5vbmU7XCIsXG5cdFx0XHRcImJkY2lcIjogXCJib3JkZXItY29ybmVyLWltYWdlOnVybCh8KTtcIixcblx0XHRcdFwiYmRjaTpuXCI6IFwiYm9yZGVyLWNvcm5lci1pbWFnZTpub25lO1wiLFxuXHRcdFx0XCJiZGNpOmNcIjogXCJib3JkZXItY29ybmVyLWltYWdlOmNvbnRpbnVlO1wiLFxuXHRcdFx0XCJiZHRsaVwiOiBcImJvcmRlci10b3AtbGVmdC1pbWFnZTp1cmwofCk7XCIsXG5cdFx0XHRcImJkdGxpOm5cIjogXCJib3JkZXItdG9wLWxlZnQtaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmR0bGk6Y1wiOiBcImJvcmRlci10b3AtbGVmdC1pbWFnZTpjb250aW51ZTtcIixcblx0XHRcdFwiYmR0cmlcIjogXCJib3JkZXItdG9wLXJpZ2h0LWltYWdlOnVybCh8KTtcIixcblx0XHRcdFwiYmR0cmk6blwiOiBcImJvcmRlci10b3AtcmlnaHQtaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmR0cmk6Y1wiOiBcImJvcmRlci10b3AtcmlnaHQtaW1hZ2U6Y29udGludWU7XCIsXG5cdFx0XHRcImJkYnJpXCI6IFwiYm9yZGVyLWJvdHRvbS1yaWdodC1pbWFnZTp1cmwofCk7XCIsXG5cdFx0XHRcImJkYnJpOm5cIjogXCJib3JkZXItYm90dG9tLXJpZ2h0LWltYWdlOm5vbmU7XCIsXG5cdFx0XHRcImJkYnJpOmNcIjogXCJib3JkZXItYm90dG9tLXJpZ2h0LWltYWdlOmNvbnRpbnVlO1wiLFxuXHRcdFx0XCJiZGJsaVwiOiBcImJvcmRlci1ib3R0b20tbGVmdC1pbWFnZTp1cmwofCk7XCIsXG5cdFx0XHRcImJkYmxpOm5cIjogXCJib3JkZXItYm90dG9tLWxlZnQtaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmRibGk6Y1wiOiBcImJvcmRlci1ib3R0b20tbGVmdC1pbWFnZTpjb250aW51ZTtcIixcblx0XHRcdFwiYmRmXCI6IFwiYm9yZGVyLWZpdDokezE6cmVwZWF0fTtcIixcblx0XHRcdFwiYmRmOmNcIjogXCJib3JkZXItZml0OmNsaXA7XCIsXG5cdFx0XHRcImJkZjpyXCI6IFwiYm9yZGVyLWZpdDpyZXBlYXQ7XCIsXG5cdFx0XHRcImJkZjpzY1wiOiBcImJvcmRlci1maXQ6c2NhbGU7XCIsXG5cdFx0XHRcImJkZjpzdFwiOiBcImJvcmRlci1maXQ6c3RyZXRjaDtcIixcblx0XHRcdFwiYmRmOm93XCI6IFwiYm9yZGVyLWZpdDpvdmVyd3JpdGU7XCIsXG5cdFx0XHRcImJkZjpvZlwiOiBcImJvcmRlci1maXQ6b3ZlcmZsb3c7XCIsXG5cdFx0XHRcImJkZjpzcFwiOiBcImJvcmRlci1maXQ6c3BhY2U7XCIsXG5cdFx0XHRcImJkbGVuXCI6IFwiYm9yZGVyLWxlbmd0aDp8O1wiLFxuXHRcdFx0XCJiZGxlbjphXCI6IFwiYm9yZGVyLWxlbmd0aDphdXRvO1wiLFxuXHRcdFx0XCJiZHNwXCI6IFwiYm9yZGVyLXNwYWNpbmc6fDtcIixcblx0XHRcdFwiYmRzXCI6IFwiYm9yZGVyLXN0eWxlOnw7XCIsXG5cdFx0XHRcImJkczpuXCI6IFwiYm9yZGVyLXN0eWxlOm5vbmU7XCIsXG5cdFx0XHRcImJkczpoXCI6IFwiYm9yZGVyLXN0eWxlOmhpZGRlbjtcIixcblx0XHRcdFwiYmRzOmR0XCI6IFwiYm9yZGVyLXN0eWxlOmRvdHRlZDtcIixcblx0XHRcdFwiYmRzOmRzXCI6IFwiYm9yZGVyLXN0eWxlOmRhc2hlZDtcIixcblx0XHRcdFwiYmRzOnNcIjogXCJib3JkZXItc3R5bGU6c29saWQ7XCIsXG5cdFx0XHRcImJkczpkYlwiOiBcImJvcmRlci1zdHlsZTpkb3VibGU7XCIsXG5cdFx0XHRcImJkczpkdGRzXCI6IFwiYm9yZGVyLXN0eWxlOmRvdC1kYXNoO1wiLFxuXHRcdFx0XCJiZHM6ZHRkdGRzXCI6IFwiYm9yZGVyLXN0eWxlOmRvdC1kb3QtZGFzaDtcIixcblx0XHRcdFwiYmRzOndcIjogXCJib3JkZXItc3R5bGU6d2F2ZTtcIixcblx0XHRcdFwiYmRzOmdcIjogXCJib3JkZXItc3R5bGU6Z3Jvb3ZlO1wiLFxuXHRcdFx0XCJiZHM6clwiOiBcImJvcmRlci1zdHlsZTpyaWRnZTtcIixcblx0XHRcdFwiYmRzOmlcIjogXCJib3JkZXItc3R5bGU6aW5zZXQ7XCIsXG5cdFx0XHRcImJkczpvXCI6IFwiYm9yZGVyLXN0eWxlOm91dHNldDtcIixcblx0XHRcdFwiYmR3XCI6IFwiYm9yZGVyLXdpZHRoOnw7XCIsXG5cdFx0XHRcImJkdHdcIjogXCJib3JkZXItdG9wLXdpZHRoOnw7XCIsXG5cdFx0XHRcImJkcndcIjogXCJib3JkZXItcmlnaHQtd2lkdGg6fDtcIixcblx0XHRcdFwiYmRid1wiOiBcImJvcmRlci1ib3R0b20td2lkdGg6fDtcIixcblx0XHRcdFwiYmRsd1wiOiBcImJvcmRlci1sZWZ0LXdpZHRoOnw7XCIsXG5cdFx0XHRcImJkdFwiOiBcImJvcmRlci10b3A6fDtcIixcblx0XHRcdFwiYnRcIjogXCJib3JkZXItdG9wOnw7XCIsXG5cdFx0XHRcImJkdCtcIjogXCJib3JkZXItdG9wOiR7MToxcHh9ICR7Mjpzb2xpZH0gJHszOiMwMDB9O1wiLFxuXHRcdFx0XCJiZHQ6blwiOiBcImJvcmRlci10b3A6bm9uZTtcIixcblx0XHRcdFwiYmR0c1wiOiBcImJvcmRlci10b3Atc3R5bGU6fDtcIixcblx0XHRcdFwiYmR0czpuXCI6IFwiYm9yZGVyLXRvcC1zdHlsZTpub25lO1wiLFxuXHRcdFx0XCJiZHRjXCI6IFwiYm9yZGVyLXRvcC1jb2xvcjojJHsxOjAwMH07XCIsXG5cdFx0XHRcImJkdGM6dFwiOiBcImJvcmRlci10b3AtY29sb3I6dHJhbnNwYXJlbnQ7XCIsXG5cdFx0XHRcImJkclwiOiBcImJvcmRlci1yaWdodDp8O1wiLFxuXHRcdFx0XCJiclwiOiBcImJvcmRlci1yaWdodDp8O1wiLFxuXHRcdFx0XCJiZHIrXCI6IFwiYm9yZGVyLXJpZ2h0OiR7MToxcHh9ICR7Mjpzb2xpZH0gJHszOiMwMDB9O1wiLFxuXHRcdFx0XCJiZHI6blwiOiBcImJvcmRlci1yaWdodDpub25lO1wiLFxuXHRcdFx0XCJiZHJzdFwiOiBcImJvcmRlci1yaWdodC1zdHlsZTp8O1wiLFxuXHRcdFx0XCJiZHJzdDpuXCI6IFwiYm9yZGVyLXJpZ2h0LXN0eWxlOm5vbmU7XCIsXG5cdFx0XHRcImJkcmNcIjogXCJib3JkZXItcmlnaHQtY29sb3I6IyR7MTowMDB9O1wiLFxuXHRcdFx0XCJiZHJjOnRcIjogXCJib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnQ7XCIsXG5cdFx0XHRcImJkYlwiOiBcImJvcmRlci1ib3R0b206fDtcIixcblx0XHRcdFwiYmJcIjogXCJib3JkZXItYm90dG9tOnw7XCIsXG5cdFx0XHRcImJkYitcIjogXCJib3JkZXItYm90dG9tOiR7MToxcHh9ICR7Mjpzb2xpZH0gJHszOiMwMDB9O1wiLFxuXHRcdFx0XCJiZGI6blwiOiBcImJvcmRlci1ib3R0b206bm9uZTtcIixcblx0XHRcdFwiYmRic1wiOiBcImJvcmRlci1ib3R0b20tc3R5bGU6fDtcIixcblx0XHRcdFwiYmRiczpuXCI6IFwiYm9yZGVyLWJvdHRvbS1zdHlsZTpub25lO1wiLFxuXHRcdFx0XCJiZGJjXCI6IFwiYm9yZGVyLWJvdHRvbS1jb2xvcjojJHsxOjAwMH07XCIsXG5cdFx0XHRcImJkYmM6dFwiOiBcImJvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7XCIsXG5cdFx0XHRcImJkbFwiOiBcImJvcmRlci1sZWZ0Onw7XCIsXG5cdFx0XHRcImJsXCI6IFwiYm9yZGVyLWxlZnQ6fDtcIixcblx0XHRcdFwiYmRsK1wiOiBcImJvcmRlci1sZWZ0OiR7MToxcHh9ICR7Mjpzb2xpZH0gJHszOiMwMDB9O1wiLFxuXHRcdFx0XCJiZGw6blwiOiBcImJvcmRlci1sZWZ0Om5vbmU7XCIsXG5cdFx0XHRcImJkbHNcIjogXCJib3JkZXItbGVmdC1zdHlsZTp8O1wiLFxuXHRcdFx0XCJiZGxzOm5cIjogXCJib3JkZXItbGVmdC1zdHlsZTpub25lO1wiLFxuXHRcdFx0XCJiZGxjXCI6IFwiYm9yZGVyLWxlZnQtY29sb3I6IyR7MTowMDB9O1wiLFxuXHRcdFx0XCJiZGxjOnRcIjogXCJib3JkZXItbGVmdC1jb2xvcjp0cmFuc3BhcmVudDtcIixcblx0XHRcdFwiYmRyc1wiOiBcImJvcmRlci1yYWRpdXM6fDtcIixcblx0XHRcdFwiYmR0cnJzXCI6IFwiYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6fDtcIixcblx0XHRcdFwiYmR0bHJzXCI6IFwiYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czp8O1wiLFxuXHRcdFx0XCJiZGJycnNcIjogXCJib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czp8O1wiLFxuXHRcdFx0XCJiZGJscnNcIjogXCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOnw7XCIsXG5cdFx0XHRcImJnXCI6IFwiYmFja2dyb3VuZDojJHsxOjAwMH07XCIsXG5cdFx0XHRcImJnK1wiOiBcImJhY2tncm91bmQ6JHsxOiNmZmZ9IHVybCgkezJ9KSAkezM6MH0gJHs0OjB9ICR7NTpuby1yZXBlYXR9O1wiLFxuXHRcdFx0XCJiZzpuXCI6IFwiYmFja2dyb3VuZDpub25lO1wiLFxuXHRcdFx0XCJiZzppZVwiOiBcImZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGFJbWFnZUxvYWRlcihzcmM9JyR7MTp4fS5wbmcnLHNpemluZ01ldGhvZD0nJHsyOmNyb3B9Jyk7XCIsXG5cdFx0XHRcImJnY1wiOiBcImJhY2tncm91bmQtY29sb3I6IyR7MTpmZmZ9O1wiLFxuXHRcdFx0XCJiZ2M6dFwiOiBcImJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7XCIsXG5cdFx0XHRcImJnaVwiOiBcImJhY2tncm91bmQtaW1hZ2U6dXJsKHwpO1wiLFxuXHRcdFx0XCJiZ2k6blwiOiBcImJhY2tncm91bmQtaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmdyXCI6IFwiYmFja2dyb3VuZC1yZXBlYXQ6fDtcIixcblx0XHRcdFwiYmdyOm5cIjogXCJiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7XCIsXG5cdFx0XHRcImJncjp4XCI6IFwiYmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7XCIsXG5cdFx0XHRcImJncjp5XCI6IFwiYmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXk7XCIsXG5cdFx0XHRcImJncjpzcFwiOiBcImJhY2tncm91bmQtcmVwZWF0OnNwYWNlO1wiLFxuXHRcdFx0XCJiZ3I6cmRcIjogXCJiYWNrZ3JvdW5kLXJlcGVhdDpyb3VuZDtcIixcblx0XHRcdFwiYmdhXCI6IFwiYmFja2dyb3VuZC1hdHRhY2htZW50Onw7XCIsXG5cdFx0XHRcImJnYTpmXCI6IFwiYmFja2dyb3VuZC1hdHRhY2htZW50OmZpeGVkO1wiLFxuXHRcdFx0XCJiZ2E6c1wiOiBcImJhY2tncm91bmQtYXR0YWNobWVudDpzY3JvbGw7XCIsXG5cdFx0XHRcImJncFwiOiBcImJhY2tncm91bmQtcG9zaXRpb246JHsxOjB9ICR7MjowfTtcIixcblx0XHRcdFwiYmdweFwiOiBcImJhY2tncm91bmQtcG9zaXRpb24teDp8O1wiLFxuXHRcdFx0XCJiZ3B5XCI6IFwiYmFja2dyb3VuZC1wb3NpdGlvbi15Onw7XCIsXG5cdFx0XHRcImJnYmtcIjogXCJiYWNrZ3JvdW5kLWJyZWFrOnw7XCIsXG5cdFx0XHRcImJnYms6YmJcIjogXCJiYWNrZ3JvdW5kLWJyZWFrOmJvdW5kaW5nLWJveDtcIixcblx0XHRcdFwiYmdiazplYlwiOiBcImJhY2tncm91bmQtYnJlYWs6ZWFjaC1ib3g7XCIsXG5cdFx0XHRcImJnYms6Y1wiOiBcImJhY2tncm91bmQtYnJlYWs6Y29udGludW91cztcIixcblx0XHRcdFwiYmdjcFwiOiBcImJhY2tncm91bmQtY2xpcDokezE6cGFkZGluZy1ib3h9O1wiLFxuXHRcdFx0XCJiZ2NwOmJiXCI6IFwiYmFja2dyb3VuZC1jbGlwOmJvcmRlci1ib3g7XCIsXG5cdFx0XHRcImJnY3A6cGJcIjogXCJiYWNrZ3JvdW5kLWNsaXA6cGFkZGluZy1ib3g7XCIsXG5cdFx0XHRcImJnY3A6Y2JcIjogXCJiYWNrZ3JvdW5kLWNsaXA6Y29udGVudC1ib3g7XCIsXG5cdFx0XHRcImJnY3A6bmNcIjogXCJiYWNrZ3JvdW5kLWNsaXA6bm8tY2xpcDtcIixcblx0XHRcdFwiYmdvXCI6IFwiYmFja2dyb3VuZC1vcmlnaW46fDtcIixcblx0XHRcdFwiYmdvOnBiXCI6IFwiYmFja2dyb3VuZC1vcmlnaW46cGFkZGluZy1ib3g7XCIsXG5cdFx0XHRcImJnbzpiYlwiOiBcImJhY2tncm91bmQtb3JpZ2luOmJvcmRlci1ib3g7XCIsXG5cdFx0XHRcImJnbzpjYlwiOiBcImJhY2tncm91bmQtb3JpZ2luOmNvbnRlbnQtYm94O1wiLFxuXHRcdFx0XCJiZ3N6XCI6IFwiYmFja2dyb3VuZC1zaXplOnw7XCIsXG5cdFx0XHRcImJnc3o6YVwiOiBcImJhY2tncm91bmQtc2l6ZTphdXRvO1wiLFxuXHRcdFx0XCJiZ3N6OmN0XCI6IFwiYmFja2dyb3VuZC1zaXplOmNvbnRhaW47XCIsXG5cdFx0XHRcImJnc3o6Y3ZcIjogXCJiYWNrZ3JvdW5kLXNpemU6Y292ZXI7XCIsXG5cdFx0XHRcImNcIjogXCJjb2xvcjojJHsxOjAwMH07XCIsXG5cdFx0XHRcImM6clwiOiBcImNvbG9yOnJnYigkezE6MH0sICR7MjowfSwgJHszOjB9KTtcIixcblx0XHRcdFwiYzpyYVwiOiBcImNvbG9yOnJnYmEoJHsxOjB9LCAkezI6MH0sICR7MzowfSwgLiR7NDo1fSk7XCIsXG5cdFx0XHRcImNtXCI6IFwiLyogfCR7Y2hpbGR9ICovXCIsXG5cdFx0XHRcImNudFwiOiBcImNvbnRlbnQ6J3wnO1wiLFxuXHRcdFx0XCJjbnQ6blwiOiBcImNvbnRlbnQ6bm9ybWFsO1wiLFxuXHRcdFx0XCJjbnQ6b3FcIjogXCJjb250ZW50Om9wZW4tcXVvdGU7XCIsXG5cdFx0XHRcImNudDpub3FcIjogXCJjb250ZW50Om5vLW9wZW4tcXVvdGU7XCIsXG5cdFx0XHRcImNudDpjcVwiOiBcImNvbnRlbnQ6Y2xvc2UtcXVvdGU7XCIsXG5cdFx0XHRcImNudDpuY3FcIjogXCJjb250ZW50Om5vLWNsb3NlLXF1b3RlO1wiLFxuXHRcdFx0XCJjbnQ6YVwiOiBcImNvbnRlbnQ6YXR0cih8KTtcIixcblx0XHRcdFwiY250OmNcIjogXCJjb250ZW50OmNvdW50ZXIofCk7XCIsXG5cdFx0XHRcImNudDpjc1wiOiBcImNvbnRlbnQ6Y291bnRlcnMofCk7XCIsXG5cblx0XHRcdFwidGJsXCI6IFwidGFibGUtbGF5b3V0Onw7XCIsXG5cdFx0XHRcInRibDphXCI6IFwidGFibGUtbGF5b3V0OmF1dG87XCIsXG5cdFx0XHRcInRibDpmXCI6IFwidGFibGUtbGF5b3V0OmZpeGVkO1wiLFxuXHRcdFx0XCJjcHNcIjogXCJjYXB0aW9uLXNpZGU6fDtcIixcblx0XHRcdFwiY3BzOnRcIjogXCJjYXB0aW9uLXNpZGU6dG9wO1wiLFxuXHRcdFx0XCJjcHM6YlwiOiBcImNhcHRpb24tc2lkZTpib3R0b207XCIsXG5cdFx0XHRcImVjXCI6IFwiZW1wdHktY2VsbHM6fDtcIixcblx0XHRcdFwiZWM6c1wiOiBcImVtcHR5LWNlbGxzOnNob3c7XCIsXG5cdFx0XHRcImVjOmhcIjogXCJlbXB0eS1jZWxsczpoaWRlO1wiLFxuXHRcdFx0XCJsaXNcIjogXCJsaXN0LXN0eWxlOnw7XCIsXG5cdFx0XHRcImxpczpuXCI6IFwibGlzdC1zdHlsZTpub25lO1wiLFxuXHRcdFx0XCJsaXNwXCI6IFwibGlzdC1zdHlsZS1wb3NpdGlvbjp8O1wiLFxuXHRcdFx0XCJsaXNwOmlcIjogXCJsaXN0LXN0eWxlLXBvc2l0aW9uOmluc2lkZTtcIixcblx0XHRcdFwibGlzcDpvXCI6IFwibGlzdC1zdHlsZS1wb3NpdGlvbjpvdXRzaWRlO1wiLFxuXHRcdFx0XCJsaXN0XCI6IFwibGlzdC1zdHlsZS10eXBlOnw7XCIsXG5cdFx0XHRcImxpc3Q6blwiOiBcImxpc3Qtc3R5bGUtdHlwZTpub25lO1wiLFxuXHRcdFx0XCJsaXN0OmRcIjogXCJsaXN0LXN0eWxlLXR5cGU6ZGlzYztcIixcblx0XHRcdFwibGlzdDpjXCI6IFwibGlzdC1zdHlsZS10eXBlOmNpcmNsZTtcIixcblx0XHRcdFwibGlzdDpzXCI6IFwibGlzdC1zdHlsZS10eXBlOnNxdWFyZTtcIixcblx0XHRcdFwibGlzdDpkY1wiOiBcImxpc3Qtc3R5bGUtdHlwZTpkZWNpbWFsO1wiLFxuXHRcdFx0XCJsaXN0OmRjbHpcIjogXCJsaXN0LXN0eWxlLXR5cGU6ZGVjaW1hbC1sZWFkaW5nLXplcm87XCIsXG5cdFx0XHRcImxpc3Q6bHJcIjogXCJsaXN0LXN0eWxlLXR5cGU6bG93ZXItcm9tYW47XCIsXG5cdFx0XHRcImxpc3Q6dXJcIjogXCJsaXN0LXN0eWxlLXR5cGU6dXBwZXItcm9tYW47XCIsXG5cdFx0XHRcImxpc2lcIjogXCJsaXN0LXN0eWxlLWltYWdlOnw7XCIsXG5cdFx0XHRcImxpc2k6blwiOiBcImxpc3Qtc3R5bGUtaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwicVwiOiBcInF1b3Rlczp8O1wiLFxuXHRcdFx0XCJxOm5cIjogXCJxdW90ZXM6bm9uZTtcIixcblx0XHRcdFwicTpydVwiOiBcInF1b3RlczonXFxcXDAwQUInICdcXFxcMDBCQicgJ1xcXFwyMDFFJyAnXFxcXDIwMUMnO1wiLFxuXHRcdFx0XCJxOmVuXCI6IFwicXVvdGVzOidcXFxcMjAxQycgJ1xcXFwyMDFEJyAnXFxcXDIwMTgnICdcXFxcMjAxOSc7XCIsXG5cdFx0XHRcImN0XCI6IFwiY29udGVudDp8O1wiLFxuXHRcdFx0XCJjdDpuXCI6IFwiY29udGVudDpub3JtYWw7XCIsXG5cdFx0XHRcImN0Om9xXCI6IFwiY29udGVudDpvcGVuLXF1b3RlO1wiLFxuXHRcdFx0XCJjdDpub3FcIjogXCJjb250ZW50Om5vLW9wZW4tcXVvdGU7XCIsXG5cdFx0XHRcImN0OmNxXCI6IFwiY29udGVudDpjbG9zZS1xdW90ZTtcIixcblx0XHRcdFwiY3Q6bmNxXCI6IFwiY29udGVudDpuby1jbG9zZS1xdW90ZTtcIixcblx0XHRcdFwiY3Q6YVwiOiBcImNvbnRlbnQ6YXR0cih8KTtcIixcblx0XHRcdFwiY3Q6Y1wiOiBcImNvbnRlbnQ6Y291bnRlcih8KTtcIixcblx0XHRcdFwiY3Q6Y3NcIjogXCJjb250ZW50OmNvdW50ZXJzKHwpO1wiLFxuXHRcdFx0XCJjb2lcIjogXCJjb3VudGVyLWluY3JlbWVudDp8O1wiLFxuXHRcdFx0XCJjb3JcIjogXCJjb3VudGVyLXJlc2V0Onw7XCIsXG5cdFx0XHRcInZhXCI6IFwidmVydGljYWwtYWxpZ246JHsxOnRvcH07XCIsXG5cdFx0XHRcInZhOnN1cFwiOiBcInZlcnRpY2FsLWFsaWduOnN1cGVyO1wiLFxuXHRcdFx0XCJ2YTp0XCI6IFwidmVydGljYWwtYWxpZ246dG9wO1wiLFxuXHRcdFx0XCJ2YTp0dFwiOiBcInZlcnRpY2FsLWFsaWduOnRleHQtdG9wO1wiLFxuXHRcdFx0XCJ2YTptXCI6IFwidmVydGljYWwtYWxpZ246bWlkZGxlO1wiLFxuXHRcdFx0XCJ2YTpibFwiOiBcInZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO1wiLFxuXHRcdFx0XCJ2YTpiXCI6IFwidmVydGljYWwtYWxpZ246Ym90dG9tO1wiLFxuXHRcdFx0XCJ2YTp0YlwiOiBcInZlcnRpY2FsLWFsaWduOnRleHQtYm90dG9tO1wiLFxuXHRcdFx0XCJ2YTpzdWJcIjogXCJ2ZXJ0aWNhbC1hbGlnbjpzdWI7XCIsXG5cdFx0XHRcInRhXCI6IFwidGV4dC1hbGlnbjokezE6bGVmdH07XCIsXG5cdFx0XHRcInRhOmxcIjogXCJ0ZXh0LWFsaWduOmxlZnQ7XCIsXG5cdFx0XHRcInRhOmNcIjogXCJ0ZXh0LWFsaWduOmNlbnRlcjtcIixcblx0XHRcdFwidGE6clwiOiBcInRleHQtYWxpZ246cmlnaHQ7XCIsXG5cdFx0XHRcInRhOmpcIjogXCJ0ZXh0LWFsaWduOmp1c3RpZnk7XCIsXG5cdFx0XHRcInRhLWxzdFwiOiBcInRleHQtYWxpZ24tbGFzdDp8O1wiLFxuXHRcdFx0XCJ0YWw6YVwiOiBcInRleHQtYWxpZ24tbGFzdDphdXRvO1wiLFxuXHRcdFx0XCJ0YWw6bFwiOiBcInRleHQtYWxpZ24tbGFzdDpsZWZ0O1wiLFxuXHRcdFx0XCJ0YWw6Y1wiOiBcInRleHQtYWxpZ24tbGFzdDpjZW50ZXI7XCIsXG5cdFx0XHRcInRhbDpyXCI6IFwidGV4dC1hbGlnbi1sYXN0OnJpZ2h0O1wiLFxuXHRcdFx0XCJ0ZFwiOiBcInRleHQtZGVjb3JhdGlvbjokezE6bm9uZX07XCIsXG5cdFx0XHRcInRkOm5cIjogXCJ0ZXh0LWRlY29yYXRpb246bm9uZTtcIixcblx0XHRcdFwidGQ6dVwiOiBcInRleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7XCIsXG5cdFx0XHRcInRkOm9cIjogXCJ0ZXh0LWRlY29yYXRpb246b3ZlcmxpbmU7XCIsXG5cdFx0XHRcInRkOmxcIjogXCJ0ZXh0LWRlY29yYXRpb246bGluZS10aHJvdWdoO1wiLFxuXHRcdFx0XCJ0ZVwiOiBcInRleHQtZW1waGFzaXM6fDtcIixcblx0XHRcdFwidGU6blwiOiBcInRleHQtZW1waGFzaXM6bm9uZTtcIixcblx0XHRcdFwidGU6YWNcIjogXCJ0ZXh0LWVtcGhhc2lzOmFjY2VudDtcIixcblx0XHRcdFwidGU6ZHRcIjogXCJ0ZXh0LWVtcGhhc2lzOmRvdDtcIixcblx0XHRcdFwidGU6Y1wiOiBcInRleHQtZW1waGFzaXM6Y2lyY2xlO1wiLFxuXHRcdFx0XCJ0ZTpkc1wiOiBcInRleHQtZW1waGFzaXM6ZGlzYztcIixcblx0XHRcdFwidGU6YlwiOiBcInRleHQtZW1waGFzaXM6YmVmb3JlO1wiLFxuXHRcdFx0XCJ0ZTphXCI6IFwidGV4dC1lbXBoYXNpczphZnRlcjtcIixcblx0XHRcdFwidGhcIjogXCJ0ZXh0LWhlaWdodDp8O1wiLFxuXHRcdFx0XCJ0aDphXCI6IFwidGV4dC1oZWlnaHQ6YXV0bztcIixcblx0XHRcdFwidGg6ZlwiOiBcInRleHQtaGVpZ2h0OmZvbnQtc2l6ZTtcIixcblx0XHRcdFwidGg6dFwiOiBcInRleHQtaGVpZ2h0OnRleHQtc2l6ZTtcIixcblx0XHRcdFwidGg6bVwiOiBcInRleHQtaGVpZ2h0Om1heC1zaXplO1wiLFxuXHRcdFx0XCJ0aVwiOiBcInRleHQtaW5kZW50Onw7XCIsXG5cdFx0XHRcInRpOi1cIjogXCJ0ZXh0LWluZGVudDotOTk5OXB4O1wiLFxuXHRcdFx0XCJ0alwiOiBcInRleHQtanVzdGlmeTp8O1wiLFxuXHRcdFx0XCJ0ajphXCI6IFwidGV4dC1qdXN0aWZ5OmF1dG87XCIsXG5cdFx0XHRcInRqOml3XCI6IFwidGV4dC1qdXN0aWZ5OmludGVyLXdvcmQ7XCIsXG5cdFx0XHRcInRqOmlpXCI6IFwidGV4dC1qdXN0aWZ5OmludGVyLWlkZW9ncmFwaDtcIixcblx0XHRcdFwidGo6aWNcIjogXCJ0ZXh0LWp1c3RpZnk6aW50ZXItY2x1c3RlcjtcIixcblx0XHRcdFwidGo6ZFwiOiBcInRleHQtanVzdGlmeTpkaXN0cmlidXRlO1wiLFxuXHRcdFx0XCJ0ajprXCI6IFwidGV4dC1qdXN0aWZ5Omthc2hpZGE7XCIsXG5cdFx0XHRcInRqOnRcIjogXCJ0ZXh0LWp1c3RpZnk6dGliZXRhbjtcIixcblx0XHRcdFwidG92XCI6IFwidGV4dC1vdmVyZmxvdzoke2VsbGlwc2lzfTtcIixcblx0XHRcdFwidG92OmVcIjogXCJ0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO1wiLFxuXHRcdFx0XCJ0b3Y6Y1wiOiBcInRleHQtb3ZlcmZsb3c6Y2xpcDtcIixcblx0XHRcdFwidG9cIjogXCJ0ZXh0LW91dGxpbmU6fDtcIixcblx0XHRcdFwidG8rXCI6IFwidGV4dC1vdXRsaW5lOiR7MTowfSAkezI6MH0gJHszOiMwMDB9O1wiLFxuXHRcdFx0XCJ0bzpuXCI6IFwidGV4dC1vdXRsaW5lOm5vbmU7XCIsXG5cdFx0XHRcInRyXCI6IFwidGV4dC1yZXBsYWNlOnw7XCIsXG5cdFx0XHRcInRyOm5cIjogXCJ0ZXh0LXJlcGxhY2U6bm9uZTtcIixcblx0XHRcdFwidHRcIjogXCJ0ZXh0LXRyYW5zZm9ybTokezE6dXBwZXJjYXNlfTtcIixcblx0XHRcdFwidHQ6blwiOiBcInRleHQtdHJhbnNmb3JtOm5vbmU7XCIsXG5cdFx0XHRcInR0OmNcIjogXCJ0ZXh0LXRyYW5zZm9ybTpjYXBpdGFsaXplO1wiLFxuXHRcdFx0XCJ0dDp1XCI6IFwidGV4dC10cmFuc2Zvcm06dXBwZXJjYXNlO1wiLFxuXHRcdFx0XCJ0dDpsXCI6IFwidGV4dC10cmFuc2Zvcm06bG93ZXJjYXNlO1wiLFxuXHRcdFx0XCJ0d1wiOiBcInRleHQtd3JhcDp8O1wiLFxuXHRcdFx0XCJ0dzpuXCI6IFwidGV4dC13cmFwOm5vcm1hbDtcIixcblx0XHRcdFwidHc6bm9cIjogXCJ0ZXh0LXdyYXA6bm9uZTtcIixcblx0XHRcdFwidHc6dVwiOiBcInRleHQtd3JhcDp1bnJlc3RyaWN0ZWQ7XCIsXG5cdFx0XHRcInR3OnNcIjogXCJ0ZXh0LXdyYXA6c3VwcHJlc3M7XCIsXG5cdFx0XHRcInRzaFwiOiBcInRleHQtc2hhZG93OiR7MTpob2ZmfSAkezI6dm9mZn0gJHszOmJsdXJ9ICR7NDojMDAwfTtcIixcblx0XHRcdFwidHNoOnJcIjogXCJ0ZXh0LXNoYWRvdzokezE6aH0gJHsyOnZ9ICR7MzpibHVyfSByZ2IoJHs0OjB9LCAkezU6MH0sICR7NjowfSk7XCIsXG5cdFx0XHRcInRzaDpyYVwiOiBcInRleHQtc2hhZG93OiR7MTpofSAkezI6dn0gJHszOmJsdXJ9IHJnYmEoJHs0OjB9LCAkezU6MH0sICR7NjowfSwgLiR7Nzo1fSk7XCIsXG5cdFx0XHRcInRzaCtcIjogXCJ0ZXh0LXNoYWRvdzokezE6MH0gJHsyOjB9ICR7MzowfSAkezQ6IzAwMH07XCIsXG5cdFx0XHRcInRzaDpuXCI6IFwidGV4dC1zaGFkb3c6bm9uZTtcIixcblx0XHRcdFwidHJmXCI6IFwidHJhbnNmb3JtOnw7XCIsXG5cdFx0XHRcInRyZjpza3hcIjogXCJ0cmFuc2Zvcm06IHNrZXdYKCR7MTphbmdsZX0pO1wiLFxuXHRcdFx0XCJ0cmY6c2t5XCI6IFwidHJhbnNmb3JtOiBza2V3WSgkezE6YW5nbGV9KTtcIixcblx0XHRcdFwidHJmOnNjXCI6IFwidHJhbnNmb3JtOiBzY2FsZSgkezE6eH0sICR7Mjp5fSk7XCIsXG5cdFx0XHRcInRyZjpzY3hcIjogXCJ0cmFuc2Zvcm06IHNjYWxlWCgkezE6eH0pO1wiLFxuXHRcdFx0XCJ0cmY6c2N5XCI6IFwidHJhbnNmb3JtOiBzY2FsZVkoJHsxOnl9KTtcIixcblx0XHRcdFwidHJmOnNjelwiOiBcInRyYW5zZm9ybTogc2NhbGVaKCR7MTp6fSk7XCIsXG5cdFx0XHRcInRyZjpzYzNcIjogXCJ0cmFuc2Zvcm06IHNjYWxlM2QoJHsxOnh9LCAkezI6eX0sICR7Mzp6fSk7XCIsXG5cdFx0XHRcInRyZjpyXCI6IFwidHJhbnNmb3JtOiByb3RhdGUoJHsxOmFuZ2xlfSk7XCIsXG5cdFx0XHRcInRyZjpyeFwiOiBcInRyYW5zZm9ybTogcm90YXRlWCgkezE6YW5nbGV9KTtcIixcblx0XHRcdFwidHJmOnJ5XCI6IFwidHJhbnNmb3JtOiByb3RhdGVZKCR7MTphbmdsZX0pO1wiLFxuXHRcdFx0XCJ0cmY6cnpcIjogXCJ0cmFuc2Zvcm06IHJvdGF0ZVooJHsxOmFuZ2xlfSk7XCIsXG5cdFx0XHRcInRyZjp0XCI6IFwidHJhbnNmb3JtOiB0cmFuc2xhdGUoJHsxOnh9LCAkezI6eX0pO1wiLFxuXHRcdFx0XCJ0cmY6dHhcIjogXCJ0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoJHsxOnh9KTtcIixcblx0XHRcdFwidHJmOnR5XCI6IFwidHJhbnNmb3JtOiB0cmFuc2xhdGVZKCR7MTp5fSk7XCIsXG5cdFx0XHRcInRyZjp0elwiOiBcInRyYW5zZm9ybTogdHJhbnNsYXRlWigkezE6en0pO1wiLFxuXHRcdFx0XCJ0cmY6dDNcIjogXCJ0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCR7MTp0eH0sICR7Mjp0eX0sICR7Mzp0en0pO1wiLFxuXHRcdFx0XCJ0cmZvXCI6IFwidHJhbnNmb3JtLW9yaWdpbjp8O1wiLFxuXHRcdFx0XCJ0cmZzXCI6IFwidHJhbnNmb3JtLXN0eWxlOiR7MTpwcmVzZXJ2ZS0zZH07XCIsXG5cdFx0XHRcInRyc1wiOiBcInRyYW5zaXRpb246JHsxOnByb3B9ICR7Mjp0aW1lfTtcIixcblx0XHRcdFwidHJzZGVcIjogXCJ0cmFuc2l0aW9uLWRlbGF5OiR7MTp0aW1lfTtcIixcblx0XHRcdFwidHJzZHVcIjogXCJ0cmFuc2l0aW9uLWR1cmF0aW9uOiR7MTp0aW1lfTtcIixcblx0XHRcdFwidHJzcFwiOiBcInRyYW5zaXRpb24tcHJvcGVydHk6JHsxOnByb3B9O1wiLFxuXHRcdFx0XCJ0cnN0ZlwiOiBcInRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiR7MTp0ZnVuY307XCIsXG5cdFx0XHRcImxoXCI6IFwibGluZS1oZWlnaHQ6fDtcIixcblx0XHRcdFwid2hzXCI6IFwid2hpdGUtc3BhY2U6fDtcIixcblx0XHRcdFwid2hzOm5cIjogXCJ3aGl0ZS1zcGFjZTpub3JtYWw7XCIsXG5cdFx0XHRcIndoczpwXCI6IFwid2hpdGUtc3BhY2U6cHJlO1wiLFxuXHRcdFx0XCJ3aHM6bndcIjogXCJ3aGl0ZS1zcGFjZTpub3dyYXA7XCIsXG5cdFx0XHRcIndoczpwd1wiOiBcIndoaXRlLXNwYWNlOnByZS13cmFwO1wiLFxuXHRcdFx0XCJ3aHM6cGxcIjogXCJ3aGl0ZS1zcGFjZTpwcmUtbGluZTtcIixcblx0XHRcdFwid2hzY1wiOiBcIndoaXRlLXNwYWNlLWNvbGxhcHNlOnw7XCIsXG5cdFx0XHRcIndoc2M6blwiOiBcIndoaXRlLXNwYWNlLWNvbGxhcHNlOm5vcm1hbDtcIixcblx0XHRcdFwid2hzYzprXCI6IFwid2hpdGUtc3BhY2UtY29sbGFwc2U6a2VlcC1hbGw7XCIsXG5cdFx0XHRcIndoc2M6bFwiOiBcIndoaXRlLXNwYWNlLWNvbGxhcHNlOmxvb3NlO1wiLFxuXHRcdFx0XCJ3aHNjOmJzXCI6IFwid2hpdGUtc3BhY2UtY29sbGFwc2U6YnJlYWstc3RyaWN0O1wiLFxuXHRcdFx0XCJ3aHNjOmJhXCI6IFwid2hpdGUtc3BhY2UtY29sbGFwc2U6YnJlYWstYWxsO1wiLFxuXHRcdFx0XCJ3b2JcIjogXCJ3b3JkLWJyZWFrOnw7XCIsXG5cdFx0XHRcIndvYjpuXCI6IFwid29yZC1icmVhazpub3JtYWw7XCIsXG5cdFx0XHRcIndvYjprXCI6IFwid29yZC1icmVhazprZWVwLWFsbDtcIixcblx0XHRcdFwid29iOmJhXCI6IFwid29yZC1icmVhazpicmVhay1hbGw7XCIsXG5cdFx0XHRcIndvc1wiOiBcIndvcmQtc3BhY2luZzp8O1wiLFxuXHRcdFx0XCJ3b3dcIjogXCJ3b3JkLXdyYXA6fDtcIixcblx0XHRcdFwid293Om5tXCI6IFwid29yZC13cmFwOm5vcm1hbDtcIixcblx0XHRcdFwid293Om5cIjogXCJ3b3JkLXdyYXA6bm9uZTtcIixcblx0XHRcdFwid293OnVcIjogXCJ3b3JkLXdyYXA6dW5yZXN0cmljdGVkO1wiLFxuXHRcdFx0XCJ3b3c6c1wiOiBcIndvcmQtd3JhcDpzdXBwcmVzcztcIixcblx0XHRcdFwid293OmJcIjogXCJ3b3JkLXdyYXA6YnJlYWstd29yZDtcIixcblx0XHRcdFwid21cIjogXCJ3cml0aW5nLW1vZGU6JHsxOmxyLXRifTtcIixcblx0XHRcdFwid206bHJ0XCI6IFwid3JpdGluZy1tb2RlOmxyLXRiO1wiLFxuXHRcdFx0XCJ3bTpscmJcIjogXCJ3cml0aW5nLW1vZGU6bHItYnQ7XCIsXG5cdFx0XHRcIndtOnJsdFwiOiBcIndyaXRpbmctbW9kZTpybC10YjtcIixcblx0XHRcdFwid206cmxiXCI6IFwid3JpdGluZy1tb2RlOnJsLWJ0O1wiLFxuXHRcdFx0XCJ3bTp0YnJcIjogXCJ3cml0aW5nLW1vZGU6dGItcmw7XCIsXG5cdFx0XHRcIndtOnRibFwiOiBcIndyaXRpbmctbW9kZTp0Yi1scjtcIixcblx0XHRcdFwid206YnRsXCI6IFwid3JpdGluZy1tb2RlOmJ0LWxyO1wiLFxuXHRcdFx0XCJ3bTpidHJcIjogXCJ3cml0aW5nLW1vZGU6YnQtcmw7XCIsXG5cdFx0XHRcImx0c1wiOiBcImxldHRlci1zcGFjaW5nOnw7XCIsXG5cdFx0XHRcImx0cy1uXCI6IFwibGV0dGVyLXNwYWNpbmc6bm9ybWFsO1wiLFxuXHRcdFx0XCJmXCI6IFwiZm9udDp8O1wiLFxuXHRcdFx0XCJmK1wiOiBcImZvbnQ6JHsxOjFlbX0gJHsyOkFyaWFsLHNhbnMtc2VyaWZ9O1wiLFxuXHRcdFx0XCJmd1wiOiBcImZvbnQtd2VpZ2h0Onw7XCIsXG5cdFx0XHRcImZ3Om5cIjogXCJmb250LXdlaWdodDpub3JtYWw7XCIsXG5cdFx0XHRcImZ3OmJcIjogXCJmb250LXdlaWdodDpib2xkO1wiLFxuXHRcdFx0XCJmdzpiclwiOiBcImZvbnQtd2VpZ2h0OmJvbGRlcjtcIixcblx0XHRcdFwiZnc6bHJcIjogXCJmb250LXdlaWdodDpsaWdodGVyO1wiLFxuXHRcdFx0XCJmc1wiOiBcImZvbnQtc3R5bGU6JHtpdGFsaWN9O1wiLFxuXHRcdFx0XCJmczpuXCI6IFwiZm9udC1zdHlsZTpub3JtYWw7XCIsXG5cdFx0XHRcImZzOmlcIjogXCJmb250LXN0eWxlOml0YWxpYztcIixcblx0XHRcdFwiZnM6b1wiOiBcImZvbnQtc3R5bGU6b2JsaXF1ZTtcIixcblx0XHRcdFwiZnZcIjogXCJmb250LXZhcmlhbnQ6fDtcIixcblx0XHRcdFwiZnY6blwiOiBcImZvbnQtdmFyaWFudDpub3JtYWw7XCIsXG5cdFx0XHRcImZ2OnNjXCI6IFwiZm9udC12YXJpYW50OnNtYWxsLWNhcHM7XCIsXG5cdFx0XHRcImZ6XCI6IFwiZm9udC1zaXplOnw7XCIsXG5cdFx0XHRcImZ6YVwiOiBcImZvbnQtc2l6ZS1hZGp1c3Q6fDtcIixcblx0XHRcdFwiZnphOm5cIjogXCJmb250LXNpemUtYWRqdXN0Om5vbmU7XCIsXG5cdFx0XHRcImZmXCI6IFwiZm9udC1mYW1pbHk6fDtcIixcblx0XHRcdFwiZmY6c1wiOiBcImZvbnQtZmFtaWx5OnNlcmlmO1wiLFxuXHRcdFx0XCJmZjpzc1wiOiBcImZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7XCIsXG5cdFx0XHRcImZmOmNcIjogXCJmb250LWZhbWlseTpjdXJzaXZlO1wiLFxuXHRcdFx0XCJmZjpmXCI6IFwiZm9udC1mYW1pbHk6ZmFudGFzeTtcIixcblx0XHRcdFwiZmY6bVwiOiBcImZvbnQtZmFtaWx5Om1vbm9zcGFjZTtcIixcblx0XHRcdFwiZmY6YVwiOiBcImZvbnQtZmFtaWx5OiBBcmlhbCwgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1wiLFxuXHRcdFx0XCJmZjp0XCI6IFwiZm9udC1mYW1pbHk6IFxcXCJUaW1lcyBOZXcgUm9tYW5cXFwiLCBUaW1lcywgQmFza2VydmlsbGUsIEdlb3JnaWEsIHNlcmlmO1wiLFxuXHRcdFx0XCJmZjp2XCI6IFwiZm9udC1mYW1pbHk6IFZlcmRhbmEsIEdlbmV2YSwgc2Fucy1zZXJpZjtcIixcblx0XHRcdFwiZmVmXCI6IFwiZm9udC1lZmZlY3Q6fDtcIixcblx0XHRcdFwiZmVmOm5cIjogXCJmb250LWVmZmVjdDpub25lO1wiLFxuXHRcdFx0XCJmZWY6ZWdcIjogXCJmb250LWVmZmVjdDplbmdyYXZlO1wiLFxuXHRcdFx0XCJmZWY6ZWJcIjogXCJmb250LWVmZmVjdDplbWJvc3M7XCIsXG5cdFx0XHRcImZlZjpvXCI6IFwiZm9udC1lZmZlY3Q6b3V0bGluZTtcIixcblx0XHRcdFwiZmVtXCI6IFwiZm9udC1lbXBoYXNpemU6fDtcIixcblx0XHRcdFwiZmVtcFwiOiBcImZvbnQtZW1waGFzaXplLXBvc2l0aW9uOnw7XCIsXG5cdFx0XHRcImZlbXA6YlwiOiBcImZvbnQtZW1waGFzaXplLXBvc2l0aW9uOmJlZm9yZTtcIixcblx0XHRcdFwiZmVtcDphXCI6IFwiZm9udC1lbXBoYXNpemUtcG9zaXRpb246YWZ0ZXI7XCIsXG5cdFx0XHRcImZlbXNcIjogXCJmb250LWVtcGhhc2l6ZS1zdHlsZTp8O1wiLFxuXHRcdFx0XCJmZW1zOm5cIjogXCJmb250LWVtcGhhc2l6ZS1zdHlsZTpub25lO1wiLFxuXHRcdFx0XCJmZW1zOmFjXCI6IFwiZm9udC1lbXBoYXNpemUtc3R5bGU6YWNjZW50O1wiLFxuXHRcdFx0XCJmZW1zOmR0XCI6IFwiZm9udC1lbXBoYXNpemUtc3R5bGU6ZG90O1wiLFxuXHRcdFx0XCJmZW1zOmNcIjogXCJmb250LWVtcGhhc2l6ZS1zdHlsZTpjaXJjbGU7XCIsXG5cdFx0XHRcImZlbXM6ZHNcIjogXCJmb250LWVtcGhhc2l6ZS1zdHlsZTpkaXNjO1wiLFxuXHRcdFx0XCJmc21cIjogXCJmb250LXNtb290aDp8O1wiLFxuXHRcdFx0XCJmc206YVwiOiBcImZvbnQtc21vb3RoOmF1dG87XCIsXG5cdFx0XHRcImZzbTpuXCI6IFwiZm9udC1zbW9vdGg6bmV2ZXI7XCIsXG5cdFx0XHRcImZzbTphd1wiOiBcImZvbnQtc21vb3RoOmFsd2F5cztcIixcblx0XHRcdFwiZnN0XCI6IFwiZm9udC1zdHJldGNoOnw7XCIsXG5cdFx0XHRcImZzdDpuXCI6IFwiZm9udC1zdHJldGNoOm5vcm1hbDtcIixcblx0XHRcdFwiZnN0OnVjXCI6IFwiZm9udC1zdHJldGNoOnVsdHJhLWNvbmRlbnNlZDtcIixcblx0XHRcdFwiZnN0OmVjXCI6IFwiZm9udC1zdHJldGNoOmV4dHJhLWNvbmRlbnNlZDtcIixcblx0XHRcdFwiZnN0OmNcIjogXCJmb250LXN0cmV0Y2g6Y29uZGVuc2VkO1wiLFxuXHRcdFx0XCJmc3Q6c2NcIjogXCJmb250LXN0cmV0Y2g6c2VtaS1jb25kZW5zZWQ7XCIsXG5cdFx0XHRcImZzdDpzZVwiOiBcImZvbnQtc3RyZXRjaDpzZW1pLWV4cGFuZGVkO1wiLFxuXHRcdFx0XCJmc3Q6ZVwiOiBcImZvbnQtc3RyZXRjaDpleHBhbmRlZDtcIixcblx0XHRcdFwiZnN0OmVlXCI6IFwiZm9udC1zdHJldGNoOmV4dHJhLWV4cGFuZGVkO1wiLFxuXHRcdFx0XCJmc3Q6dWVcIjogXCJmb250LXN0cmV0Y2g6dWx0cmEtZXhwYW5kZWQ7XCIsXG5cdFx0XHRcIm9wXCI6IFwib3BhY2l0eTp8O1wiLFxuXHRcdFx0XCJvcCtcIjogXCJvcGFjaXR5OiAkMTtcXG5maWx0ZXI6IGFscGhhKG9wYWNpdHk9JDIpO1wiLFxuXHRcdFx0XCJvcDppZVwiOiBcImZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEoT3BhY2l0eT0xMDApO1wiLFxuXHRcdFx0XCJvcDptc1wiOiBcIi1tcy1maWx0ZXI6J3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTEwMCknO1wiLFxuXHRcdFx0XCJyc3pcIjogXCJyZXNpemU6fDtcIixcblx0XHRcdFwicnN6Om5cIjogXCJyZXNpemU6bm9uZTtcIixcblx0XHRcdFwicnN6OmJcIjogXCJyZXNpemU6Ym90aDtcIixcblx0XHRcdFwicnN6OmhcIjogXCJyZXNpemU6aG9yaXpvbnRhbDtcIixcblx0XHRcdFwicnN6OnZcIjogXCJyZXNpemU6dmVydGljYWw7XCIsXG5cdFx0XHRcImN1clwiOiBcImN1cnNvcjoke3BvaW50ZXJ9O1wiLFxuXHRcdFx0XCJjdXI6YVwiOiBcImN1cnNvcjphdXRvO1wiLFxuXHRcdFx0XCJjdXI6ZFwiOiBcImN1cnNvcjpkZWZhdWx0O1wiLFxuXHRcdFx0XCJjdXI6Y1wiOiBcImN1cnNvcjpjcm9zc2hhaXI7XCIsXG5cdFx0XHRcImN1cjpoYVwiOiBcImN1cnNvcjpoYW5kO1wiLFxuXHRcdFx0XCJjdXI6aGVcIjogXCJjdXJzb3I6aGVscDtcIixcblx0XHRcdFwiY3VyOm1cIjogXCJjdXJzb3I6bW92ZTtcIixcblx0XHRcdFwiY3VyOnBcIjogXCJjdXJzb3I6cG9pbnRlcjtcIixcblx0XHRcdFwiY3VyOnRcIjogXCJjdXJzb3I6dGV4dDtcIixcblx0XHRcdFwiZnhkXCI6IFwiZmxleC1kaXJlY3Rpb246fDtcIixcblx0XHRcdFwiZnhkOnJcIjogXCJmbGV4LWRpcmVjdGlvbjpyb3c7XCIsXG5cdFx0XHRcImZ4ZDpyclwiOiBcImZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlO1wiLFxuXHRcdFx0XCJmeGQ6Y1wiOiBcImZsZXgtZGlyZWN0aW9uOmNvbHVtbjtcIixcblx0XHRcdFwiZnhkOmNyXCI6IFwiZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2U7XCIsXG5cdFx0XHRcImZ4d1wiOiBcImZsZXgtd3JhcDogfDtcIixcblx0XHRcdFwiZnh3Om5cIjogXCJmbGV4LXdyYXA6bm93cmFwO1wiLFxuXHRcdFx0XCJmeHc6d1wiOiBcImZsZXgtd3JhcDp3cmFwO1wiLFxuXHRcdFx0XCJmeHc6d3JcIjogXCJmbGV4LXdyYXA6d3JhcC1yZXZlcnNlO1wiLFxuXHRcdFx0XCJmeGZcIjogXCJmbGV4LWZsb3c6fDtcIixcblx0XHRcdFwiamNcIjogXCJqdXN0aWZ5LWNvbnRlbnQ6fDtcIixcblx0XHRcdFwiamM6ZnNcIjogXCJqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtcIixcblx0XHRcdFwiamM6ZmVcIjogXCJqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7XCIsXG5cdFx0XHRcImpjOmNcIjogXCJqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO1wiLFxuXHRcdFx0XCJqYzpzYlwiOiBcImp1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO1wiLFxuXHRcdFx0XCJqYzpzYVwiOiBcImp1c3RpZnktY29udGVudDpzcGFjZS1hcm91bmQ7XCIsXG5cdFx0XHRcImFpXCI6IFwiYWxpZ24taXRlbXM6fDtcIixcblx0XHRcdFwiYWk6ZnNcIjogXCJhbGlnbi1pdGVtczpmbGV4LXN0YXJ0O1wiLFxuXHRcdFx0XCJhaTpmZVwiOiBcImFsaWduLWl0ZW1zOmZsZXgtZW5kO1wiLFxuXHRcdFx0XCJhaTpjXCI6IFwiYWxpZ24taXRlbXM6Y2VudGVyO1wiLFxuXHRcdFx0XCJhaTpiXCI6IFwiYWxpZ24taXRlbXM6YmFzZWxpbmU7XCIsXG5cdFx0XHRcImFpOnNcIjogXCJhbGlnbi1pdGVtczpzdHJldGNoO1wiLFxuXHRcdFx0XCJhY1wiOiBcImFsaWduLWNvbnRlbnQ6fDtcIixcblx0XHRcdFwiYWM6ZnNcIjogXCJhbGlnbi1jb250ZW50OmZsZXgtc3RhcnQ7XCIsXG5cdFx0XHRcImFjOmZlXCI6IFwiYWxpZ24tY29udGVudDpmbGV4LWVuZDtcIixcblx0XHRcdFwiYWM6Y1wiOiBcImFsaWduLWNvbnRlbnQ6Y2VudGVyO1wiLFxuXHRcdFx0XCJhYzpzYlwiOiBcImFsaWduLWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtcIixcblx0XHRcdFwiYWM6c2FcIjogXCJhbGlnbi1jb250ZW50OnNwYWNlLWFyb3VuZDtcIixcblx0XHRcdFwiYWM6c1wiOiBcImFsaWduLWNvbnRlbnQ6c3RyZXRjaDtcIixcblx0XHRcdFwib3JkXCI6IFwib3JkZXI6fDtcIixcblx0XHRcdFwiZnhnXCI6IFwiZmxleC1ncm93Onw7XCIsXG5cdFx0XHRcImZ4c2hcIjogXCJmbGV4LXNocmluazp8O1wiLFxuXHRcdFx0XCJmeGJcIjogXCJmbGV4LWJhc2lzOnw7XCIsXG5cdFx0XHRcImZ4XCI6IFwiZmxleDp8O1wiLFxuXHRcdFx0XCJhc1wiOiBcImFsaWduLXNlbGY6fDtcIixcblx0XHRcdFwiYXM6YVwiOiBcImFsaWduLXNlbGY6YXV0bztcIixcblx0XHRcdFwiYXM6ZnNcIjogXCJhbGlnbi1zZWxmOmZsZXgtc3RhcnQ7XCIsXG5cdFx0XHRcImFzOmZlXCI6IFwiYWxpZ24tc2VsZjpmbGV4LWVuZDtcIixcblx0XHRcdFwiYXM6Y1wiOiBcImFsaWduLXNlbGY6Y2VudGVyO1wiLFxuXHRcdFx0XCJhczpiXCI6IFwiYWxpZ24tc2VsZjpiYXNlbGluZTtcIixcblx0XHRcdFwiYXM6c1wiOiBcImFsaWduLXNlbGY6c3RyZXRjaDtcIixcblx0XHRcdFwicGdiYlwiOiBcInBhZ2UtYnJlYWstYmVmb3JlOnw7XCIsXG5cdFx0XHRcInBnYmI6YXVcIjogXCJwYWdlLWJyZWFrLWJlZm9yZTphdXRvO1wiLFxuXHRcdFx0XCJwZ2JiOmFsXCI6IFwicGFnZS1icmVhay1iZWZvcmU6YWx3YXlzO1wiLFxuXHRcdFx0XCJwZ2JiOmxcIjogXCJwYWdlLWJyZWFrLWJlZm9yZTpsZWZ0O1wiLFxuXHRcdFx0XCJwZ2JiOnJcIjogXCJwYWdlLWJyZWFrLWJlZm9yZTpyaWdodDtcIixcblx0XHRcdFwicGdiaVwiOiBcInBhZ2UtYnJlYWstaW5zaWRlOnw7XCIsXG5cdFx0XHRcInBnYmk6YXVcIjogXCJwYWdlLWJyZWFrLWluc2lkZTphdXRvO1wiLFxuXHRcdFx0XCJwZ2JpOmF2XCI6IFwicGFnZS1icmVhay1pbnNpZGU6YXZvaWQ7XCIsXG5cdFx0XHRcInBnYmFcIjogXCJwYWdlLWJyZWFrLWFmdGVyOnw7XCIsXG5cdFx0XHRcInBnYmE6YXVcIjogXCJwYWdlLWJyZWFrLWFmdGVyOmF1dG87XCIsXG5cdFx0XHRcInBnYmE6YWxcIjogXCJwYWdlLWJyZWFrLWFmdGVyOmFsd2F5cztcIixcblx0XHRcdFwicGdiYTpsXCI6IFwicGFnZS1icmVhay1hZnRlcjpsZWZ0O1wiLFxuXHRcdFx0XCJwZ2JhOnJcIjogXCJwYWdlLWJyZWFrLWFmdGVyOnJpZ2h0O1wiLFxuXHRcdFx0XCJvcnBcIjogXCJvcnBoYW5zOnw7XCIsXG5cdFx0XHRcInVzXCI6IFwidXNlci1zZWxlY3Q6JHtub25lfTtcIixcblx0XHRcdFwid2lkXCI6IFwid2lkb3dzOnw7XCIsXG5cdFx0XHRcIndmc21cIjogXCItd2Via2l0LWZvbnQtc21vb3RoaW5nOiR7YW50aWFsaWFzZWR9O1wiLFxuXHRcdFx0XCJ3ZnNtOmFcIjogXCItd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkO1wiLFxuXHRcdFx0XCJ3ZnNtOnNcIjogXCItd2Via2l0LWZvbnQtc21vb3RoaW5nOnN1YnBpeGVsLWFudGlhbGlhc2VkO1wiLFxuXHRcdFx0XCJ3ZnNtOnNhXCI6IFwiLXdlYmtpdC1mb250LXNtb290aGluZzpzdWJwaXhlbC1hbnRpYWxpYXNlZDtcIixcblx0XHRcdFwid2ZzbTpuXCI6IFwiLXdlYmtpdC1mb250LXNtb290aGluZzpub25lO1wiXG5cdFx0fVxuXHR9LFxuXHRcblx0XCJodG1sXCI6IHtcblx0XHRcImZpbHRlcnNcIjogXCJodG1sXCIsXG5cdFx0XCJwcm9maWxlXCI6IFwiaHRtbFwiLFxuXHRcdFwic25pcHBldHNcIjoge1xuXHRcdFx0XCIhISFcIjogICAgXCI8IURPQ1RZUEUgaHRtbD5cIixcblx0XHRcdFwiISEhNHRcIjogIFwiPCFET0NUWVBFIEhUTUwgUFVCTElDIFxcXCItLy9XM0MvL0RURCBIVE1MIDQuMDEgVHJhbnNpdGlvbmFsLy9FTlxcXCIgXFxcImh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw0L2xvb3NlLmR0ZFxcXCI+XCIsXG5cdFx0XHRcIiEhITRzXCI6ICBcIjwhRE9DVFlQRSBIVE1MIFBVQkxJQyBcXFwiLS8vVzNDLy9EVEQgSFRNTCA0LjAxLy9FTlxcXCIgXFxcImh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw0L3N0cmljdC5kdGRcXFwiPlwiLFxuXHRcdFx0XCIhISF4dFwiOiAgXCI8IURPQ1RZUEUgaHRtbCBQVUJMSUMgXFxcIi0vL1czQy8vRFREIFhIVE1MIDEuMCBUcmFuc2l0aW9uYWwvL0VOXFxcIiBcXFwiaHR0cDovL3d3dy53My5vcmcvVFIveGh0bWwxL0RURC94aHRtbDEtdHJhbnNpdGlvbmFsLmR0ZFxcXCI+XCIsXG5cdFx0XHRcIiEhIXhzXCI6ICBcIjwhRE9DVFlQRSBodG1sIFBVQkxJQyBcXFwiLS8vVzNDLy9EVEQgWEhUTUwgMS4wIFN0cmljdC8vRU5cXFwiIFxcXCJodHRwOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvRFREL3hodG1sMS1zdHJpY3QuZHRkXFxcIj5cIixcblx0XHRcdFwiISEheHhzXCI6IFwiPCFET0NUWVBFIGh0bWwgUFVCTElDIFxcXCItLy9XM0MvL0RURCBYSFRNTCAxLjEvL0VOXFxcIiBcXFwiaHR0cDovL3d3dy53My5vcmcvVFIveGh0bWwxMS9EVEQveGh0bWwxMS5kdGRcXFwiPlwiLFxuXG5cdFx0XHRcImNcIjogXCI8IS0tIHwke2NoaWxkfSAtLT5cIixcblx0XHRcdFwiY2M6aWU2XCI6IFwiPCEtLVtpZiBsdGUgSUUgNl0+XFxuXFx0JHtjaGlsZH18XFxuPCFbZW5kaWZdLS0+XCIsXG5cdFx0XHRcImNjOmllXCI6IFwiPCEtLVtpZiBJRV0+XFxuXFx0JHtjaGlsZH18XFxuPCFbZW5kaWZdLS0+XCIsXG5cdFx0XHRcImNjOm5vaWVcIjogXCI8IS0tW2lmICFJRV0+PCEtLT5cXG5cXHQke2NoaWxkfXxcXG48IS0tPCFbZW5kaWZdLS0+XCJcblx0XHR9LFxuXHRcdFxuXHRcdFwiYWJicmV2aWF0aW9uc1wiOiB7XG5cdFx0XHRcIiFcIjogXCJodG1sOjVcIixcblx0XHRcdFwiYVwiOiBcIjxhIGhyZWY9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImE6bGlua1wiOiBcIjxhIGhyZWY9XFxcImh0dHA6Ly98XFxcIj5cIixcblx0XHRcdFwiYTptYWlsXCI6IFwiPGEgaHJlZj1cXFwibWFpbHRvOnxcXFwiPlwiLFxuXHRcdFx0XCJhYmJyXCI6IFwiPGFiYnIgdGl0bGU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImFjcnxhY3JvbnltXCI6IFwiPGFjcm9ueW0gdGl0bGU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImJhc2VcIjogXCI8YmFzZSBocmVmPVxcXCJcXFwiIC8+XCIsXG5cdFx0XHRcImJhc2Vmb250XCI6IFwiPGJhc2Vmb250Lz5cIixcblx0XHRcdFwiYnJcIjogXCI8YnIvPlwiLFxuXHRcdFx0XCJmcmFtZVwiOiBcIjxmcmFtZS8+XCIsXG5cdFx0XHRcImhyXCI6IFwiPGhyLz5cIixcblx0XHRcdFwiYmRvXCI6IFwiPGJkbyBkaXI9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImJkbzpyXCI6IFwiPGJkbyBkaXI9XFxcInJ0bFxcXCI+XCIsXG5cdFx0XHRcImJkbzpsXCI6IFwiPGJkbyBkaXI9XFxcImx0clxcXCI+XCIsXG5cdFx0XHRcImNvbFwiOiBcIjxjb2wvPlwiLFxuXHRcdFx0XCJsaW5rXCI6IFwiPGxpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCJcXFwiIC8+XCIsXG5cdFx0XHRcImxpbms6Y3NzXCI6IFwiPGxpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCIkezE6c3R5bGV9LmNzc1xcXCIgLz5cIixcblx0XHRcdFwibGluazpwcmludFwiOiBcIjxsaW5rIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaHJlZj1cXFwiJHsxOnByaW50fS5jc3NcXFwiIG1lZGlhPVxcXCJwcmludFxcXCIgLz5cIixcblx0XHRcdFwibGluazpmYXZpY29uXCI6IFwiPGxpbmsgcmVsPVxcXCJzaG9ydGN1dCBpY29uXFxcIiB0eXBlPVxcXCJpbWFnZS94LWljb25cXFwiIGhyZWY9XFxcIiR7MTpmYXZpY29uLmljb31cXFwiIC8+XCIsXG5cdFx0XHRcImxpbms6dG91Y2hcIjogXCI8bGluayByZWw9XFxcImFwcGxlLXRvdWNoLWljb25cXFwiIGhyZWY9XFxcIiR7MTpmYXZpY29uLnBuZ31cXFwiIC8+XCIsXG5cdFx0XHRcImxpbms6cnNzXCI6IFwiPGxpbmsgcmVsPVxcXCJhbHRlcm5hdGVcXFwiIHR5cGU9XFxcImFwcGxpY2F0aW9uL3Jzcyt4bWxcXFwiIHRpdGxlPVxcXCJSU1NcXFwiIGhyZWY9XFxcIiR7MTpyc3MueG1sfVxcXCIgLz5cIixcblx0XHRcdFwibGluazphdG9tXCI6IFwiPGxpbmsgcmVsPVxcXCJhbHRlcm5hdGVcXFwiIHR5cGU9XFxcImFwcGxpY2F0aW9uL2F0b20reG1sXFxcIiB0aXRsZT1cXFwiQXRvbVxcXCIgaHJlZj1cXFwiJHsxOmF0b20ueG1sfVxcXCIgLz5cIixcblx0XHRcdFwibGluazppbXxsaW5rOmltcG9ydFwiOiBcIjxsaW5rIHJlbD1cXFwiaW1wb3J0XFxcIiBocmVmPVxcXCIkezE6Y29tcG9uZW50fS5odG1sXFxcIiAvPlwiLFxuXHRcdFx0XCJtZXRhXCI6IFwiPG1ldGEvPlwiLFxuXHRcdFx0XCJtZXRhOnV0ZlwiOiBcIjxtZXRhIGh0dHAtZXF1aXY9XFxcIkNvbnRlbnQtVHlwZVxcXCIgY29udGVudD1cXFwidGV4dC9odG1sO2NoYXJzZXQ9VVRGLThcXFwiIC8+XCIsXG5cdFx0XHRcIm1ldGE6d2luXCI6IFwiPG1ldGEgaHR0cC1lcXVpdj1cXFwiQ29udGVudC1UeXBlXFxcIiBjb250ZW50PVxcXCJ0ZXh0L2h0bWw7Y2hhcnNldD13aW5kb3dzLTEyNTFcXFwiIC8+XCIsXG5cdFx0XHRcIm1ldGE6ZWRnZVwiOiBcIjxtZXRhIGh0dHAtZXF1aXY9XFxcIlgtVUEtQ29tcGF0aWJsZVxcXCIgY29udGVudD1cXFwiJHsxOmllPWVkZ2V9XFxcIiAvPlwiLFxuXHRcdFx0XCJtZXRhOnZwXCI6IFwiPG1ldGEgbmFtZT1cXFwidmlld3BvcnRcXFwiIGNvbnRlbnQ9XFxcIndpZHRoPSR7MTpkZXZpY2Utd2lkdGh9LCBpbml0aWFsLXNjYWxlPSR7MzoxLjB9XFxcIiAvPlwiLFxuXHRcdFx0XCJtZXRhOmNvbXBhdFwiOiBcIjxtZXRhIGh0dHAtZXF1aXY9XFxcIlgtVUEtQ29tcGF0aWJsZVxcXCIgY29udGVudD1cXFwiJHsxOklFPTd9XFxcIiAvPlwiLFxuXHRcdFx0XCJtZXRhOnJlZGlyZWN0XCI6IFwiPG1ldGEgaHR0cC1lcXVpdj1cXFwicmVmcmVzaFxcXCIgY29udGVudD1cXFwiMDsgdXJsPSR7MTpodHRwOi8vZXhhbXBsZS5jb219XFxcIiAvPlwiLFxuXHRcdFx0XCJzdHlsZVwiOiBcIjxzdHlsZT5cIixcblx0XHRcdFwic2NyaXB0XCI6IFwiPHNjcmlwdCAhc3JjPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJzY3JpcHQ6c3JjXCI6IFwiPHNjcmlwdCBzcmM9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImltZ1wiOiBcIjxpbWcgc3JjPVxcXCJcXFwiIGFsdD1cXFwiXFxcIiAvPlwiLFxuXHRcdFx0XCJpbWc6c3xpbWc6c3Jjc2V0XCI6IFwiPGltZyBzcmNzZXQ9XFxcIlxcXCIgc3JjPVxcXCJcXFwiIGFsdD1cXFwiXFxcIiAvPlwiLFxuXHRcdFx0XCJpbWc6enxpbWc6c2l6ZXNcIjogXCI8aW1nIHNpemVzPVxcXCJcXFwiIHNyY3NldD1cXFwiXFxcIiBzcmM9XFxcIlxcXCIgYWx0PVxcXCJcXFwiIC8+XCIsXG5cdFx0XHRcInBpY3R1cmVcIjogXCI8cGljdHVyZT5cIixcblx0XHRcdFwic3JjfHNvdXJjZVwiOiBcIjxzb3VyY2UvPlwiLFxuXHRcdFx0XCJzcmM6c2N8c291cmNlOnNyY1wiOiBcIjxzb3VyY2Ugc3JjPVxcXCJcXFwiIHR5cGU9XFxcIlxcXCIvPlwiLFxuXHRcdFx0XCJzcmM6c3xzb3VyY2U6c3Jjc2V0XCI6IFwiPHNvdXJjZSBzcmNzZXQ9XFxcIlxcXCIvPlwiLFxuXHRcdFx0XCJzcmM6bXxzb3VyY2U6bWVkaWFcIjogXCI8c291cmNlIG1lZGlhPVxcXCIoJHsxOm1pbi13aWR0aDogfSlcXFwiIHNyY3NldD1cXFwiXFxcIi8+XCIsXG5cdFx0XHRcInNyYzp0fHNvdXJjZTp0eXBlXCI6IFwiPHNvdXJjZSBzcmNzZXQ9XFxcInxcXFwiIHR5cGU9XFxcIiR7MTppbWFnZS99XFxcIi8+XCIsXG5cdFx0XHRcInNyYzp6fHNvdXJjZTpzaXplc1wiOiBcIjxzb3VyY2Ugc2l6ZXM9XFxcIlxcXCIgc3Jjc2V0PVxcXCJcXFwiLz5cIixcblx0XHRcdFwic3JjOm10fHNvdXJjZTptZWRpYTp0eXBlXCI6IFwiPHNvdXJjZSBtZWRpYT1cXFwiKCR7MTptaW4td2lkdGg6IH0pXFxcIiBzcmNzZXQ9XFxcIlxcXCIgdHlwZT1cXFwiJHsyOmltYWdlL31cXFwiLz5cIixcblx0XHRcdFwic3JjOm16fHNvdXJjZTptZWRpYTpzaXplc1wiOiBcIjxzb3VyY2UgbWVkaWE9XFxcIigkezE6bWluLXdpZHRoOiB9KVxcXCIgc2l6ZXM9XFxcIlxcXCIgc3Jjc2V0PVxcXCJcXFwiLz5cIixcblx0XHRcdFwic3JjOnp0fHNvdXJjZTpzaXplczp0eXBlXCI6IFwiPHNvdXJjZSBzaXplcz1cXFwiXFxcIiBzcmNzZXQ9XFxcIlxcXCIgdHlwZT1cXFwiJHsxOmltYWdlL31cXFwiLz5cIixcblx0XHRcdFwiaWZyYW1lXCI6IFwiPGlmcmFtZSBzcmM9XFxcIlxcXCIgZnJhbWVib3JkZXI9XFxcIjBcXFwiPlwiLFxuXHRcdFx0XCJlbWJlZFwiOiBcIjxlbWJlZCBzcmM9XFxcIlxcXCIgdHlwZT1cXFwiXFxcIiAvPlwiLFxuXHRcdFx0XCJvYmplY3RcIjogXCI8b2JqZWN0IGRhdGE9XFxcIlxcXCIgdHlwZT1cXFwiXFxcIj5cIixcblx0XHRcdFwicGFyYW1cIjogXCI8cGFyYW0gbmFtZT1cXFwiXFxcIiB2YWx1ZT1cXFwiXFxcIiAvPlwiLFxuXHRcdFx0XCJtYXBcIjogXCI8bWFwIG5hbWU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImFyZWFcIjogXCI8YXJlYSBzaGFwZT1cXFwiXFxcIiBjb29yZHM9XFxcIlxcXCIgaHJlZj1cXFwiXFxcIiBhbHQ9XFxcIlxcXCIgLz5cIixcblx0XHRcdFwiYXJlYTpkXCI6IFwiPGFyZWEgc2hhcGU9XFxcImRlZmF1bHRcXFwiIGhyZWY9XFxcIlxcXCIgYWx0PVxcXCJcXFwiIC8+XCIsXG5cdFx0XHRcImFyZWE6Y1wiOiBcIjxhcmVhIHNoYXBlPVxcXCJjaXJjbGVcXFwiIGNvb3Jkcz1cXFwiXFxcIiBocmVmPVxcXCJcXFwiIGFsdD1cXFwiXFxcIiAvPlwiLFxuXHRcdFx0XCJhcmVhOnJcIjogXCI8YXJlYSBzaGFwZT1cXFwicmVjdFxcXCIgY29vcmRzPVxcXCJcXFwiIGhyZWY9XFxcIlxcXCIgYWx0PVxcXCJcXFwiIC8+XCIsXG5cdFx0XHRcImFyZWE6cFwiOiBcIjxhcmVhIHNoYXBlPVxcXCJwb2x5XFxcIiBjb29yZHM9XFxcIlxcXCIgaHJlZj1cXFwiXFxcIiBhbHQ9XFxcIlxcXCIgLz5cIixcblx0XHRcdFwiZm9ybVwiOiBcIjxmb3JtIGFjdGlvbj1cXFwiXFxcIj5cIixcblx0XHRcdFwiZm9ybTpnZXRcIjogXCI8Zm9ybSBhY3Rpb249XFxcIlxcXCIgbWV0aG9kPVxcXCJnZXRcXFwiPlwiLFxuXHRcdFx0XCJmb3JtOnBvc3RcIjogXCI8Zm9ybSBhY3Rpb249XFxcIlxcXCIgbWV0aG9kPVxcXCJwb3N0XFxcIj5cIixcblx0XHRcdFwibGFiZWxcIjogXCI8bGFiZWwgZm9yPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJpbnB1dFwiOiBcIjxpbnB1dCB0eXBlPVxcXCIkezE6dGV4dH1cXFwiIC8+XCIsXG5cdFx0XHRcImlucFwiOiBcIjxpbnB1dCB0eXBlPVxcXCIkezE6dGV4dH1cXFwiIG5hbWU9XFxcIlxcXCIgaWQ9XFxcIlxcXCIgLz5cIixcblx0XHRcdFwiaW5wdXQ6aHxpbnB1dDpoaWRkZW5cIjogXCJpbnB1dFt0eXBlPWhpZGRlbiBuYW1lXVwiLFxuXHRcdFx0XCJpbnB1dDp0fGlucHV0OnRleHRcIjogXCJpbnBcIixcblx0XHRcdFwiaW5wdXQ6c2VhcmNoXCI6IFwiaW5wW3R5cGU9c2VhcmNoXVwiLFxuXHRcdFx0XCJpbnB1dDplbWFpbFwiOiBcImlucFt0eXBlPWVtYWlsXVwiLFxuXHRcdFx0XCJpbnB1dDp1cmxcIjogXCJpbnBbdHlwZT11cmxdXCIsXG5cdFx0XHRcImlucHV0OnB8aW5wdXQ6cGFzc3dvcmRcIjogXCJpbnBbdHlwZT1wYXNzd29yZF1cIixcblx0XHRcdFwiaW5wdXQ6ZGF0ZXRpbWVcIjogXCJpbnBbdHlwZT1kYXRldGltZV1cIixcblx0XHRcdFwiaW5wdXQ6ZGF0ZVwiOiBcImlucFt0eXBlPWRhdGVdXCIsXG5cdFx0XHRcImlucHV0OmRhdGV0aW1lLWxvY2FsXCI6IFwiaW5wW3R5cGU9ZGF0ZXRpbWUtbG9jYWxdXCIsXG5cdFx0XHRcImlucHV0Om1vbnRoXCI6IFwiaW5wW3R5cGU9bW9udGhdXCIsXG5cdFx0XHRcImlucHV0OndlZWtcIjogXCJpbnBbdHlwZT13ZWVrXVwiLFxuXHRcdFx0XCJpbnB1dDp0aW1lXCI6IFwiaW5wW3R5cGU9dGltZV1cIixcblx0XHRcdFwiaW5wdXQ6dGVsXCI6IFwiaW5wW3R5cGU9dGVsXVwiLFxuXHRcdFx0XCJpbnB1dDpudW1iZXJcIjogXCJpbnBbdHlwZT1udW1iZXJdXCIsXG5cdFx0XHRcImlucHV0OmNvbG9yXCI6IFwiaW5wW3R5cGU9Y29sb3JdXCIsXG5cdFx0XHRcImlucHV0OmN8aW5wdXQ6Y2hlY2tib3hcIjogXCJpbnBbdHlwZT1jaGVja2JveF1cIixcblx0XHRcdFwiaW5wdXQ6cnxpbnB1dDpyYWRpb1wiOiBcImlucFt0eXBlPXJhZGlvXVwiLFxuXHRcdFx0XCJpbnB1dDpyYW5nZVwiOiBcImlucFt0eXBlPXJhbmdlXVwiLFxuXHRcdFx0XCJpbnB1dDpmfGlucHV0OmZpbGVcIjogXCJpbnBbdHlwZT1maWxlXVwiLFxuXHRcdFx0XCJpbnB1dDpzfGlucHV0OnN1Ym1pdFwiOiBcIjxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiIHZhbHVlPVxcXCJcXFwiIC8+XCIsXG5cdFx0XHRcImlucHV0Oml8aW5wdXQ6aW1hZ2VcIjogXCI8aW5wdXQgdHlwZT1cXFwiaW1hZ2VcXFwiIHNyYz1cXFwiXFxcIiBhbHQ9XFxcIlxcXCIgLz5cIixcblx0XHRcdFwiaW5wdXQ6YnxpbnB1dDpidXR0b25cIjogXCI8aW5wdXQgdHlwZT1cXFwiYnV0dG9uXFxcIiB2YWx1ZT1cXFwiXFxcIiAvPlwiLFxuXHRcdFx0XCJpc2luZGV4XCI6IFwiPGlzaW5kZXgvPlwiLFxuXHRcdFx0XCJpbnB1dDpyZXNldFwiOiBcImlucHV0OmJ1dHRvblt0eXBlPXJlc2V0XVwiLFxuXHRcdFx0XCJzZWxlY3RcIjogXCI8c2VsZWN0IG5hbWU9XFxcIlxcXCIgaWQ9XFxcIlxcXCI+XCIsXG5cdFx0XHRcInNlbGVjdDpkfHNlbGVjdDpkaXNhYmxlZFwiOiBcInNlbGVjdFtkaXNhYmxlZC5dXCIsXG5cdFx0XHRcIm9wdHxvcHRpb25cIjogXCI8b3B0aW9uIHZhbHVlPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJ0ZXh0YXJlYVwiOiBcIjx0ZXh0YXJlYSBuYW1lPVxcXCJcXFwiIGlkPVxcXCJcXFwiIGNvbHM9XFxcIiR7MTozMH1cXFwiIHJvd3M9XFxcIiR7MjoxMH1cXFwiPlwiLFxuXHRcdFx0XCJtYXJxdWVlXCI6IFwiPG1hcnF1ZWUgYmVoYXZpb3I9XFxcIlxcXCIgZGlyZWN0aW9uPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJtZW51OmN8bWVudTpjb250ZXh0XCI6IFwibWVudVt0eXBlPWNvbnRleHRdPlwiLFxuXHRcdFx0XCJtZW51OnR8bWVudTp0b29sYmFyXCI6IFwibWVudVt0eXBlPXRvb2xiYXJdPlwiLFxuXHRcdFx0XCJ2aWRlb1wiOiBcIjx2aWRlbyBzcmM9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImF1ZGlvXCI6IFwiPGF1ZGlvIHNyYz1cXFwiXFxcIj5cIixcblx0XHRcdFwiaHRtbDp4bWxcIjogXCI8aHRtbCB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFxcXCI+XCIsXG5cdFx0XHRcImtleWdlblwiOiBcIjxrZXlnZW4vPlwiLFxuXHRcdFx0XCJjb21tYW5kXCI6IFwiPGNvbW1hbmQvPlwiLFxuXHRcdFx0XCJidG46c3xidXR0b246c3xidXR0b246c3VibWl0XCIgOiBcImJ1dHRvblt0eXBlPXN1Ym1pdF1cIixcblx0XHRcdFwiYnRuOnJ8YnV0dG9uOnJ8YnV0dG9uOnJlc2V0XCIgOiBcImJ1dHRvblt0eXBlPXJlc2V0XVwiLFxuXHRcdFx0XCJidG46ZHxidXR0b246ZHxidXR0b246ZGlzYWJsZWRcIiA6IFwiYnV0dG9uW2Rpc2FibGVkLl1cIixcblx0XHRcdFwiZnN0OmR8ZnNldDpkfGZpZWxkc2V0OmR8ZmllbGRzZXQ6ZGlzYWJsZWRcIiA6IFwiZmllbGRzZXRbZGlzYWJsZWQuXVwiLFxuXHRcdFx0XG5cdFx0XHRcImJxXCI6IFwiYmxvY2txdW90ZVwiLFxuXHRcdFx0XCJmaWdcIjogXCJmaWd1cmVcIixcblx0XHRcdFwiZmlnY1wiOiBcImZpZ2NhcHRpb25cIixcblx0XHRcdFwicGljXCI6IFwicGljdHVyZVwiLFxuXHRcdFx0XCJpZnJcIjogXCJpZnJhbWVcIixcblx0XHRcdFwiZW1iXCI6IFwiZW1iZWRcIixcblx0XHRcdFwib2JqXCI6IFwib2JqZWN0XCIsXG5cdFx0XHRcImNhcFwiOiBcImNhcHRpb25cIixcblx0XHRcdFwiY29sZ1wiOiBcImNvbGdyb3VwXCIsXG5cdFx0XHRcImZzdFwiOiBcImZpZWxkc2V0XCIsXG5cdFx0XHRcImJ0blwiOiBcImJ1dHRvblwiLFxuXHRcdFx0XCJvcHRnXCI6IFwib3B0Z3JvdXBcIixcblx0XHRcdFwidGFyZWFcIjogXCJ0ZXh0YXJlYVwiLFxuXHRcdFx0XCJsZWdcIjogXCJsZWdlbmRcIixcblx0XHRcdFwic2VjdFwiOiBcInNlY3Rpb25cIixcblx0XHRcdFwiYXJ0XCI6IFwiYXJ0aWNsZVwiLFxuXHRcdFx0XCJoZHJcIjogXCJoZWFkZXJcIixcblx0XHRcdFwiZnRyXCI6IFwiZm9vdGVyXCIsXG5cdFx0XHRcImFkclwiOiBcImFkZHJlc3NcIixcblx0XHRcdFwiZGxnXCI6IFwiZGlhbG9nXCIsXG5cdFx0XHRcInN0clwiOiBcInN0cm9uZ1wiLFxuXHRcdFx0XCJwcm9nXCI6IFwicHJvZ3Jlc3NcIixcblx0XHRcdFwibW5cIjogXCJtYWluXCIsXG5cdFx0XHRcInRlbVwiOiBcInRlbXBsYXRlXCIsXG5cdFx0XHRcImZzZXRcIjogXCJmaWVsZHNldFwiLFxuXHRcdFx0XCJkYXRhZ1wiOiBcImRhdGFncmlkXCIsXG5cdFx0XHRcImRhdGFsXCI6IFwiZGF0YWxpc3RcIixcblx0XHRcdFwia2dcIjogXCJrZXlnZW5cIixcblx0XHRcdFwib3V0XCI6IFwib3V0cHV0XCIsXG5cdFx0XHRcImRldFwiOiBcImRldGFpbHNcIixcblx0XHRcdFwiY21kXCI6IFwiY29tbWFuZFwiLFxuXG5cdFx0XHRcImRvY1wiOiBcImh0bWw+KGhlYWQ+bWV0YVtjaGFyc2V0PSR7Y2hhcnNldH1dK21ldGE6dnArbWV0YTplZGdlK3RpdGxleyR7MTpEb2N1bWVudH19KStib2R5XCIsXG5cdFx0XHRcImRvYzRcIjogXCJodG1sPihoZWFkPm1ldGFbaHR0cC1lcXVpdj1cXFwiQ29udGVudC1UeXBlXFxcIiBjb250ZW50PVxcXCJ0ZXh0L2h0bWw7Y2hhcnNldD0ke2NoYXJzZXR9XFxcIl0rdGl0bGV7JHsxOkRvY3VtZW50fX0pK2JvZHlcIixcblxuXHRcdFx0XCJyaTpkfHJpOmRwclwiOiBcImltZzpzXCIsXG5cdFx0XHRcInJpOnZ8cmk6dmlld3BvcnRcIjogXCJpbWc6elwiLFxuXHRcdFx0XCJyaTphfHJpOmFydFwiOiBcInBpYz5zcmM6bStpbWdcIixcblx0XHRcdFwicmk6dHxyaTp0eXBlXCI6IFwicGljPnNyYzp0K2ltZ1wiLFxuXG5cdFx0XHRcImh0bWw6NHRcIjogIFwiISEhNHQrZG9jNFtsYW5nPSR7bGFuZ31dXCIsXG5cdFx0XHRcImh0bWw6NHNcIjogIFwiISEhNHMrZG9jNFtsYW5nPSR7bGFuZ31dXCIsXG5cdFx0XHRcImh0bWw6eHRcIjogIFwiISEheHQrZG9jNFt4bWxucz1odHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIHhtbDpsYW5nPSR7bGFuZ31dXCIsXG5cdFx0XHRcImh0bWw6eHNcIjogIFwiISEheHMrZG9jNFt4bWxucz1odHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIHhtbDpsYW5nPSR7bGFuZ31dXCIsXG5cdFx0XHRcImh0bWw6eHhzXCI6IFwiISEheHhzK2RvYzRbeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCB4bWw6bGFuZz0ke2xhbmd9XVwiLFxuXHRcdFx0XCJodG1sOjVcIjogICBcIiEhIStkb2NbbGFuZz0ke2xhbmd9XVwiLFxuXHRcdFx0XG5cdFx0XHRcIm9sK1wiOiBcIm9sPmxpXCIsXG5cdFx0XHRcInVsK1wiOiBcInVsPmxpXCIsXG5cdFx0XHRcImRsK1wiOiBcImRsPmR0K2RkXCIsXG5cdFx0XHRcIm1hcCtcIjogXCJtYXA+YXJlYVwiLFxuXHRcdFx0XCJ0YWJsZStcIjogXCJ0YWJsZT50cj50ZFwiLFxuXHRcdFx0XCJjb2xncm91cCtcIjogXCJjb2xncm91cD5jb2xcIixcblx0XHRcdFwiY29sZytcIjogXCJjb2xncm91cD5jb2xcIixcblx0XHRcdFwidHIrXCI6IFwidHI+dGRcIixcblx0XHRcdFwic2VsZWN0K1wiOiBcInNlbGVjdD5vcHRpb25cIixcblx0XHRcdFwib3B0Z3JvdXArXCI6IFwib3B0Z3JvdXA+b3B0aW9uXCIsXG5cdFx0XHRcIm9wdGcrXCI6IFwib3B0Z3JvdXA+b3B0aW9uXCIsXG5cdFx0XHRcInBpYytcIjogXCJwaWN0dXJlPnNvdXJjZTpzcmNzZXQraW1nXCJcblx0XHR9XG5cdH0sXG5cdFxuXHRcInhtbFwiOiB7XG5cdFx0XCJleHRlbmRzXCI6IFwiaHRtbFwiLFxuXHRcdFwicHJvZmlsZVwiOiBcInhtbFwiLFxuXHRcdFwiZmlsdGVyc1wiOiBcImh0bWxcIlxuXHR9LFxuXHRcblx0XCJzdmdcIjoge1xuXHRcdFwiZmlsdGVyc1wiOiBcImh0bWxcIixcblx0XHRcInByb2ZpbGVcIjogXCJ4bWxcIixcblx0XHRcInNuaXBwZXRzXCI6IHtcblx0XHRcdFwiISEhXCI6IFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XCIsXG5cdFx0XHRcInN2Z2RvY1wiOiBcIjwhRE9DVFlQRSBzdmcgUFVCTElDIFxcXCItLy9XM0MvL0RURCBTVkcgMS4xLy9FTlxcXCIgXFxcImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZFxcXCI+XCJcblx0XHR9LFxuXHRcdFwiYWJicmV2aWF0aW9uc1wiOiB7XG5cdFx0XHRcIiFzdmdcIjogXCIhISErc3ZnZG9jK3N2Z1wiLFxuXHRcdFx0XCJzdmdcIjogXCI8c3ZnIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cIixcblx0XHRcdFwiYVwiOiBcIjxhIHhsaW5rOmhyZWY9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImFnXCI6IFwiYWx0R2xpcGhcIixcblx0XHRcdFwiYWdkXCI6IFwiYWx0R2xpcGhEZWZcIixcblx0XHRcdFwiYWdpXCI6IFwiYWx0R2xpcGhJdGVtXCIsXG5cdFx0XHRcImFuaW18YW5pbWF0ZVwiOiBcIjxhbmltYXRlIGF0dHJpYnV0ZVR5cGU9XFxcIlxcXCIgYXR0cmlidXRlTmFtZT1cXFwiXFxcIiBmcm9tPVxcXCJcXFwiIHRvPVxcXCJcXFwiIGR1cj1cXFwiXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCI+XCIsXG5cdFx0XHRcImFjXCI6IFwiPGFuaW1hdGVDb2xvcj5cIixcblx0XHRcdFwiYW1cIjogXCI8YW5pbWF0ZU1vdGlvbj5cIixcblx0XHRcdFwiYXRcIjogXCI8YW5pbWF0ZVRyYW5zZm9ybT5cIixcblx0XHRcdFwiY1wiOiBcImNpcmNsZVwiLFxuXHRcdFx0XCJjcFwiOiBcImNvbG9yUGF0aFwiLFxuXHRcdFx0XCJjLXBcIjogXCJjb2xvci1wcm9maWxlXCIsXG5cdFx0XHRcImN1clwiOiBcImN1cnNvclwiLFxuXHRcdFx0XCJkZlwiOiBcImRlZnNcIixcblx0XHRcdFwiZXxlbGxpcHNlXCI6IFwiPGVsbGlwc2UgIGN4PVxcXCJcXFwiIGN5PVxcXCJcXFwiIHJ4PVxcXCJcXFwiIHJ5PVxcXCJcXFwiLz5cIixcblx0XHRcdFwiZmZcIjogXCI8Zm9udC1mYWNlPlwiLFxuXHRcdFx0XCJmZmZcIjogXCI8Zm9udC1mYWNlLWZvcm1hdD5cIixcblx0XHRcdFwiZmZuXCI6IFwiPGZvbnQtZmFjZS1uYW1lPlwiLFxuXHRcdFx0XCJmZnNcIjogXCI8Zm9udC1mYWNlLXNyYz5cIixcblx0XHRcdFwiZmZ1XCI6IFwiPGZvbnQtZmFjZS11cmk+XCIsXG5cdFx0XHRcImZvXCI6IFwiPGZvcmVpZ25PYmplY3Q+XCIsXG5cdFx0XHRcImdcIjogXCI8Zz5cIixcblx0XHRcdFwiZ2xcIjogXCI8Z2x5cGg+XCIsXG5cdFx0XHRcImdsclwiOiBcIjxnbHlwaFJlZj5cIixcblx0XHRcdFwiaGtcIjogXCI8aGtlcm4+XCIsXG5cdFx0XHRcIml8aW1hZ2VcIjogXCI8aW1hZ2UgeGxpbms6aHJlZj1cXFwiXFxcIiB4PVxcXCJcXFwiIHk9XFxcIlxcXCIgd2lkdGg9XFxcIlxcXCIgaGVpZ2h0PVxcXCJcXFwiLz5cIixcblx0XHRcdFwibFwiOiBcIjxsaW5lPlwiLFxuXHRcdFx0XCJsZ1wiOiBcIjxsaW5lYXJHcmFkaWVudD5cIixcblx0XHRcdFwibWFya2VyXCI6IFwiPG1hcmtlcj5cIixcblx0XHRcdFwibWFza1wiOiBcIjxtYXNrPlwiLFxuXHRcdFx0XCJtZFwiOiBcIjxtZXRhZGF0YT5cIixcblx0XHRcdFwibWdcIjogXCI8bWlzc2luZy1nbHlwaD5cIixcblx0XHRcdFwibXBcIjogXCI8bXBhdGg+XCIsXG5cdFx0XHRcInBhdGhcIjogXCI8cGF0aCBkPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJwYXR0XCI6IFwiPHBhdHRlcm4+XCIsXG5cdFx0XHRcInBnXCI6IFwiPHBvbHlnb24gcG9pbnRzPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJwbFwiOiBcIjxwb2x5bGluZSBwb2ludHM9XFxcIlxcXCI+XCIsXG5cdFx0XHRcInJnXCI6IFwiPHJhZGlhbEdyYWRpZW50PlwiLFxuXHRcdFx0XCJyXCI6IFwiPHJlY3QgeD1cXFwiXFxcIiB5PVxcXCJcXFwiIHdpZHRoPVxcXCJcXFwiIGhlaWdodD1cXFwiXFxcIi8+XCIsXG5cdFx0XHRcInNjclwiOiBcIjxzY3JpcHQ+XCIsXG5cdFx0XHRcInNiXCI6IFwiPHN5bWJvbD5cIixcblx0XHRcdFwidHh0XCI6IFwiPHRleHQ+XCIsXG5cdFx0XHRcInRwXCI6IFwiPHRleHRQYXRoPlwiLFxuXHRcdFx0XCJ0c1wiOiBcIjx0c3Bhbj5cIixcblx0XHRcdFwidXx1c2VcIjogXCI8dXNlIHhsaW5rOmhyZWY9XFxcIlxcXCIvPlwiLFxuXHRcdFx0XCJ2XCI6IFwiPHZpZXc+XCIsXG5cdFx0XHRcInZrXCI6IFwiPHZrZXJuPlwiXG5cdFx0fVxuXHR9LFxuXHRcblx0XCJ4c2xcIjoge1xuXHRcdFwiZXh0ZW5kc1wiOiBcImh0bWxcIixcblx0XHRcInByb2ZpbGVcIjogXCJ4bWxcIixcblx0XHRcImZpbHRlcnNcIjogXCJodG1sLCB4c2xcIixcblx0XHRcImFiYnJldmlhdGlvbnNcIjoge1xuXHRcdFx0XCJ0bXx0bWF0Y2hcIjogXCI8eHNsOnRlbXBsYXRlIG1hdGNoPVxcXCJcXFwiIG1vZGU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcInRufHRuYW1lXCI6IFwiPHhzbDp0ZW1wbGF0ZSBuYW1lPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJjYWxsXCI6IFwiPHhzbDpjYWxsLXRlbXBsYXRlIG5hbWU9XFxcIlxcXCIvPlwiLFxuXHRcdFx0XCJhcFwiOiBcIjx4c2w6YXBwbHktdGVtcGxhdGVzIHNlbGVjdD1cXFwiXFxcIiBtb2RlPVxcXCJcXFwiLz5cIixcblx0XHRcdFwiYXBpXCI6IFwiPHhzbDphcHBseS1pbXBvcnRzLz5cIixcblx0XHRcdFwiaW1wXCI6IFwiPHhzbDppbXBvcnQgaHJlZj1cXFwiXFxcIi8+XCIsXG5cdFx0XHRcImluY1wiOiBcIjx4c2w6aW5jbHVkZSBocmVmPVxcXCJcXFwiLz5cIixcblxuXHRcdFx0XCJjaFwiOiBcIjx4c2w6Y2hvb3NlPlwiLFxuXHRcdFx0XCJ3aHx4c2w6d2hlblwiOiBcIjx4c2w6d2hlbiB0ZXN0PVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJvdFwiOiBcIjx4c2w6b3RoZXJ3aXNlPlwiLFxuXHRcdFx0XCJpZlwiOiBcIjx4c2w6aWYgdGVzdD1cXFwiXFxcIj5cIixcblxuXHRcdFx0XCJwYXJcIjogXCI8eHNsOnBhcmFtIG5hbWU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcInBhcmVcIjogXCI8eHNsOnBhcmFtIG5hbWU9XFxcIlxcXCIgc2VsZWN0PVxcXCJcXFwiLz5cIixcblx0XHRcdFwidmFyXCI6IFwiPHhzbDp2YXJpYWJsZSBuYW1lPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJ2YXJlXCI6IFwiPHhzbDp2YXJpYWJsZSBuYW1lPVxcXCJcXFwiIHNlbGVjdD1cXFwiXFxcIi8+XCIsXG5cdFx0XHRcIndwXCI6IFwiPHhzbDp3aXRoLXBhcmFtIG5hbWU9XFxcIlxcXCIgc2VsZWN0PVxcXCJcXFwiLz5cIixcblx0XHRcdFwia2V5XCI6IFwiPHhzbDprZXkgbmFtZT1cXFwiXFxcIiBtYXRjaD1cXFwiXFxcIiB1c2U9XFxcIlxcXCIvPlwiLFxuXG5cdFx0XHRcImVsZW1cIjogXCI8eHNsOmVsZW1lbnQgbmFtZT1cXFwiXFxcIj5cIixcblx0XHRcdFwiYXR0clwiOiBcIjx4c2w6YXR0cmlidXRlIG5hbWU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImF0dHJzXCI6IFwiPHhzbDphdHRyaWJ1dGUtc2V0IG5hbWU9XFxcIlxcXCI+XCIsXG5cblx0XHRcdFwiY3BcIjogXCI8eHNsOmNvcHkgc2VsZWN0PVxcXCJcXFwiLz5cIixcblx0XHRcdFwiY29cIjogXCI8eHNsOmNvcHktb2Ygc2VsZWN0PVxcXCJcXFwiLz5cIixcblx0XHRcdFwidmFsXCI6IFwiPHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XFxcIlxcXCIvPlwiLFxuXHRcdFx0XCJmb3J8ZWFjaFwiOiBcIjx4c2w6Zm9yLWVhY2ggc2VsZWN0PVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJ0ZXhcIjogXCI8eHNsOnRleHQ+PC94c2w6dGV4dD5cIixcblxuXHRcdFx0XCJjb21cIjogXCI8eHNsOmNvbW1lbnQ+XCIsXG5cdFx0XHRcIm1zZ1wiOiBcIjx4c2w6bWVzc2FnZSB0ZXJtaW5hdGU9XFxcIm5vXFxcIj5cIixcblx0XHRcdFwiZmFsbFwiOiBcIjx4c2w6ZmFsbGJhY2s+XCIsXG5cdFx0XHRcIm51bVwiOiBcIjx4c2w6bnVtYmVyIHZhbHVlPVxcXCJcXFwiLz5cIixcblx0XHRcdFwibmFtXCI6IFwiPG5hbWVzcGFjZS1hbGlhcyBzdHlsZXNoZWV0LXByZWZpeD1cXFwiXFxcIiByZXN1bHQtcHJlZml4PVxcXCJcXFwiLz5cIixcblx0XHRcdFwicHJlc1wiOiBcIjx4c2w6cHJlc2VydmUtc3BhY2UgZWxlbWVudHM9XFxcIlxcXCIvPlwiLFxuXHRcdFx0XCJzdHJpcFwiOiBcIjx4c2w6c3RyaXAtc3BhY2UgZWxlbWVudHM9XFxcIlxcXCIvPlwiLFxuXHRcdFx0XCJwcm9jXCI6IFwiPHhzbDpwcm9jZXNzaW5nLWluc3RydWN0aW9uIG5hbWU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcInNvcnRcIjogXCI8eHNsOnNvcnQgc2VsZWN0PVxcXCJcXFwiIG9yZGVyPVxcXCJcXFwiLz5cIixcblxuXHRcdFx0XCJjaG9vc2UrXCI6IFwieHNsOmNob29zZT54c2w6d2hlbit4c2w6b3RoZXJ3aXNlXCIsXG5cdFx0XHRcInhzbFwiOiBcIiEhISt4c2w6c3R5bGVzaGVldFt2ZXJzaW9uPTEuMCB4bWxuczp4c2w9aHR0cDovL3d3dy53My5vcmcvMTk5OS9YU0wvVHJhbnNmb3JtXT57XFxufH1cIlxuXHRcdH0sIFxuXHRcdFwic25pcHBldHNcIjoge1xuXHRcdFx0XCIhISFcIjogXCI8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCJVVEYtOFxcXCI/PlwiXG5cdFx0fVxuXHR9LFxuXHRcblx0XCJoYW1sXCI6IHtcblx0XHRcImZpbHRlcnNcIjogXCJoYW1sXCIsXG5cdFx0XCJleHRlbmRzXCI6IFwiaHRtbFwiLFxuXHRcdFwicHJvZmlsZVwiOiBcInhtbFwiXG5cdH0sXG5cblx0XCJqYWRlXCI6IHtcblx0XHRcImZpbHRlcnNcIjogXCJqYWRlXCIsXG5cdFx0XCJleHRlbmRzXCI6IFwiaHRtbFwiLFxuXHRcdFwicHJvZmlsZVwiOiBcInhtbFwiXG5cdH0sXG5cblx0XCJqc3hcIjoge1xuXHRcdFwiZmlsdGVyc1wiOiBcImpzeCwgaHRtbFwiLFxuXHRcdFwiZXh0ZW5kc1wiOiBcImh0bWxcIixcblx0XHRcInByb2ZpbGVcIjogXCJ4bWxcIlxuXHR9LFxuXG5cdFwic2xpbVwiOiB7XG5cdFx0XCJmaWx0ZXJzXCI6IFwic2xpbVwiLFxuXHRcdFwiZXh0ZW5kc1wiOiBcImh0bWxcIixcblx0XHRcInByb2ZpbGVcIjogXCJ4bWxcIlxuXHR9LFxuXHRcblx0XCJzY3NzXCI6IHtcblx0XHRcImV4dGVuZHNcIjogXCJjc3NcIlxuXHR9LFxuXHRcblx0XCJzYXNzXCI6IHtcblx0XHRcImV4dGVuZHNcIjogXCJjc3NcIlxuXHR9LFxuXHRcblx0XCJsZXNzXCI6IHtcblx0XHRcImV4dGVuZHNcIjogXCJjc3NcIlxuXHR9LFxuXHRcblx0XCJzdHlsdXNcIjoge1xuXHRcdFwiZXh0ZW5kc1wiOiBcImNzc1wiXG5cdH0sXG5cblx0XCJzdHlsXCI6IHtcblx0XHRcImV4dGVuZHNcIjogXCJzdHlsdXNcIlxuXHR9XG59XG5cbn0se31dLFwidXRpbHNcXFxcYWJicmV2aWF0aW9uLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggPGNvZGU+QWJicmV2aWF0aW9uTm9kZTwvY29kZT4gYXMgSFRNTCBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIGVsZW1lbnRzID0gcmVxdWlyZSgnLi4vYXNzZXRzL2VsZW1lbnRzJyk7XG5cdHZhciB0YWJTdG9wcyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy90YWJTdG9wcycpO1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblx0dmFyIHRhZ05hbWUgPSByZXF1aXJlKCcuLi9yZXNvbHZlci90YWdOYW1lJyk7XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBUZXN0IGlmIHBhc3NlZCBub2RlIGlzIHVuYXJ5IChubyBjbG9zaW5nIHRhZylcblx0XHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzVW5hcnk6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCB8fCBub2RlLl90ZXh0IHx8IHRoaXMuaXNTbmlwcGV0KG5vZGUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIHIgPSBub2RlLmRhdGEoJ3Jlc291cmNlJyk7XG5cdFx0XHRyZXR1cm4gciAmJiByLmlzX2VtcHR5O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGVzdCBpZiBwYXNzZWQgbm9kZSBpcyBpbmxpbmUtbGV2ZWwgKGxpa2UgJmx0O3N0cm9uZyZndDssICZsdDtpbWcmZ3Q7KVxuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNJbmxpbmU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBub2RlLmlzVGV4dE5vZGUoKSBcblx0XHRcdFx0fHwgIW5vZGUubmFtZSgpIFxuXHRcdFx0XHR8fCB0YWdOYW1lLmlzSW5saW5lTGV2ZWwobm9kZS5uYW1lKCkpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGVzdCBpZiBwYXNzZWQgbm9kZSBpcyBibG9jay1sZXZlbFxuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNCbG9jazogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNTbmlwcGV0KG5vZGUpIHx8ICF0aGlzLmlzSW5saW5lKG5vZGUpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGVzdCBpZiBnaXZlbiBub2RlIGlzIGEgc25pcHBldFxuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNTbmlwcGV0OiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMuaXMobm9kZS5kYXRhKCdyZXNvdXJjZScpLCAnc25pcHBldCcpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiB0ZXN0cyBpZiBwYXNzZWQgbm9kZSBjb250ZW50IGNvbnRhaW5zIEhUTUwgdGFncy4gXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBpcyBtb3N0bHkgdXNlZCBmb3Igb3V0cHV0IGZvcm1hdHRpbmdcblx0XHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRoYXNUYWdzSW5Db250ZW50OiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gdXRpbHMubWF0Y2hlc1RhZyhub2RlLmNvbnRlbnQpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGVzdCBpZiBjdXJyZW50IGVsZW1lbnQgY29udGFpbnMgYmxvY2stbGV2ZWwgY2hpbGRyZW5cblx0XHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGhhc0Jsb2NrQ2hpbGRyZW46IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiAodGhpcy5oYXNUYWdzSW5Db250ZW50KG5vZGUpICYmIHRoaXMuaXNCbG9jayhub2RlKSkgXG5cdFx0XHRcdHx8IG5vZGUuY2hpbGRyZW4uc29tZShmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmlzQmxvY2soY2hpbGQpO1xuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCBpbnNlcnRzIGNvbnRlbnQgaW5zdGVhZCBvZiA8Y29kZT4ke2NoaWxkfTwvY29kZT5cblx0XHQgKiB2YXJpYWJsZXMgb24gPGNvZGU+dGV4dDwvY29kZT5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHdoZXJlIGNoaWxkIGNvbnRlbnQgc2hvdWxkIGJlIGluc2VydGVkXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNoaWxkQ29udGVudCBDb250ZW50IHRvIGluc2VydFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdFx0ICogQHJldHVybnMge1N0cmluZ1xuXHRcdCAqL1xuXHRcdGluc2VydENoaWxkQ29udGVudDogZnVuY3Rpb24odGV4dCwgY2hpbGRDb250ZW50LCBvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gdXRpbHMuZXh0ZW5kKHtcblx0XHRcdFx0a2VlcFZhcmlhYmxlOiB0cnVlLFxuXHRcdFx0XHRhcHBlbmRJZk5vQ2hpbGQ6IHRydWVcblx0XHRcdH0sIG9wdGlvbnMgfHwge30pO1xuXHRcdFx0XG5cdFx0XHR2YXIgY2hpbGRWYXJpYWJsZVJlcGxhY2VkID0gZmFsc2U7XG5cdFx0XHR0ZXh0ID0gdGFiU3RvcHMucmVwbGFjZVZhcmlhYmxlcyh0ZXh0LCBmdW5jdGlvbih2YXJpYWJsZSwgbmFtZSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgb3V0cHV0ID0gdmFyaWFibGU7XG5cdFx0XHRcdGlmIChuYW1lID09ICdjaGlsZCcpIHtcblx0XHRcdFx0XHQvLyBhZGQgY29ycmVjdCBpbmRlbnRhdGlvblxuXHRcdFx0XHRcdG91dHB1dCA9IHV0aWxzLnBhZFN0cmluZyhjaGlsZENvbnRlbnQsIHV0aWxzLmdldExpbmVQYWRkaW5nRnJvbVBvc2l0aW9uKHRleHQsIGRhdGEuc3RhcnQpKTtcblx0XHRcdFx0XHRjaGlsZFZhcmlhYmxlUmVwbGFjZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGlmIChvcHRpb25zLmtlZXBWYXJpYWJsZSlcblx0XHRcdFx0XHRcdG91dHB1dCArPSB2YXJpYWJsZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoIWNoaWxkVmFyaWFibGVSZXBsYWNlZCAmJiBvcHRpb25zLmFwcGVuZElmTm9DaGlsZCkge1xuXHRcdFx0XHR0ZXh0ICs9IGNoaWxkQ29udGVudDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9O1xufSk7XG59LHtcIi4uL2Fzc2V0cy9lbGVtZW50c1wiOlwiYXNzZXRzXFxcXGVsZW1lbnRzLmpzXCIsXCIuLi9hc3NldHMvdGFiU3RvcHNcIjpcImFzc2V0c1xcXFx0YWJTdG9wcy5qc1wiLFwiLi4vcmVzb2x2ZXIvdGFnTmFtZVwiOlwicmVzb2x2ZXJcXFxcdGFnTmFtZS5qc1wiLFwiLi4vdXRpbHMvY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIn1dLFwidXRpbHNcXFxcYWN0aW9uLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZHMgZm9yIEVtbWV0IGFjdGlvbnNcbiAqIEBhdXRob3IgU2VyZ2V5IENoaWt1eW9ub2sgKHNlcmdlLmNoZUBnbWFpbC5jb20pIDxodHRwOi8vY2hpa3V5b25vay5ydT5cbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblx0dmFyIGNzc1NlY3Rpb25zID0gcmVxdWlyZSgnLi9jc3NTZWN0aW9ucycpO1xuXHR2YXIgYWJicmV2aWF0aW9uUGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2VyL2FiYnJldmlhdGlvbicpO1xuXHR2YXIgaHRtbE1hdGNoZXIgPSByZXF1aXJlKCcuLi9hc3NldHMvaHRtbE1hdGNoZXInKTtcblx0dmFyIHhtbEVkaXRUcmVlID0gcmVxdWlyZSgnLi4vZWRpdFRyZWUveG1sJyk7XG5cdHZhciByYW5nZSA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9yYW5nZScpO1xuXHR2YXIgcmVzb3VyY2VzID0gcmVxdWlyZSgnLi4vYXNzZXRzL3Jlc291cmNlcycpO1xuXG5cdHJldHVybiB7XG5cdFx0bWltZVR5cGVzOiB7XG5cdFx0XHQnZ2lmJyA6ICdpbWFnZS9naWYnLFxuXHRcdFx0J3BuZycgOiAnaW1hZ2UvcG5nJyxcblx0XHRcdCdqcGcnIDogJ2ltYWdlL2pwZWcnLFxuXHRcdFx0J2pwZWcnOiAnaW1hZ2UvanBlZycsXG5cdFx0XHQnc3ZnJyA6ICdpbWFnZS9zdmcreG1sJyxcblx0XHRcdCdodG1sJzogJ3RleHQvaHRtbCcsXG5cdFx0XHQnaHRtJyA6ICd0ZXh0L2h0bWwnXG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBFeHRyYWN0cyBhYmJyZXZpYXRpb25zIGZyb20gdGV4dCBzdHJlYW0sIHN0YXJ0aW5nIGZyb20gdGhlIGVuZFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IEFiYnJldmlhdGlvbiBvciBlbXB0eSBzdHJpbmdcblx0XHQgKiBAbWVtYmVyT2YgZW1tZXQuYWN0aW9uVXRpbHNcblx0XHQgKi9cblx0XHRleHRyYWN0QWJicmV2aWF0aW9uOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHZhciBjdXJPZmZzZXQgPSBzdHIubGVuZ3RoO1xuXHRcdFx0dmFyIHN0YXJ0SW5kZXggPSAtMTtcblx0XHRcdHZhciBncm91cENvdW50ID0gMDtcblx0XHRcdHZhciBicmFjZUNvdW50ID0gMDtcblx0XHRcdHZhciB0ZXh0Q291bnQgPSAwO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRjdXJPZmZzZXQtLTtcblx0XHRcdFx0aWYgKGN1ck9mZnNldCA8IDApIHtcblx0XHRcdFx0XHQvLyBtb3ZlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG5cdFx0XHRcdFx0c3RhcnRJbmRleCA9IDA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHZhciBjaCA9IHN0ci5jaGFyQXQoY3VyT2Zmc2V0KTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjaCA9PSAnXScpIHtcblx0XHRcdFx0XHRicmFjZUNvdW50Kys7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2ggPT0gJ1snKSB7XG5cdFx0XHRcdFx0aWYgKCFicmFjZUNvdW50KSB7IC8vIHVuZXhwZWN0ZWQgYnJhY2Vcblx0XHRcdFx0XHRcdHN0YXJ0SW5kZXggPSBjdXJPZmZzZXQgKyAxO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyYWNlQ291bnQtLTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSAnfScpIHtcblx0XHRcdFx0XHR0ZXh0Q291bnQrKztcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSAneycpIHtcblx0XHRcdFx0XHRpZiAoIXRleHRDb3VudCkgeyAvLyB1bmV4cGVjdGVkIGJyYWNlXG5cdFx0XHRcdFx0XHRzdGFydEluZGV4ID0gY3VyT2Zmc2V0ICsgMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZXh0Q291bnQtLTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSAnKScpIHtcblx0XHRcdFx0XHRncm91cENvdW50Kys7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2ggPT0gJygnKSB7XG5cdFx0XHRcdFx0aWYgKCFncm91cENvdW50KSB7IC8vIHVuZXhwZWN0ZWQgYnJhY2Vcblx0XHRcdFx0XHRcdHN0YXJ0SW5kZXggPSBjdXJPZmZzZXQgKyAxO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGdyb3VwQ291bnQtLTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoYnJhY2VDb3VudCB8fCB0ZXh0Q291bnQpIFxuXHRcdFx0XHRcdFx0Ly8gcmVzcGVjdCBhbGwgY2hhcmFjdGVycyBpbnNpZGUgYXR0cmlidXRlIHNldHMgb3IgdGV4dCBub2Rlc1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIWFiYnJldmlhdGlvblBhcnNlci5pc0FsbG93ZWRDaGFyKGNoKSB8fCAoY2ggPT0gJz4nICYmIHV0aWxzLmVuZHNXaXRoVGFnKHN0ci5zdWJzdHJpbmcoMCwgY3VyT2Zmc2V0ICsgMSkpKSkge1xuXHRcdFx0XHRcdFx0Ly8gZm91bmQgc3RvcCBzeW1ib2xcblx0XHRcdFx0XHRcdHN0YXJ0SW5kZXggPSBjdXJPZmZzZXQgKyAxO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChzdGFydEluZGV4ICE9IC0xICYmICF0ZXh0Q291bnQgJiYgIWJyYWNlQ291bnQgJiYgIWdyb3VwQ291bnQpIFxuXHRcdFx0XHQvLyBmb3VuZCBzb21ldGhpbmcsIHJlbW92ZSBzb21lIGludmFsaWQgc3ltYm9scyBmcm9tIHRoZSBcblx0XHRcdFx0Ly8gYmVnaW5uaW5nIGFuZCByZXR1cm4gYWJicmV2aWF0aW9uXG5cdFx0XHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpLnJlcGxhY2UoL15bXFwqXFwrXFw+XFxeXSsvLCAnJyk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJldHVybiAnJztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgaW1hZ2Ugc2l6ZSBmcm9tIGltYWdlIGJ5dGUgc3RyZWFtLlxuXHRcdCAqIEBhdXRob3IgaHR0cDovL3JvbWVkYS5vcmcvcmVQdWJsaXNoL1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJlYW0gSW1hZ2UgYnl0ZSBzdHJlYW0gKHVzZSA8Y29kZT5JRW1tZXRGaWxlLnJlYWQoKTwvY29kZT4pXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCA8Y29kZT53aWR0aDwvY29kZT4gYW5kIDxjb2RlPmhlaWdodDwvY29kZT4gcHJvcGVydGllc1xuXHRcdCAqL1xuXHRcdGdldEltYWdlU2l6ZTogZnVuY3Rpb24oc3RyZWFtKSB7XG5cdFx0XHR2YXIgcG5nTWFnaWNOdW0gPSBcIlxcMjExUE5HXFxyXFxuXFwwMzJcXG5cIixcblx0XHRcdFx0anBnTWFnaWNOdW0gPSBcIlxcMzc3XFwzMzBcIixcblx0XHRcdFx0Z2lmTWFnaWNOdW0gPSBcIkdJRjhcIixcblx0XHRcdFx0cG9zID0gMCxcblx0XHRcdFx0bmV4dEJ5dGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RyZWFtLmNoYXJDb2RlQXQocG9zKyspO1xuXHRcdFx0XHR9O1xuXHRcdFxuXHRcdFx0aWYgKHN0cmVhbS5zdWJzdHIoMCwgOCkgPT09IHBuZ01hZ2ljTnVtKSB7XG5cdFx0XHRcdC8vIFBORy4gRWFzeSBwZWFzeS5cblx0XHRcdFx0cG9zID0gc3RyZWFtLmluZGV4T2YoJ0lIRFInKSArIDQ7XG5cdFx0XHRcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR3aWR0aDogIChuZXh0Qnl0ZSgpIDw8IDI0KSB8IChuZXh0Qnl0ZSgpIDw8IDE2KSB8IChuZXh0Qnl0ZSgpIDw8ICA4KSB8IG5leHRCeXRlKCksXG5cdFx0XHRcdFx0aGVpZ2h0OiAobmV4dEJ5dGUoKSA8PCAyNCkgfCAobmV4dEJ5dGUoKSA8PCAxNikgfCAobmV4dEJ5dGUoKSA8PCAgOCkgfCBuZXh0Qnl0ZSgpXG5cdFx0XHRcdH07XG5cdFx0XHRcblx0XHRcdH0gZWxzZSBpZiAoc3RyZWFtLnN1YnN0cigwLCA0KSA9PT0gZ2lmTWFnaWNOdW0pIHtcblx0XHRcdFx0cG9zID0gNjtcblx0XHRcdFxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHdpZHRoOiAgbmV4dEJ5dGUoKSB8IChuZXh0Qnl0ZSgpIDw8IDgpLFxuXHRcdFx0XHRcdGhlaWdodDogbmV4dEJ5dGUoKSB8IChuZXh0Qnl0ZSgpIDw8IDgpXG5cdFx0XHRcdH07XG5cdFx0XHRcblx0XHRcdH0gZWxzZSBpZiAoc3RyZWFtLnN1YnN0cigwLCAyKSA9PT0ganBnTWFnaWNOdW0pIHtcblx0XHRcdFx0cG9zID0gMjtcblx0XHRcdFxuXHRcdFx0XHR2YXIgbCA9IHN0cmVhbS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChwb3MgPCBsKSB7XG5cdFx0XHRcdFx0aWYgKG5leHRCeXRlKCkgIT0gMHhGRikgcmV0dXJuO1xuXHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgbWFya2VyID0gbmV4dEJ5dGUoKTtcblx0XHRcdFx0XHRpZiAobWFya2VyID09IDB4REEpIGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgc2l6ZSA9IChuZXh0Qnl0ZSgpIDw8IDgpIHwgbmV4dEJ5dGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG1hcmtlciA+PSAweEMwICYmIG1hcmtlciA8PSAweENGICYmICEobWFya2VyICYgMHg0KSAmJiAhKG1hcmtlciAmIDB4OCkpIHtcblx0XHRcdFx0XHRcdHBvcyArPSAxO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiAobmV4dEJ5dGUoKSA8PCA4KSB8IG5leHRCeXRlKCksXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAobmV4dEJ5dGUoKSA8PCA4KSB8IG5leHRCeXRlKClcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb3MgKz0gc2l6ZSAtIDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBDYXB0dXJlcyBjb250ZXh0IFhIVE1MIGVsZW1lbnQgZnJvbSBlZGl0b3IgdW5kZXIgY3VycmVudCBjYXJldCBwb3NpdGlvbi5cblx0XHQgKiBUaGlzIG5vZGUgY2FuIGJlIHVzZWQgYXMgYSBoZWxwZXIgZm9yIGFiYnJldmlhdGlvbiBleHRyYWN0aW9uXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0Y2FwdHVyZUNvbnRleHQ6IGZ1bmN0aW9uKGVkaXRvciwgcG9zKSB7XG5cdFx0XHR2YXIgYWxsb3dlZFN5bnRheGVzID0geydodG1sJzogMSwgJ3htbCc6IDEsICd4c2wnOiAxLCAnanN4JzogMX07XG5cdFx0XHR2YXIgc3ludGF4ID0gZWRpdG9yLmdldFN5bnRheCgpO1xuXHRcdFx0aWYgKHN5bnRheCBpbiBhbGxvd2VkU3ludGF4ZXMpIHtcblx0XHRcdFx0dmFyIGNvbnRlbnQgPSBlZGl0b3IuZ2V0Q29udGVudCgpO1xuXHRcdFx0XHRpZiAodHlwZW9mIHBvcyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRwb3MgPSBlZGl0b3IuZ2V0Q2FyZXRQb3MoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0YWcgPSBodG1sTWF0Y2hlci5maW5kKGNvbnRlbnQsIHBvcyk7XG5cdFx0XHRcdGlmICh0YWcgJiYgdGFnLnR5cGUgPT0gJ3RhZycpIHtcblx0XHRcdFx0XHR2YXIgc3RhcnRUYWcgPSB0YWcub3Blbjtcblx0XHRcdFx0XHR2YXIgY29udGV4dE5vZGUgPSB7XG5cdFx0XHRcdFx0XHRuYW1lOiBzdGFydFRhZy5uYW1lLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczogW10sXG5cdFx0XHRcdFx0XHRtYXRjaDogdGFnXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBwYXJzZSBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0dmFyIHRhZ1RyZWUgPSB4bWxFZGl0VHJlZS5wYXJzZShzdGFydFRhZy5yYW5nZS5zdWJzdHJpbmcoY29udGVudCkpO1xuXHRcdFx0XHRcdGlmICh0YWdUcmVlKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0Tm9kZS5hdHRyaWJ1dGVzID0gdGFnVHJlZS5nZXRBbGwoKS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IGl0ZW0ubmFtZSgpLFxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlOiBpdGVtLnZhbHVlKClcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gY29udGV4dE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBGaW5kIGV4cHJlc3Npb24gYm91bmRzIGluIGN1cnJlbnQgZWRpdG9yIGF0IGNhcmV0IHBvc2l0aW9uLiBcblx0XHQgKiBPbiBlYWNoIGNoYXJhY3RlciBhIDxjb2RlPmZuPC9jb2RlPiBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhbmQgbXVzdCBcblx0XHQgKiByZXR1cm4gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgY3VycmVudCBjaGFyYWN0ZXIgbWVldHMgcmVxdWlyZW1lbnRzLCBcblx0XHQgKiA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBjaGFyYWN0ZXIgb2YgZXhwcmVzc2lvblxuXHRcdCAqIEByZXR1cm4ge1JhbmdlfVxuXHRcdCAqL1xuXHRcdGZpbmRFeHByZXNzaW9uQm91bmRzOiBmdW5jdGlvbihlZGl0b3IsIGZuKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IFN0cmluZyhlZGl0b3IuZ2V0Q29udGVudCgpKTtcblx0XHRcdHZhciBpbCA9IGNvbnRlbnQubGVuZ3RoO1xuXHRcdFx0dmFyIGV4cHJTdGFydCA9IGVkaXRvci5nZXRDYXJldFBvcygpIC0gMTtcblx0XHRcdHZhciBleHByRW5kID0gZXhwclN0YXJ0ICsgMTtcblx0XHRcdFx0XG5cdFx0XHQvLyBzdGFydCBieSBzZWFyY2hpbmcgbGVmdFxuXHRcdFx0d2hpbGUgKGV4cHJTdGFydCA+PSAwICYmIGZuKGNvbnRlbnQuY2hhckF0KGV4cHJTdGFydCksIGV4cHJTdGFydCwgY29udGVudCkpIGV4cHJTdGFydC0tO1xuXHRcdFx0XG5cdFx0XHQvLyB0aGVuIHNlYXJjaCByaWdodFxuXHRcdFx0d2hpbGUgKGV4cHJFbmQgPCBpbCAmJiBmbihjb250ZW50LmNoYXJBdChleHByRW5kKSwgZXhwckVuZCwgY29udGVudCkpIGV4cHJFbmQrKztcblx0XHRcdFxuXHRcdFx0aWYgKGV4cHJFbmQgPiBleHByU3RhcnQpIHtcblx0XHRcdFx0cmV0dXJuIHJhbmdlKFsrK2V4cHJTdGFydCwgZXhwckVuZF0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0Y29tcG91bmRVcGRhdGU6IGZ1bmN0aW9uKGVkaXRvciwgZGF0YSkge1xuXHRcdFx0aWYgKGRhdGEpIHtcblx0XHRcdFx0dmFyIHNlbCA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuXHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQoZGF0YS5kYXRhLCBkYXRhLnN0YXJ0LCBkYXRhLmVuZCwgdHJ1ZSk7XG5cdFx0XHRcdGVkaXRvci5jcmVhdGVTZWxlY3Rpb24oZGF0YS5jYXJldCwgZGF0YS5jYXJldCArIHNlbC5lbmQgLSBzZWwuc3RhcnQpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29tbW9uIHN5bnRheCBkZXRlY3Rpb24gbWV0aG9kIGZvciBlZGl0b3JzIHRoYXQgZG9lc27igJl0IHByb3ZpZGUgYW55XG5cdFx0ICogaW5mbyBhYm91dCBjdXJyZW50IHN5bnRheCBzY29wZS4gXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvciBDdXJyZW50IGVkaXRvclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBoaW50IEFueSBzeW50YXggaGludCB0aGF0IGVkaXRvciBjYW4gcHJvdmlkZSBcblx0XHQgKiBmb3Igc3ludGF4IGRldGVjdGlvbi4gRGVmYXVsdCBpcyAnaHRtbCdcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfSBcblx0XHQgKi9cblx0XHRkZXRlY3RTeW50YXg6IGZ1bmN0aW9uKGVkaXRvciwgaGludCkge1xuXHRcdFx0dmFyIHN5bnRheCA9IGhpbnQgfHwgJ2h0bWwnO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXJlc291cmNlcy5oYXNTeW50YXgoc3ludGF4KSkge1xuXHRcdFx0XHRzeW50YXggPSAnaHRtbCc7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChzeW50YXggPT0gJ2h0bWwnICYmICh0aGlzLmlzU3R5bGUoZWRpdG9yKSB8fCB0aGlzLmlzSW5saW5lQ1NTKGVkaXRvcikpKSB7XG5cdFx0XHRcdHN5bnRheCA9ICdjc3MnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3ludGF4ID09ICdzdHlsJykge1xuXHRcdFx0XHRzeW50YXggPSAnc3R5bHVzJztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHN5bnRheDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbW1vbiBtZXRob2QgZm9yIGRldGVjdGluZyBvdXRwdXQgcHJvZmlsZVxuXHRcdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGRldGVjdFByb2ZpbGU6IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0dmFyIHN5bnRheCA9IGVkaXRvci5nZXRTeW50YXgoKTtcblx0XHRcdFxuXHRcdFx0Ly8gZ2V0IHByb2ZpbGUgZnJvbSBzeW50YXggZGVmaW5pdGlvblxuXHRcdFx0dmFyIHByb2ZpbGUgPSByZXNvdXJjZXMuZmluZEl0ZW0oc3ludGF4LCAncHJvZmlsZScpO1xuXHRcdFx0aWYgKHByb2ZpbGUpIHtcblx0XHRcdFx0cmV0dXJuIHByb2ZpbGU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHN3aXRjaChzeW50YXgpIHtcblx0XHRcdFx0Y2FzZSAneG1sJzpcblx0XHRcdFx0Y2FzZSAneHNsJzpcblx0XHRcdFx0XHRyZXR1cm4gJ3htbCc7XG5cdFx0XHRcdGNhc2UgJ2Nzcyc6XG5cdFx0XHRcdFx0aWYgKHRoaXMuaXNJbmxpbmVDU1MoZWRpdG9yKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICdsaW5lJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2h0bWwnOlxuXHRcdFx0XHRcdHByb2ZpbGUgPSByZXNvdXJjZXMuZ2V0VmFyaWFibGUoJ3Byb2ZpbGUnKTtcblx0XHRcdFx0XHRpZiAoIXByb2ZpbGUpIHsgLy8gbm8gZm9yY2VkIHByb2ZpbGUsIGd1ZXNzIGZyb20gY29udGVudFxuXHRcdFx0XHRcdFx0Ly8gaHRtbCBvciB4aHRtbD9cblx0XHRcdFx0XHRcdHByb2ZpbGUgPSB0aGlzLmlzWEhUTUwoZWRpdG9yKSA/ICd4aHRtbCc6ICdodG1sJztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gcHJvZmlsZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICd4aHRtbCc7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUcmllcyB0byBkZXRlY3QgaWYgY3VycmVudCBkb2N1bWVudCBpcyBYSFRNTCBvbmUuXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzWEhUTUw6IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0cmV0dXJuIGVkaXRvci5nZXRDb250ZW50KCkuc2VhcmNoKC88IURPQ1RZUEVbXj5dK1hIVE1ML2kpICE9IC0xO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBjdXJyZW50IGNhcmV0IHBvc2l0aW9uIGlzIGluc2lkZSAmbHQ7c3R5bGUmZ3Q7IHRhZ1xuXHRcdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0XHQgKiBAcmV0dXJucyB7UmFuZ2V9IElubmVyIHJhbmdlIG9mICZsdDtzdHlsZSZndDsgdGFnXG5cdFx0ICovXG5cdFx0aXNTdHlsZTogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHRyZXR1cm4gISFjc3NTZWN0aW9ucy5zdHlsZVRhZ1JhbmdlKGVkaXRvci5nZXRDb250ZW50KCksIGVkaXRvci5nZXRDYXJldFBvcygpKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgZ2l2ZW4gQ1NTIGRpYWxlY3QgaXMgc3VwcG9ydGVkIGJ5IENTUyBhY3Rpb25zXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSAgc3ludGF4XG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc1N1cHBvcnRlZENTUzogZnVuY3Rpb24oc3ludGF4KSB7XG5cdFx0XHRyZXR1cm4gc3ludGF4ID09ICdjc3MnIHx8IHN5bnRheCA9PSAnbGVzcycgfHwgc3ludGF4ID09ICdzY3NzJztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24gaXMgaW5zaWRlIFwic3R5bGVcIiBhdHRyaWJ1dGUgb2YgSFRNTFxuXHRcdCAqIGVsZW1lbnRcblx0XHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdFx0ICogQHJldHVybnMge1JhbmdlfSBJbm5lciByYW5nZSBvZiBzdHlsZSBhdHRyaWJ1dGVcblx0XHQgKi9cblx0XHRpc0lubGluZUNTUzogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHRyZXR1cm4gISFjc3NTZWN0aW9ucy5zdHlsZUF0dHJSYW5nZShlZGl0b3IuZ2V0Q29udGVudCgpLCBlZGl0b3IuZ2V0Q2FyZXRQb3MoKSk7XG5cdFx0fVxuXHR9O1xufSk7XG59LHtcIi4uL2Fzc2V0cy9odG1sTWF0Y2hlclwiOlwiYXNzZXRzXFxcXGh0bWxNYXRjaGVyLmpzXCIsXCIuLi9hc3NldHMvcmFuZ2VcIjpcImFzc2V0c1xcXFxyYW5nZS5qc1wiLFwiLi4vYXNzZXRzL3Jlc291cmNlc1wiOlwiYXNzZXRzXFxcXHJlc291cmNlcy5qc1wiLFwiLi4vZWRpdFRyZWUveG1sXCI6XCJlZGl0VHJlZVxcXFx4bWwuanNcIixcIi4uL3BhcnNlci9hYmJyZXZpYXRpb25cIjpcInBhcnNlclxcXFxhYmJyZXZpYXRpb24uanNcIixcIi4vY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIixcIi4vY3NzU2VjdGlvbnNcIjpcInV0aWxzXFxcXGNzc1NlY3Rpb25zLmpzXCJ9XSxcInV0aWxzXFxcXGJhc2U2NC5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBTZXJnZXkgQ2hpa3V5b25vayAoc2VyZ2UuY2hlQGdtYWlsLmNvbSlcbiAqIEBsaW5rIGh0dHA6Ly9jaGlrdXlvbm9rLnJ1XG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cdFxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIEVuY29kZXMgZGF0YSB1c2luZyBiYXNlNjQgYWxnb3JpdGhtXG5cdFx0ICogQGF1dGhvciBUeWxlciBBa2lucyAoaHR0cDovL3J1bWtpbi5jb20pXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0XG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRlbmNvZGUgOiBmdW5jdGlvbihpbnB1dCkge1xuXHRcdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdFx0dmFyIGNocjEsIGNocjIsIGNocjMsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQsIGNkcDEsIGNkcDIsIGNkcDM7XG5cdFx0XHR2YXIgaSA9IDAsIGlsID0gaW5wdXQubGVuZ3RoLCBiNjQgPSBjaGFycztcblxuXHRcdFx0d2hpbGUgKGkgPCBpbCkge1xuXG5cdFx0XHRcdGNkcDEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG5cdFx0XHRcdGNkcDIgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG5cdFx0XHRcdGNkcDMgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG5cblx0XHRcdFx0Y2hyMSA9IGNkcDEgJiAweGZmO1xuXHRcdFx0XHRjaHIyID0gY2RwMiAmIDB4ZmY7XG5cdFx0XHRcdGNocjMgPSBjZHAzICYgMHhmZjtcblxuXHRcdFx0XHRlbmMxID0gY2hyMSA+PiAyO1xuXHRcdFx0XHRlbmMyID0gKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KTtcblx0XHRcdFx0ZW5jMyA9ICgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpO1xuXHRcdFx0XHRlbmM0ID0gY2hyMyAmIDYzO1xuXG5cdFx0XHRcdGlmIChpc05hTihjZHAyKSkge1xuXHRcdFx0XHRcdGVuYzMgPSBlbmM0ID0gNjQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNOYU4oY2RwMykpIHtcblx0XHRcdFx0XHRlbmM0ID0gNjQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQucHVzaChiNjQuY2hhckF0KGVuYzEpICsgYjY0LmNoYXJBdChlbmMyKSArIGI2NC5jaGFyQXQoZW5jMykgKyBiNjQuY2hhckF0KGVuYzQpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVjb2RlcyBzdHJpbmcgdXNpbmcgTUlNRSBiYXNlNjQgYWxnb3JpdGhtXG5cdFx0ICogXG5cdFx0ICogQGF1dGhvciBUeWxlciBBa2lucyAoaHR0cDovL3J1bWtpbi5jb20pXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0ZGVjb2RlIDogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0dmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCwgYWMgPSAwLCB0bXBBcnIgPSBbXTtcblx0XHRcdHZhciBiNjQgPSBjaGFycywgaWwgPSBkYXRhLmxlbmd0aDtcblxuXHRcdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHRkYXRhICs9ICcnO1xuXG5cdFx0XHRkbyB7IC8vIHVucGFjayBmb3VyIGhleGV0cyBpbnRvIHRocmVlIG9jdGV0cyB1c2luZyBpbmRleCBwb2ludHMgaW4gYjY0XG5cdFx0XHRcdGgxID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG5cdFx0XHRcdGgyID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG5cdFx0XHRcdGgzID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG5cdFx0XHRcdGg0ID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG5cblx0XHRcdFx0Yml0cyA9IGgxIDw8IDE4IHwgaDIgPDwgMTIgfCBoMyA8PCA2IHwgaDQ7XG5cblx0XHRcdFx0bzEgPSBiaXRzID4+IDE2ICYgMHhmZjtcblx0XHRcdFx0bzIgPSBiaXRzID4+IDggJiAweGZmO1xuXHRcdFx0XHRvMyA9IGJpdHMgJiAweGZmO1xuXG5cdFx0XHRcdGlmIChoMyA9PSA2NCkge1xuXHRcdFx0XHRcdHRtcEFyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGg0ID09IDY0KSB7XG5cdFx0XHRcdFx0dG1wQXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSwgbzIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRtcEFyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEsIG8yLCBvMyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKGkgPCBpbCk7XG5cblx0XHRcdHJldHVybiB0bXBBcnIuam9pbignJyk7XG5cdFx0fVxuXHR9O1xufSk7XG59LHt9XSxcInV0aWxzXFxcXGNvbW1lbnRzLmpzXCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSBmb3Igd29ya2luZyB3aXRoIGNvbW1lbnRzIGluIHNvdXJjZSBjb2RlXG4gKiAobW9zdGx5IHN0cmlwcGluZyBpdCBmcm9tIHNvdXJjZSlcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcblx0dmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG5cdH07XG59XG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblx0dmFyIHJhbmdlID0gcmVxdWlyZSgnLi4vYXNzZXRzL3JhbmdlJyk7XG5cdHZhciBzdHJpbmdTdHJlYW0gPSByZXF1aXJlKCcuLi9hc3NldHMvc3RyaW5nU3RyZWFtJyk7XG5cdHZhciByZUhhc0NvbW1lbnQgPSAvXFwvXFwqfFxcL1xcLy87XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBSZXBsYWNlcyBhbGwgY29tbWVudHMgaW4gZ2l2ZW4gQ1NTIHNvdXJjZSB3aXRoIHNwYWNlcyxcblx0XHQgKiB3aGljaCBhbGxvd3MgbW9yZSByZWxpYWJsZSAoYW5kIGZhc3RlcikgdG9rZW4gc2VhcmNoXG5cdFx0ICogaW4gQ1NTIGNvbnRlbnRcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGNvbnRlbnQgQ1NTIGNvbnRlbnRcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0c3RyaXA6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcblx0XHRcdGlmICghcmVIYXNDb21tZW50LnRlc3QoY29udGVudCkpIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzdHJlYW0gPSBzdHJpbmdTdHJlYW0oY29udGVudCk7XG5cdFx0XHR2YXIgcmVwbGFjZVJhbmdlcyA9IFtdO1xuXHRcdFx0dmFyIGNoLCBjaDI7XG5cblx0XHRcdHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSkge1xuXHRcdFx0XHRpZiAoY2ggPT09ICcvJykge1xuXHRcdFx0XHRcdGNoMiA9IHN0cmVhbS5wZWVrKCk7XG5cdFx0XHRcdFx0aWYgKGNoMiA9PT0gJyonKSB7IC8vIG11bHRpbGluZSBDU1MgY29tbWVudFxuXHRcdFx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcyAtIDE7XG5cblx0XHRcdFx0XHRcdGlmIChzdHJlYW0uc2tpcFRvKCcqLycpKSB7XG5cdFx0XHRcdFx0XHRcdHN0cmVhbS5wb3MgKz0gMjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVuY2xvc2VkIGNvbW1lbnRcblx0XHRcdFx0XHRcdFx0c3RyZWFtLnNraXBUb0VuZCgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXBsYWNlUmFuZ2VzLnB1c2goW3N0cmVhbS5zdGFydCwgc3RyZWFtLnBvc10pO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY2gyID09PSAnLycpIHtcblx0XHRcdFx0XHRcdC8vIHByZXByb2Nlc3NvcuKAmXMgc2luZ2xlIGxpbmUgY29tbWVudHNcblx0XHRcdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3MgLSAxO1xuXHRcdFx0XHRcdFx0d2hpbGUgKChjaDIgPSBzdHJlYW0ubmV4dCgpKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoY2gyID09PSAnXFxuJyB8fCBjaDIgPT0gJ1xccicpIHtcblx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJlcGxhY2VSYW5nZXMucHVzaChbc3RyZWFtLnN0YXJ0LCBzdHJlYW0ucG9zXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0cmVhbS5za2lwUXVvdGVkKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHV0aWxzLnJlcGxhY2VXaXRoKGNvbnRlbnQsIHJlcGxhY2VSYW5nZXMsICcgJyk7XG5cdFx0fVxuXHR9O1xufSk7XG59LHtcIi4uL2Fzc2V0cy9yYW5nZVwiOlwiYXNzZXRzXFxcXHJhbmdlLmpzXCIsXCIuLi9hc3NldHMvc3RyaW5nU3RyZWFtXCI6XCJhc3NldHNcXFxcc3RyaW5nU3RyZWFtLmpzXCIsXCIuL2NvbW1vblwiOlwidXRpbHNcXFxcY29tbW9uLmpzXCJ9XSxcInV0aWxzXFxcXGNvbW1vbi5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQ29tbW9uIHV0aWxpdHkgaGVscGVyIGZvciBFbW1ldFxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgcmFuZ2UgPSByZXF1aXJlKCcuLi9hc3NldHMvcmFuZ2UnKTtcblxuXHQvKiogXG5cdCAqIFNwZWNpYWwgdG9rZW4gdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBjYXJldCBwb3NpdGlvbnMgaW5zaWRlIFxuXHQgKiBnZW5lcmF0ZWQgb3V0cHV0IFxuXHQgKi9cblx0dmFyIGNhcmV0UGxhY2Vob2xkZXIgPSAnJHswfSc7XG5cdFxuXHRyZXR1cm4ge1xuXHRcdHJlVGFnOiAvPFxcLz9bXFx3OlxcLV0rKD86XFxzK1tcXHdcXC06XSsoPzpcXHMqPVxccyooPzooPzpcIlteXCJdKlwiKXwoPzonW14nXSonKXxbXj5cXHNdKykpPykqXFxzKihcXC8/KT4kLyxcblxuXHRcdGRlZmF1bHRTeW50YXg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICdodG1sJztcblx0XHR9LFxuXG5cdFx0ZGVmYXVsdFByb2ZpbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICdwbGFpbic7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUZXN0IGlmIHBhc3NlZCBzdHJpbmcgZW5kcyB3aXRoIFhIVE1MIHRhZy4gVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgdGVzdGluZ1xuXHRcdCAqICc+JyBjaGFyYWN0ZXI6IGl0IGJlbG9uZ3MgdG8gdGFnIG9yIGl0J3MgYSBwYXJ0IG9mIGFiYnJldmlhdGlvbj8gXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0ZW5kc1dpdGhUYWc6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVUYWcudGVzdChzdHIpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgcGFzc2VkIHN5bWJvbCBpcyBhIG51bWJlclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjaFxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzTnVtZXJpYzogZnVuY3Rpb24oY2gpIHtcblx0XHRcdGlmICh0eXBlb2YoY2gpID09ICdzdHJpbmcnKVxuXHRcdFx0XHRjaCA9IGNoLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdFxuXHRcdFx0cmV0dXJuIChjaCAmJiBjaCA+IDQ3ICYmIGNoIDwgNTgpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVHJpbSB3aGl0ZXNwYWNlIGZyb20gc3RyaW5nXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dHJpbTogKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKFN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuXHRcdFx0XHRcdHJldHVybiB0ZXh0ID8gdGV4dC50cmltKCkgOiAnJztcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcblx0XHRcdFx0cmV0dXJuICh0ZXh0IHx8IFwiXCIpLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuXHRcdFx0fVxuXHRcdH0pKCksXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3BsaXQgdGV4dCBpbnRvIGxpbmVzLiBTZXQgPGNvZGU+cmVtb3ZlX2VtcHR5PC9jb2RlPiB0byB0cnVlIHRvIGZpbHRlclxuXHRcdCAqIGVtcHR5IGxpbmVzXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCB0byBzcGxpdFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlRW1wdHkgUmVtb3ZlIGVtcHR5IGxpbmVzIGZyb20gcmVzdWx0XG5cdFx0ICogQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdFx0c3BsaXRCeUxpbmVzOiBmdW5jdGlvbih0ZXh0LCByZW1vdmVFbXB0eSkge1xuXHRcdFx0Ly8gSUUgZmFpbHMgdG8gc3BsaXQgc3RyaW5nIGJ5IHJlZ2V4cCwgXG5cdFx0XHQvLyBuZWVkIHRvIG5vcm1hbGl6ZSBuZXdsaW5lcyBmaXJzdFxuXHRcdFx0Ly8gQWxzbywgTW96aWxsYSdzIFJoaWhvIEpTIGVuZ2luZSBoYXMgYSB3ZWlyZCBuZXdsaW5lIGJ1Z1xuXHRcdFx0dmFyIG5sID0gJ1xcbic7XG5cdFx0XHR2YXIgbGluZXMgPSAodGV4dCB8fCAnJylcblx0XHRcdFx0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJylcblx0XHRcdFx0LnJlcGxhY2UoL1xcblxcci9nLCAnXFxuJylcblx0XHRcdFx0LnJlcGxhY2UoL1xcci9nLCAnXFxuJylcblx0XHRcdFx0LnJlcGxhY2UoL1xcbi9nLCBubClcblx0XHRcdFx0LnNwbGl0KG5sKTtcblx0XHRcdFxuXHRcdFx0aWYgKHJlbW92ZUVtcHR5KSB7XG5cdFx0XHRcdGxpbmVzID0gbGluZXMuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGluZS5sZW5ndGggJiYgISF0aGlzLnRyaW0obGluZSk7XG5cdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGluZXM7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXBlYXRzIHN0cmluZyA8Y29kZT5ob3dNYW55PC9jb2RlPiB0aW1lc1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaG93X21hbnlcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cmVwZWF0U3RyaW5nOiBmdW5jdGlvbihzdHIsIGhvd01hbnkpIHtcblx0XHRcdHZhciBvdXQgPSAnJztcblx0XHRcdHdoaWxlIChob3dNYW55LS0pIHtcblx0XHRcdFx0b3V0ICs9IHN0cjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbGlzdCBvZiBwYWRkaW5ncyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGFsaWduIHBhc3NlZCBzdHJpbmdcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBzdHJpbmdzXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdCAqL1xuXHRcdGdldFN0cmluZ3NQYWRzOiBmdW5jdGlvbihzdHJpbmdzKSB7XG5cdFx0XHR2YXIgbGVuZ3RocyA9IHN0cmluZ3MubWFwKGZ1bmN0aW9uKHMpIHtcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJyA/IHMubGVuZ3RoIDogK3M7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dmFyIG1heCA9IGxlbmd0aHMucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHByZXYgPT09ICd1bmRlZmluZWQnID8gY3VyIDogTWF0aC5tYXgocHJldiwgY3VyKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGxlbmd0aHMubWFwKGZ1bmN0aW9uKGwpIHtcblx0XHRcdFx0dmFyIHBhZCA9IG1heCAtIGw7XG5cdFx0XHRcdHJldHVybiBwYWQgPyB0aGlzLnJlcGVhdFN0cmluZygnICcsIHBhZCkgOiAnJztcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kZW50cyB0ZXh0IHdpdGggcGFkZGluZ1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgdG8gaW5kZW50XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhZCBQYWRkaW5nIHNpemUgKG51bWJlcikgb3IgcGFkZGluZyBpdHNlbGYgKHN0cmluZylcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cGFkU3RyaW5nOiBmdW5jdGlvbih0ZXh0LCBwYWQpIHtcblx0XHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRcdHZhciBsaW5lcyA9IHRoaXMuc3BsaXRCeUxpbmVzKHRleHQpO1xuXHRcdFx0dmFyIG5sID0gJ1xcbic7XG5cdFx0XHRcdFxuXHRcdFx0cmVzdWx0LnB1c2gobGluZXNbMF0pO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDE7IGogPCBsaW5lcy5sZW5ndGg7IGorKykgXG5cdFx0XHRcdHJlc3VsdC5wdXNoKG5sICsgcGFkICsgbGluZXNbal0pO1xuXHRcdFx0XHRcblx0XHRcdHJldHVybiByZXN1bHQuam9pbignJyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBQYWQgc3RyaW5nIHdpdGggemVyb2VzXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gcGFkXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZCBEZXNpcmVkIHN0cmluZyBsZW5ndGhcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0emVyb1BhZFN0cmluZzogZnVuY3Rpb24oc3RyLCBwYWQpIHtcblx0XHRcdHZhciBwYWRkaW5nID0gJyc7XG5cdFx0XHR2YXIgaWwgPSBzdHIubGVuZ3RoO1xuXHRcdFx0XHRcblx0XHRcdHdoaWxlIChwYWQgPiBpbCsrKSBwYWRkaW5nICs9ICcwJztcblx0XHRcdHJldHVybiBwYWRkaW5nICsgc3RyOyBcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgcGFkZGluZyBhdCB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggdGV4dCdzIGxpbmVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYWRcblx0XHQgKi9cblx0XHR1bmluZGVudFN0cmluZzogZnVuY3Rpb24odGV4dCwgcGFkKSB7XG5cdFx0XHR2YXIgbGluZXMgPSB0aGlzLnNwbGl0QnlMaW5lcyh0ZXh0KTtcblx0XHRcdHZhciBwbCA9IHBhZC5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaWwgPSBsaW5lcy5sZW5ndGgsIGxpbmU7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdGxpbmUgPSBsaW5lc1tpXTtcblx0XHRcdFx0aWYgKGxpbmUuc3Vic3RyKDAsIHBsKSA9PT0gcGFkKSB7XG5cdFx0XHRcdFx0bGluZXNbaV0gPSBsaW5lLnN1YnN0cihwbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVwbGFjZXMgdW5lc2NhcGVkIHN5bWJvbHMgaW4gPGNvZGU+c3RyPC9jb2RlPi4gRm9yIGV4YW1wbGUsIHRoZSAnJCcgc3ltYm9sXG5cdFx0ICogd2lsbCBiZSByZXBsYWNlZCBpbiAnaXRlbSRjb3VudCcsIGJ1dCBub3QgaW4gJ2l0ZW1cXCRjb3VudCcuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBPcmlnaW5hbCBzdHJpbmdcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIFN5bWJvbCB0byByZXBsYWNlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHJlcGxhY2UgU3ltYm9sIHJlcGxhY2VtZW50LiBNaWdodCBiZSBhIGZ1bmN0aW9uIHRoYXQgXG5cdFx0ICogcmV0dXJucyBuZXcgdmFsdWVcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cmVwbGFjZVVuZXNjYXBlZFN5bWJvbDogZnVuY3Rpb24oc3RyLCBzeW1ib2wsIHJlcGxhY2UpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdHZhciBpbCA9IHN0ci5sZW5ndGg7XG5cdFx0XHR2YXIgc2wgPSBzeW1ib2wubGVuZ3RoO1xuXHRcdFx0dmFyIG1hdGNoQ291bnQgPSAwO1xuXHRcdFx0XHRcblx0XHRcdHdoaWxlIChpIDwgaWwpIHtcblx0XHRcdFx0aWYgKHN0ci5jaGFyQXQoaSkgPT0gJ1xcXFwnKSB7XG5cdFx0XHRcdFx0Ly8gZXNjYXBlZCBzeW1ib2wsIHNraXAgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0XHRpICs9IHNsICsgMTtcblx0XHRcdFx0fSBlbHNlIGlmIChzdHIuc3Vic3RyKGksIHNsKSA9PSBzeW1ib2wpIHtcblx0XHRcdFx0XHQvLyBoYXZlIG1hdGNoXG5cdFx0XHRcdFx0dmFyIGN1clNsID0gc2w7XG5cdFx0XHRcdFx0bWF0Y2hDb3VudCsrO1xuXHRcdFx0XHRcdHZhciBuZXdWYWx1ZSA9IHJlcGxhY2U7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiByZXBsYWNlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVwbGFjZURhdGEgPSByZXBsYWNlKHN0ciwgc3ltYm9sLCBpLCBtYXRjaENvdW50KTtcblx0XHRcdFx0XHRcdGlmIChyZXBsYWNlRGF0YSkge1xuXHRcdFx0XHRcdFx0XHRjdXJTbCA9IHJlcGxhY2VEYXRhWzBdLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0bmV3VmFsdWUgPSByZXBsYWNlRGF0YVsxXTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5ld1ZhbHVlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChuZXdWYWx1ZSA9PT0gZmFsc2UpIHsgLy8gc2tpcCByZXBsYWNlbWVudFxuXHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSkgKyBuZXdWYWx1ZSArIHN0ci5zdWJzdHJpbmcoaSArIGN1clNsKTtcblx0XHRcdFx0XHQvLyBhZGp1c3QgaW5kZXhlc1xuXHRcdFx0XHRcdGlsID0gc3RyLmxlbmd0aDtcblx0XHRcdFx0XHRpICs9IG5ld1ZhbHVlLmxlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2VzICckJyBjaGFyYWN0ZXIgaW4gc3RyaW5nIGFzc3VtaW5nIGl0IG1pZ2h0IGJlIGVzY2FwZWQgd2l0aCAnXFwnXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgd2hlcmUgY2hhcmFjdGVyIHNob3VsZCBiZSByZXBsYWNlZFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBOZXcgdmFsdWVcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cmVwbGFjZUNvdW50ZXI6IGZ1bmN0aW9uKHN0ciwgdmFsdWUsIHRvdGFsKSB7XG5cdFx0XHR2YXIgc3ltYm9sID0gJyQnO1xuXHRcdFx0Ly8gaW4gY2FzZSB3ZSByZWNlaXZlZCBzdHJpbmdzIGZyb20gSmF2YSwgY29udmVydCB0aGUgdG8gbmF0aXZlIHN0cmluZ3Ncblx0XHRcdHN0ciA9IFN0cmluZyhzdHIpO1xuXHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXHRcdFx0XG5cdFx0XHRpZiAoL15cXC0/XFxkKyQvLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlID0gK3ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnJlcGxhY2VVbmVzY2FwZWRTeW1ib2woc3RyLCBzeW1ib2wsIGZ1bmN0aW9uKHN0ciwgc3ltYm9sLCBwb3MsIG1hdGNoTnVtKXtcblx0XHRcdFx0aWYgKHN0ci5jaGFyQXQocG9zICsgMSkgPT0gJ3snIHx8IHRoYXQuaXNOdW1lcmljKHN0ci5jaGFyQXQocG9zICsgMSkpICkge1xuXHRcdFx0XHRcdC8vIGl0J3MgYSB2YXJpYWJsZSwgc2tpcCBpdFxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gcmVwbGFjZSBzZXF1ZW5zZSBvZiAkIHN5bWJvbHMgd2l0aCBwYWRkZWQgbnVtYmVyICBcblx0XHRcdFx0dmFyIGogPSBwb3MgKyAxO1xuXHRcdFx0XHR3aGlsZShzdHIuY2hhckF0KGopID09ICckJyAmJiBzdHIuY2hhckF0KGogKyAxKSAhPSAneycpIGorKztcblx0XHRcdFx0dmFyIHBhZCA9IGogLSBwb3M7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBnZXQgY291bnRlciBiYXNlXG5cdFx0XHRcdHZhciBiYXNlID0gMCwgZGVjcmVtZW50ID0gZmFsc2UsIG07XG5cdFx0XHRcdGlmICgobSA9IHN0ci5zdWJzdHIoaikubWF0Y2goL15AKFxcLT8pKFxcZCopLykpKSB7XG5cdFx0XHRcdFx0aiArPSBtWzBdLmxlbmd0aDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobVsxXSkge1xuXHRcdFx0XHRcdFx0ZGVjcmVtZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0YmFzZSA9IHBhcnNlSW50KG1bMl0gfHwgMSwgMTApIC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGRlY3JlbWVudCAmJiB0b3RhbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB0b3RhbCAtIHZhbHVlICsgMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0dmFsdWUgKz0gYmFzZTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBbc3RyLnN1YnN0cmluZyhwb3MsIGopLCB0aGF0Lnplcm9QYWRTdHJpbmcodmFsdWUgKyAnJywgcGFkKV07XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIHN0cmluZyBtYXRjaGVzIGFnYWluc3QgPGNvZGU+cmVUYWc8L2NvZGU+IHJlZ2V4cC4gVGhpcyBcblx0XHQgKiBmdW5jdGlvbiBtYXkgYmUgdXNlZCB0byB0ZXN0IGlmIHByb3ZpZGVkIHN0cmluZyBjb250YWlucyBIVE1MIHRhZ3Ncblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0bWF0Y2hlc1RhZzogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZVRhZy50ZXN0KHN0ciB8fCAnJyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBFc2NhcGVzIHNwZWNpYWwgY2hhcmFjdGVycyB1c2VkIGluIEVtbWV0LCBsaWtlICckJywgJ3wnLCBldGMuXG5cdFx0ICogVXNlIHRoaXMgbWV0aG9kIGJlZm9yZSBwYXNzaW5nIHRvIGFjdGlvbnMgbGlrZSBcIldyYXAgd2l0aCBBYmJyZXZpYXRpb25cIlxuXHRcdCAqIHRvIG1ha2Ugc3VyZSB0aGF0IGV4aXN0aW5nIHNwZWNpYWwgY2hhcmFjdGVycyB3b24ndCBiZSBhbHRlcmVkXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0ZXNjYXBlVGV4dDogZnVuY3Rpb24odGV4dCkge1xuXHRcdFx0cmV0dXJuIHRleHQucmVwbGFjZSgvKFtcXCRcXFxcXSkvZywgJ1xcXFwkMScpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVW5lc2NhcGVzIHNwZWNpYWwgY2hhcmFjdGVycyB1c2VkIGluIEVtbWV0LCBsaWtlICckJywgJ3wnLCBldGMuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dW5lc2NhcGVUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG5cdFx0XHRyZXR1cm4gdGV4dC5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBjYXJldCBwbGFjZWhvbGRlclxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0Z2V0Q2FyZXRQbGFjZWhvbGRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGNhcmV0UGxhY2Vob2xkZXIgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0PyBjYXJldFBsYWNlaG9sZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0XHRcdFx0OiBjYXJldFBsYWNlaG9sZGVyO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2V0cyBuZXcgcmVwcmVzZW50YXRpb24gZm9yIGNhcmV0cyBpbiBnZW5lcmF0ZWQgb3V0cHV0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIE5ldyBjYXJldCBwbGFjZWhvbGRlci4gTWlnaHQgYmUgYSBcblx0XHQgKiA8Y29kZT5GdW5jdGlvbjwvY29kZT5cblx0XHQgKi9cblx0XHRzZXRDYXJldFBsYWNlaG9sZGVyOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0Y2FyZXRQbGFjZWhvbGRlciA9IHZhbHVlO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBsaW5lIHBhZGRpbmdcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbGluZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRMaW5lUGFkZGluZzogZnVuY3Rpb24obGluZSkge1xuXHRcdFx0cmV0dXJuIChsaW5lLm1hdGNoKC9eKFxccyspLykgfHwgWycnXSlbMF07XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHBhZGRpbmcgb2YgbGluZSBvZiA8Y29kZT5wb3M8L2NvZGU+XG5cdFx0ICogcG9zaXRpb24gaW4gPGNvZGU+Y29udGVudDwvY29kZT5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3Ncblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldExpbmVQYWRkaW5nRnJvbVBvc2l0aW9uOiBmdW5jdGlvbihjb250ZW50LCBwb3MpIHtcblx0XHRcdHZhciBsaW5lUmFuZ2UgPSB0aGlzLmZpbmROZXdsaW5lQm91bmRzKGNvbnRlbnQsIHBvcyk7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRMaW5lUGFkZGluZyhsaW5lUmFuZ2Uuc3Vic3RyaW5nKGNvbnRlbnQpKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEVzY2FwZSBzcGVjaWFsIHJlZ2V4cCBjaGFycyBpbiBzdHJpbmcsIG1ha2luZyBpdCB1c2FibGUgZm9yIGNyZWF0aW5nIGR5bmFtaWNcblx0XHQgKiByZWd1bGFyIGV4cHJlc3Npb25zXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRlc2NhcGVGb3JSZWdleHA6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0dmFyIHNwZWNpYWxzID0gbmV3IFJlZ0V4cChcIlsuKis/fCgpXFxcXFtcXFxcXXt9XFxcXFxcXFxdXCIsIFwiZ1wiKTsgLy8gLiorP3woKVtde31cXFxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKHNwZWNpYWxzLCBcIlxcXFwkJlwiKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIE1ha2UgZGVjaW1hbCBudW1iZXIgbG9vayBnb29kOiBjb252ZXJ0IGl0IHRvIGZpeGVkIHByZWNpc2lvbiBlbmQgcmVtb3ZlXG5cdFx0ICogdHJhbGluZyB6ZXJvZXMgXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBmcmFjaW9uIEZyYWN0aW9uIG51bWJlcnMgKGRlZmF1bHQgaXMgMilcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cHJldHRpZnlOdW1iZXI6IGZ1bmN0aW9uKG51bSwgZnJhY3Rpb24pIHtcblx0XHRcdHJldHVybiBudW0udG9GaXhlZCh0eXBlb2YgZnJhY3Rpb24gPT0gJ3VuZGVmaW5lZCcgPyAyIDogZnJhY3Rpb24pLnJlcGxhY2UoL1xcLj8wKyQvLCAnJyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXBsYWNlIHN1YnN0cmluZyBvZiA8Y29kZT5zdHI8L2NvZGU+IHdpdGggPGNvZGU+dmFsdWU8L2NvZGU+XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgd2hlcmUgdG8gcmVwbGFjZSBzdWJzdHJpbmdcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgTmV3IHN1YnN0cmluZyB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydCBpbmRleCBvZiBzdWJzdHJpbmcgdG8gcmVwbGFjZS4gTWF5IGFsc29cblx0XHQgKiBiZSBhIDxjb2RlPlJhbmdlPC9jb2RlPiBvYmplY3Q6IGluIHRoaXMgY2FzZSwgdGhlIDxjb2RlPmVuZDwvY29kZT5cblx0XHQgKiBhcmd1bWVudCBpcyBub3QgcmVxdWlyZWRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZCBpbmRleCBvZiBzdWJzdHJpbmcgdG8gcmVwbGFjZS4gSWYgb21taXRlZCwgXG5cdFx0ICogPGNvZGU+c3RhcnQ8L2NvZGU+IGFyZ3VtZW50IGlzIHVzZWRcblx0XHQgKi9cblx0XHRyZXBsYWNlU3Vic3RyaW5nOiBmdW5jdGlvbihzdHIsIHZhbHVlLCBzdGFydCwgZW5kKSB7XG5cdFx0XHRpZiAodHlwZW9mIHN0YXJ0ID09PSAnb2JqZWN0JyAmJiAnZW5kJyBpbiBzdGFydCkge1xuXHRcdFx0XHRlbmQgPSBzdGFydC5lbmQ7XG5cdFx0XHRcdHN0YXJ0ID0gc3RhcnQuc3RhcnQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRlbmQgPSBzdGFydCArIGVuZC5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRlbmQgPSBzdGFydDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+IHN0ci5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiBzdHI7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHZhbHVlICsgc3RyLnN1YnN0cmluZyhlbmQpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGaWxscyBzdWJzdHJpbmdzIGluIGBjb250ZW50YCwgZGVmaW5lZCBieSBnaXZlbiByYW5nZXMsXG5cdFx0ICogd2ljaCBgY2hgIGNoYXJhY3RlclxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gY29udGVudFxuXHRcdCAqIEBwYXJhbSAge0FycmF5fSByYW5nZXNcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKGNvbnRlbnQsIHJhbmdlcywgY2gsIG5vUmVwZWF0KSB7XG5cdFx0XHRpZiAocmFuZ2VzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gMCwgZnJhZ21lbnRzID0gW107XG5cdFx0XHRcdHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcblx0XHRcdFx0XHR2YXIgcmVwbCA9IG5vUmVwZWF0ID8gY2ggOiB0aGlzLnJlcGVhdFN0cmluZyhjaCwgclsxXSAtIHJbMF0pO1xuXHRcdFx0XHRcdGZyYWdtZW50cy5wdXNoKGNvbnRlbnQuc3Vic3RyaW5nKG9mZnNldCwgclswXSksIHJlcGwpO1xuXHRcdFx0XHRcdG9mZnNldCA9IHJbMV07XG5cdFx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRcdGNvbnRlbnQgPSBmcmFnbWVudHMuam9pbignJykgKyBjb250ZW50LnN1YnN0cmluZyhvZmZzZXQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIE5hcnJvd3MgZG93biB0ZXh0IHJhbmdlLCBhZGp1c3Rpbmcgc2VsZWN0aW9uIHRvIG5vbi1zcGFjZSBjaGFyYWN0ZXJzXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnRpbmcgcmFuZ2UgaW4gPGNvZGU+dGV4dDwvY29kZT4gd2hlcmUgXG5cdFx0ICogc2xlY3Rpb24gc2hvdWxkIGJlIGFkanVzdGVkLiBDYW4gYWxzbyBiZSBhbnkgb2JqZWN0IHRoYXQgaXMgYWNjZXB0ZWRcblx0XHQgKiBieSA8Y29kZT5SYW5nZTwvY29kZT4gY2xhc3Ncblx0XHQgKiBAcmV0dXJuIHtSYW5nZX1cblx0XHQgKi9cblx0XHRuYXJyb3dUb05vblNwYWNlOiBmdW5jdGlvbih0ZXh0LCBzdGFydCwgZW5kKSB7XG5cdFx0XHR2YXIgcm5nID0gcmFuZ2UuY3JlYXRlKHN0YXJ0LCBlbmQpO1xuXHRcdFx0XG5cdFx0XHR2YXIgcmVTcGFjZSA9IC9bXFxzXFxuXFxyXFx1MDBhMF0vO1xuXHRcdFx0Ly8gbmFycm93IGRvd24gc2VsZWN0aW9uIHVudGlsIGZpcnN0IG5vbi1zcGFjZSBjaGFyYWN0ZXJcblx0XHRcdHdoaWxlIChybmcuc3RhcnQgPCBybmcuZW5kKSB7XG5cdFx0XHRcdGlmICghcmVTcGFjZS50ZXN0KHRleHQuY2hhckF0KHJuZy5zdGFydCkpKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRybmcuc3RhcnQrKztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0d2hpbGUgKHJuZy5lbmQgPiBybmcuc3RhcnQpIHtcblx0XHRcdFx0cm5nLmVuZC0tO1xuXHRcdFx0XHRpZiAoIXJlU3BhY2UudGVzdCh0ZXh0LmNoYXJBdChybmcuZW5kKSkpIHtcblx0XHRcdFx0XHRybmcuZW5kKys7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJuZztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEZpbmQgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiB0ZXh0IGxpbmUgZm9yIDxjb2RlPmZyb208L2NvZGU+IGluZGV4XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGZyb21cblx0XHQgKi9cblx0XHRmaW5kTmV3bGluZUJvdW5kczogZnVuY3Rpb24odGV4dCwgZnJvbSkge1xuXHRcdFx0dmFyIGxlbiA9IHRleHQubGVuZ3RoLFxuXHRcdFx0XHRzdGFydCA9IDAsXG5cdFx0XHRcdGVuZCA9IGxlbiAtIDEsIFxuXHRcdFx0XHRjaDtcblxuXHRcdFx0XG5cdFx0XHQvLyBzZWFyY2ggbGVmdFxuXHRcdFx0Zm9yICh2YXIgaSA9IGZyb20gLSAxOyBpID4gMDsgaS0tKSB7XG5cdFx0XHRcdGNoID0gdGV4dC5jaGFyQXQoaSk7XG5cdFx0XHRcdGlmIChjaCA9PSAnXFxuJyB8fCBjaCA9PSAnXFxyJykge1xuXHRcdFx0XHRcdHN0YXJ0ID0gaSArIDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIHNlYXJjaCByaWdodFxuXHRcdFx0Zm9yICh2YXIgaiA9IGZyb207IGogPCBsZW47IGorKykge1xuXHRcdFx0XHRjaCA9IHRleHQuY2hhckF0KGopO1xuXHRcdFx0XHRpZiAoY2ggPT0gJ1xcbicgfHwgY2ggPT0gJ1xccicpIHtcblx0XHRcdFx0XHRlbmQgPSBqO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiByYW5nZS5jcmVhdGUoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVlcCBtZXJnZSBvZiB0d28gb3IgbW9yZSBvYmplY3RzLiBUYWtlbiBmcm9tIGpRdWVyeS5leHRlbmQoKVxuXHRcdCAqL1xuXHRcdGRlZXBNZXJnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0XHRcdHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcblx0XHRcdFx0aSA9IDEsXG5cdFx0XHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cblxuXHRcdFx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdFx0XHRpZiAodHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0YXJnZXQgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0aWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRcdFx0aWYgKCBjb3B5ICYmICggdHlwZW9mIGNvcHkgPT09ICdvYmplY3QnIHx8IChjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29weSkpICkgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIHR5cGVvZiBzcmMgPT09ICdvYmplY3QnID8gc3JjIDoge307XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSB0aGlzLmRlZXBNZXJnZShjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlYWQgc2ltcGxlIHN0cmluZy10by1KU09OIHBhcnNlclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHBhcnNlSlNPTjogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRpZiAodHlwZW9mIHN0ciA9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRyZXR1cm4gc3RyO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHJldHVybiB7fTtcblx0XHRcdH1cblx0XHR9LFxuXG5cblx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHQgKiBVdGlsaXR5IGJlbHRcblx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdFx0dW5pcXVlOiBmdW5jdGlvbihhcnIsIGNvbXBhcmF0b3IpIHtcblx0XHRcdHZhciBsb29rdXAgPSBbXTtcblx0XHRcdHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0dmFyIHZhbCA9IGNvbXBhcmF0b3IgPyBjb21wYXJhdG9yKGl0ZW0pIDogaXRlbTtcblx0XHRcdFx0aWYgKGxvb2t1cC5pbmRleE9mKHZhbCkgPCAwKSB7XG5cdFx0XHRcdFx0bG9va3VwLnB1c2godmFsKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCwgZmlsdGVyZWQgdG8gb25seSBoYXZlIHZhbHVlcyBmb3IgXG5cdFx0ICogdGhlIHdoaXRlbGlzdGVkIGtleXMuIFxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gb2JqXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHBpY2s6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHt9O1xuXHRcdFx0dmFyIGtleXMgPSB0aGlzLnRvQXJyYXkoYXJndW1lbnRzLCAxKTtcblx0XHRcdE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0aWYgKH5rZXlzLmluZGV4T2Yoa2V5KSkge1xuXHRcdFx0XHRcdHJlc3VsdFtrZXldID0gb2JqW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXG5cdFx0ZmluZDogZnVuY3Rpb24oYXJyLCBjb21wYXJhdG9yLCBjdHgpIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cdFx0XHRpZiAoY3R4KSB7XG5cdFx0XHRcdGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yLmJpbmQoY3R4KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuXHRcdFx0XHRhcnIuc29tZShmdW5jdGlvbihpdGVtLCBpKSB7XG5cdFx0XHRcdFx0aWYgKGNvbXBhcmF0b3IoaXRlbSwgaSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQgPSBpdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRPYmplY3Qua2V5cyhhcnIpLnNvbWUoZnVuY3Rpb24oa2V5LCBpKSB7XG5cdFx0XHRcdFx0aWYgKGNvbXBhcmF0b3IoYXJyW2tleV0sIGkpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0ID0gYXJyW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXG5cdFx0dG9BcnJheTogZnVuY3Rpb24ob2JqLCBzbGljZUl4KSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopICYmICFzbGljZUl4KSB7XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCBzbGljZUl4IHx8IDApO1xuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGlsID0gYXJndW1lbnRzLmxlbmd0aCwgYTsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0YSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0aWYgKGEpIHtcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRcdFx0b2JqW2tleV0gPSBhW2tleV07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdGRlZmF1bHRzOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdGZvciAodmFyIGkgPSAxLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGgsIGE7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdGEgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGlmIChhKSB7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoYSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0XHRcdGlmICghKGtleSBpbiBvYmopKSB7XG5cdFx0XHRcdFx0XHRcdG9ialtrZXldID0gYVtrZXldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cblx0XHRmbGF0dGVuOiBmdW5jdGlvbihhcnIsIG91dCkge1xuXHRcdFx0b3V0ID0gb3V0IHx8IFtdO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0c2VsZi50b0FycmF5KGFycikuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG5cdFx0XHRcdFx0c2VsZi5mbGF0dGVuKGl0ZW0sIG91dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdHJldHVybiBvYmouc2xpY2UoMCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmV4dGVuZCh7fSwgb2JqKTtcblx0XHR9LFxuXG5cdFx0d2l0aG91dDogZnVuY3Rpb24oYXJyKSB7XG5cdFx0XHR0aGlzLnRvQXJyYXkoYXJndW1lbnRzLCAxKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0dmFyIGl4O1xuXHRcdFx0XHR3aGlsZSAofihpeCA9IGFyci5pbmRleE9mKGl0ZW0pKSkge1xuXHRcdFx0XHRcdGFyci5zcGxpY2UoaXgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBhcnI7XG5cdFx0fSxcblxuXHRcdGxhc3Q6IGZ1bmN0aW9uKGFycikge1xuXHRcdFx0cmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG5cdFx0fVxuXHR9O1xufSk7XG5cbn0se1wiLi4vYXNzZXRzL3JhbmdlXCI6XCJhc3NldHNcXFxccmFuZ2UuanNcIn1dLFwidXRpbHNcXFxcY3NzU2VjdGlvbnMuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXHR2YXIgY29tbWVudHNVdGlscyA9IHJlcXVpcmUoJy4vY29tbWVudHMnKTtcblx0dmFyIHJhbmdlID0gcmVxdWlyZSgnLi4vYXNzZXRzL3JhbmdlJyk7XG5cdHZhciBzdHJpbmdTdHJlYW0gPSByZXF1aXJlKCcuLi9hc3NldHMvc3RyaW5nU3RyZWFtJyk7XG5cdHZhciBjc3NQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXIvY3NzJyk7XG5cdHZhciBodG1sTWF0Y2hlciA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9odG1sTWF0Y2hlcicpO1xuXHR2YXIgeG1sRWRpdFRyZWUgPSByZXF1aXJlKCcuLi9lZGl0VHJlZS94bWwnKTtcblxuXHR2YXIgaWRDb3VudGVyID0gMTtcblx0dmFyIG1heElkID0gMTAwMDAwMDtcblxuXHR2YXIgcmVTcGFjZVRyaW0gPSAvXihcXHMqKS4rPyhcXHMqKSQvO1xuXHR2YXIgcmVTcGFjZSA9IC9cXHMvZztcblx0dmFyIHJlQ29tbWEgPSAvLC87XG5cblx0ZnVuY3Rpb24gaXNRdW90ZShjaCkge1xuXHRcdHJldHVybiBjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SWQoKSB7XG5cdFx0aWRDb3VudGVyID0gKGlkQ291bnRlciArIDEpICUgbWF4SWQ7XG5cdFx0cmV0dXJuICdzJyArIGlkQ291bnRlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSBGdWxsIHNlbGVjdG9yIHJhbmdlIHdpdGggYWRkaXRpb25hbFxuXHQgKiBwcm9wZXJ0aWVzIGZvciBtYXRjaGluZyBuYW1lIGFuZCBjb250ZW50IChAc2VlIGZpbmRBbGxSdWxlcygpKVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIENTUyBzb3VyY2Vcblx0ICovXG5cdGZ1bmN0aW9uIENTU1NlY3Rpb24ocm5nLCBzb3VyY2UpIHtcblx0XHR0aGlzLmlkID0gZ2V0SWQoKTtcblx0XHQvKiogQHR5cGUge0NTU1NlY3Rpb259ICovXG5cdFx0dGhpcy5wYXJlbnQgPSBudWxsO1xuXHRcdC8qKiBAdHlwZSB7Q1NTU2VjdGlvbn0gKi9cblx0XHR0aGlzLm5leHRTaWJsaW5nID0gbnVsbDtcblx0XHQvKiogQHR5cGUge0NTU1NlY3Rpb259ICovXG5cdFx0dGhpcy5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuXHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcblx0XHR0aGlzLl9uYW1lID0gbnVsbDtcblx0XHR0aGlzLl9jb250ZW50ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEN1c3RvbSBkYXRhIGZvciBjdXJyZW50IG5vZGVzLCB1c2VkIGJ5IG90aGVyIG1vZHVsZXMgZm9yXG5cdFx0ICogY2FjaGluZyBldGMuXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLl9kYXRhID0ge307XG5cblx0XHRpZiAoIXJuZyAmJiBzb3VyY2UpIHtcblx0XHRcdHJuZyA9IHJhbmdlKDAsIHNvdXJjZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5yYW5nZSA9IHJuZztcblx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cdH1cblxuXHRDU1NTZWN0aW9uLnByb3RvdHlwZSA9IHtcblx0XHRhZGRDaGlsZDogZnVuY3Rpb24oc2VjdGlvbikge1xuXHRcdFx0aWYgKCEoc2VjdGlvbiBpbnN0YW5jZW9mIENTU1NlY3Rpb24pKSB7XG5cdFx0XHRcdHNlY3Rpb24gPSBuZXcgQ1NTU2VjdGlvbihzZWN0aW9uKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxhc3RDaGlsZCA9IHV0aWxzLmxhc3QodGhpcy5jaGlsZHJlbik7XG5cdFx0XHRpZiAobGFzdENoaWxkKSB7XG5cdFx0XHRcdGxhc3RDaGlsZC5uZXh0U2libGluZyA9IHNlY3Rpb247XG5cdFx0XHRcdHNlY3Rpb24ucHJldmlvdXNTaWJsaW5nID0gbGFzdENoaWxkO1xuXHRcdFx0fVxuXHRcdFx0c2VjdGlvbi5wYXJlbnQgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goc2VjdGlvbik7XG5cdFx0XHRyZXR1cm4gc2VjdGlvbjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyByb290IG5vZGVcblx0XHQgKiBAcmV0dXJuIHtDU1NTZWN0aW9ufVxuXHRcdCAqL1xuXHRcdHJvb3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJvb3QgPSB0aGlzO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpZiAoIXJvb3QucGFyZW50KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJvb3Q7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUocm9vdCA9IHJvb3QucGFyZW50KTtcblxuXHRcdFx0cmV0dXJuIHJvb3Q7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgY3VycmVjdCBDU1Mgc291cmNlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHNvdXJjZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc291cmNlIHx8IHRoaXMucm9vdCgpLl9zb3VyY2U7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgc2VjdGlvbiBuYW1lXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdG5hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuX25hbWUgPT09IG51bGwpIHtcblx0XHRcdFx0dmFyIHJhbmdlID0gdGhpcy5uYW1lUmFuZ2UoKTtcblx0XHRcdFx0aWYgKHJhbmdlKSB7XG5cdFx0XHRcdFx0dGhpcy5fbmFtZSA9IHJhbmdlLnN1YnN0cmluZyh0aGlzLnNvdXJjZSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5fbmFtZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBzZWN0aW9uIG5hbWUgcmFuZ2Vcblx0XHQgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cblx0XHQgKi9cblx0XHRuYW1lUmFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMucmFuZ2UgJiYgJ19zZWxlY3RvckVuZCcgaW4gdGhpcy5yYW5nZSkge1xuXHRcdFx0XHRyZXR1cm4gcmFuZ2UuY3JlYXRlMih0aGlzLnJhbmdlLnN0YXJ0LCB0aGlzLnJhbmdlLl9zZWxlY3RvckVuZCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgZGVlcGVzdCBjaGlsZCBvZiBjdXJyZW50IHNlY3Rpb24gKG9yIHNlY3Rpb24gaXRzZWxmKSBcblx0XHQgKiB3aGljaCBpbmNsdWRlcyBnaXZlbiBwb3NpdGlvbi5cblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHBvc1xuXHRcdCAqIEByZXR1cm4ge0NTU1NlY3Rpb259XG5cdFx0ICovXG5cdFx0bWF0Y2hEZWVwOiBmdW5jdGlvbihwb3MpIHtcblx0XHRcdGlmICghdGhpcy5yYW5nZS5pbnNpZGUocG9zKSkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGgsIG07IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdG0gPSB0aGlzLmNoaWxkcmVuW2ldLm1hdGNoRGVlcChwb3MpO1xuXHRcdFx0XHRpZiAobSkge1xuXHRcdFx0XHRcdHJldHVybiBtO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzIDogbnVsbDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBjdXJyZW50IGFuZCBhbGwgbmVzdGVkIHNlY3Rpb25zIHJhbmdlc1xuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxuXHRcdCAqL1xuXHRcdGFsbFJhbmdlczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb3V0ID0gW107XG5cdFx0XHRpZiAodGhpcy5wYXJlbnQpIHtcblx0XHRcdFx0Ly8gYWRkIGN1cnJlbnQgcmFuZ2UgaWYgaXQgaXMgbm90IHJvb3Qgbm9kZVxuXHRcdFx0XHRvdXQucHVzaCh0aGlzLnJhbmdlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0XHRcdG91dCA9IG91dC5jb25jYXQoY2hpbGQuYWxsUmFuZ2VzKCkpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fSxcblxuXHRcdGRhdGE6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGFba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5fZGF0YVtrZXldO1xuXHRcdH0sXG5cblx0XHRzdHJpbmdpZnk6IGZ1bmN0aW9uKGluZGVudCkge1xuXHRcdFx0aW5kZW50ID0gaW5kZW50IHx8ICcnO1xuXHRcdFx0dmFyIG91dCA9ICcnO1xuXHRcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0b3V0ICs9IGluZGVudCArIGl0ZW0ubmFtZSgpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSArICdcXG4nO1xuXHRcdFx0XHRvdXQgKz0gaXRlbS5zdHJpbmdpZnkoaW5kZW50ICsgJy0tJyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBjdXJyZW50IHNlY3Rpb27igJlzIGFjdHVhbCBjb250ZW50LFxuXHRcdCAqIGUuZy4gY29udGVudCB3aXRob3V0IG5lc3RlZCBzZWN0aW9uc1xuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gXG5cdFx0ICovXG5cdFx0Y29udGVudDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5fY29udGVudCAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLnJhbmdlIHx8ICEoJ19jb250ZW50U3RhcnQnIGluIHRoaXMucmFuZ2UpKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH1cblxuXHRcdFx0dmFyIHIgPSByYW5nZS5jcmVhdGUyKHRoaXMucmFuZ2UuX2NvbnRlbnRTdGFydCArIDEsIHRoaXMucmFuZ2UuZW5kIC0gMSk7XG5cdFx0XHR2YXIgc291cmNlID0gdGhpcy5zb3VyY2UoKTtcblx0XHRcdHZhciBzdGFydCA9IHIuc3RhcnQ7XG5cdFx0XHR2YXIgb3V0ID0gJyc7XG5cblx0XHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0XHRvdXQgKz0gc291cmNlLnN1YnN0cmluZyhzdGFydCwgY2hpbGQucmFuZ2Uuc3RhcnQpO1xuXHRcdFx0XHRzdGFydCA9IGNoaWxkLnJhbmdlLmVuZDtcblx0XHRcdH0pO1xuXG5cdFx0XHRvdXQgKz0gc291cmNlLnN1YnN0cmluZyhzdGFydCwgci5lbmQpO1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQgPSB1dGlscy50cmltKG91dCk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogRmluZHMgYWxsIENTUyBydWxlc+KAmCByYW5nZXMgaW4gZ2l2ZW4gQ1NTIHNvdXJjZVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gY29udGVudCBDU1Mgc291cmNlXG5cdFx0ICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIHJhbmdlc1xuXHRcdCAqL1xuXHRcdGZpbmRBbGxSdWxlczogZnVuY3Rpb24oY29udGVudCkge1xuXHRcdFx0Y29udGVudCA9IHRoaXMuc2FuaXRpemUoY29udGVudCk7XG5cdFx0XHR2YXIgc3RyZWFtID0gc3RyaW5nU3RyZWFtKGNvbnRlbnQpO1xuXHRcdFx0dmFyIHJhbmdlcyA9IFtdLCBtYXRjaGVkUmFuZ2VzO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHR2YXIgc2F2ZVJ1bGUgPSBmdW5jdGlvbihyKSB7XG5cdFx0XHRcdHZhciBzZWxSYW5nZSA9IHNlbGYuZXh0cmFjdFNlbGVjdG9yKGNvbnRlbnQsIHIuc3RhcnQpO1xuXHRcdFx0XHR2YXIgcnVsZSA9IHJhbmdlLmNyZWF0ZTIoc2VsUmFuZ2Uuc3RhcnQsIHIuZW5kKTtcblx0XHRcdFx0cnVsZS5fc2VsZWN0b3JFbmQgPSBzZWxSYW5nZS5lbmQ7XG5cdFx0XHRcdHJ1bGUuX2NvbnRlbnRTdGFydCA9IHIuc3RhcnQ7XG5cdFx0XHRcdHJhbmdlcy5wdXNoKHJ1bGUpO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGNoO1xuXHRcdFx0d2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuXHRcdFx0XHRpZiAoaXNRdW90ZShjaCkpIHtcblx0XHRcdFx0XHRpZiAoIXN0cmVhbS5za2lwU3RyaW5nKGNoKSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIHVudGVybWluYXRlZCBzdHJpbmdcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjaCA9PSAneycpIHtcblx0XHRcdFx0XHRtYXRjaGVkUmFuZ2VzID0gdGhpcy5tYXRjaEJyYWNlc1Jhbmdlcyhjb250ZW50LCBzdHJlYW0ucG9zIC0gMSk7XG5cdFx0XHRcdFx0bWF0Y2hlZFJhbmdlcy5mb3JFYWNoKHNhdmVSdWxlKTtcblxuXHRcdFx0XHRcdGlmIChtYXRjaGVkUmFuZ2VzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0c3RyZWFtLnBvcyA9IHV0aWxzLmxhc3QobWF0Y2hlZFJhbmdlcykuZW5kO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fSBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmFuZ2VzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTWF0Y2hlcyBjdXJseSBicmFjZXMgY29udGVudCByaWdodCBhZnRlciBnaXZlbiBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gY29udGVudCBDU1MgY29udGVudC4gTXVzdCBub3QgY29udGFpbiBjb21tZW50cyFcblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHBvcyAgICAgU2VhcmNoIHN0YXJ0IHBvc2l0aW9uXG5cdFx0ICogQHJldHVybiB7UmFuZ2V9XG5cdFx0ICovXG5cdFx0bWF0Y2hCcmFjZXNSYW5nZXM6IGZ1bmN0aW9uKGNvbnRlbnQsIHBvcywgc2FuaXRpemUpIHtcblx0XHRcdGlmIChzYW5pdGl6ZSkge1xuXHRcdFx0XHRjb250ZW50ID0gdGhpcy5zYW5pdGl6ZShjb250ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHN0cmVhbSA9IHN0cmluZ1N0cmVhbShjb250ZW50KTtcblx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3MgPSBwb3M7XG5cdFx0XHR2YXIgc3RhY2sgPSBbXSwgcmFuZ2VzID0gW107XG5cdFx0XHR2YXIgY2g7XG5cdFx0XHR3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG5cdFx0XHRcdGlmIChjaCA9PSAneycpIHtcblx0XHRcdFx0XHRzdGFjay5wdXNoKHN0cmVhbS5wb3MgLSAxKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSAnfScpIHtcblx0XHRcdFx0XHRpZiAoIXN0YWNrLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dGhyb3cgJ0ludmFsaWQgc291cmNlIHN0cnVjdHVyZSAoY2hlY2sgZm9yIGN1cmx5IGJyYWNlcyknO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyYW5nZXMucHVzaChyYW5nZS5jcmVhdGUyKHN0YWNrLnBvcCgpLCBzdHJlYW0ucG9zKSk7XG5cdFx0XHRcdFx0aWYgKCFzdGFjay5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiByYW5nZXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0cmVhbS5za2lwUXVvdGVkKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJhbmdlcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRXh0cmFjdHMgQ1NTIHNlbGVjdG9yIGZyb20gQ1NTIGRvY3VtZW50IGZyb21cblx0XHQgKiBnaXZlbiBwb3NpdGlvbi4gVGhlIHNlbGVjdG9yIGlzIGxvY2F0ZWQgYnkgbW92aW5nIGJhY2t3YXJkXG5cdFx0ICogZnJvbSBnaXZlbiBwb3NpdGlvbiB3aGljaCBtZWFucyB0aGF0IHBhc3NlZCBwb3NpdGlvblxuXHRcdCAqIG11c3QgcG9pbnQgdG8gdGhlIGVuZCBvZiBzZWxlY3RvciBcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9ICBjb250ZW50IENTUyBzb3VyY2Vcblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9ICBwb3MgICAgIFNlYXJjaCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IHNhbml0aXplIFNhbml0aXplIENTUyBzb3VyY2UgYmVmb3JlIHByb2Nlc3NpbmcuXG5cdFx0ICogT2ZmIGJ5IGRlZmF1bHQgYW5kIGFzc3VtZXMgdGhhdCBDU1MgbXVzdCBiZSBjb21tZW50LWZyZWUgYWxyZWFkeVxuXHRcdCAqIChmb3IgcGVyZm9ybWFuY2UpXG5cdFx0ICogQHJldHVybiB7UmFuZ2V9XG5cdFx0ICovXG5cdFx0ZXh0cmFjdFNlbGVjdG9yOiBmdW5jdGlvbihjb250ZW50LCBwb3MsIHNhbml0aXplKSB7XG5cdFx0XHRpZiAoc2FuaXRpemUpIHtcblx0XHRcdFx0Y29udGVudCA9IHRoaXMuc2FuaXRpemUoY29udGVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBza2lwU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdW90ZSA9IGNvbnRlbnQuY2hhckF0KHBvcyk7XG5cdFx0XHRcdGlmIChxdW90ZSA9PSAnXCInIHx8IHF1b3RlID09IFwiJ1wiKSB7XG5cdFx0XHRcdFx0d2hpbGUgKC0tcG9zID49IDApIHtcblx0XHRcdFx0XHRcdGlmIChjb250ZW50LmNoYXJBdChwb3MpID09IHF1b3RlICYmIGNvbnRlbnQuY2hhckF0KHBvcyAtIDEpICE9ICdcXFxcJykge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBmaW5kIENTUyBzZWxlY3RvclxuXHRcdFx0dmFyIGNoO1xuXHRcdFx0dmFyIGVuZFBvcyA9IHBvcztcblx0XHRcdHdoaWxlICgtLXBvcyA+PSAwKSB7XG5cdFx0XHRcdGlmIChza2lwU3RyaW5nKCkpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGNoID0gY29udGVudC5jaGFyQXQocG9zKTtcblx0XHRcdFx0aWYgKGNoID09ICcpJykge1xuXHRcdFx0XHRcdC8vIGxvb2tzIGxpa2UgaXTigJlzIGEgcHJlcHJvY2Vzc29yIHRoaW5nLFxuXHRcdFx0XHRcdC8vIG1vc3QgbGlrZWx5IGEgbWl4aW4gYXJndW1lbnRzIGxpc3QsIGUuZy5cblx0XHRcdFx0XHQvLyAubWl4aW4gKEBhcmcxOyBAYXJnMikgey4uLn1cblx0XHRcdFx0XHR3aGlsZSAoLS1wb3MgPj0gMCkge1xuXHRcdFx0XHRcdFx0aWYgKHNraXBTdHJpbmcoKSkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdGlmIChjb250ZW50LmNoYXJBdChwb3MpID09ICcoJykge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY2ggPT0gJ3snIHx8IGNoID09ICd9JyB8fCBjaCA9PSAnOycpIHtcblx0XHRcdFx0XHRwb3MrKztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocG9zIDwgMCkge1xuXHRcdFx0XHRwb3MgPSAwO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSBjb250ZW50LnN1YnN0cmluZyhwb3MsIGVuZFBvcyk7XG5cblx0XHRcdC8vIHRyaW0gd2hpdGVzcGFjZSBmcm9tIG1hdGNoZWQgc2VsZWN0b3Jcblx0XHRcdHZhciBtID0gc2VsZWN0b3IucmVwbGFjZShyZVNwYWNlLCAnICcpLm1hdGNoKHJlU3BhY2VUcmltKTtcblx0XHRcdGlmIChtKSB7XG5cdFx0XHRcdHBvcyArPSBtWzFdLmxlbmd0aDtcblx0XHRcdFx0ZW5kUG9zIC09IG1bMl0ubGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmFuZ2UuY3JlYXRlMihwb3MsIGVuZFBvcyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNlYXJjaCBmb3IgbmVhcmVzdCBDU1MgcnVsZS9zZWN0aW9uIHRoYXQgY29udGFpbnNcblx0XHQgKiBnaXZlbiBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gY29udGVudCBDU1MgY29udGVudCBvciBtYXRjaGVkIENTUyBydWxlcyAoYXJyYXkgb2YgcmFuZ2VzKVxuXHRcdCAqIEBwYXJhbSAge051bWJlcn0gcG9zICAgICBTZWFyY2ggcG9zaXRpb25cblx0XHQgKiBAcmV0dXJuIHtSYW5nZX1cblx0XHQgKi9cblx0XHRtYXRjaEVuY2xvc2luZ1J1bGU6IGZ1bmN0aW9uKGNvbnRlbnQsIHBvcykge1xuXHRcdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRjb250ZW50ID0gdGhpcy5maW5kQWxsUnVsZXMoY29udGVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBydWxlcyA9IGNvbnRlbnQuZmlsdGVyKGZ1bmN0aW9uKHIpIHtcblx0XHRcdFx0cmV0dXJuIHIuaW5zaWRlKHBvcyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHV0aWxzLmxhc3QocnVsZXMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBMb2NhdGVzIENTUyBydWxlIG5leHQgb3IgYmVmb3JlIGdpdmVuIHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSAgY29udGVudCAgICBDU1MgY29udGVudFxuXHRcdCAqIEBwYXJhbSAge051bWJlcn0gIHBvcyAgICAgICAgU2VhcmNoIHN0YXJ0IHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gaXNCYWNrd2FyZCBTZWFyY2ggYmFja3dhcmQgKGZpbmQgcHJldmlvdXMgcnVsZSBpbnN0ZWFmIG9mIG5leHQgb25lKVxuXHRcdCAqIEByZXR1cm4ge1JhbmdlfVxuXHRcdCAqL1xuXHRcdGxvY2F0ZVJ1bGU6IGZ1bmN0aW9uKGNvbnRlbnQsIHBvcywgaXNCYWNrd2FyZCkge1xuXHRcdFx0Ly8gcG9zc2libGUgY2FzZTogZWRpdG9yIHJlcG9ydGVkIHRoYXQgY3VycmVudCBzeW50YXggaXNcblx0XHRcdC8vIENTUywgYnV0IGl04oCZcyBhY3R1YWxseSBhIEhUTUwgZG9jdW1lbnQgKGVpdGhlciBgc3R5bGVgIHRhZyBvciBhdHRyaWJ1dGUpXG5cdFx0XHR2YXIgb2Zmc2V0ID0gMDtcblx0XHRcdHZhciBzdWJyYW5nZSA9IHRoaXMuc3R5bGVUYWdSYW5nZShjb250ZW50LCBwb3MpO1xuXHRcdFx0aWYgKHN1YnJhbmdlKSB7XG5cdFx0XHRcdG9mZnNldCA9IHN1YnJhbmdlLnN0YXJ0O1xuXHRcdFx0XHRwb3MgLT0gc3VicmFuZ2Uuc3RhcnQ7XG5cdFx0XHRcdGNvbnRlbnQgPSBzdWJyYW5nZS5zdWJzdHJpbmcoY29udGVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBydWxlcyA9IHRoaXMuZmluZEFsbFJ1bGVzKGNvbnRlbnQpO1xuXHRcdFx0dmFyIGN0eFJ1bGUgPSB0aGlzLm1hdGNoRW5jbG9zaW5nUnVsZShydWxlcywgcG9zKTtcblxuXHRcdFx0aWYgKGN0eFJ1bGUpIHtcblx0XHRcdFx0cmV0dXJuIGN0eFJ1bGUuc2hpZnQob2Zmc2V0KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGlsID0gcnVsZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRpZiAocnVsZXNbaV0uc3RhcnQgPiBwb3MpIHtcblx0XHRcdFx0XHRyZXR1cm4gcnVsZXNbaXNCYWNrd2FyZCAmJiBpID4gMCA/IGkgLSAxIDogaV0uc2hpZnQob2Zmc2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTYW5pdGl6ZXMgZ2l2ZW4gQ1NTIGNvbnRlbnQ6IHJlcGxhY2VzIGNvbnRlbnQgdGhhdCBtYXkgXG5cdFx0ICogaW50ZXJmZXJlIHdpdGggcGFyc2luZyAoY29tbWVudHMsIGludGVycG9sYXRpb25zLCBldGMuKVxuXHRcdCAqIHdpdGggc3BhY2VzLiBTYW5pdGl6ZWQgY29udGVudCBNVVNUIE5PVCBiZSB1c2VkIGZvclxuXHRcdCAqIGVkaXRpbmcgb3Igb3V0cHV0dGluZywgaXQganVzdCBzaW1wbGlmaWVzIHNlYXJjaGluZ1xuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gY29udGVudCBDU1MgY29udGVudFxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRzYW5pdGl6ZTogZnVuY3Rpb24oY29udGVudCkge1xuXHRcdFx0Y29udGVudCA9IGNvbW1lbnRzVXRpbHMuc3RyaXAoY29udGVudCk7XG5cblx0XHRcdC8vIHJlbW92ZSBwcmVwcm9jZXNzb3Igc3RyaW5nIGludGVycG9sYXRpb25zIGxpa2UgI3t2YXJ9XG5cdFx0XHR2YXIgc3RyZWFtID0gc3RyaW5nU3RyZWFtKGNvbnRlbnQpO1xuXHRcdFx0dmFyIHJlcGxhY2VSYW5nZXMgPSBbXTtcblx0XHRcdHZhciBjaCwgY2gyO1xuXG5cdFx0XHR3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkpIHtcblx0XHRcdFx0aWYgKGlzUXVvdGUoY2gpKSB7XG5cdFx0XHRcdFx0Ly8gc2tpcCBzdHJpbmdcblx0XHRcdFx0XHRzdHJlYW0uc2tpcFN0cmluZyhjaClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PT0gJyMnIHx8IGNoID09PSAnQCcpIHtcblx0XHRcdFx0XHRjaDIgPSBzdHJlYW0ucGVlaygpO1xuXHRcdFx0XHRcdGlmIChjaDIgPT09ICd7JykgeyAvLyBzdHJpbmcgaW50ZXJwb2xhdGlvblxuXHRcdFx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcyAtIDE7XG5cblx0XHRcdFx0XHRcdGlmIChzdHJlYW0uc2tpcFRvKCd9JykpIHtcblx0XHRcdFx0XHRcdFx0c3RyZWFtLnBvcyArPSAxO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgJ0ludmFsaWQgc3RyaW5nIGludGVycG9sYXRpb24gYXQgJyArIHN0cmVhbS5zdGFydDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmVwbGFjZVJhbmdlcy5wdXNoKFtzdHJlYW0uc3RhcnQsIHN0cmVhbS5wb3NdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHV0aWxzLnJlcGxhY2VXaXRoKGNvbnRlbnQsIHJlcGxhY2VSYW5nZXMsICdhJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBhcnNlcyBhbmQgcmV0dXJucyBhbGwgc2VjdGlvbnMgaW4gZ2l2ZW4gQ1NTXG5cdFx0ICogYXMgdHJlZS1saWtlIHN0cnVjdHVyZSwgZS5nLiBwcm92aWRlcyBuZXN0aW5nXG5cdFx0ICogaW5mb1xuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gY29udGVudCBDU1MgY29udGVudFxuXHRcdCAqIEByZXR1cm4ge0NTU1NlY3Rpb259XG5cdFx0ICovXG5cdFx0c2VjdGlvblRyZWU6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcblx0XHRcdHZhciByb290ID0gbmV3IENTU1NlY3Rpb24obnVsbCwgY29udGVudCk7XG5cdFx0XHR2YXIgcnVsZXMgPSB0aGlzLmZpbmRBbGxSdWxlcyhjb250ZW50KTtcblxuXHRcdFx0Ly8gcnVsZXMgYXJlIHNvcnRlZCBpbiBvcmRlciB0aGV5IGFwcGVhciBpbiBDU1Mgc291cmNlXG5cdFx0XHQvLyBzbyB3ZSBjYW4gb3B0aW1pemUgdGhlaXIgbmVzdGluZyByb3V0aW5lXG5cdFx0XHR2YXIgaW5zZXJ0ID0gZnVuY3Rpb24ocmFuZ2UsIGN0eCkge1xuXHRcdFx0XHR3aGlsZSAoY3R4ICYmIGN0eC5yYW5nZSkge1xuXHRcdFx0XHRcdGlmIChjdHgucmFuZ2UuY29udGFpbnMocmFuZ2UpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY3R4LmFkZENoaWxkKHJhbmdlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdHggPSBjdHgucGFyZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgd2UgYXJlIGhlcmUgdGhlbiBnaXZlbiByYW5nZSBpcyBhIHRvcC1sZXZlbCBzZWN0aW9uXG5cdFx0XHRcdHJldHVybiByb290LmFkZENoaWxkKHJhbmdlKTtcblx0XHRcdH07XG5cblx0XHRcdHZhciBjdHggPSByb290O1xuXHRcdFx0cnVsZXMuZm9yRWFjaChmdW5jdGlvbihyKSB7XG5cdFx0XHRcdGN0eCA9IGluc2VydChyLCBjdHgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiByb290O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHJhbmdlcyBmb3IgYWxsIG5lc3RlZCBzZWN0aW9ucywgYXZhaWxhYmxlIGluXG5cdFx0ICogZ2l2ZW4gQ1NTIHJ1bGVcblx0XHQgKiBAcGFyYW0gIHtDU1NFZGl0Q29udGFpbmVyfSBydWxlXG5cdFx0ICogQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdFx0bmVzdGVkU2VjdGlvbnNJblJ1bGU6IGZ1bmN0aW9uKHJ1bGUpIHtcblx0XHRcdHZhciBvZmZzZXQgPSBydWxlLnZhbHVlUmFuZ2UodHJ1ZSkuc3RhcnQ7XG5cdFx0XHR2YXIgbmVzdGVkU2VjdGlvbnMgPSB0aGlzLmZpbmRBbGxSdWxlcyhydWxlLnZhbHVlUmFuZ2UoKS5zdWJzdHJpbmcocnVsZS5zb3VyY2UpKTtcblx0XHRcdG5lc3RlZFNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VjdGlvbikge1xuXHRcdFx0XHRzZWN0aW9uLnN0YXJ0ICs9IG9mZnNldDtcblx0XHRcdFx0c2VjdGlvbi5lbmQgKz0gb2Zmc2V0O1xuXHRcdFx0XHRzZWN0aW9uLl9zZWxlY3RvckVuZCArPSBvZmZzZXQ7XG5cdFx0XHRcdHNlY3Rpb24uX2NvbnRlbnRTdGFydCArPSBvZmZzZXQ7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBuZXN0ZWRTZWN0aW9ucztcblx0XHR9LFxuXG5cdFx0c3R5bGVUYWdSYW5nZTogZnVuY3Rpb24oY29udGVudCwgcG9zKSB7XG5cdFx0XHR2YXIgdGFnID0gaHRtbE1hdGNoZXIudGFnKGNvbnRlbnQsIHBvcyk7XG5cdFx0XHRyZXR1cm4gdGFnICYmIHRhZy5vcGVuLm5hbWUudG9Mb3dlckNhc2UoKSA9PSAnc3R5bGUnIFxuXHRcdFx0XHQmJiB0YWcuaW5uZXJSYW5nZS5jbXAocG9zLCAnbHRlJywgJ2d0ZScpXG5cdFx0XHRcdCYmIHRhZy5pbm5lclJhbmdlO1xuXHRcdH0sXG5cblx0XHRzdHlsZUF0dHJSYW5nZTogZnVuY3Rpb24oY29udGVudCwgcG9zKSB7XG5cdFx0XHR2YXIgdHJlZSA9IHhtbEVkaXRUcmVlLnBhcnNlRnJvbVBvc2l0aW9uKGNvbnRlbnQsIHBvcywgdHJ1ZSk7XG5cdFx0XHRpZiAodHJlZSkge1xuXHRcdFx0XHR2YXIgYXR0ciA9IHRyZWUuaXRlbUZyb21Qb3NpdGlvbihwb3MsIHRydWUpO1xuXHRcdFx0XHRyZXR1cm4gYXR0ciAmJiBhdHRyLm5hbWUoKS50b0xvd2VyQ2FzZSgpID09ICdzdHlsZScgXG5cdFx0XHRcdFx0JiYgYXR0ci52YWx1ZVJhbmdlKHRydWUpLmNtcChwb3MsICdsdGUnLCAnZ3RlJylcblx0XHRcdFx0XHQmJiBhdHRyLnZhbHVlUmFuZ2UodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdENTU1NlY3Rpb246IENTU1NlY3Rpb25cblx0fTtcbn0pO1xufSx7XCIuLi9hc3NldHMvaHRtbE1hdGNoZXJcIjpcImFzc2V0c1xcXFxodG1sTWF0Y2hlci5qc1wiLFwiLi4vYXNzZXRzL3JhbmdlXCI6XCJhc3NldHNcXFxccmFuZ2UuanNcIixcIi4uL2Fzc2V0cy9zdHJpbmdTdHJlYW1cIjpcImFzc2V0c1xcXFxzdHJpbmdTdHJlYW0uanNcIixcIi4uL2VkaXRUcmVlL3htbFwiOlwiZWRpdFRyZWVcXFxceG1sLmpzXCIsXCIuLi9wYXJzZXIvY3NzXCI6XCJwYXJzZXJcXFxcY3NzLmpzXCIsXCIuL2NvbW1lbnRzXCI6XCJ1dGlsc1xcXFxjb21tZW50cy5qc1wiLFwiLi9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wifV0sXCJ1dGlsc1xcXFxlZGl0b3IuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHVzZWQgdG8gcHJlcGFyZSB0ZXh0IGZvciBwYXN0aW5nIGludG8gYmFjay1lbmQgZWRpdG9yXG4gKiBAYXV0aG9yIFNlcmdleSBDaGlrdXlvbm9rIChzZXJnZS5jaGVAZ21haWwuY29tKSA8aHR0cDovL2NoaWt1eW9ub2sucnU+XG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cdHZhciByZXNvdXJjZXMgPSByZXF1aXJlKCcuLi9hc3NldHMvcmVzb3VyY2VzJyk7XG5cblx0cmV0dXJuICB7XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgY3Vyc29yIGlzIHBsYWNlZCBpbnNpZGUgWEhUTUwgdGFnXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgQ29udGVudHMgb2YgdGhlIGRvY3VtZW50XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGNhcmV0UG9zIEN1cnJlbnQgY2FyZXQgcG9zaXRpb24gaW5zaWRlIHRhZ1xuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNJbnNpZGVUYWc6IGZ1bmN0aW9uKGh0bWwsIGNhcmV0UG9zKSB7XG5cdFx0XHR2YXIgcmVUYWcgPSAvXjxcXC8/XFx3W1xcd1xcOlxcLV0qLio/Pi87XG5cdFx0XHRcblx0XHRcdC8vIHNlYXJjaCBsZWZ0IHRvIGZpbmQgb3BlbmluZyBicmFjZVxuXHRcdFx0dmFyIHBvcyA9IGNhcmV0UG9zO1xuXHRcdFx0d2hpbGUgKHBvcyA+IC0xKSB7XG5cdFx0XHRcdGlmIChodG1sLmNoYXJBdChwb3MpID09ICc8JykgXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdHBvcy0tO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAocG9zICE9IC0xKSB7XG5cdFx0XHRcdHZhciBtID0gcmVUYWcuZXhlYyhodG1sLnN1YnN0cmluZyhwb3MpKTtcblx0XHRcdFx0aWYgKG0gJiYgY2FyZXRQb3MgPiBwb3MgJiYgY2FyZXRQb3MgPCBwb3MgKyBtWzBdLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2FuaXRpemVzIGluY29taW5nIGVkaXRvciBkYXRhIGFuZCBwcm92aWRlcyBkZWZhdWx0IHZhbHVlcyBmb3Jcblx0XHQgKiBvdXRwdXQtc3BlY2lmaWMgaW5mb1xuXHRcdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGVcblx0XHQgKi9cblx0XHRvdXRwdXRJbmZvOiBmdW5jdGlvbihlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSkge1xuXHRcdFx0Ly8gbW9zdCBvZiB0aGlzIGNvZGUgbWFrZXMgc2Vuc2UgZm9yIEphdmEvUmhpbm8gZW52aXJvbm1lbnRcblx0XHRcdC8vIGJlY2F1c2Ugc3RyaW5nIHRoYXQgY29tZXMgZnJvbSBKYXZhIGFyZSBub3QgYWN0dWFsbHkgSlMgc3RyaW5nXG5cdFx0XHQvLyBidXQgSmF2YSBTdHJpbmcgb2JqZWN0IHNvIHRoZSBoYXZlIHRvIGJlIGV4cGxpY2l0bHkgY29udmVydGVkXG5cdFx0XHQvLyB0byBuYXRpdmUgc3RyaW5nXG5cdFx0XHRwcm9maWxlID0gcHJvZmlsZSB8fCBlZGl0b3IuZ2V0UHJvZmlsZU5hbWUoKTtcblx0XHRcdHJldHVybiAge1xuXHRcdFx0XHQvKiogQG1lbWJlck9mIG91dHB1dEluZm8gKi9cblx0XHRcdFx0c3ludGF4OiBTdHJpbmcoc3ludGF4IHx8IGVkaXRvci5nZXRTeW50YXgoKSksXG5cdFx0XHRcdHByb2ZpbGU6IHByb2ZpbGUgfHwgbnVsbCxcblx0XHRcdFx0Y29udGVudDogU3RyaW5nKGVkaXRvci5nZXRDb250ZW50KCkpXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVW5pbmRlbnQgY29udGVudCwgdGh1cyBwcmVwYXJpbmcgdGV4dCBmb3IgdGFnIHdyYXBwaW5nXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvciBFZGl0b3IgaW5zdGFuY2Vcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHR1bmluZGVudDogZnVuY3Rpb24oZWRpdG9yLCB0ZXh0KSB7XG5cdFx0XHRyZXR1cm4gdXRpbHMudW5pbmRlbnRTdHJpbmcodGV4dCwgdGhpcy5nZXRDdXJyZW50TGluZVBhZGRpbmcoZWRpdG9yKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHBhZGRpbmcgb2YgY3VycmVudCBlZGl0b3IncyBsaW5lXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IEVkaXRvciBpbnN0YW5jZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRDdXJyZW50TGluZVBhZGRpbmc6IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0cmV0dXJuIHV0aWxzLmdldExpbmVQYWRkaW5nKGVkaXRvci5nZXRDdXJyZW50TGluZSgpKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTm9ybWFsaXplcyBjb250ZW50IGFjY29yZGluZyB0byBnaXZlbiBwcmVmZXJlbmNlcywgZS5nLlxuXHRcdCAqIHJlcGxhY2VzIG5ld2xpbmVzIGFuZCBpbmRlbnRhdGlvbiB3aXRoIG9uZXMgZGVmaW5lZCBpblxuXHRcdCAqIGBvcHRpb25zYC4gSWYgb3B0aW9ucyBhcmUgbm90IHByb3ZpZGVkIG9yIGluY29tcGxldGUsIFxuXHRcdCAqIHZhbHVlcyB3aWxsIGJlIHRha2VuIGZyb20gY3VycmVudCB1c2VyIGVudmlyb25tZW50XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRub3JtYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSB1dGlscy5leHRlbmQoe1xuXHRcdFx0XHRuZXdsaW5lOiByZXNvdXJjZXMuZ2V0TmV3bGluZSgpLFxuXHRcdFx0XHRpbmRlbnRhdGlvbjogcmVzb3VyY2VzLmdldFZhcmlhYmxlKCdpbmRlbnRhdGlvbicpXG5cdFx0XHR9LCBvcHRpb25zKTtcblxuXHRcdFx0dmFyIGluZGVudCA9IGZ1bmN0aW9uKHRhYnMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzLnJlcGVhdFN0cmluZyhvcHRpb25zLmluZGVudGF0aW9uLCB0YWJzLmxlbmd0aCk7XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgbGluZXMgPSB1dGlscy5zcGxpdEJ5TGluZXModGV4dCk7XG5cblx0XHRcdC8vIG5vcm1haWx6ZSBpbmRlbnRhdGlvbiBpZiBpdOKAmXMgbm90IHRhYnNcblx0XHRcdGlmIChvcHRpb25zLmluZGVudGF0aW9uICE9PSAnXFx0Jykge1xuXHRcdFx0XHRsaW5lcyA9IGxpbmVzLm1hcChmdW5jdGlvbihsaW5lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxpbmUucmVwbGFjZSgvXlxccysvLCBmdW5jdGlvbihzcGFjZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNwYWNlLnJlcGxhY2UoL1xcdC9nLCBpbmRlbnQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbm9ybWFsaXplIG5ld2xpbmVzXG5cdFx0XHRyZXR1cm4gbGluZXMuam9pbihvcHRpb25zLm5ld2xpbmUpO1xuXHRcdH1cblx0fTtcbn0pO1xuXG59LHtcIi4uL2Fzc2V0cy9yZXNvdXJjZXNcIjpcImFzc2V0c1xcXFxyZXNvdXJjZXMuanNcIixcIi4vY29tbW9uXCI6XCJ1dGlsc1xcXFxjb21tb24uanNcIn1dLFwidXRpbHNcXFxcbWF0aC5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdC8qXG5cdCBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaWxlbnRtYXR0L2pzLWV4cHJlc3Npb24tZXZhbFxuXG5cdCBCYXNlZCBvbiBuZGVmLnBhcnNlciwgYnkgUmFwaGFlbCBHcmFmKHJAdW5kZWZpbmVkLmNoKVxuXHQgaHR0cDovL3d3dy51bmRlZmluZWQuY2gvbXBhcnNlci9pbmRleC5odG1sXG5cblx0IFBvcnRlZCB0byBKYXZhU2NyaXB0IGFuZCBtb2RpZmllZCBieSBNYXR0aGV3IENydW1sZXkgKGVtYWlsQG1hdHRoZXdjcnVtbGV5LmNvbSwgaHR0cDovL3NpbGVudG1hdHQuY29tLylcblxuXHQgWW91IGFyZSBmcmVlIHRvIHVzZSBhbmQgbW9kaWZ5IHRoaXMgY29kZSBpbiBhbnl3YXkgeW91IGZpbmQgdXNlZnVsLiBQbGVhc2UgbGVhdmUgdGhpcyBjb21tZW50IGluIHRoZSBjb2RlXG5cdCB0byBhY2tub3dsZWRnZSBpdHMgb3JpZ2luYWwgc291cmNlLiBJZiB5b3UgZmVlbCBsaWtlIGl0LCBJIGVuam95IGhlYXJpbmcgYWJvdXQgcHJvamVjdHMgdGhhdCB1c2UgbXkgY29kZSxcblx0IGJ1dCBkb24ndCBmZWVsIGxpa2UgeW91IGhhdmUgdG8gbGV0IG1lIGtub3cgb3IgYXNrIHBlcm1pc3Npb24uXG5cdCovXG5cblx0ZnVuY3Rpb24gb2JqZWN0KG8pIHtcblx0XHRmdW5jdGlvbiBGKCkge31cblx0XHRGLnByb3RvdHlwZSA9IG87XG5cdFx0cmV0dXJuIG5ldyBGKCk7XG5cdH1cblxuXHR2YXIgVE5VTUJFUiA9IDA7XG5cdHZhciBUT1AxID0gMTtcblx0dmFyIFRPUDIgPSAyO1xuXHR2YXIgVFZBUiA9IDM7XG5cdHZhciBURlVOQ0FMTCA9IDQ7XG5cblx0ZnVuY3Rpb24gVG9rZW4odHlwZV8sIGluZGV4XywgcHJpb18sIG51bWJlcl8pIHtcblx0XHR0aGlzLnR5cGVfID0gdHlwZV87XG5cdFx0dGhpcy5pbmRleF8gPSBpbmRleF8gfHwgMDtcblx0XHR0aGlzLnByaW9fID0gcHJpb18gfHwgMDtcblx0XHR0aGlzLm51bWJlcl8gPSAobnVtYmVyXyAhPT0gdW5kZWZpbmVkICYmIG51bWJlcl8gIT09IG51bGwpID8gbnVtYmVyXyA6IDA7XG5cdFx0dGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHN3aXRjaCAodGhpcy50eXBlXykge1xuXHRcdFx0Y2FzZSBUTlVNQkVSOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5udW1iZXJfO1xuXHRcdFx0Y2FzZSBUT1AxOlxuXHRcdFx0Y2FzZSBUT1AyOlxuXHRcdFx0Y2FzZSBUVkFSOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5pbmRleF87XG5cdFx0XHRjYXNlIFRGVU5DQUxMOlxuXHRcdFx0XHRyZXR1cm4gXCJDQUxMXCI7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gXCJJbnZhbGlkIFRva2VuXCI7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIEV4cHJlc3Npb24odG9rZW5zLCBvcHMxLCBvcHMyLCBmdW5jdGlvbnMpIHtcblx0XHR0aGlzLnRva2VucyA9IHRva2Vucztcblx0XHR0aGlzLm9wczEgPSBvcHMxO1xuXHRcdHRoaXMub3BzMiA9IG9wczI7XG5cdFx0dGhpcy5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG5cdH1cblxuXHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3Lmpzb24ub3JnL2pzb24yLmpzXG4gICAgdmFyIGN4ID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcJ1xceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICBcIidcIiA6IFwiXFxcXCdcIixcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICB9O1xuXG5cdGZ1bmN0aW9uIGVzY2FwZVZhbHVlKHYpIHtcblx0XHRpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuXHQgICAgICAgIHJldHVybiBlc2NhcGFibGUudGVzdCh2KSA/XG5cdCAgICAgICAgICAgIFwiJ1wiICsgdi5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcblx0ICAgICAgICAgICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcblx0ICAgICAgICAgICAgfSkgKyBcIidcIiA6XG5cdCAgICAgICAgICAgIFwiJ1wiICsgdiArIFwiJ1wiO1xuXHRcdH1cblx0XHRyZXR1cm4gdjtcblx0fVxuXG5cdEV4cHJlc3Npb24ucHJvdG90eXBlID0ge1xuXHRcdHNpbXBsaWZ5OiBmdW5jdGlvbiAodmFsdWVzKSB7XG5cdFx0XHR2YWx1ZXMgPSB2YWx1ZXMgfHwge307XG5cdFx0XHR2YXIgbnN0YWNrID0gW107XG5cdFx0XHR2YXIgbmV3ZXhwcmVzc2lvbiA9IFtdO1xuXHRcdFx0dmFyIG4xO1xuXHRcdFx0dmFyIG4yO1xuXHRcdFx0dmFyIGY7XG5cdFx0XHR2YXIgTCA9IHRoaXMudG9rZW5zLmxlbmd0aDtcblx0XHRcdHZhciBpdGVtO1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IEw7IGkrKykge1xuXHRcdFx0XHRpdGVtID0gdGhpcy50b2tlbnNbaV07XG5cdFx0XHRcdHZhciB0eXBlXyA9IGl0ZW0udHlwZV87XG5cdFx0XHRcdGlmICh0eXBlXyA9PT0gVE5VTUJFUikge1xuXHRcdFx0XHRcdG5zdGFjay5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVfID09PSBUVkFSICYmIChpdGVtLmluZGV4XyBpbiB2YWx1ZXMpKSB7XG5cdFx0XHRcdFx0aXRlbSA9IG5ldyBUb2tlbihUTlVNQkVSLCAwLCAwLCB2YWx1ZXNbaXRlbS5pbmRleF9dKTtcblx0XHRcdFx0XHRuc3RhY2sucHVzaChpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0eXBlXyA9PT0gVE9QMiAmJiBuc3RhY2subGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdG4yID0gbnN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdG4xID0gbnN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdGYgPSB0aGlzLm9wczJbaXRlbS5pbmRleF9dO1xuXHRcdFx0XHRcdGl0ZW0gPSBuZXcgVG9rZW4oVE5VTUJFUiwgMCwgMCwgZihuMS5udW1iZXJfLCBuMi5udW1iZXJfKSk7XG5cdFx0XHRcdFx0bnN0YWNrLnB1c2goaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodHlwZV8gPT09IFRPUDEgJiYgbnN0YWNrLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRuMSA9IG5zdGFjay5wb3AoKTtcblx0XHRcdFx0XHRmID0gdGhpcy5vcHMxW2l0ZW0uaW5kZXhfXTtcblx0XHRcdFx0XHRpdGVtID0gbmV3IFRva2VuKFROVU1CRVIsIDAsIDAsIGYobjEubnVtYmVyXykpO1xuXHRcdFx0XHRcdG5zdGFjay5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHdoaWxlIChuc3RhY2subGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0bmV3ZXhwcmVzc2lvbi5wdXNoKG5zdGFjay5zaGlmdCgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3ZXhwcmVzc2lvbi5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAobnN0YWNrLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0bmV3ZXhwcmVzc2lvbi5wdXNoKG5zdGFjay5zaGlmdCgpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBFeHByZXNzaW9uKG5ld2V4cHJlc3Npb24sIG9iamVjdCh0aGlzLm9wczEpLCBvYmplY3QodGhpcy5vcHMyKSwgb2JqZWN0KHRoaXMuZnVuY3Rpb25zKSk7XG5cdFx0fSxcblxuXHRcdHN1YnN0aXR1dGU6IGZ1bmN0aW9uICh2YXJpYWJsZSwgZXhwcikge1xuXHRcdFx0aWYgKCEoZXhwciBpbnN0YW5jZW9mIEV4cHJlc3Npb24pKSB7XG5cdFx0XHRcdGV4cHIgPSBuZXcgUGFyc2VyKCkucGFyc2UoU3RyaW5nKGV4cHIpKTtcblx0XHRcdH1cblx0XHRcdHZhciBuZXdleHByZXNzaW9uID0gW107XG5cdFx0XHR2YXIgTCA9IHRoaXMudG9rZW5zLmxlbmd0aDtcblx0XHRcdHZhciBpdGVtO1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IEw7IGkrKykge1xuXHRcdFx0XHRpdGVtID0gdGhpcy50b2tlbnNbaV07XG5cdFx0XHRcdHZhciB0eXBlXyA9IGl0ZW0udHlwZV87XG5cdFx0XHRcdGlmICh0eXBlXyA9PT0gVFZBUiAmJiBpdGVtLmluZGV4XyA9PT0gdmFyaWFibGUpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGV4cHIudG9rZW5zLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHR2YXIgZXhwcml0ZW0gPSBleHByLnRva2Vuc1tqXTtcblx0XHRcdFx0XHRcdHZhciByZXBsaXRlbSA9IG5ldyBUb2tlbihleHByaXRlbS50eXBlXywgZXhwcml0ZW0uaW5kZXhfLCBleHByaXRlbS5wcmlvXywgZXhwcml0ZW0ubnVtYmVyXyk7XG5cdFx0XHRcdFx0XHRuZXdleHByZXNzaW9uLnB1c2gocmVwbGl0ZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRuZXdleHByZXNzaW9uLnB1c2goaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHJldCA9IG5ldyBFeHByZXNzaW9uKG5ld2V4cHJlc3Npb24sIG9iamVjdCh0aGlzLm9wczEpLCBvYmplY3QodGhpcy5vcHMyKSwgb2JqZWN0KHRoaXMuZnVuY3Rpb25zKSk7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0sXG5cblx0XHRldmFsdWF0ZTogZnVuY3Rpb24gKHZhbHVlcykge1xuXHRcdFx0dmFsdWVzID0gdmFsdWVzIHx8IHt9O1xuXHRcdFx0dmFyIG5zdGFjayA9IFtdO1xuXHRcdFx0dmFyIG4xO1xuXHRcdFx0dmFyIG4yO1xuXHRcdFx0dmFyIGY7XG5cdFx0XHR2YXIgTCA9IHRoaXMudG9rZW5zLmxlbmd0aDtcblx0XHRcdHZhciBpdGVtO1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IEw7IGkrKykge1xuXHRcdFx0XHRpdGVtID0gdGhpcy50b2tlbnNbaV07XG5cdFx0XHRcdHZhciB0eXBlXyA9IGl0ZW0udHlwZV87XG5cdFx0XHRcdGlmICh0eXBlXyA9PT0gVE5VTUJFUikge1xuXHRcdFx0XHRcdG5zdGFjay5wdXNoKGl0ZW0ubnVtYmVyXyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodHlwZV8gPT09IFRPUDIpIHtcblx0XHRcdFx0XHRuMiA9IG5zdGFjay5wb3AoKTtcblx0XHRcdFx0XHRuMSA9IG5zdGFjay5wb3AoKTtcblx0XHRcdFx0XHRmID0gdGhpcy5vcHMyW2l0ZW0uaW5kZXhfXTtcblx0XHRcdFx0XHRuc3RhY2sucHVzaChmKG4xLCBuMikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVfID09PSBUVkFSKSB7XG5cdFx0XHRcdFx0aWYgKGl0ZW0uaW5kZXhfIGluIHZhbHVlcykge1xuXHRcdFx0XHRcdFx0bnN0YWNrLnB1c2godmFsdWVzW2l0ZW0uaW5kZXhfXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKGl0ZW0uaW5kZXhfIGluIHRoaXMuZnVuY3Rpb25zKSB7XG5cdFx0XHRcdFx0XHRuc3RhY2sucHVzaCh0aGlzLmZ1bmN0aW9uc1tpdGVtLmluZGV4X10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuZGVmaW5lZCB2YXJpYWJsZTogXCIgKyBpdGVtLmluZGV4Xyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVfID09PSBUT1AxKSB7XG5cdFx0XHRcdFx0bjEgPSBuc3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0ZiA9IHRoaXMub3BzMVtpdGVtLmluZGV4X107XG5cdFx0XHRcdFx0bnN0YWNrLnB1c2goZihuMSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVfID09PSBURlVOQ0FMTCkge1xuXHRcdFx0XHRcdG4xID0gbnN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdGYgPSBuc3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0aWYgKGYuYXBwbHkgJiYgZi5jYWxsKSB7XG5cdFx0XHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG4xKSA9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcblx0XHRcdFx0XHRcdFx0bnN0YWNrLnB1c2goZi5hcHBseSh1bmRlZmluZWQsIG4xKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0bnN0YWNrLnB1c2goZi5jYWxsKHVuZGVmaW5lZCwgbjEpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoZiArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEV4cHJlc3Npb25cIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChuc3RhY2subGVuZ3RoID4gMSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEV4cHJlc3Npb24gKHBhcml0eSlcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnN0YWNrWzBdO1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZzogZnVuY3Rpb24gKHRvSlMpIHtcblx0XHRcdHZhciBuc3RhY2sgPSBbXTtcblx0XHRcdHZhciBuMTtcblx0XHRcdHZhciBuMjtcblx0XHRcdHZhciBmO1xuXHRcdFx0dmFyIEwgPSB0aGlzLnRva2Vucy5sZW5ndGg7XG5cdFx0XHR2YXIgaXRlbTtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBMOyBpKyspIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMudG9rZW5zW2ldO1xuXHRcdFx0XHR2YXIgdHlwZV8gPSBpdGVtLnR5cGVfO1xuXHRcdFx0XHRpZiAodHlwZV8gPT09IFROVU1CRVIpIHtcblx0XHRcdFx0XHRuc3RhY2sucHVzaChlc2NhcGVWYWx1ZShpdGVtLm51bWJlcl8pKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0eXBlXyA9PT0gVE9QMikge1xuXHRcdFx0XHRcdG4yID0gbnN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdG4xID0gbnN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdGYgPSBpdGVtLmluZGV4Xztcblx0XHRcdFx0XHRpZiAodG9KUyAmJiBmID09IFwiXlwiKSB7XG5cdFx0XHRcdFx0XHRuc3RhY2sucHVzaChcIk1hdGgucG93KFwiICsgbjEgKyBcIixcIiArIG4yICsgXCIpXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdG5zdGFjay5wdXNoKFwiKFwiICsgbjEgKyBmICsgbjIgKyBcIilcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVfID09PSBUVkFSKSB7XG5cdFx0XHRcdFx0bnN0YWNrLnB1c2goaXRlbS5pbmRleF8pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVfID09PSBUT1AxKSB7XG5cdFx0XHRcdFx0bjEgPSBuc3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0ZiA9IGl0ZW0uaW5kZXhfO1xuXHRcdFx0XHRcdGlmIChmID09PSBcIi1cIikge1xuXHRcdFx0XHRcdFx0bnN0YWNrLnB1c2goXCIoXCIgKyBmICsgbjEgKyBcIilcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0bnN0YWNrLnB1c2goZiArIFwiKFwiICsgbjEgKyBcIilcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVfID09PSBURlVOQ0FMTCkge1xuXHRcdFx0XHRcdG4xID0gbnN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdGYgPSBuc3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0bnN0YWNrLnB1c2goZiArIFwiKFwiICsgbjEgKyBcIilcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBFeHByZXNzaW9uXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobnN0YWNrLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBFeHByZXNzaW9uIChwYXJpdHkpXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5zdGFja1swXTtcblx0XHR9LFxuXG5cdFx0dmFyaWFibGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgTCA9IHRoaXMudG9rZW5zLmxlbmd0aDtcblx0XHRcdHZhciB2YXJzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IEw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHRoaXMudG9rZW5zW2ldO1xuXHRcdFx0XHRpZiAoaXRlbS50eXBlXyA9PT0gVFZBUiAmJiAodmFycy5pbmRleE9mKGl0ZW0uaW5kZXhfKSA9PSAtMSkpIHtcblx0XHRcdFx0XHR2YXJzLnB1c2goaXRlbS5pbmRleF8pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YXJzO1xuXHRcdH0sXG5cblx0XHR0b0pTRnVuY3Rpb246IGZ1bmN0aW9uIChwYXJhbSwgdmFyaWFibGVzKSB7XG5cdFx0XHR2YXIgZiA9IG5ldyBGdW5jdGlvbihwYXJhbSwgXCJ3aXRoKFBhcnNlci52YWx1ZXMpIHsgcmV0dXJuIFwiICsgdGhpcy5zaW1wbGlmeSh2YXJpYWJsZXMpLnRvU3RyaW5nKHRydWUpICsgXCI7IH1cIik7XG5cdFx0XHRyZXR1cm4gZjtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gYWRkKGEsIGIpIHtcblx0XHRyZXR1cm4gTnVtYmVyKGEpICsgTnVtYmVyKGIpO1xuXHR9XG5cdGZ1bmN0aW9uIHN1YihhLCBiKSB7XG5cdFx0cmV0dXJuIGEgLSBiOyBcblx0fVxuXHRmdW5jdGlvbiBtdWwoYSwgYikge1xuXHRcdHJldHVybiBhICogYjtcblx0fVxuXHRmdW5jdGlvbiBkaXYoYSwgYikge1xuXHRcdHJldHVybiBhIC8gYjtcblx0fVxuXHRmdW5jdGlvbiBtb2QoYSwgYikge1xuXHRcdHJldHVybiBhICUgYjtcblx0fVxuXHRmdW5jdGlvbiBjb25jYXQoYSwgYikge1xuXHRcdHJldHVybiBcIlwiICsgYSArIGI7XG5cdH1cblxuXHRmdW5jdGlvbiBuZWcoYSkge1xuXHRcdHJldHVybiAtYTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJhbmRvbShhKSB7XG5cdFx0cmV0dXJuIE1hdGgucmFuZG9tKCkgKiAoYSB8fCAxKTtcblx0fVxuXHRmdW5jdGlvbiBmYWMoYSkgeyAvL2EhXG5cdFx0YSA9IE1hdGguZmxvb3IoYSk7XG5cdFx0dmFyIGIgPSBhO1xuXHRcdHdoaWxlIChhID4gMSkge1xuXHRcdFx0YiA9IGIgKiAoLS1hKTtcblx0XHR9XG5cdFx0cmV0dXJuIGI7XG5cdH1cblxuXHQvLyBUT0RPOiB1c2UgaHlwb3QgdGhhdCBkb2Vzbid0IG92ZXJmbG93XG5cdGZ1bmN0aW9uIHB5dChhLCBiKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGVuZChhLCBiKSB7XG5cdFx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSAhPSBcIltvYmplY3QgQXJyYXldXCIpIHtcblx0XHRcdHJldHVybiBbYSwgYl07XG5cdFx0fVxuXHRcdGEgPSBhLnNsaWNlKCk7XG5cdFx0YS5wdXNoKGIpO1xuXHRcdHJldHVybiBhO1xuXHR9XG5cblx0ZnVuY3Rpb24gUGFyc2VyKCkge1xuXHRcdHRoaXMuc3VjY2VzcyA9IGZhbHNlO1xuXHRcdHRoaXMuZXJyb3Jtc2cgPSBcIlwiO1xuXHRcdHRoaXMuZXhwcmVzc2lvbiA9IFwiXCI7XG5cblx0XHR0aGlzLnBvcyA9IDA7XG5cblx0XHR0aGlzLnRva2VubnVtYmVyID0gMDtcblx0XHR0aGlzLnRva2VucHJpbyA9IDA7XG5cdFx0dGhpcy50b2tlbmluZGV4ID0gMDtcblx0XHR0aGlzLnRtcHByaW8gPSAwO1xuXG5cdFx0dGhpcy5vcHMxID0ge1xuXHRcdFx0XCJzaW5cIjogTWF0aC5zaW4sXG5cdFx0XHRcImNvc1wiOiBNYXRoLmNvcyxcblx0XHRcdFwidGFuXCI6IE1hdGgudGFuLFxuXHRcdFx0XCJhc2luXCI6IE1hdGguYXNpbixcblx0XHRcdFwiYWNvc1wiOiBNYXRoLmFjb3MsXG5cdFx0XHRcImF0YW5cIjogTWF0aC5hdGFuLFxuXHRcdFx0XCJzcXJ0XCI6IE1hdGguc3FydCxcblx0XHRcdFwibG9nXCI6IE1hdGgubG9nLFxuXHRcdFx0XCJhYnNcIjogTWF0aC5hYnMsXG5cdFx0XHRcImNlaWxcIjogTWF0aC5jZWlsLFxuXHRcdFx0XCJmbG9vclwiOiBNYXRoLmZsb29yLFxuXHRcdFx0XCJyb3VuZFwiOiBNYXRoLnJvdW5kLFxuXHRcdFx0XCItXCI6IG5lZyxcblx0XHRcdFwiZXhwXCI6IE1hdGguZXhwXG5cdFx0fTtcblxuXHRcdHRoaXMub3BzMiA9IHtcblx0XHRcdFwiK1wiOiBhZGQsXG5cdFx0XHRcIi1cIjogc3ViLFxuXHRcdFx0XCIqXCI6IG11bCxcblx0XHRcdFwiL1wiOiBkaXYsXG5cdFx0XHRcIiVcIjogbW9kLFxuXHRcdFx0XCJeXCI6IE1hdGgucG93LFxuXHRcdFx0XCIsXCI6IGFwcGVuZCxcblx0XHRcdFwifHxcIjogY29uY2F0XG5cdFx0fTtcblxuXHRcdHRoaXMuZnVuY3Rpb25zID0ge1xuXHRcdFx0XCJyYW5kb21cIjogcmFuZG9tLFxuXHRcdFx0XCJmYWNcIjogZmFjLFxuXHRcdFx0XCJtaW5cIjogTWF0aC5taW4sXG5cdFx0XHRcIm1heFwiOiBNYXRoLm1heCxcblx0XHRcdFwicHl0XCI6IHB5dCxcblx0XHRcdFwicG93XCI6IE1hdGgucG93LFxuXHRcdFx0XCJhdGFuMlwiOiBNYXRoLmF0YW4yXG5cdFx0fTtcblxuXHRcdHRoaXMuY29uc3RzID0ge1xuXHRcdFx0XCJFXCI6IE1hdGguRSxcblx0XHRcdFwiUElcIjogTWF0aC5QSVxuXHRcdH07XG5cdH1cblxuXHRQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiAoZXhwcikge1xuXHRcdHJldHVybiBuZXcgUGFyc2VyKCkucGFyc2UoZXhwcik7XG5cdH07XG5cblx0UGFyc2VyLmV2YWx1YXRlID0gZnVuY3Rpb24gKGV4cHIsIHZhcmlhYmxlcykge1xuXHRcdHJldHVybiBQYXJzZXIucGFyc2UoZXhwcikuZXZhbHVhdGUodmFyaWFibGVzKTtcblx0fTtcblxuXHRQYXJzZXIuRXhwcmVzc2lvbiA9IEV4cHJlc3Npb247XG5cblx0UGFyc2VyLnZhbHVlcyA9IHtcblx0XHRzaW46IE1hdGguc2luLFxuXHRcdGNvczogTWF0aC5jb3MsXG5cdFx0dGFuOiBNYXRoLnRhbixcblx0XHRhc2luOiBNYXRoLmFzaW4sXG5cdFx0YWNvczogTWF0aC5hY29zLFxuXHRcdGF0YW46IE1hdGguYXRhbixcblx0XHRzcXJ0OiBNYXRoLnNxcnQsXG5cdFx0bG9nOiBNYXRoLmxvZyxcblx0XHRhYnM6IE1hdGguYWJzLFxuXHRcdGNlaWw6IE1hdGguY2VpbCxcblx0XHRmbG9vcjogTWF0aC5mbG9vcixcblx0XHRyb3VuZDogTWF0aC5yb3VuZCxcblx0XHRyYW5kb206IHJhbmRvbSxcblx0XHRmYWM6IGZhYyxcblx0XHRleHA6IE1hdGguZXhwLFxuXHRcdG1pbjogTWF0aC5taW4sXG5cdFx0bWF4OiBNYXRoLm1heCxcblx0XHRweXQ6IHB5dCxcblx0XHRwb3c6IE1hdGgucG93LFxuXHRcdGF0YW4yOiBNYXRoLmF0YW4yLFxuXHRcdEU6IE1hdGguRSxcblx0XHRQSTogTWF0aC5QSVxuXHR9O1xuXG5cdHZhciBQUklNQVJZICAgICAgPSAxIDw8IDA7XG5cdHZhciBPUEVSQVRPUiAgICAgPSAxIDw8IDE7XG5cdHZhciBGVU5DVElPTiAgICAgPSAxIDw8IDI7XG5cdHZhciBMUEFSRU4gICAgICAgPSAxIDw8IDM7XG5cdHZhciBSUEFSRU4gICAgICAgPSAxIDw8IDQ7XG5cdHZhciBDT01NQSAgICAgICAgPSAxIDw8IDU7XG5cdHZhciBTSUdOICAgICAgICAgPSAxIDw8IDY7XG5cdHZhciBDQUxMICAgICAgICAgPSAxIDw8IDc7XG5cdHZhciBOVUxMQVJZX0NBTEwgPSAxIDw8IDg7XG5cblx0UGFyc2VyLnByb3RvdHlwZSA9IHtcblx0XHRwYXJzZTogZnVuY3Rpb24gKGV4cHIpIHtcblx0XHRcdHRoaXMuZXJyb3Jtc2cgPSBcIlwiO1xuXHRcdFx0dGhpcy5zdWNjZXNzID0gdHJ1ZTtcblx0XHRcdHZhciBvcGVyc3RhY2sgPSBbXTtcblx0XHRcdHZhciB0b2tlbnN0YWNrID0gW107XG5cdFx0XHR0aGlzLnRtcHByaW8gPSAwO1xuXHRcdFx0dmFyIGV4cGVjdGVkID0gKFBSSU1BUlkgfCBMUEFSRU4gfCBGVU5DVElPTiB8IFNJR04pO1xuXHRcdFx0dmFyIG5vcGVyYXRvcnMgPSAwO1xuXHRcdFx0dGhpcy5leHByZXNzaW9uID0gZXhwcjtcblx0XHRcdHRoaXMucG9zID0gMDtcblxuXHRcdFx0d2hpbGUgKHRoaXMucG9zIDwgdGhpcy5leHByZXNzaW9uLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5pc09wZXJhdG9yKCkpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5pc1NpZ24oKSAmJiAoZXhwZWN0ZWQgJiBTSUdOKSkge1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuaXNOZWdhdGl2ZVNpZ24oKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnRva2VucHJpbyA9IDI7XG5cdFx0XHRcdFx0XHRcdHRoaXMudG9rZW5pbmRleCA9IFwiLVwiO1xuXHRcdFx0XHRcdFx0XHRub3BlcmF0b3JzKys7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYWRkZnVuYyh0b2tlbnN0YWNrLCBvcGVyc3RhY2ssIFRPUDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZXhwZWN0ZWQgPSAoUFJJTUFSWSB8IExQQVJFTiB8IEZVTkNUSU9OIHwgU0lHTik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKHRoaXMuaXNDb21tZW50KCkpIHtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGlmICgoZXhwZWN0ZWQgJiBPUEVSQVRPUikgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5lcnJvcl9wYXJzaW5nKHRoaXMucG9zLCBcInVuZXhwZWN0ZWQgb3BlcmF0b3JcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRub3BlcmF0b3JzICs9IDI7XG5cdFx0XHRcdFx0XHR0aGlzLmFkZGZ1bmModG9rZW5zdGFjaywgb3BlcnN0YWNrLCBUT1AyKTtcblx0XHRcdFx0XHRcdGV4cGVjdGVkID0gKFBSSU1BUlkgfCBMUEFSRU4gfCBGVU5DVElPTiB8IFNJR04pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLmlzTnVtYmVyKCkpIHtcblx0XHRcdFx0XHRpZiAoKGV4cGVjdGVkICYgUFJJTUFSWSkgPT09IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuZXJyb3JfcGFyc2luZyh0aGlzLnBvcywgXCJ1bmV4cGVjdGVkIG51bWJlclwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHRva2VuID0gbmV3IFRva2VuKFROVU1CRVIsIDAsIDAsIHRoaXMudG9rZW5udW1iZXIpO1xuXHRcdFx0XHRcdHRva2Vuc3RhY2sucHVzaCh0b2tlbik7XG5cblx0XHRcdFx0XHRleHBlY3RlZCA9IChPUEVSQVRPUiB8IFJQQVJFTiB8IENPTU1BKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLmlzU3RyaW5nKCkpIHtcblx0XHRcdFx0XHRpZiAoKGV4cGVjdGVkICYgUFJJTUFSWSkgPT09IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuZXJyb3JfcGFyc2luZyh0aGlzLnBvcywgXCJ1bmV4cGVjdGVkIHN0cmluZ1wiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHRva2VuID0gbmV3IFRva2VuKFROVU1CRVIsIDAsIDAsIHRoaXMudG9rZW5udW1iZXIpO1xuXHRcdFx0XHRcdHRva2Vuc3RhY2sucHVzaCh0b2tlbik7XG5cblx0XHRcdFx0XHRleHBlY3RlZCA9IChPUEVSQVRPUiB8IFJQQVJFTiB8IENPTU1BKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLmlzTGVmdFBhcmVudGgoKSkge1xuXHRcdFx0XHRcdGlmICgoZXhwZWN0ZWQgJiBMUEFSRU4pID09PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVycm9yX3BhcnNpbmcodGhpcy5wb3MsIFwidW5leHBlY3RlZCBcXFwiKFxcXCJcIik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGV4cGVjdGVkICYgQ0FMTCkge1xuXHRcdFx0XHRcdFx0bm9wZXJhdG9ycyArPSAyO1xuXHRcdFx0XHRcdFx0dGhpcy50b2tlbnByaW8gPSAtMjtcblx0XHRcdFx0XHRcdHRoaXMudG9rZW5pbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0dGhpcy5hZGRmdW5jKHRva2Vuc3RhY2ssIG9wZXJzdGFjaywgVEZVTkNBTEwpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGV4cGVjdGVkID0gKFBSSU1BUlkgfCBMUEFSRU4gfCBGVU5DVElPTiB8IFNJR04gfCBOVUxMQVJZX0NBTEwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMuaXNSaWdodFBhcmVudGgoKSkge1xuXHRcdFx0XHQgICAgaWYgKGV4cGVjdGVkICYgTlVMTEFSWV9DQUxMKSB7XG5cdFx0XHRcdFx0XHR2YXIgdG9rZW4gPSBuZXcgVG9rZW4oVE5VTUJFUiwgMCwgMCwgW10pO1xuXHRcdFx0XHRcdFx0dG9rZW5zdGFjay5wdXNoKHRva2VuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoKGV4cGVjdGVkICYgUlBBUkVOKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5lcnJvcl9wYXJzaW5nKHRoaXMucG9zLCBcInVuZXhwZWN0ZWQgXFxcIilcXFwiXCIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGV4cGVjdGVkID0gKE9QRVJBVE9SIHwgUlBBUkVOIHwgQ09NTUEgfCBMUEFSRU4gfCBDQUxMKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLmlzQ29tbWEoKSkge1xuXHRcdFx0XHRcdGlmICgoZXhwZWN0ZWQgJiBDT01NQSkgPT09IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuZXJyb3JfcGFyc2luZyh0aGlzLnBvcywgXCJ1bmV4cGVjdGVkIFxcXCIsXFxcIlwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5hZGRmdW5jKHRva2Vuc3RhY2ssIG9wZXJzdGFjaywgVE9QMik7XG5cdFx0XHRcdFx0bm9wZXJhdG9ycyArPSAyO1xuXHRcdFx0XHRcdGV4cGVjdGVkID0gKFBSSU1BUlkgfCBMUEFSRU4gfCBGVU5DVElPTiB8IFNJR04pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMuaXNDb25zdCgpKSB7XG5cdFx0XHRcdFx0aWYgKChleHBlY3RlZCAmIFBSSU1BUlkpID09PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVycm9yX3BhcnNpbmcodGhpcy5wb3MsIFwidW5leHBlY3RlZCBjb25zdGFudFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGNvbnN0dG9rZW4gPSBuZXcgVG9rZW4oVE5VTUJFUiwgMCwgMCwgdGhpcy50b2tlbm51bWJlcik7XG5cdFx0XHRcdFx0dG9rZW5zdGFjay5wdXNoKGNvbnN0dG9rZW4pO1xuXHRcdFx0XHRcdGV4cGVjdGVkID0gKE9QRVJBVE9SIHwgUlBBUkVOIHwgQ09NTUEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMuaXNPcDIoKSkge1xuXHRcdFx0XHRcdGlmICgoZXhwZWN0ZWQgJiBGVU5DVElPTikgPT09IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuZXJyb3JfcGFyc2luZyh0aGlzLnBvcywgXCJ1bmV4cGVjdGVkIGZ1bmN0aW9uXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmFkZGZ1bmModG9rZW5zdGFjaywgb3BlcnN0YWNrLCBUT1AyKTtcblx0XHRcdFx0XHRub3BlcmF0b3JzICs9IDI7XG5cdFx0XHRcdFx0ZXhwZWN0ZWQgPSAoTFBBUkVOKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLmlzT3AxKCkpIHtcblx0XHRcdFx0XHRpZiAoKGV4cGVjdGVkICYgRlVOQ1RJT04pID09PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVycm9yX3BhcnNpbmcodGhpcy5wb3MsIFwidW5leHBlY3RlZCBmdW5jdGlvblwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5hZGRmdW5jKHRva2Vuc3RhY2ssIG9wZXJzdGFjaywgVE9QMSk7XG5cdFx0XHRcdFx0bm9wZXJhdG9ycysrO1xuXHRcdFx0XHRcdGV4cGVjdGVkID0gKExQQVJFTik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodGhpcy5pc1ZhcigpKSB7XG5cdFx0XHRcdFx0aWYgKChleHBlY3RlZCAmIFBSSU1BUlkpID09PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVycm9yX3BhcnNpbmcodGhpcy5wb3MsIFwidW5leHBlY3RlZCB2YXJpYWJsZVwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHZhcnRva2VuID0gbmV3IFRva2VuKFRWQVIsIHRoaXMudG9rZW5pbmRleCwgMCwgMCk7XG5cdFx0XHRcdFx0dG9rZW5zdGFjay5wdXNoKHZhcnRva2VuKTtcblxuXHRcdFx0XHRcdGV4cGVjdGVkID0gKE9QRVJBVE9SIHwgUlBBUkVOIHwgQ09NTUEgfCBMUEFSRU4gfCBDQUxMKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLmlzV2hpdGUoKSkge1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLmVycm9ybXNnID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVycm9yX3BhcnNpbmcodGhpcy5wb3MsIFwidW5rbm93biBjaGFyYWN0ZXJcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5lcnJvcl9wYXJzaW5nKHRoaXMucG9zLCB0aGlzLmVycm9ybXNnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnRtcHByaW8gPCAwIHx8IHRoaXMudG1wcHJpbyA+PSAxMCkge1xuXHRcdFx0XHR0aGlzLmVycm9yX3BhcnNpbmcodGhpcy5wb3MsIFwidW5tYXRjaGVkIFxcXCIoKVxcXCJcIik7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAob3BlcnN0YWNrLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIHRtcCA9IG9wZXJzdGFjay5wb3AoKTtcblx0XHRcdFx0dG9rZW5zdGFjay5wdXNoKHRtcCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobm9wZXJhdG9ycyArIDEgIT09IHRva2Vuc3RhY2subGVuZ3RoKSB7XG5cdFx0XHRcdC8vcHJpbnQobm9wZXJhdG9ycyArIDEpO1xuXHRcdFx0XHQvL3ByaW50KHRva2Vuc3RhY2spO1xuXHRcdFx0XHR0aGlzLmVycm9yX3BhcnNpbmcodGhpcy5wb3MsIFwicGFyaXR5XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEV4cHJlc3Npb24odG9rZW5zdGFjaywgb2JqZWN0KHRoaXMub3BzMSksIG9iamVjdCh0aGlzLm9wczIpLCBvYmplY3QodGhpcy5mdW5jdGlvbnMpKTtcblx0XHR9LFxuXG5cdFx0ZXZhbHVhdGU6IGZ1bmN0aW9uIChleHByLCB2YXJpYWJsZXMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlKGV4cHIpLmV2YWx1YXRlKHZhcmlhYmxlcyk7XG5cdFx0fSxcblxuXHRcdGVycm9yX3BhcnNpbmc6IGZ1bmN0aW9uIChjb2x1bW4sIG1zZykge1xuXHRcdFx0dGhpcy5zdWNjZXNzID0gZmFsc2U7XG5cdFx0XHR0aGlzLmVycm9ybXNnID0gXCJwYXJzZSBlcnJvciBbY29sdW1uIFwiICsgKGNvbHVtbikgKyBcIl06IFwiICsgbXNnO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3Jtc2cpO1xuXHRcdH0sXG5cbi8vXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFwvXFxcblxuXHRcdGFkZGZ1bmM6IGZ1bmN0aW9uICh0b2tlbnN0YWNrLCBvcGVyc3RhY2ssIHR5cGVfKSB7XG5cdFx0XHR2YXIgb3BlcmF0b3IgPSBuZXcgVG9rZW4odHlwZV8sIHRoaXMudG9rZW5pbmRleCwgdGhpcy50b2tlbnByaW8gKyB0aGlzLnRtcHByaW8sIDApO1xuXHRcdFx0d2hpbGUgKG9wZXJzdGFjay5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGlmIChvcGVyYXRvci5wcmlvXyA8PSBvcGVyc3RhY2tbb3BlcnN0YWNrLmxlbmd0aCAtIDFdLnByaW9fKSB7XG5cdFx0XHRcdFx0dG9rZW5zdGFjay5wdXNoKG9wZXJzdGFjay5wb3AoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9wZXJzdGFjay5wdXNoKG9wZXJhdG9yKTtcblx0XHR9LFxuXG5cdFx0aXNOdW1iZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciByID0gZmFsc2U7XG5cdFx0XHR2YXIgc3RyID0gXCJcIjtcblx0XHRcdHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuZXhwcmVzc2lvbi5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGNvZGUgPSB0aGlzLmV4cHJlc3Npb24uY2hhckNvZGVBdCh0aGlzLnBvcyk7XG5cdFx0XHRcdGlmICgoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fCBjb2RlID09PSA0Nikge1xuXHRcdFx0XHRcdHN0ciArPSB0aGlzLmV4cHJlc3Npb24uY2hhckF0KHRoaXMucG9zKTtcblx0XHRcdFx0XHR0aGlzLnBvcysrO1xuXHRcdFx0XHRcdHRoaXMudG9rZW5udW1iZXIgPSBwYXJzZUZsb2F0KHN0cik7XG5cdFx0XHRcdFx0ciA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByO1xuXHRcdH0sXG5cblx0XHQvLyBQb3J0ZWQgZnJvbSB0aGUgeWFqamwgSlNPTiBwYXJzZXIgYXQgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3lhampsL1xuXHRcdHVuZXNjYXBlOiBmdW5jdGlvbih2LCBwb3MpIHtcblx0XHRcdHZhciBidWZmZXIgPSBbXTtcblx0XHRcdHZhciBlc2NhcGluZyA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGMgPSB2LmNoYXJBdChpKTtcblx0XG5cdFx0XHRcdGlmIChlc2NhcGluZykge1xuXHRcdFx0XHRcdHN3aXRjaCAoYykge1xuXHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRidWZmZXIucHVzaChcIidcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdcXFxcJzpcblx0XHRcdFx0XHRcdGJ1ZmZlci5wdXNoKCdcXFxcJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICcvJzpcblx0XHRcdFx0XHRcdGJ1ZmZlci5wdXNoKCcvJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdiJzpcblx0XHRcdFx0XHRcdGJ1ZmZlci5wdXNoKCdcXGInKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2YnOlxuXHRcdFx0XHRcdFx0YnVmZmVyLnB1c2goJ1xcZicpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbic6XG5cdFx0XHRcdFx0XHRidWZmZXIucHVzaCgnXFxuJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdyJzpcblx0XHRcdFx0XHRcdGJ1ZmZlci5wdXNoKCdcXHInKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3QnOlxuXHRcdFx0XHRcdFx0YnVmZmVyLnB1c2goJ1xcdCcpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAndSc6XG5cdFx0XHRcdFx0XHQvLyBpbnRlcnByZXQgdGhlIGZvbGxvd2luZyA0IGNoYXJhY3RlcnMgYXMgdGhlIGhleCBvZiB0aGUgdW5pY29kZSBjb2RlIHBvaW50XG5cdFx0XHRcdFx0XHR2YXIgY29kZVBvaW50ID0gcGFyc2VJbnQodi5zdWJzdHJpbmcoaSArIDEsIGkgKyA1KSwgMTYpO1xuXHRcdFx0XHRcdFx0YnVmZmVyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0XHRcdFx0XHRcdGkgKz0gNDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR0aHJvdyB0aGlzLmVycm9yX3BhcnNpbmcocG9zICsgaSwgXCJJbGxlZ2FsIGVzY2FwZSBzZXF1ZW5jZTogJ1xcXFxcIiArIGMgKyBcIidcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVzY2FwaW5nID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGMgPT0gJ1xcXFwnKSB7XG5cdFx0XHRcdFx0XHRlc2NhcGluZyA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJ1ZmZlci5wdXNoKGMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiBidWZmZXIuam9pbignJyk7XG5cdFx0fSxcblxuXHRcdGlzU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgciA9IGZhbHNlO1xuXHRcdFx0dmFyIHN0ciA9IFwiXCI7XG5cdFx0XHR2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcblx0XHRcdGlmICh0aGlzLnBvcyA8IHRoaXMuZXhwcmVzc2lvbi5sZW5ndGggJiYgdGhpcy5leHByZXNzaW9uLmNoYXJBdCh0aGlzLnBvcykgPT0gXCInXCIpIHtcblx0XHRcdFx0dGhpcy5wb3MrKztcblx0XHRcdFx0d2hpbGUgKHRoaXMucG9zIDwgdGhpcy5leHByZXNzaW9uLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhciBjb2RlID0gdGhpcy5leHByZXNzaW9uLmNoYXJBdCh0aGlzLnBvcyk7XG5cdFx0XHRcdFx0aWYgKGNvZGUgIT0gXCInXCIgfHwgc3RyLnNsaWNlKC0xKSA9PSBcIlxcXFxcIikge1xuXHRcdFx0XHRcdFx0c3RyICs9IHRoaXMuZXhwcmVzc2lvbi5jaGFyQXQodGhpcy5wb3MpO1xuXHRcdFx0XHRcdFx0dGhpcy5wb3MrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBvcysrO1xuXHRcdFx0XHRcdFx0dGhpcy50b2tlbm51bWJlciA9IHRoaXMudW5lc2NhcGUoc3RyLCBzdGFydHBvcyk7XG5cdFx0XHRcdFx0XHRyID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHI7XG5cdFx0fSxcblxuXHRcdGlzQ29uc3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzdHI7XG5cdFx0XHRmb3IgKHZhciBpIGluIHRoaXMuY29uc3RzKSB7XG5cdFx0XHRcdGlmICh0cnVlKSB7XG5cdFx0XHRcdFx0dmFyIEwgPSBpLmxlbmd0aDtcblx0XHRcdFx0XHRzdHIgPSB0aGlzLmV4cHJlc3Npb24uc3Vic3RyKHRoaXMucG9zLCBMKTtcblx0XHRcdFx0XHRpZiAoaSA9PT0gc3RyKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRva2VubnVtYmVyID0gdGhpcy5jb25zdHNbaV07XG5cdFx0XHRcdFx0XHR0aGlzLnBvcyArPSBMO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdGlzT3BlcmF0b3I6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjb2RlID0gdGhpcy5leHByZXNzaW9uLmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuXHRcdFx0aWYgKGNvZGUgPT09IDQzKSB7IC8vICtcblx0XHRcdFx0dGhpcy50b2tlbnByaW8gPSAwO1xuXHRcdFx0XHR0aGlzLnRva2VuaW5kZXggPSBcIitcIjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGNvZGUgPT09IDQ1KSB7IC8vIC1cblx0XHRcdFx0dGhpcy50b2tlbnByaW8gPSAwO1xuXHRcdFx0XHR0aGlzLnRva2VuaW5kZXggPSBcIi1cIjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGNvZGUgPT09IDEyNCkgeyAvLyB8XG5cdFx0XHRcdGlmICh0aGlzLmV4cHJlc3Npb24uY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMjQpIHtcblx0XHRcdFx0XHR0aGlzLnBvcysrO1xuXHRcdFx0XHRcdHRoaXMudG9rZW5wcmlvID0gMDtcblx0XHRcdFx0XHR0aGlzLnRva2VuaW5kZXggPSBcInx8XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChjb2RlID09PSA0MikgeyAvLyAqXG5cdFx0XHRcdHRoaXMudG9rZW5wcmlvID0gMTtcblx0XHRcdFx0dGhpcy50b2tlbmluZGV4ID0gXCIqXCI7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChjb2RlID09PSA0NykgeyAvLyAvXG5cdFx0XHRcdHRoaXMudG9rZW5wcmlvID0gMjtcblx0XHRcdFx0dGhpcy50b2tlbmluZGV4ID0gXCIvXCI7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChjb2RlID09PSAzNykgeyAvLyAlXG5cdFx0XHRcdHRoaXMudG9rZW5wcmlvID0gMjtcblx0XHRcdFx0dGhpcy50b2tlbmluZGV4ID0gXCIlXCI7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChjb2RlID09PSA5NCkgeyAvLyBeXG5cdFx0XHRcdHRoaXMudG9rZW5wcmlvID0gMztcblx0XHRcdFx0dGhpcy50b2tlbmluZGV4ID0gXCJeXCI7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wb3MrKztcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRpc1NpZ246IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjb2RlID0gdGhpcy5leHByZXNzaW9uLmNoYXJDb2RlQXQodGhpcy5wb3MgLSAxKTtcblx0XHRcdGlmIChjb2RlID09PSA0NSB8fCBjb2RlID09PSA0MykgeyAvLyAtXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHRpc1Bvc2l0aXZlU2lnbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNvZGUgPSB0aGlzLmV4cHJlc3Npb24uY2hhckNvZGVBdCh0aGlzLnBvcyAtIDEpO1xuXHRcdFx0aWYgKGNvZGUgPT09IDQzKSB7IC8vIC1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdGlzTmVnYXRpdmVTaWduOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY29kZSA9IHRoaXMuZXhwcmVzc2lvbi5jaGFyQ29kZUF0KHRoaXMucG9zIC0gMSk7XG5cdFx0XHRpZiAoY29kZSA9PT0gNDUpIHsgLy8gLVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0aXNMZWZ0UGFyZW50aDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNvZGUgPSB0aGlzLmV4cHJlc3Npb24uY2hhckNvZGVBdCh0aGlzLnBvcyk7XG5cdFx0XHRpZiAoY29kZSA9PT0gNDApIHsgLy8gKFxuXHRcdFx0XHR0aGlzLnBvcysrO1xuXHRcdFx0XHR0aGlzLnRtcHByaW8gKz0gMTA7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHRpc1JpZ2h0UGFyZW50aDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNvZGUgPSB0aGlzLmV4cHJlc3Npb24uY2hhckNvZGVBdCh0aGlzLnBvcyk7XG5cdFx0XHRpZiAoY29kZSA9PT0gNDEpIHsgLy8gKVxuXHRcdFx0XHR0aGlzLnBvcysrO1xuXHRcdFx0XHR0aGlzLnRtcHByaW8gLT0gMTA7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHRpc0NvbW1hOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY29kZSA9IHRoaXMuZXhwcmVzc2lvbi5jaGFyQ29kZUF0KHRoaXMucG9zKTtcblx0XHRcdGlmIChjb2RlID09PSA0NCkgeyAvLyAsXG5cdFx0XHRcdHRoaXMucG9zKys7XG5cdFx0XHRcdHRoaXMudG9rZW5wcmlvID0gLTE7XG5cdFx0XHRcdHRoaXMudG9rZW5pbmRleCA9IFwiLFwiO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0aXNXaGl0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNvZGUgPSB0aGlzLmV4cHJlc3Npb24uY2hhckNvZGVBdCh0aGlzLnBvcyk7XG5cdFx0XHRpZiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gOSB8fCBjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMykge1xuXHRcdFx0XHR0aGlzLnBvcysrO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0aXNPcDE6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzdHIgPSBcIlwiO1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMucG9zOyBpIDwgdGhpcy5leHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjID0gdGhpcy5leHByZXNzaW9uLmNoYXJBdChpKTtcblx0XHRcdFx0aWYgKGMudG9VcHBlckNhc2UoKSA9PT0gYy50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0aWYgKGkgPT09IHRoaXMucG9zIHx8IChjICE9ICdfJyAmJiAoYyA8ICcwJyB8fCBjID4gJzknKSkpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHIgKz0gYztcblx0XHRcdH1cblx0XHRcdGlmIChzdHIubGVuZ3RoID4gMCAmJiAoc3RyIGluIHRoaXMub3BzMSkpIHtcblx0XHRcdFx0dGhpcy50b2tlbmluZGV4ID0gc3RyO1xuXHRcdFx0XHR0aGlzLnRva2VucHJpbyA9IDU7XG5cdFx0XHRcdHRoaXMucG9zICs9IHN0ci5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHRpc09wMjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHN0ciA9IFwiXCI7XG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5wb3M7IGkgPCB0aGlzLmV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGMgPSB0aGlzLmV4cHJlc3Npb24uY2hhckF0KGkpO1xuXHRcdFx0XHRpZiAoYy50b1VwcGVyQ2FzZSgpID09PSBjLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRpZiAoaSA9PT0gdGhpcy5wb3MgfHwgKGMgIT0gJ18nICYmIChjIDwgJzAnIHx8IGMgPiAnOScpKSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0ciArPSBjO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0ci5sZW5ndGggPiAwICYmIChzdHIgaW4gdGhpcy5vcHMyKSkge1xuXHRcdFx0XHR0aGlzLnRva2VuaW5kZXggPSBzdHI7XG5cdFx0XHRcdHRoaXMudG9rZW5wcmlvID0gNTtcblx0XHRcdFx0dGhpcy5wb3MgKz0gc3RyLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdGlzVmFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc3RyID0gXCJcIjtcblx0XHRcdGZvciAodmFyIGkgPSB0aGlzLnBvczsgaSA8IHRoaXMuZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgYyA9IHRoaXMuZXhwcmVzc2lvbi5jaGFyQXQoaSk7XG5cdFx0XHRcdGlmIChjLnRvVXBwZXJDYXNlKCkgPT09IGMudG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0XHRcdGlmIChpID09PSB0aGlzLnBvcyB8fCAoYyAhPSAnXycgJiYgKGMgPCAnMCcgfHwgYyA+ICc5JykpKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RyICs9IGM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3RyLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dGhpcy50b2tlbmluZGV4ID0gc3RyO1xuXHRcdFx0XHR0aGlzLnRva2VucHJpbyA9IDQ7XG5cdFx0XHRcdHRoaXMucG9zICs9IHN0ci5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHRpc0NvbW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjb2RlID0gdGhpcy5leHByZXNzaW9uLmNoYXJDb2RlQXQodGhpcy5wb3MgLSAxKTtcblx0XHRcdGlmIChjb2RlID09PSA0NyAmJiB0aGlzLmV4cHJlc3Npb24uY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDQyKSB7XG5cdFx0XHRcdHRoaXMucG9zID0gdGhpcy5leHByZXNzaW9uLmluZGV4T2YoXCIqL1wiLCB0aGlzLnBvcykgKyAyO1xuXHRcdFx0XHRpZiAodGhpcy5wb3MgPT09IDEpIHtcblx0XHRcdFx0XHR0aGlzLnBvcyA9IHRoaXMuZXhwcmVzc2lvbi5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBQYXJzZXI7XG59KTtcbn0se31dLFwidXRpbHNcXFxcdGVtcGxhdGUuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEEgdmVyeSBzaW1wbGUsIEVSQi1zdHlsZSB0ZW1wbGF0aW5nLiBCYXNpY2FsbHksIGp1c3QgYXMgc3RyaW5nIHN1YnN0aXR1dGlvbi5cbiAqIFRoZSByZWFzb24gdG8gbm90IHVzZSBkZWZhdWx0IExvLWRhc2jigJllcyBgXy50ZW1wbGF0ZSgpYCBpbXBsZW1lbnRhdGlvblxuICogaXMgYmVjYXVzZSBpdCBmYWlscyB0byBydW4gaW4gQ1NQLWVuYWJsZWQgZW52aXJvbm1lbnRzIChDaHJvbWUgZXh0ZW5zaW9uLCBBdG9tKVxuICovXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgc3RyaW5nU3RyZWFtID0gcmVxdWlyZSgnLi4vYXNzZXRzL3N0cmluZ1N0cmVhbScpO1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cdGZ1bmN0aW9uIHBhcnNlQXJncyhzdHIpIHtcblx0XHR2YXIgYXJncyA9IFtdO1xuXHRcdHZhciBzdHJlYW0gPSBzdHJpbmdTdHJlYW0oc3RyKTtcblxuXHRcdHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG5cdFx0XHRpZiAoc3RyZWFtLnBlZWsoKSA9PSAnLCcpIHtcblx0XHRcdFx0YXJncy5wdXNoKHV0aWxzLnRyaW0oc3RyZWFtLmN1cnJlbnQoKSkpO1xuXHRcdFx0XHRzdHJlYW0ubmV4dCgpO1xuXHRcdFx0XHRzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuXHRcdFx0fVxuXHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHR9XG5cblx0XHRhcmdzLnB1c2godXRpbHMudHJpbShzdHJlYW0uY3VycmVudCgpKSk7XG5cdFx0cmV0dXJuIGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcblx0XHRcdHJldHVybiAhIWE7XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uQ2FsbChzdHIpIHtcblx0XHR2YXIgZm5OYW1lID0gbnVsbCwgYXJncztcblx0XHR2YXIgc3RyZWFtID0gc3RyaW5nU3RyZWFtKHN0cik7XG5cdFx0d2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcblx0XHRcdGlmIChzdHJlYW0ucGVlaygpID09ICcoJykge1xuXHRcdFx0XHRmbk5hbWUgPSBzdHJlYW0uY3VycmVudCgpO1xuXHRcdFx0XHRzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuXHRcdFx0XHRzdHJlYW0uc2tpcFRvUGFpcignKCcsICcpJywgdHJ1ZSk7XG5cdFx0XHRcdGFyZ3MgPSBzdHJlYW0uY3VycmVudCgpO1xuXHRcdFx0XHRhcmdzID0gcGFyc2VBcmdzKGFyZ3Muc3Vic3RyaW5nKDEsIGFyZ3MubGVuZ3RoIC0gMSkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZm5OYW1lICYmIHtcblx0XHRcdG5hbWU6IGZuTmFtZSxcblx0XHRcdGFyZ3M6IGFyZ3Ncblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZXZhbEFyZyhhcmcsIGNvbnRleHQpIHtcblx0XHRpZiAoL15bJ1wiXS8udGVzdChhcmcpKSB7XG5cdFx0XHQvLyBwbGFpbiBzdHJpbmdcblx0XHRcdHJldHVybiBhcmcucmVwbGFjZSgvXihbJ1wiXSkoLis/KVxcMSQvLCAnJDInKTtcblx0XHR9XG5cblx0XHRpZiAoIWlzTmFOKCthcmcpKSB7XG5cdFx0XHQvLyBhIG51bWJlclxuXHRcdFx0cmV0dXJuICthcmc7XG5cdFx0fVxuXG5cdFx0Ly8gb3RoZXJ3aXNlLCB0cmVhdCBhcmd1bWVudCBhcyBhIHByb3BlcnR5IG5hbWVcblx0XHRpZiAoYXJnKSB7XG5cdFx0XHR2YXIgcGFydHMgPSBhcmcuc3BsaXQoJy4nKTtcblx0XHRcdHZhciBwcm9wID0gY29udGV4dDtcblx0XHRcdHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0cHJvcCA9IHByb3BbcGFydHMuc2hpZnQoKV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9wO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3ModGVtcGxhdGUsIGNvbnRleHQpIHtcblx0XHRyZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvPCVbPVxcLV0oLis/KSU+L2csIGZ1bmN0aW9uKHN0ciwgbWF0Y2gpIHtcblx0XHRcdG1hdGNoID0gdXRpbHMudHJpbShtYXRjaCk7XG5cdFx0XHR2YXIgZm4gPSBwYXJzZUZ1bmN0aW9uQ2FsbChtYXRjaCk7XG5cdFx0XHRpZiAoZm4pIHtcblx0XHRcdFx0dmFyIGZuQXJncyA9IGZuLmFyZ3MubWFwKGZ1bmN0aW9uKGFyZykge1xuXHRcdFx0XHRcdHJldHVybiBldmFsQXJnKGFyZywgY29udGV4dCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dFtmbi5uYW1lXS5hcHBseShjb250ZXh0LCBmbkFyZ3MpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZhbEFyZyhtYXRjaCwgY29udGV4dCk7XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24odGVtcGxhdGUsIGNvbnRleHQpIHtcblx0XHRyZXR1cm4gY29udGV4dCA/IHByb2Nlc3ModGVtcGxhdGUsIGNvbnRleHQpIDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0cmV0dXJuIHByb2Nlc3ModGVtcGxhdGUsIGNvbnRleHQpO1xuXHRcdH07XG5cdH07XG59KTtcbn0se1wiLi4vYXNzZXRzL3N0cmluZ1N0cmVhbVwiOlwiYXNzZXRzXFxcXHN0cmluZ1N0cmVhbS5qc1wiLFwiLi9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wifV0sXCJ2ZW5kb3JcXFxca2xhc3MuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHR2YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcblx0fTtcbn1cblxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuXHQvKipcblx0ICogU2hhcmVkIGVtcHR5IGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGFpZCBpbiBwcm90b3R5cGUtY2hhaW4gY3JlYXRpb24uXG5cdCAqL1xuXHR2YXIgY3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiwgZm9yIHN1YmNsYXNzZXMuXG5cdCAqIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG5cdCAqIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZXh0ZW5kZWQuXG5cdCAqIFRvb2sgaXQgZnJvbSBCYWNrYm9uZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvdG9Qcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gc3RhdGljUHJvcHNcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICovXG5cdGZ1bmN0aW9uIGluaGVyaXRzKHBhcmVudCwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcblx0XHR2YXIgY2hpbGQ7XG5cblx0XHQvLyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBuZXcgc3ViY2xhc3MgaXMgZWl0aGVyIGRlZmluZWQgYnlcblx0XHQvLyB5b3UgKHRoZSBcImNvbnN0cnVjdG9yXCIgcHJvcGVydHkgaW4geW91ciBgZXh0ZW5kYCBkZWZpbml0aW9uKSwgb3Jcblx0XHQvLyBkZWZhdWx0ZWQgYnkgdXMgdG8gc2ltcGx5IGNhbGwgdGhlIHBhcmVudCdzIGNvbnN0cnVjdG9yLlxuXHRcdGlmIChwcm90b1Byb3BzICYmIHByb3RvUHJvcHMuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykpIHtcblx0XHRcdGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3Rvcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hpbGQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEluaGVyaXQgY2xhc3MgKHN0YXRpYykgcHJvcGVydGllcyBmcm9tIHBhcmVudC5cblx0XHR1dGlscy5leHRlbmQoY2hpbGQsIHBhcmVudCk7XG5cblx0XHQvLyBTZXQgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBpbmhlcml0IGZyb20gYHBhcmVudGAsIHdpdGhvdXQgY2FsbGluZ1xuXHRcdC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG5cdFx0Y3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuXHRcdGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG5cblx0XHQvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcblx0XHQvLyBpZiBzdXBwbGllZC5cblx0XHRpZiAocHJvdG9Qcm9wcylcblx0XHRcdHV0aWxzLmV4dGVuZChjaGlsZC5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuXG5cdFx0Ly8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG5cdFx0aWYgKHN0YXRpY1Byb3BzKVxuXHRcdFx0dXRpbHMuZXh0ZW5kKGNoaWxkLCBzdGF0aWNQcm9wcyk7XG5cblx0XHQvLyBDb3JyZWN0bHkgc2V0IGNoaWxkJ3MgYHByb3RvdHlwZS5jb25zdHJ1Y3RvcmAuXG5cdFx0Y2hpbGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG5cblx0XHQvLyBTZXQgYSBjb252ZW5pZW5jZSBwcm9wZXJ0eSBpbiBjYXNlIHRoZSBwYXJlbnQncyBwcm90b3R5cGUgaXMgbmVlZGVkXG5cdFx0Ly8gbGF0ZXIuXG5cdFx0Y2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTtcblxuXHRcdHJldHVybiBjaGlsZDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHNlbGYtcHJvcGFnYXRpbmcgZXh0ZW5kIGZ1bmN0aW9uIGZvciBjbGFzc2VzLlxuXHRcdCAqIFRvb2sgaXQgZnJvbSBCYWNrYm9uZSBcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcHJvdG9Qcm9wc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjbGFzc1Byb3BzXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKHByb3RvUHJvcHMsIGNsYXNzUHJvcHMpIHtcblx0XHRcdHZhciBjaGlsZCA9IGluaGVyaXRzKHRoaXMsIHByb3RvUHJvcHMsIGNsYXNzUHJvcHMpO1xuXHRcdFx0Y2hpbGQuZXh0ZW5kID0gdGhpcy5leHRlbmQ7XG5cdFx0XHQvLyBhIGhhY2sgcmVxdWlyZWQgdG8gV1NIIGluaGVyaXQgYHRvU3RyaW5nYCBtZXRob2Rcblx0XHRcdGlmIChwcm90b1Byb3BzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKVxuXHRcdFx0XHRjaGlsZC5wcm90b3R5cGUudG9TdHJpbmcgPSBwcm90b1Byb3BzLnRvU3RyaW5nO1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblx0fTtcbn0pO1xufSx7XCIuLi91dGlscy9jb21tb25cIjpcInV0aWxzXFxcXGNvbW1vbi5qc1wifV0sXCJ2ZW5kb3JcXFxcc3RyaW5nU2NvcmUuanNcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiFcbiAqIHN0cmluZ19zY29yZS5qczogU3RyaW5nIFNjb3JpbmcgQWxnb3JpdGhtIDAuMS4xMCBcbiAqXG4gKiBodHRwOi8vam9zaGF2ZW4uY29tL3N0cmluZ19zY29yZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2pvc2hhdmVuL3N0cmluZ19zY29yZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOS0yMDExIEpvc2hhdmVuIFBvdHRlciA8eW91cnRlY2hAZ21haWwuY29tPlxuICogU3BlY2lhbCB0aGFua3MgdG8gYWxsIG9mIHRoZSBjb250cmlidXRvcnMgbGlzdGVkIGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL2pvc2hhdmVuL3N0cmluZ19zY29yZVxuICogTUlUIGxpY2Vuc2U6IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogRGF0ZTogVHVlIE1hciAxIDIwMTFcbiovXG5cbi8qKlxuICogU2NvcmVzIGEgc3RyaW5nIGFnYWluc3QgYW5vdGhlciBzdHJpbmcuXG4gKiAgJ0hlbGxvIFdvcmxkJy5zY29yZSgnaGUnKTsgICAgIC8vPT4gMC41OTMxODE4MTgxODE4MTgxXG4gKiAgJ0hlbGxvIFdvcmxkJy5zY29yZSgnSGVsbG8nKTsgIC8vPT4gMC43MzE4MTgxODE4MTgxODE4XG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdHJldHVybiB7XG5cdFx0c2NvcmU6IGZ1bmN0aW9uKHN0cmluZywgYWJicmV2aWF0aW9uLCBmdXp6aW5lc3MpIHtcblx0XHRcdC8vIElmIHRoZSBzdHJpbmcgaXMgZXF1YWwgdG8gdGhlIGFiYnJldmlhdGlvbiwgcGVyZmVjdCBtYXRjaC5cblx0XHRcdCAgaWYgKHN0cmluZyA9PSBhYmJyZXZpYXRpb24pIHtyZXR1cm4gMTt9XG5cdFx0XHQgIC8vaWYgaXQncyBub3QgYSBwZXJmZWN0IG1hdGNoIGFuZCBpcyBlbXB0eSByZXR1cm4gMFxuXHRcdFx0ICBpZihhYmJyZXZpYXRpb24gPT0gXCJcIikge3JldHVybiAwO31cblxuXHRcdFx0ICB2YXIgdG90YWxfY2hhcmFjdGVyX3Njb3JlID0gMCxcblx0XHRcdCAgICAgIGFiYnJldmlhdGlvbl9sZW5ndGggPSBhYmJyZXZpYXRpb24ubGVuZ3RoLFxuXHRcdFx0ICAgICAgc3RyaW5nX2xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0XHQgICAgICBzdGFydF9vZl9zdHJpbmdfYm9udXMsXG5cdFx0XHQgICAgICBhYmJyZXZpYXRpb25fc2NvcmUsXG5cdFx0XHQgICAgICBmdXp6aWVzPTEsXG5cdFx0XHQgICAgICBmaW5hbF9zY29yZTtcblx0XHRcdCAgXG5cdFx0XHQgIC8vIFdhbGsgdGhyb3VnaCBhYmJyZXZpYXRpb24gYW5kIGFkZCB1cCBzY29yZXMuXG5cdFx0XHQgIGZvciAodmFyIGkgPSAwLFxuXHRcdFx0ICAgICAgICAgY2hhcmFjdGVyX3Njb3JlLyogPSAwKi8sXG5cdFx0XHQgICAgICAgICBpbmRleF9pbl9zdHJpbmcvKiA9IDAqLyxcblx0XHRcdCAgICAgICAgIGMvKiA9ICcnKi8sXG5cdFx0XHQgICAgICAgICBpbmRleF9jX2xvd2VyY2FzZS8qID0gMCovLFxuXHRcdFx0ICAgICAgICAgaW5kZXhfY191cHBlcmNhc2UvKiA9IDAqLyxcblx0XHRcdCAgICAgICAgIG1pbl9pbmRleC8qID0gMCovO1xuXHRcdFx0ICAgICBpIDwgYWJicmV2aWF0aW9uX2xlbmd0aDtcblx0XHRcdCAgICAgKytpKSB7XG5cdFx0XHQgICAgXG5cdFx0XHQgICAgLy8gRmluZCB0aGUgZmlyc3QgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBvZiBhIGNoYXJhY3Rlci5cblx0XHRcdCAgICBjID0gYWJicmV2aWF0aW9uLmNoYXJBdChpKTtcblx0XHRcdCAgICBcblx0XHRcdCAgICBpbmRleF9jX2xvd2VyY2FzZSA9IHN0cmluZy5pbmRleE9mKGMudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHQgICAgaW5kZXhfY191cHBlcmNhc2UgPSBzdHJpbmcuaW5kZXhPZihjLnRvVXBwZXJDYXNlKCkpO1xuXHRcdFx0ICAgIG1pbl9pbmRleCA9IE1hdGgubWluKGluZGV4X2NfbG93ZXJjYXNlLCBpbmRleF9jX3VwcGVyY2FzZSk7XG5cdFx0XHQgICAgaW5kZXhfaW5fc3RyaW5nID0gKG1pbl9pbmRleCA+IC0xKSA/IG1pbl9pbmRleCA6IE1hdGgubWF4KGluZGV4X2NfbG93ZXJjYXNlLCBpbmRleF9jX3VwcGVyY2FzZSk7XG5cdFx0XHQgICAgXG5cdFx0XHQgICAgaWYgKGluZGV4X2luX3N0cmluZyA9PT0gLTEpIHsgXG5cdFx0XHQgICAgICBpZiAoZnV6emluZXNzKSB7XG5cdFx0XHQgICAgICAgIGZ1enppZXMgKz0gMS1mdXp6aW5lc3M7XG5cdFx0XHQgICAgICAgIGNvbnRpbnVlO1xuXHRcdFx0ICAgICAgfSBlbHNlIHtcblx0XHRcdCAgICAgICAgcmV0dXJuIDA7XG5cdFx0XHQgICAgICB9XG5cdFx0XHQgICAgfSBlbHNlIHtcblx0XHRcdCAgICAgIGNoYXJhY3Rlcl9zY29yZSA9IDAuMTtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgXG5cdFx0XHQgICAgLy8gU2V0IGJhc2Ugc2NvcmUgZm9yIG1hdGNoaW5nICdjJy5cblx0XHRcdCAgICBcblx0XHRcdCAgICAvLyBTYW1lIGNhc2UgYm9udXMuXG5cdFx0XHQgICAgaWYgKHN0cmluZ1tpbmRleF9pbl9zdHJpbmddID09PSBjKSB7IFxuXHRcdFx0ICAgICAgY2hhcmFjdGVyX3Njb3JlICs9IDAuMTsgXG5cdFx0XHQgICAgfVxuXHRcdFx0ICAgIFxuXHRcdFx0ICAgIC8vIENvbnNlY3V0aXZlIGxldHRlciAmIHN0YXJ0LW9mLXN0cmluZyBCb251c1xuXHRcdFx0ICAgIGlmIChpbmRleF9pbl9zdHJpbmcgPT09IDApIHtcblx0XHRcdCAgICAgIC8vIEluY3JlYXNlIHRoZSBzY29yZSB3aGVuIG1hdGNoaW5nIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBzdHJpbmdcblx0XHRcdCAgICAgIGNoYXJhY3Rlcl9zY29yZSArPSAwLjY7XG5cdFx0XHQgICAgICBpZiAoaSA9PT0gMCkge1xuXHRcdFx0ICAgICAgICAvLyBJZiBtYXRjaCBpcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmdcblx0XHRcdCAgICAgICAgLy8gJiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGFiYnJldmlhdGlvbiwgYWRkIGFcblx0XHRcdCAgICAgICAgLy8gc3RhcnQtb2Ytc3RyaW5nIG1hdGNoIGJvbnVzLlxuXHRcdFx0ICAgICAgICBzdGFydF9vZl9zdHJpbmdfYm9udXMgPSAxOyAvL3RydWU7XG5cdFx0XHQgICAgICB9XG5cdFx0XHQgICAgfVxuXHRcdFx0ICAgIGVsc2Uge1xuXHRcdFx0ICAvLyBBY3JvbnltIEJvbnVzXG5cdFx0XHQgIC8vIFdlaWdoaW5nIExvZ2ljOiBUeXBpbmcgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhbiBhY3JvbnltIGlzIGFzIGlmIHlvdVxuXHRcdFx0ICAvLyBwcmVjZWRlZCBpdCB3aXRoIHR3byBwZXJmZWN0IGNoYXJhY3RlciBtYXRjaGVzLlxuXHRcdFx0ICBpZiAoc3RyaW5nLmNoYXJBdChpbmRleF9pbl9zdHJpbmcgLSAxKSA9PT0gJyAnKSB7XG5cdFx0XHQgICAgY2hhcmFjdGVyX3Njb3JlICs9IDAuODsgLy8gKiBNYXRoLm1pbihpbmRleF9pbl9zdHJpbmcsIDUpOyAvLyBDYXAgYm9udXMgYXQgMC40ICogNVxuXHRcdFx0ICB9XG5cdFx0XHQgICAgfVxuXHRcdFx0ICAgIFxuXHRcdFx0ICAgIC8vIExlZnQgdHJpbSB0aGUgYWxyZWFkeSBtYXRjaGVkIHBhcnQgb2YgdGhlIHN0cmluZ1xuXHRcdFx0ICAgIC8vIChmb3JjZXMgc2VxdWVudGlhbCBtYXRjaGluZykuXG5cdFx0XHQgICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZyhpbmRleF9pbl9zdHJpbmcgKyAxLCBzdHJpbmdfbGVuZ3RoKTtcblx0XHRcdCAgICBcblx0XHRcdCAgICB0b3RhbF9jaGFyYWN0ZXJfc2NvcmUgKz0gY2hhcmFjdGVyX3Njb3JlO1xuXHRcdFx0ICB9IC8vIGVuZCBvZiBmb3IgbG9vcFxuXHRcdFx0ICBcblx0XHRcdCAgLy8gVW5jb21tZW50IHRvIHdlaWdoIHNtYWxsZXIgd29yZHMgaGlnaGVyLlxuXHRcdFx0ICAvLyByZXR1cm4gdG90YWxfY2hhcmFjdGVyX3Njb3JlIC8gc3RyaW5nX2xlbmd0aDtcblx0XHRcdCAgXG5cdFx0XHQgIGFiYnJldmlhdGlvbl9zY29yZSA9IHRvdGFsX2NoYXJhY3Rlcl9zY29yZSAvIGFiYnJldmlhdGlvbl9sZW5ndGg7XG5cdFx0XHQgIC8vcGVyY2VudGFnZV9vZl9tYXRjaGVkX3N0cmluZyA9IGFiYnJldmlhdGlvbl9sZW5ndGggLyBzdHJpbmdfbGVuZ3RoO1xuXHRcdFx0ICAvL3dvcmRfc2NvcmUgPSBhYmJyZXZpYXRpb25fc2NvcmUgKiBwZXJjZW50YWdlX29mX21hdGNoZWRfc3RyaW5nO1xuXHRcdFx0ICBcblx0XHRcdCAgLy8gUmVkdWNlIHBlbmFsdHkgZm9yIGxvbmdlciBzdHJpbmdzLlxuXHRcdFx0ICAvL2ZpbmFsX3Njb3JlID0gKHdvcmRfc2NvcmUgKyBhYmJyZXZpYXRpb25fc2NvcmUpIC8gMjtcblx0XHRcdCAgZmluYWxfc2NvcmUgPSAoKGFiYnJldmlhdGlvbl9zY29yZSAqIChhYmJyZXZpYXRpb25fbGVuZ3RoIC8gc3RyaW5nX2xlbmd0aCkpICsgYWJicmV2aWF0aW9uX3Njb3JlKSAvIDI7XG5cdFx0XHQgIFxuXHRcdFx0ICBmaW5hbF9zY29yZSA9IGZpbmFsX3Njb3JlIC8gZnV6emllcztcblx0XHRcdCAgXG5cdFx0XHQgIGlmIChzdGFydF9vZl9zdHJpbmdfYm9udXMgJiYgKGZpbmFsX3Njb3JlICsgMC4xNSA8IDEpKSB7XG5cdFx0XHQgICAgZmluYWxfc2NvcmUgKz0gMC4xNTtcblx0XHRcdCAgfVxuXHRcdFx0ICBcblx0XHRcdCAgcmV0dXJuIGZpbmFsX3Njb3JlO1xuXHRcdH1cblx0fTtcbn0pO1xufSx7fV19LHt9LFtcIi4vbGliL2VtbWV0LmpzXCIsXCIuL2J1bmRsZXMvc25pcHBldHMuanNcIl0pKFwiLi9saWIvZW1tZXQuanNcIilcbn0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/emmet/emmet.js\n");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzPzkxNTIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzP2UzZGIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/isarray/index.js\n");

/***/ })

}]);